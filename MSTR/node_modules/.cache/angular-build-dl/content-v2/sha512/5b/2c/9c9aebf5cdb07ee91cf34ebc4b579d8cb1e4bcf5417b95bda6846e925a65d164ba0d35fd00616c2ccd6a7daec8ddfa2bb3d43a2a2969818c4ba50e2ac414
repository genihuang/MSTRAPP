function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~login-login-module~main-main-module"], {
  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-accordion.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-accordion.js ***!
    \*******************************************************************************/

  /*! exports provided: NxExpansionPanelComponent, NxAccordionDirective, NxAccordionModule, ɵa, ɵb, ɵd, ɵc, ɵe */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxAccordionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxExpansionPanelComponent", function () {
      return NxExpansionPanelComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAccordionDirective", function () {
      return NxAccordionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAccordionModule", function () {
      return NxAccordionModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return nxAccordionAnimations;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return NxExpansionPanelBodyDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return NxExpansionPanelDescriptionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return NxExpansionPanelHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵe", function () {
      return NxExpansionPanelTitleDirective;
    });
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /* harmony import */


    var _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/accordion */
    "./node_modules/@angular/cdk/esm2015/accordion.js");
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/animations */
    "./node_modules/@angular/animations/fesm2015/animations.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/esm2015/portal.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var DEFAULT_TYPE = 'regular';

    var NxAccordionDirective =
    /*#__PURE__*/
    function (_angular_cdk_accordio) {
      _inherits(NxAccordionDirective, _angular_cdk_accordio);

      function NxAccordionDirective() {
        var _this;

        _classCallCheck(this, NxAccordionDirective);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(NxAccordionDirective).apply(this, arguments));
        _this._style = 'regular';
        _this._negative = null;
        return _this;
      }
      /**
       * Value for the styling that should be chosen.
       * Default value: 'regular'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxAccordionDirective, [{
        key: "style",
        set: function set(value) {
          value = value ? value : DEFAULT_TYPE;

          var _ref = value.match(/regular|light/) || [DEFAULT_TYPE],
              _ref2 = _slicedToArray(_ref, 1),
              newValue = _ref2[0];

          this._style =
          /** @type {?} */
          newValue;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._style;
        }
        /**
         * Whether the negative set of styles should be used.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
      }]);

      return NxAccordionDirective;
    }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_1__["CdkAccordion"]);

    NxAccordionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-accordion',
        host: {
          '[class.nx-accordion]': 'true',
          'role': 'presentation'
        }
      }]
    }];
    NxAccordionDirective.propDecorators = {
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxStyle']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nxAccordionAnimations = {
      bodyExpansion: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('bodyExpansion', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
        height: '0px',
        visibility: 'hidden'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('open', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
        height: '*',
        visibility: 'visible'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('open <=> closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('.5s cubic-bezier(0.86, 0, 0.07, 1)'))]),
      indicatorRotate: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('indicatorRotate', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
        transform: 'rotate(0deg)'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('open', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
        transform: 'rotate(180deg)'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('open <=> closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('.3s ease'))])
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxExpansionPanelBodyDirective =
    /**
     * @param {?} _template
     */
    function NxExpansionPanelBodyDirective(_template) {
      _classCallCheck(this, NxExpansionPanelBodyDirective);

      this._template = _template;
    };

    NxExpansionPanelBodyDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"],
      args: [{
        selector: '[nxExpansionPanelBody]'
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelBodyDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nextId = 0;
    /** @type {?} */

    var DEFAULT_TYPE$1 = 'regular';
    var ɵ0 = undefined;

    var NxExpansionPanelComponent =
    /*#__PURE__*/
    function (_angular_cdk_accordio2) {
      _inherits(NxExpansionPanelComponent, _angular_cdk_accordio2);

      /**
       * @param {?} accordion
       * @param {?} _changeDetectorRef
       * @param {?} _expansionDispatcher
       * @param {?} _viewContainerRef
       */
      function NxExpansionPanelComponent(accordion, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
        var _this2;

        _classCallCheck(this, NxExpansionPanelComponent);

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NxExpansionPanelComponent).call(this, accordion, _changeDetectorRef, _expansionDispatcher));
        _this2._viewContainerRef = _viewContainerRef;
        _this2._negative = null;
        _this2._accordionStyle = DEFAULT_TYPE$1;
        _this2._style = null;
        _this2._headerId = "nx-expansion-panel-header-".concat(nextId++);
        /**
         * Stream that emits for changes in `\@Input` properties.
         */

        _this2._inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
        _this2.accordion = accordion;
        return _this2;
      }
      /**
       * Whether the negative set of styles should be used.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxExpansionPanelComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this3 = this;

          if (this.lazyContent) {
            // Render the content as soon as the panel becomes open.
            this.opened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(
            /**
            * @return {?}
            */
            function () {
              return _this3.expanded && !_this3._portal;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(
            /**
            * @return {?}
            */
            function () {
              _this3._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["TemplatePortal"](_this3.lazyContent._template, _this3._viewContainerRef);
            });
          } // Inherit appearance given by the accordion (if any).


          if (Boolean(this.accordion)) {
            if (this.style === null && this.accordion.style !== null) {
              this.style = this.accordion.style;
            }

            if (this.negative === null && this.accordion.negative !== null) {
              this.negative = this.accordion.negative;
            }
          }
        }
        /**
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          this._inputChanges.next(changes);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          _get(_getPrototypeOf(NxExpansionPanelComponent.prototype), "ngOnDestroy", this).call(this);

          this._inputChanges.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getOpenState",
        value: function getOpenState() {
          return this.expanded ? 'open' : 'closed';
        }
      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Value for the styling that should be chosen.
         * Default value: 'regular'.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "style",
        set: function set(value) {
          value = value ? value : DEFAULT_TYPE$1;

          var _ref3 = value.match(/regular|light/) || [DEFAULT_TYPE$1],
              _ref4 = _slicedToArray(_ref3, 1),
              newValue = _ref4[0];

          this._style =
          /** @type {?} */
          newValue;
          this._accordionStyle =
          /** @type {?} */
          newValue;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._style;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "portal",
        get: function get() {
          return this._portal;
        }
      }]);

      return NxExpansionPanelComponent;
    }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_1__["CdkAccordionItem"]);

    NxExpansionPanelComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"],
      args: [{
        selector: 'nx-expansion-panel',
        exportAs: 'NxExpansionPanelComponent',
        template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
        animations: [nxAccordionAnimations.bodyExpansion],
        host: {
          '[class.nx-expanded]': 'expanded',
          '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
          '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
          '[class.nx-expansion-panel--negative]': 'negative'
        },
        providers: [// Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
        // to the same accordion.
        {
          provide: NxAccordionDirective,
          useValue: ɵ0
        }],
        styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;line-height:24px;padding:24px 88px 32px 32px}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host:last-child ::ng-deep .nx-expansion-panel__header-content,:host:only-child ::ng-deep .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-content{border-top:1px solid #d9d9d9;border-bottom:none}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__body{padding-top:0}:host(.nx-expansion-panel--light):first-child ::ng-deep .nx-expansion-panel__header-content{border-top:none}"]
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelComponent.ctorParameters = function () {
      return [{
        type: NxAccordionDirective,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["SkipSelf"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__["UniqueSelectionDispatcher"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"]
      }];
    };

    NxExpansionPanelComponent.propDecorators = {
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"]
      }],
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxStyle']
      }],
      lazyContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChild"],
        args: [NxExpansionPanelBodyDirective]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxExpansionPanelHeaderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} panel
       * @param {?} _changeDetectorRef
       */
      function NxExpansionPanelHeaderComponent(panel, _changeDetectorRef) {
        var _this4 = this;

        _classCallCheck(this, NxExpansionPanelHeaderComponent);

        this.panel = panel;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_9__["Subscription"].EMPTY;
        this._parentChangeSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"])(panel.opened, panel.closed, panel._inputChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(
        /**
        * @param {?} changes
        * @return {?}
        */
        function (changes) {
          return !!(changes.hideToggle || changes.disabled);
        }))).subscribe(
        /**
        * @return {?}
        */
        function () {
          return _this4._changeDetectorRef.markForCheck();
        });
      }
      /**
       * @return {?}
       */


      _createClass(NxExpansionPanelHeaderComponent, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._parentChangeSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isExpanded",
        value: function isExpanded() {
          return this.panel.expanded;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getOpenState",
        value: function getOpenState() {
          return this.panel.getOpenState();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_getPanelId",
        value: function _getPanelId() {
          return this.panel.id;
        }
        /**
         * Toggle the expansion panel.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.panel.toggle();
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "keydown",
        value: function keydown(event) {
          switch (event.keyCode) {
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["SPACE"]:
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["ENTER"]:
              event.preventDefault();
              this.toggle();
              break;

            default:
              return;
          }
        }
      }]);

      return NxExpansionPanelHeaderComponent;
    }();

    NxExpansionPanelHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"],
      args: [{
        selector: 'nx-expansion-panel-header',
        template: "<div class=\"nx-expansion-panel__header-content\">\n  <ng-content select=\"nx-expansion-panel-title\"></ng-content>\n  <ng-content select=\"nx-expansion-panel-description\"></ng-content>\n  <nx-icon\n    [@indicatorRotate]=\"getOpenState()\"\n    class=\"nx-expansion-panel__chevron\"\n    name=\"chevron-down\">\n  </nx-icon>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
        animations: [nxAccordionAnimations.indicatorRotate],
        host: {
          '[class.nx-expanded]': 'isExpanded()',
          'class': 'nx-expansion-panel__header',
          'role': 'button',
          '[attr.id]': 'panel._headerId',
          '[attr.tabindex]': 'panel.disabled ? -1 : 0',
          '[attr.aria-controls]': '_getPanelId()',
          '[attr.aria-expanded]': 'isExpanded()',
          '[attr.aria-disabled]': 'panel.disabled',
          '(keydown)': 'keydown($event)',
          '(click)': 'toggle()'
        },
        styles: [":host:focus{outline:0}.nx-expansion-panel__header-content{width:100%;cursor:pointer;align-items:center;color:#414141;display:flex;justify-content:space-between;position:relative;padding:24px 32px;margin-top:16px;background:#f5f5f5;outline:0;border:none}::ng-deep .nx-expansion-panel__header-title{font-size:26px;font-weight:300;line-height:32px;letter-spacing:.3px;text-align:left;margin-right:32px}:host-context(.nx-expansion-panel--negative) .nx-expansion-panel__header-content{background-color:#fff}.nx-expansion-panel__chevron{color:#006192;pointer-events:none;font-size:24px}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__header-content{margin-top:0;background:0 0}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{color:#006192;letter-spacing:.2px;font-weight:400;font-size:20px;line-height:28px}@media (max-width:703px){.nx-expansion-panel__header-content{padding:16px;margin-top:0;border-top:1px solid #d9d9d9}::ng-deep .nx-expansion-panel__header-title{font-size:20px;line-height:28px;margin-right:16px;font-weight:400}:host(.nx-expanded) .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{line-height:24px;font-size:16px}:host-context(.nx-expansion-panel--light.nx-expanded) .nx-expansion-panel__header-content{border-bottom:none}}:host[aria-disabled=true] .nx-expansion-panel__header-content{cursor:not-allowed}:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__chevron,:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__header-title{color:#c2c2c2}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content{border-color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-title{color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__chevron{color:#fff}:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-top-color:transparent;z-index:1}"]
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelHeaderComponent.ctorParameters = function () {
      return [{
        type: NxExpansionPanelComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Host"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"]
      }];
    };
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */


    var NxExpansionPanelDescriptionDirective = function NxExpansionPanelDescriptionDirective() {
      _classCallCheck(this, NxExpansionPanelDescriptionDirective);
    };

    NxExpansionPanelDescriptionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-expansion-panel-description',
        host: {
          class: 'nx-expansion-panel__header-description'
        }
      }]
    }];
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */

    var NxExpansionPanelTitleDirective = function NxExpansionPanelTitleDirective() {
      _classCallCheck(this, NxExpansionPanelTitleDirective);
    };

    NxExpansionPanelTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-expansion-panel-title',
        host: {
          class: 'nx-expansion-panel__header-title'
        }
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxAccordionModule = function NxAccordionModule() {
      _classCallCheck(this, NxAccordionModule);
    };

    NxAccordionModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_4__["NxIconModule"]],
        exports: [NxAccordionDirective, NxExpansionPanelComponent, NxExpansionPanelHeaderComponent, NxExpansionPanelDescriptionDirective, NxExpansionPanelTitleDirective, NxExpansionPanelBodyDirective],
        declarations: [NxAccordionDirective, NxExpansionPanelComponent, NxExpansionPanelHeaderComponent, NxExpansionPanelDescriptionDirective, NxExpansionPanelTitleDirective, NxExpansionPanelBodyDirective],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-autocomplete.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-autocomplete.js ***!
    \**********************************************************************************/

  /*! exports provided: NxAutocompleteModule, NxAutocompleteOptionSelected, NxAutocompleteOptionComponent, NxAutocompleteSelectedEvent, NxAutocompleteComponent, getNxAutocompleteMissingPanelError, NX_AUTOCOMPLETE_VALUE_ACCESSOR, NxAutocompleteTriggerDirective */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxAutocompleteJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteModule", function () {
      return NxAutocompleteModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteOptionSelected", function () {
      return NxAutocompleteOptionSelected;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteOptionComponent", function () {
      return NxAutocompleteOptionComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteSelectedEvent", function () {
      return NxAutocompleteSelectedEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteComponent", function () {
      return NxAutocompleteComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getNxAutocompleteMissingPanelError", function () {
      return getNxAutocompleteMissingPanelError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NX_AUTOCOMPLETE_VALUE_ACCESSOR", function () {
      return NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteTriggerDirective", function () {
      return NxAutocompleteTriggerDirective;
    });
    /* harmony import */


    var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/a11y */
    "./node_modules/@angular/cdk/esm2015/a11y.js");
    /* harmony import */


    var _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/formfield */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js");
    /* harmony import */


    var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/cdk/bidi */
    "./node_modules/@angular/cdk/esm2015/bidi.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */


    var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/cdk/overlay */
    "./node_modules/@angular/cdk/esm2015/overlay.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/esm2015/portal.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _allianz_ngx_ndbx_natural_language_form__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/natural-language-form */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-natural-language-form.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Option selected event
     */


    var NxAutocompleteOptionSelected =
    /**
     * @param {?} source
     * @param {?=} isUserInput
     */
    function NxAutocompleteOptionSelected(source) {
      var isUserInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, NxAutocompleteOptionSelected);

      this.source = source;
      this.isUserInput = isUserInput;
    };
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */


    var _uniqueIdCounter = 0;

    var NxAutocompleteOptionComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} _changeDetectorRef
       */
      function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
        _classCallCheck(this, NxAutocompleteOptionComponent);

        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = "nx-autocomplete-option-".concat(_uniqueIdCounter++);
        this._selected = false;
        this._active = false;
        this._disabled = false;
        /**
         * Event emitted when the option is selected or deselected.
         */

        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
      }
      /**
       * Id of the autocomplete option. By default it is set to an incremented value.
       * @return {?}
       */


      _createClass(NxAutocompleteOptionComponent, [{
        key: "_handleKeydown",

        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        value: function _handleKeydown(event) {
          if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ENTER"] || event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["SPACE"]) {
            this._selectViaInteraction(); // Prevent the page from scrolling down and form submits.


            event.preventDefault();
          }
        }
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */

      }, {
        key: "_selectViaInteraction",
        value: function _selectViaInteraction() {
          if (!this.disabled) {
            this._selected = true;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent(true);
          }
        }
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */

      }, {
        key: "_getTabIndex",
        value: function _getTabIndex() {
          return this.disabled ? '-1' : '0';
        }
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */

      }, {
        key: "_emitSelectionChangeEvent",
        value: function _emitSelectionChangeEvent() {
          var isUserInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setActiveStyles",

        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        value: function setActiveStyles() {
          if (!this._active) {
            this._active = true;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */

      }, {
        key: "setInactiveStyles",
        value: function setInactiveStyles() {
          if (this._active) {
            this._active = false;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */

      }, {
        key: "getLabel",
        value: function getLabel() {
          return this.viewValue;
        }
        /**
         * Selects the option.
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          this._selected = true;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent();
        }
        /**
         * Deselects the option.
         * @return {?}
         */

      }, {
        key: "deselect",
        value: function deselect() {
          this._selected = false;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent();
        }
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          /** @type {?} */
          var element = this.elementRef.nativeElement;

          if (typeof element.focus === 'function') {
            element.focus();
          }
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * Whether or not the option is currently selected.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * Whether or not the option is currently active and ready to be selected.
         * An active option displays styles as if it is focused, but the
         * focus is actually retained somewhere else. This comes in handy
         * for components like autocomplete where focus must remain on the input.
         * @return {?}
         */

      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * Whether the option is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          if (this._disabled !== newValue) {
            this._disabled = newValue;
          }
        }
      }, {
        key: "viewValue",
        get: function get() {
          return (this.elementRef.nativeElement.textContent || '').trim();
        }
      }]);

      return NxAutocompleteOptionComponent;
    }();

    NxAutocompleteOptionComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"],
      args: [{
        selector: 'nx-autocomplete-option',
        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        host: {
          'role': 'option',
          '[attr.tabindex]': '_getTabIndex()',
          '[id]': 'id',
          '[attr.aria-selected]': 'selected.toString()',
          '[attr.aria-disabled]': 'disabled.toString()',
          '(click)': '_selectViaInteraction()',
          '(keydown)': '_handleKeydown($event)',
          '[class.nx-active]': 'active',
          '[class.nx-disabled]': 'disabled',
          '[style.display]': '\'block\'' // needed for to be able to calculate offset height

        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
        styles: [":host:focus{outline:0}.nx-autocomplete-option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:highlightText}}.nx-autocomplete-option__label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteOptionComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"]
      }];
    };

    NxAutocompleteOptionComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"]
      }],
      onSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */

    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */

    var NxAutocompleteSelectedEvent =
    /**
     * @param {?} source
     * @param {?} option
     */
    function NxAutocompleteSelectedEvent(source, option) {
      _classCallCheck(this, NxAutocompleteSelectedEvent);

      this.source = source;
      this.option = option;
    };

    var NxAutocompleteComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxAutocompleteComponent(_changeDetectorRef, _elementRef) {
        _classCallCheck(this, NxAutocompleteComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         */

        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /**
         * Event that is emitted whenever an option from the list is selected.
         */

        this.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
        /**
         * Event that is emitted when the autocomplete panel is opened.
         */

        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
        /**
         * Event that is emitted when the autocomplete panel is closed.
         */

        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
        this._classList = {};
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         */

        this.id = "nx-autocomplete-".concat(_uniqueAutocompleteIdCounter++); // As autocomplete option can hold any value, we might need a converter
        // to get a string representation, which can be stored in input. Default value ? value.toString() : null.

        /**
         * Value to string converter.
         */

        this.valueFormatter =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return value ? value.toString() : null;
        };
      }
      /**
       * Whether the autocomplete panel is open.
       * @return {?}
       */


      _createClass(NxAutocompleteComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["ActiveDescendantKeyManager"](this.options).withWrap();

          this._setVisibility();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
          }
        }
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */

      }, {
        key: "_setScrollTop",
        value: function _setScrollTop(scrollTop) {
          if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
          }
        }
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */

      }, {
        key: "_getScrollTop",
        value: function _getScrollTop() {
          return this.panel ? this.panel.nativeElement.scrollTop : 0;
        }
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */

      }, {
        key: "_setVisibility",
        value: function _setVisibility() {
          this.showPanel = !!(this.options && this.options.length);
          this._classList['nx-autocomplete-visible'] = this.showPanel;
          this._classList['nx-autocomplete-hidden'] = !this.showPanel;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */

      }, {
        key: "_emitSelectEvent",
        value: function _emitSelectEvent(option) {
          /** @type {?} */
          var event = new NxAutocompleteSelectedEvent(this, option);
          this.optionSelected.emit(event);
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this._isOpen && this.showPanel;
        }
        /**
         * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "items",
        set: function set(val) {
          var _this5 = this;

          this._hasItems = true;

          if (Array.isArray(val)) {
            this._items = val;
          } else if (val instanceof rxjs__WEBPACK_IMPORTED_MODULE_10__["Observable"]) {
            if (this._itemsSubscription) {
              this._itemsSubscription.unsubscribe();
            }

            this._itemsSubscription = val.subscribe(
            /**
            * @param {?} itms
            * @return {?}
            */
            function (itms) {
              _this5._items = itms;

              _this5._changeDetectorRef.markForCheck(); // and check visibility in next cycle, when options are set


              setTimeout(
              /**
              * @return {?}
              */
              function () {
                return _this5._setVisibility();
              });
            });
          } else if (val === null) {
            this._items = val;
          } else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._items;
        }
        /**
         * \@docs-private
         * Is items observable set
         * @return {?}
         */

      }, {
        key: "hasItems",
        get: function get() {
          return this._hasItems;
        }
        /**
         * Autocomplete options
         * @return {?}
         */

      }, {
        key: "options",
        get: function get() {
          return this.hasItems ? this._vOptions : this._cOptions;
        }
        /**
         * Takes classes set on the host nx-autocomplete element and applies them to the panel
         * inside the overlay container to allow for easy styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "classList",
        set: function set(value) {
          var _this6 = this;

          if (value && value.length) {
            value.split(' ').forEach(
            /**
            * @param {?} className
            * @return {?}
            */
            function (className) {
              return _this6._classList[className.trim()] = true;
            });
            this._elementRef.nativeElement.className = '';
          }
        }
      }]);

      return NxAutocompleteComponent;
    }();

    NxAutocompleteComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"],
      args: [{
        selector: 'nx-autocomplete',
        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxAutocomplete',
        host: {
          'class': 'nx-autocomplete'
        },
        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:24px;overflow-y:auto;overflow-x:hidden;max-height:336px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"]
      }];
    };

    NxAutocompleteComponent.propDecorators = {
      template: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"],
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_8__["TemplateRef"]]
      }],
      panel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"],
        args: ['panel']
      }],
      items: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"]
      }],
      optionSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"]
      }],
      opened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"]
      }],
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"]
      }],
      _vOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChildren"],
        args: [NxAutocompleteOptionComponent]
      }],
      _cOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChildren"],
        args: [NxAutocompleteOptionComponent, {
          descendants: true
        }]
      }],
      classList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['class']
      }],
      valueFormatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxValueFormatter']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */

    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_9__["NG_VALUE_ACCESSOR"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["forwardRef"])(
      /**
      * @return {?}
      */
      function () {
        return NxAutocompleteTriggerDirective;
      }),
      multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */

    function getNxAutocompleteMissingPanelError() {
      return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' + 'Make sure that the id passed to the `nxAutocomplete` is correct and that ' + 'you\'re attempting to open it after the ngAfterContentInit hook.');
    }

    var NxAutocompleteTriggerDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       * @param {?} _overlay
       * @param {?} _viewContainerRef
       * @param {?} _zone
       * @param {?} _changeDetectorRef
       * @param {?} _dir
       * @param {?} _nxFormField
       * @param {?} _nxWordField
       * @param {?} _document
       * @param {?=} _viewportRuler
       */
      function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
        var _this7 = this;

        _classCallCheck(this, NxAutocompleteTriggerDirective);

        this._element = _element;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._nxFormField = _nxFormField;
        this._nxWordField = _nxWordField;
        this._document = _document;
        this._viewportRuler = _viewportRuler;
        this._componentDestroyed = false;
        /**
         * Whether or not the label state is being overridden.
         */

        this._manuallyFloatingLabel = false;
        /**
         * Subscription to viewport size changes.
         */

        this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_10__["Subscription"].EMPTY;
        /**
         * Stream of keyboard events that can close the panel.
         */

        this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_10__["Subject"]();
        /**
         * Value changes
         */

        this._valueChanges = new rxjs__WEBPACK_IMPORTED_MODULE_10__["Subject"]();
        this._itemsCb = null;
        this._debounce = 400;
        this._autocompleteDisabled = false;
        this._overlayAttached = false;
        /**
         * Stream of autocomplete option selections.
         */

        this.optionSelections = Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["defer"])(
        /**
        * @return {?}
        */
        function () {
          if (_this7.autocomplete && _this7.autocomplete.options) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["merge"]).apply(void 0, _toConsumableArray(_this7.autocomplete.options.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.onSelectionChange;
            })));
          } // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
          // Return a stream that we'll replace with the real one once everything is in place.


          return _this7._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            return _this7.optionSelections;
          }));
        });
        /**
         * `View -> model callback called when value changes`
         */

        this._onChange =
        /**
        * @param {?} val
        * @return {?}
        */
        function (val) {
          _this7._valueChanges.next(val);
        };
        /**
         * `View -> model callback called when autocomplete has been touched`
         */


        this._onTouched =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * The items callback. Called with input value, must return Observable of Array of strings
       * @param {?} val
       * @return {?}
       */


      _createClass(NxAutocompleteTriggerDirective, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._viewportSubscription.unsubscribe();

          this._componentDestroyed = true;

          this._destroyPanel();

          this._closeKeyEventStream.complete();

          if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
          }

          if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this._bindAutocompleteItems();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this._bindAutocompleteItems();
        }
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */

      }, {
        key: "_bindAutocompleteItems",
        value: function _bindAutocompleteItems() {
          var _this8 = this;

          if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
          }

          if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
            /** @type {?} */
            var itemsSubject = new rxjs__WEBPACK_IMPORTED_MODULE_10__["Subject"]();
            this.autocomplete.items = itemsSubject;
            /** @type {?} */

            var valueChanges = this._formField && this._formField._control && this._formField._control.ngControl && this._formField._control.ngControl.valueChanges ? this._formField._control.ngControl.valueChanges : this._valueChanges;
            this._controlValueChangesSubscription = valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["debounceTime"])(this._debounce)).subscribe(
            /**
            * @param {?} input
            * @return {?}
            */
            function (input) {
              if (_this8._itemsSubscription) {
                _this8._itemsSubscription.unsubscribe();
              }

              _this8._itemsSubscription = _this8._itemsCb(input).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["first"])()).subscribe(
              /**
              * @param {?} result
              * @return {?}
              */
              function (result) {
                itemsSubject.next(result);
              },
              /**
              * @param {?} err
              * @return {?}
              */
              function (err) {
                // On error reset
                // TODO: Log error?
                itemsSubject.next([]);
              });
            });
          }
        }
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */

      }, {
        key: "openPanel",
        value: function openPanel() {
          if (!this.autocompleteDisabled) {
            this._attachOverlay();

            this._floatLabel();
          }
        }
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */

      }, {
        key: "closePanel",
        value: function closePanel() {
          this._resetLabel();

          if (!this._overlayAttached) {
            return;
          }

          if (this.panelOpen) {
            // Only emit if the panel was visible.
            this.autocomplete.closed.emit();
          }

          this.autocomplete._isOpen = this._overlayAttached = false;

          if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();

            this._closingActionsSubscription.unsubscribe();
          } // Note that in some cases this can end up being called after the component is destroyed.
          // Add a check to ensure that we don't try to run change detection on a destroyed view.


          if (!this._componentDestroyed) {
            // We need to trigger change detection manually, because
            // `fromEvent` doesn't seem to do it at the proper time.
            // This ensures that the label is reset when the
            // user clicks outside.
            this._changeDetectorRef.detectChanges();
          }
        }
        /**
         * A stream of actions that should close the autocomplete panel, including
         * when an option is selected, on blur, and when TAB is pressed.
         * @return {?}
         */

      }, {
        key: "writeValue",
        // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} value
         * @return {?}
         */
        value: function writeValue(value) {
          var _this9 = this;

          Promise.resolve(null).then(
          /**
          * @return {?}
          */
          function () {
            return _this9._setTriggerValue(value);
          });
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this._element.nativeElement.disabled = isDisabled;
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleKeydown",
        value: function _handleKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode; // Prevent the default action on all escape key presses. This is here primarily to bring IE
          // in line with other browsers. By default, pressing escape on IE will cause it to revert
          // the input value to the one that it had on focus, however it won't dispatch any events
          // which means that the model value will be out of sync with the view.

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ESCAPE"]) {
            event.preventDefault();
          } // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
          // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction


          if (this.panelOpen && (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ESCAPE"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["UP_ARROW"] && event.altKey)) {
            this._resetActiveItem();

            this._closeKeyEventStream.next();

            event.stopPropagation();
          } else if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ENTER"] && this.panelOpen) {
            this.activeOption._selectViaInteraction();

            this._resetActiveItem();

            event.preventDefault();
          } else {
            /** @type {?} */
            var prevActiveItem = this.autocomplete._keyManager.activeItem;
            /** @type {?} */

            var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["DOWN_ARROW"];

            if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["TAB"]) {
              this.autocomplete._keyManager.onKeydown(event);
            } else if (isArrowKey && this._isFieldEnabled()) {
              this.openPanel();
            }

            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
              this._scrollToOption();
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleInput",
        value: function _handleInput(event) {
          /** @type {?} */
          var target =
          /** @type {?} */
          event.target;
          /** @type {?} */

          var value = target.value; // Based on `NumberValueAccessor` from forms.

          if (target.type === 'number') {
            value = value === '' ? null : parseFloat(value);
          } // If the input has a placeholder, IE will fire the `input` event on page load,
          // focus and blur, in addition to when the user actually changed the value. To
          // filter out all of the extra events, we save the value on focus and between
          // `input` events, and we check whether it changed.
          // See: https://connect.microsoft.com/IE/feedback/details/885747/


          if (this._isFieldEnabled() && this._previousValue !== value && document.activeElement === event.target) {
            this._previousValue = value;

            this._onChange(value);

            this.openPanel();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "_handleFocus",
        value: function _handleFocus() {
          if (this._isFieldEnabled()) {
            this._previousValue = this._element.nativeElement.value;
            this.openPanel();
          }
        }
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */

      }, {
        key: "_floatLabel",
        value: function _floatLabel() {
          if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
            this._nxFormField.floatLabel = 'always';
            this._manuallyFloatingLabel = true;
          }
        }
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetLabel",
        value: function _resetLabel() {
          if (this._manuallyFloatingLabel) {
            this._nxFormField.floatLabel = 'auto';
            this._manuallyFloatingLabel = false;
          }
        }
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollToOption",
        value: function _scrollToOption() {
          if (this.autocomplete.options.length === 0) {
            return;
          }
          /** @type {?} */


          var optionOffset = 0;
          /** @type {?} */

          var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;

          if (this.autocomplete._keyManager.activeItem) {
            optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
          }
          /** @type {?} */


          var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);

          this.autocomplete._setScrollTop(newScrollPosition);
        }
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToClosingActions",
        value: function _subscribeToClosingActions() {
          var _this10 = this;

          /** @type {?} */
          var firstStable = this._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["take"])(1));
          /** @type {?} */


          var optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["tap"])(
          /**
          * @return {?}
          */
          function () {
            return _this10._positionStrategy.reapplyLastPosition();
          }), // Defer emitting to the stream until the next tick, because changing
          // bindings in here will cause "changed after checked" errors.
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["delay"])(0)); // When the zone is stable initially, and when the option list changes...

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["merge"])(firstStable, optionChanges).pipe( // create a new stream of panelClosingActions, replacing any previous streams
          // that were created, and flatten it so our stream only emits closing events...
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            _this10._resetActiveItem();

            _this10.autocomplete._setVisibility();

            return _this10.panelClosingActions;
          }), // when the first closing event occurs...
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["take"])(1)) // set the value, close the panel, and complete.
          .subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            return _this10._setValueAndClose(event);
          });
        }
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_destroyPanel",
        value: function _destroyPanel() {
          if (this._overlayRef) {
            this.closePanel();

            this._overlayRef.dispose();

            this._overlayRef = null;
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setTriggerValue",
        value: function _setTriggerValue(value) {
          /** @type {?} */
          var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ? this.autocomplete.valueFormatter(value) : value; // Simply falling back to an empty string if the display value is falsy does not work properly.
          // The display value can also be the number zero and shouldn't fall back to an empty string.

          /** @type {?} */

          var inputValue = toDisplay != null ? toDisplay : ''; // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
          // through change detection.

          if (this._formField) {
            this._formField._control.value = inputValue;
          } else {
            this._element.nativeElement.value = inputValue;
          }
        }
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_setValueAndClose",
        value: function _setValueAndClose(event) {
          if (event && event.source) {
            this._clearPreviousSelectedOption(event.source);

            this._setTriggerValue(event.source.value);

            this._onChange(event.source.value);

            this._element.nativeElement.focus();

            this.autocomplete._emitSelectEvent(event.source);
          }

          this.closePanel();
        }
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */

      }, {
        key: "_clearPreviousSelectedOption",
        value: function _clearPreviousSelectedOption(skip) {
          this.autocomplete.options.forEach(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            if (option !== skip && option.selected) {
              option.deselect();
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_attachOverlay",
        value: function _attachOverlay() {
          var _this11 = this;

          if (!this.autocomplete) {
            throw getNxAutocompleteMissingPanelError();
          }

          if (!this._overlayRef) {
            this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["TemplatePortal"](this.autocomplete.template, this._viewContainerRef);
            this._overlayRef = this._overlay.create(this._getOverlayConfig());

            if (this._viewportRuler) {
              this._viewportSubscription = this._viewportRuler.change().subscribe(
              /**
              * @return {?}
              */
              function () {
                if (_this11.panelOpen && _this11._overlayRef) {
                  _this11._overlayRef.updateSize({
                    minWidth: _this11._getHostWidth()
                  });
                }
              });
            }
          } else {
            /** Update the panel width, in case the host width has changed */
            this._overlayRef.updateSize({
              minWidth: this._getHostWidth()
            });
          }

          if (this._overlayRef && !this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._portal);

            this._closingActionsSubscription = this._subscribeToClosingActions();
          }
          /** @type {?} */


          var wasOpen = this.panelOpen;

          this.autocomplete._setVisibility();

          this.autocomplete._isOpen = this._overlayAttached = true; // We need to do an extra `panelOpen` check in here, because the
          // autocomplete won't be shown if there are no options.

          if (this.panelOpen && wasOpen !== this.panelOpen) {
            this.autocomplete.opened.emit();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOverlayConfig",
        value: function _getOverlayConfig() {
          return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayConfig"]({
            positionStrategy: this._getOverlayPosition(),
            scrollStrategy: this._scrollStrategy(),
            minWidth: this._getHostWidth(),
            direction: this._dir ? this._dir.value : 'ltr'
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOverlayPosition",
        value: function _getOverlayPosition() {
          this._positionStrategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withViewportMargin(16).withPush(false).withPositions([{
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
          }, {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom'
          }]);
          return this._positionStrategy;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollStrategy",
        value: function _scrollStrategy() {
          return this._overlay.scrollStrategies.reposition();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getConnectedElement",
        value: function _getConnectedElement() {
          return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
        }
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */

      }, {
        key: "_getHostWidth",
        value: function _getHostWidth() {
          return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
        }
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetActiveItem",
        value: function _resetActiveItem() {
          this.autocomplete._keyManager.setActiveItem(-1);
        }
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */

      }, {
        key: "_isFieldEnabled",
        value: function _isFieldEnabled() {
          /** @type {?} */
          var element = this._element.nativeElement;
          return !element.readOnly && !element.disabled;
        }
      }, {
        key: "itemsCb",
        set: function set(val) {
          if (typeof val === 'function') {
            this._itemsCb = val;
          } else {
            throw new Error('Wrong value type for nxAutocompleteItems');
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._itemsCb;
        }
        /**
         * Debounce in ms before items callback is triggered. Defaults to 400
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "debounce",
        set: function set(val) {
          this._debounce = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(val);
        }
        /**
         * Whether autocomplete functionality is disabled.
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "autocompleteDisabled",
        set: function set(val) {
          this._autocompleteDisabled = val;

          this._bindAutocompleteItems();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._autocompleteDisabled;
        }
        /**
         * Whether or not the autocomplete panel is open.
         * @return {?}
         */

      }, {
        key: "panelOpen",
        get: function get() {
          return this._overlayAttached && this.autocomplete.showPanel;
        }
        /**
         * The currently active option, coerced to NxAutocompleteOptionComponent type.
         * @return {?}
         */

      }, {
        key: "activeOption",
        get: function get() {
          if (this.autocomplete && this.autocomplete._keyManager) {
            return this.autocomplete._keyManager.activeItem;
          }

          return null;
        }
        /**
         * Stream of clicks outside of the autocomplete panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_outsideClickStream",
        get: function get() {
          var _this12 = this;

          if (!this._document) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["of"])(null);
          }

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["merge"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["fromEvent"])(this._document, 'click'), Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["fromEvent"])(this._document, 'touchend')).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["filter"])(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            /** @type {?} */
            var clickTarget =
            /** @type {?} */
            event.target;
            /** @type {?} */

            var formField = _this12._formField ? _this12._formField.elementRef.nativeElement : null;
            return _this12._overlayAttached && clickTarget !== _this12._element.nativeElement && (!formField || !formField.contains(clickTarget)) && !!_this12._overlayRef && !_this12._overlayRef.overlayElement.contains(clickTarget);
          }));
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_formField",
        get: function get() {
          if (this._nxFormField) {
            return this._nxFormField;
          } else if (this._nxWordField) {
            return this._nxWordField;
          }
        }
      }, {
        key: "panelClosingActions",
        get: function get() {
          var _this13 = this;

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["merge"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["filter"])(
          /**
          * @return {?}
          */
          function () {
            return _this13._overlayAttached;
          })), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ? this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["filter"])(
          /**
          * @return {?}
          */
          function () {
            return _this13._overlayAttached;
          })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_10__["of"])());
        }
      }]);

      return NxAutocompleteTriggerDirective;
    }();

    NxAutocompleteTriggerDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Directive"],
      args: [{
        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
        host: {
          'role': 'combobox',
          'autocomplete': 'off',
          'aria-autocomplete': 'list',
          '[attr.aria-activedescendant]': 'activeOption?.id',
          '[attr.aria-expanded]': 'panelOpen.toString()',
          '[attr.aria-owns]': 'autocomplete?.id',
          // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
          // a little earlier. This avoids issues where IE delays the focusing of the input.
          '(focusin)': '_handleFocus()',
          '(blur)': '_onTouched()',
          '(input)': '_handleInput($event)',
          '(keydown)': '_handleKeydown($event)'
        },
        exportAs: 'nxAutocompleteTrigger',
        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteTriggerDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"]
        }]
      }, {
        type: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_1__["NxFormfieldComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Host"]
        }]
      }, {
        type: _allianz_ngx_ndbx_natural_language_form__WEBPACK_IMPORTED_MODULE_12__["NxWordComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Host"]
        }]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["DOCUMENT"]]
        }]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["ViewportRuler"]
      }];
    };

    NxAutocompleteTriggerDirective.propDecorators = {
      autocomplete: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxAutocomplete']
      }],
      itemsCb: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxAutocompleteItems']
      }],
      debounce: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxAutocompleteDebounce']
      }],
      autocompleteDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"],
        args: ['nxAutocompleteDisabled']
      }]
    };
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */

    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
      if (optionOffset < currentScrollPosition) {
        return optionOffset;
      }

      if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
        return Math.max(0, optionOffset - panelHeight + optionHeight);
      }

      return currentScrollPosition;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxAutocompleteModule = function NxAutocompleteModule() {
      _classCallCheck(this, NxAutocompleteModule);
    };

    NxAutocompleteModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"],
      args: [{
        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["A11yModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-base.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-base.js ***!
    \**************************************************************************/

  /*! exports provided: NxErrorModule, ERROR_DEFAULT_OPTIONS, NxErrorComponent, NxLabelModule, LABEL_DEFAULT_OPTIONS, NxLabelComponent */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxBaseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxErrorModule", function () {
      return NxErrorModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ERROR_DEFAULT_OPTIONS", function () {
      return ERROR_DEFAULT_OPTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxErrorComponent", function () {
      return NxErrorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxLabelModule", function () {
      return NxLabelModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LABEL_DEFAULT_OPTIONS", function () {
      return LABEL_DEFAULT_OPTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxLabelComponent", function () {
      return NxLabelComponent;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var _allianz_ngx_ndbx_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/message */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-message.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ERROR_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('ERROR_DEFAULT_OPTIONS');

    var NxErrorComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} _defaultOptions
       */
      function NxErrorComponent(_changeDetectorRef, _defaultOptions) {
        _classCallCheck(this, NxErrorComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._defaultOptions = _defaultOptions;
        this._showIcon = true;
        this._appearance = 'message';

        if (this._defaultOptions && this._defaultOptions.appearance) {
          this.appearance = this._defaultOptions.appearance;
        }
      }
      /**
       * Whether an icon should be displayed.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxErrorComponent, [{
        key: "showIcon",
        set: function set(value) {
          this._showIcon = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._showIcon;
        }
        /**
         * Whether the error should have message or text styling.
         *
         * Default is 'message'.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "appearance",
        set: function set(value) {
          if (value !== this.appearance) {
            this._appearance = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._appearance;
        }
      }]);

      return NxErrorComponent;
    }();

    NxErrorComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
      args: [{
        selector: 'nx-error',
        template: "<!-- b2b (expert) error notification -->\n<ng-container *ngIf=\"appearance === 'text'\">\n  <nx-icon *ngIf=\"showIcon\" class=\"nx-error__icon\" [name]=\"'exclamation-triangle'\">\n  </nx-icon>\n  <div class=\"nx-error__content-wrapper\">\n    <div class=\"nx-error__content\">\n      <ng-container [ngTemplateOutlet]=\"errorContent\"></ng-container>\n    </div>\n  </div>\n</ng-container>\n\n<!-- b2c error notification -->\n<nx-message *ngIf=\"appearance === 'message'\" [showIcon]=\"showIcon\" nxContext=\"error\">\n  <ng-container [ngTemplateOutlet]=\"errorContent\"></ng-container>\n</nx-message>\n\n<ng-template #errorContent>\n  <ng-content></ng-content>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[attr.role]': '"alert"'
        },
        styles: [":host{font-size:16px;line-height:20px;color:#dc3149;width:100%;display:block}:host .nx-error__content{line-height:20px}:host .nx-error__icon{font-size:20px;line-height:20px;color:#dc3149;margin-right:8px;float:left}"]
      }]
    }];
    /** @nocollapse */

    NxErrorComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
          args: [ERROR_DEFAULT_OPTIONS]
        }]
      }];
    };

    NxErrorComponent.propDecorators = {
      showIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      appearance: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxErrorModule = function NxErrorModule() {
      _classCallCheck(this, NxErrorModule);
    };

    NxErrorModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_0__["NxIconModule"], _allianz_ngx_ndbx_message__WEBPACK_IMPORTED_MODULE_1__["NxMessageModule"]],
        declarations: [NxErrorComponent],
        exports: [NxErrorComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId = 0;
    /** @type {?} */

    var DEFAULT_SIZE = 'large';
    /** @type {?} */

    var LABEL_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('LABEL_DEFAULT_OPTIONS');

    var NxLabelComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _defaultOptions
       */
      function NxLabelComponent(_defaultOptions) {
        _classCallCheck(this, NxLabelComponent);

        this._defaultOptions = _defaultOptions;
        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._disabled = false;
        this._negative = false;
        this._id = "nx-label-".concat(nextId++);
        this._size = this._defaultOptions && this._defaultOptions.size ? this._defaultOptions.size : DEFAULT_SIZE;
      }
      /**
       * Sets the label to disabled
       * @param {?} value
       * @return {?}
       */


      _createClass(NxLabelComponent, [{
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Sets the label to disabled
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the Id of the label
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "id",
        set: function set(value) {
          if (this._id !== value) {
            this._id = value;
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * **NDBX Expert option**
         * Sets the appearance of the label
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "size",
        set: function set(value) {
          this._size = value;

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._size;
        }
      }]);

      return NxLabelComponent;
    }();

    NxLabelComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
      args: [{
        selector: 'nx-label',
        template: "<label class=\"nx-label__content\">\n  <ng-content></ng-content>\n</label>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[attr.disabled]': 'disabled',
          '[attr.aria-labelledby]': 'id || null',
          '[class.nx-label--negative]': 'negative',
          '[class.nx-label--large]': 'size === "large"',
          '[class.nx-label--small]': 'size === "small"',
          '[attr.id]': 'id'
        },
        styles: [":host{display:block;color:#414141}:host.nx-label--small{font-size:16px;line-height:24px;font-weight:600}:host.nx-label--large{font-size:20px;line-height:28px;letter-spacing:.2px;font-weight:300}:host[disabled=true] label{cursor:not-allowed}:host.nx-label--negative{color:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxLabelComponent.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"],
          args: [LABEL_DEFAULT_OPTIONS]
        }]
      }];
    };

    NxLabelComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxLabelModule = function NxLabelModule() {
      _classCallCheck(this, NxLabelModule);
    };

    NxLabelModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
        declarations: [NxLabelComponent],
        exports: [NxLabelComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-button.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-button.js ***!
    \****************************************************************************/

  /*! exports provided: NxButtonModule, NxButtonComponent, NxIconButtonComponent, ɵa, ɵb */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxButtonJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxButtonModule", function () {
      return NxButtonModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxButtonComponent", function () {
      return NxButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxIconButtonComponent", function () {
      return NxIconButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return NX_BUTTON_HOST_BINDINGS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return NxButtonBase;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var DEFAULT_SIZE = 'medium';
    /** @type {?} */

    var DEFAULT_TYPE = 'primary';
    /** @type {?} */

    var NX_BUTTON_HOST_BINDINGS = {
      '[class.nx-button--primary]': 'type === "primary"',
      '[class.nx-button--secondary]': 'type === "secondary"',
      '[class.nx-button--tertiary]': 'type === "tertiary"',
      '[class.nx-button--cta]': 'type === "cta"',
      '[class.nx-button--emphasis]': 'type === "emphasis"',
      '[class.nx-button--large]': 'size === "large"',
      '[class.nx-button--medium]': 'size === "medium"',
      '[class.nx-button--small-medium]': 'size === "small-medium"',
      '[class.nx-button--small]': 'size === "small"',
      '[class.nx-button--block]': 'block',
      '[class.nx-button--negative]': 'negative'
    };
    /**
     * \@docs-private
     */

    var NxButtonBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxButtonBase(_changeDetectorRef, _elementRef) {
        _classCallCheck(this, NxButtonBase);

        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * \@docs-private
         */

        this.type = DEFAULT_TYPE;
        /**
         * \@docs-private
         */

        this.size = DEFAULT_SIZE;
        /**
         * \@docs-private
         */

        this.negative = false;
        /**
         * \@docs-private
         */

        this.block = false;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(NxButtonBase, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;

          var _ref5 = this._classNames.match(/primary|secondary|tertiary|cta|emphasis/) || [DEFAULT_TYPE],
              _ref6 = _slicedToArray(_ref5, 1),
              _ref6$ = _ref6[0],
              type = _ref6$ === void 0 ? null : _ref6$;

          this.type =
          /** @type {?} */
          type;

          var _ref7 = this._classNames.match(/small-medium|small|medium|large/) || [DEFAULT_SIZE],
              _ref8 = _slicedToArray(_ref7, 1),
              _ref8$ = _ref8[0],
              size = _ref8$ === void 0 ? null : _ref8$;

          this.size =
          /** @type {?} */
          size;
          this.negative = /negative/.test(this._classNames);
          this.block = /block/.test(this._classNames);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
        /**
         * \@docs-private
         * getter used for the modal component as a quickfix
         * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
         * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
         * way to reach the elementRef of the component until the modal gets refactored.
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }]);

      return NxButtonBase;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxButtonComponent =
    /*#__PURE__*/
    function (_NxButtonBase) {
      _inherits(NxButtonComponent, _NxButtonBase);

      /**
       * @param {?} changeDetectorRef
       * @param {?} elementRef
       */
      function NxButtonComponent(changeDetectorRef, elementRef) {
        _classCallCheck(this, NxButtonComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(NxButtonComponent).call(this, changeDetectorRef, elementRef));
      }

      return NxButtonComponent;
    }(NxButtonBase);

    NxButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
      args: [{
        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
        // tslint:disable-next-line:component-selector
        selector: 'button[nxButton]',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
        host: NX_BUTTON_HOST_BINDINGS,
        inputs: ['classNames:nxButton'],
        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
      }]
    }];
    /** @nocollapse */

    NxButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxIconButtonComponent =
    /*#__PURE__*/
    function (_NxButtonBase2) {
      _inherits(NxIconButtonComponent, _NxButtonBase2);

      /**
       * @param {?} changeDetectorRef
       * @param {?} elementRef
       */
      function NxIconButtonComponent(changeDetectorRef, elementRef) {
        _classCallCheck(this, NxIconButtonComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(NxIconButtonComponent).call(this, changeDetectorRef, elementRef));
      }

      return NxIconButtonComponent;
    }(NxButtonBase);

    NxIconButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'button[nxIconButton]',
        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
        host: NX_BUTTON_HOST_BINDINGS,
        inputs: ['classNames:nxIconButton'],
        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
      }]
    }];
    /** @nocollapse */

    NxIconButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxButtonModule = function NxButtonModule() {
      _classCallCheck(this, NxButtonModule);
    };

    NxButtonModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
      args: [{
        declarations: [NxButtonComponent, NxIconButtonComponent],
        exports: [NxButtonComponent, NxIconButtonComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-checkbox.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-checkbox.js ***!
    \******************************************************************************/

  /*! exports provided: NxCheckboxModule, NxCheckboxChangeEvent, NxCheckboxGroupComponent, NxCheckboxComponent */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxCheckboxJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxModule", function () {
      return NxCheckboxModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxChangeEvent", function () {
      return NxCheckboxChangeEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxGroupComponent", function () {
      return NxCheckboxGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxComponent", function () {
      return NxCheckboxComponent;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/base */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-base.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nextId = 0;

    var NxCheckboxChangeEvent =
    /**
     * @param {?} checked
     * @param {?} value
     * @param {?} checkbox
     */
    function NxCheckboxChangeEvent(checked, value, checkbox) {
      _classCallCheck(this, NxCheckboxChangeEvent);

      this.checked = checked;
      this.value = value;
      this.checkbox = checkbox;
    };

    var NxCheckboxGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} ngControl
       */
      function NxCheckboxGroupComponent(_changeDetectorRef, ngControl) {
        _classCallCheck(this, NxCheckboxGroupComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this._id = "nx-checkbox-group-".concat(nextId++);
        this._disabled = false;
        this._negative = false;

        this._onChange =
        /**
        * @return {?}
        */
        function () {};

        this._onTouched =
        /**
        * @return {?}
        */
        function () {};

        if (this.ngControl) {
          // Note: we provide the value accessor through here, instead of
          // the `providers` to avoid running into a circular import.
          this.ngControl.valueAccessor = this;
        }
      }
      /**
       * Sets the Id of the checkbox group.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCheckboxGroupComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this14 = this;

          if (this.ngControl) {
            this._value = this._checkboxes.filter(
            /**
            * @param {?} checkbox
            * @return {?}
            */
            function (checkbox) {
              return checkbox.checked;
            }).map(
            /**
            * @param {?} cb
            * @return {?}
            */
            function (cb) {
              return cb.value;
            }); // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.

            Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              _this14._onChange(_this14._value);
            });
          }

          this._updateSelectedCheckboxFromValue();

          this._checkboxes.changes.subscribe(
          /**
          * @return {?}
          */
          function () {
            _this14._value = _this14._checkboxes.filter(
            /**
            * @param {?} checkbox
            * @return {?}
            */
            function (checkbox) {
              return checkbox.checked;
            }).map(
            /**
            * @param {?} cb
            * @return {?}
            */
            function (cb) {
              return cb.value;
            });

            if (_this14.ngControl) {
              _this14.ngControl.control.setValue(_this14._value);
            }

            _this14._updateSelectedCheckboxFromValue();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (this._value) {
            this._value = value;
          }

          this._updateSelectedCheckboxFromValue();
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateSelectedCheckboxFromValue",
        value: function _updateSelectedCheckboxFromValue() {
          var _this15 = this;

          if (this._checkboxes !== null) {
            if (this._value) {
              this._checkboxes.map(
              /**
              * @param {?} checkbox
              * @return {?}
              */
              function (checkbox) {
                if (_this15._value.indexOf(checkbox.value) !== -1) {
                  checkbox.checked = true;
                }
              });
            }
          }
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "change",
        value: function change(value) {
          value = this._checkboxes.filter(
          /**
          * @param {?} checkbox
          * @return {?}
          */
          function (checkbox) {
            return checkbox.checked;
          }).map(
          /**
          * @param {?} cb
          * @return {?}
          */
          function (cb) {
            return cb.value;
          });

          this._onChange(value);

          if (this._onTouched) {
            this._onTouched();
          }

          this.selectionChange.emit(new NxCheckboxChangeEvent(value.checked, value.value, value));
        }
      }, {
        key: "id",
        set: function set(value) {
          if (this._id !== value) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Sets the name of the checkboxes inside the nx-checkbox-group.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          this._name = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
        /**
         * Disables all checkboxes inside the nx-checkbox-group.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          if (this._label) {
            this._label.disabled = this._disabled;
          }

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Set the negative styles for all the checkboxes inside the nx-checkbox-group
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the label size of the checkboxes inside the group
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          this._labelSize = value;

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelSize;
        }
        /**
         * Whether the nx-checkbox-group are required.
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
        }
      }]);

      return NxCheckboxGroupComponent;
    }();

    NxCheckboxGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
      args: [{
        selector: 'nx-checkbox-group',
        template: "<div>\n  <div class=\"nx-checkbox-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-checkbox-group]': 'true',
          '[class.nx-checkbox-group--negative]': 'negative',
          '[attr.id]': 'id',
          '[attr.required]': 'required',
          '[attr.disabled]': 'disabled || null',
          '[attr.aria-labelledby]': 'this._label?.id  || null',
          '[attr.role]': '"group"'
        },
        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}:host.nx-checkbox-group--negative ::ng-deep nx-error,:host.nx-checkbox-group--negative ::ng-deep nx-icon.nx-error__icon,:host.nx-checkbox-group--negative ::ng-deep nx-label{color:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxCheckboxGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Self"]
        }]
      }];
    };

    NxCheckboxGroupComponent.propDecorators = {
      _checkboxes: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return NxCheckboxComponent;
        }), {
          descendants: true
        }]
      }],
      _label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_6__["NxLabelComponent"];
        }), {}]
      }],
      selectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }]
    };

    var NxCheckboxComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} checkboxGroup
       */
      function NxCheckboxComponent(_changeDetectorRef, checkboxGroup) {
        _classCallCheck(this, NxCheckboxComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.checkboxGroup = checkboxGroup;
        this._id = (nextId++).toString();
        this._disabled = false;
        this._negative = false;
        this._labelSize = 'small';
        this._checked = false;
        this._name = null;
        this._indeterminate = false;
        /**
         * An event emitted when the indeterminate value has changed
         */

        this.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"](false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits the boolean checked value of the changed checkbox.
         */

        this.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"](false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits a NxCheckboxChangeEvent.
         */

        this.checkboxChange = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();

        this.onChangeCallback =
        /**
        * @param {?} _
        * @return {?}
        */
        function (_) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Id of the checkbox.
       *
       * If not set, the checkbox gets an incremented value by default.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCheckboxComponent, [{
        key: "_controlInvalid",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _controlInvalid() {
          return !!(this.checkboxGroup && this.checkboxGroup.ngControl && this.checkboxGroup.ngControl.invalid && this.checkboxGroup.ngControl.touched);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this16 = this;

          if (this.checkboxGroup) {
            this.name = this.checkboxGroup.name; // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update

            this._parentChangeSubscription = this.checkboxGroup._stateChanges.subscribe(
            /**
            * @return {?}
            */
            function () {
              _this16._changeDetectorRef.markForCheck();
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setIndeterminate",
        value: function _setIndeterminate(value) {
          this._indeterminate = value;
          this.indeterminateChange.emit(this._indeterminate);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setChecked",
        value: function _setChecked(value) {
          this._checked = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.checked = !this.checked;
          this.onChangeCallback(this.checked);

          if (this.checkboxGroup !== null) {
            this.checkboxGroup.change(this);
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value === null) {
            value = false;
          }

          if (value !== this.checked) {
            this.checked = value;
          }
        }
        /**
         * @param {?} onChange
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChange) {
          this.onChangeCallback = onChange;
        }
        /**
         * @param {?} onTouched
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouched) {
          this.onTouchedCallback = onTouched;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "touch",
        value: function touch() {
          this.onTouchedCallback();
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onInputClick",
        value: function _onInputClick(event) {
          // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
          event.stopPropagation();

          if (!this.disabled) {
            this.toggle();
            this.checkedChange.emit(this._checked);
            this.checkboxChange.emit(this._createChangeEvent(this._checked));
          }
        }
        /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */

      }, {
        key: "_createChangeEvent",
        value: function _createChangeEvent(checkedValue) {
          /** @type {?} */
          var event = new NxCheckboxChangeEvent(checkedValue, this.value, this);
          event.checked = checkedValue;
          event.value = this.value;
          event.checkbox = this;
          return event;
        }
      }, {
        key: "id",
        set: function set(value) {
          if (value !== this._id) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return "nx-checkbox-".concat(this._id);
        }
        /**
         * Name of the checkbox.
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(name) {
          this._name = name;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.name ? this.checkboxGroup.name : this._name;
        }
        /**
         * Whether the checkbox is disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          if (newValue !== this._disabled) {
            this._disabled = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.disabled ? this.checkboxGroup.disabled : this._disabled;
        }
        /**
         * Sets the label size of the checkbox. Default value: small
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          this._labelSize = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.labelSize ? this.checkboxGroup.labelSize : this._labelSize;
        }
        /**
         * Whether the checkbox has negative styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          if (newValue !== this._negative) {
            this._negative = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.negative ? this.checkboxGroup.negative : this._negative;
        }
        /**
         * Whether the checkbox is checked.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "checked",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          if (newValue !== this._checked) {
            if (this._indeterminate) {
              this._setIndeterminate(false);
            }

            this._setChecked(newValue);
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._checked;
        }
        /**
         * Whether the checkbox is indeterminated.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "indeterminate",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);

          if (this._indeterminate !== newValue) {
            if (this._checked) {
              this._setChecked(false);
            }

            this._setIndeterminate(newValue);
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._indeterminate;
        }
        /**
         * Whether the checkbox is required.
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
        }
        /**
         * Sets the value of the checkbox. Default value is the checked status.
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value ? this._value : this.checked.toString();
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._value = value;

          this._changeDetectorRef.markForCheck();
        }
      }]);

      return NxCheckboxComponent;
    }();

    NxCheckboxComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
      args: [{
        selector: 'nx-checkbox',
        template: "<input\n  type=\"checkbox\"\n  [id]=\"id\"\n  [name]=\"name\"\n  [checked]=\"checked\"\n  [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  [attr.aria-labelledby]=\"id + '-label'\"\n  (click)=\"_onInputClick($event)\"\n  class=\"nx-checkbox__input\"\n  [value]=\"value\"\n>\n\n<label [id]=\"id + '-label'\" [attr.for]=\"id\" class=\"nx-checkbox__label\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"checked\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n        <div *ngIf=\"indeterminate\" class=\"nx-checkbox__indeterminate-indicator\"></div>\n    </span>\n    <div class=\"nx-checkbox__label-text\">\n        <ng-content></ng-content>\n    </div>\n</label>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-checkbox]': 'true',
          '[class.disabled]': 'disabled',
          '[class.nx-checkbox--label-large]': 'labelSize === "large"',
          '[class.nx-checkbox--negative]': 'negative',
          '[attr.required]': 'required',
          '[class.has-error]': '_controlInvalid() || null',
          '[attr.aria-invalid]': '_controlInvalid() || null'
        },
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCheckboxComponent;
          }),
          multi: true
        }],
        styles: [":host{display:block;position:relative;margin-bottom:16px}:host.has-error .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control,:host.ng-invalid .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#dc3149;border-color:#dc3149}:host.has-error .nx-checkbox__control,:host.ng-invalid .nx-checkbox__control{border-color:#dc3149}:host.has-error .nx-checkbox__indeterminate-indicator,:host.ng-invalid .nx-checkbox__indeterminate-indicator{background-color:#dc3149}.nx-checkbox__input{opacity:0;position:absolute}.nx-checkbox__label{font-size:16px;line-height:24px;cursor:pointer;display:flex}:host(.nx-checkbox--label-large) .nx-checkbox__label{font-size:20px;line-height:28px;letter-spacing:.2px}.nx-checkbox__label-text{padding:0;margin-left:12px}.nx-checkbox__control{background-color:#fff;border:2px solid #767676;border-radius:4px;color:#fff;font-size:20px;height:24px;width:24px;min-width:24px;display:flex;justify-content:center;align-items:center;z-index:0;cursor:pointer}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-radius:4px}.nx-checkbox__indeterminate-indicator{background-color:#007ab3;height:2px;width:10px}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#007ab3;border-color:#007ab3}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#ececec;border-color:#c2c2c2;cursor:not-allowed}.nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label{cursor:not-allowed;color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#c2c2c2}:host(.nx-checkbox--negative) .nx-checkbox__control{border-color:#fff;background-color:transparent}:host(.nx-checkbox--negative) .nx-checkbox__label{color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{color:#000;background-color:#fff;border-color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{color:rgba(255,255,255,.4);border-color:transparent;background-color:rgba(194,194,194,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label{color:rgba(255,255,255,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:rgba(153,153,153,.4);border-color:rgba(217,217,217,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:rgba(217,217,217,.4)}@media screen and (-ms-high-contrast:active){.nx-checkbox__input:focus+.nx-checkbox__label{color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control::after{background-color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-color:#fff}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{border-color:#ff0;color:#ff0}.nx-checkbox__input:focus:checked+.nx-checkbox__label .nx-checkbox__control{background-color:none;border-color:#fff;color:#fff}.nx-checkbox__label{color:#ff0}.nx-checkbox__input:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#ff0}.nx-checkbox__input:indeterminate:focus+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#fff}}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#075994}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#003781}:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxCheckboxComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"]
      }, {
        type: NxCheckboxGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"]
        }]
      }];
    };

    NxCheckboxComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      indeterminate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      indeterminateChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
      }],
      checkedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
      }],
      checkboxChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCheckboxModule = function NxCheckboxModule() {
      _classCallCheck(this, NxCheckboxModule);
    };

    NxCheckboxModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
      args: [{
        declarations: [NxCheckboxComponent, NxCheckboxGroupComponent],
        exports: [NxCheckboxComponent, NxCheckboxGroupComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_5__["NxIconModule"], _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_6__["NxLabelModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-core.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-core.js ***!
    \**************************************************************************/

  /*! exports provided: BREAKPOINT_MOBILE, BREAKPOINT_TABLET, BREAKPOINT_DESKTOP, MappedStyles */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxCoreJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_MOBILE", function () {
      return BREAKPOINT_MOBILE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_TABLET", function () {
      return BREAKPOINT_TABLET;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_DESKTOP", function () {
      return BREAKPOINT_DESKTOP;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MappedStyles", function () {
      return MappedStyles;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var BREAKPOINT_MOBILE = '(max-width: 703px)';
    /** @type {?} */

    var BREAKPOINT_TABLET = '(min-width: 704px) and (max-width: 992px)';
    /** @type {?} */

    var BREAKPOINT_DESKTOP = '(min-width: 993px)';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var MappedStyles =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} mapping
       * @param {?=} baseClasses
       * @param {?=} _elementRef
       * @param {?=} _renderer
       */
      function MappedStyles(mapping) {
        var baseClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var _elementRef = arguments.length > 2 ? arguments[2] : undefined;

        var _renderer = arguments.length > 3 ? arguments[3] : undefined;

        _classCallCheck(this, MappedStyles);

        this.mapping = mapping;
        this.baseClasses = baseClasses;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.classNames = '';
      }
      /**
       * @return {?}
       */


      _createClass(MappedStyles, [{
        key: "classNames",
        get: function get() {
          return this._classNames;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["removeClasses"])(this._renderer, this._elementRef, this._classNamesSanitized);
          this._classNamesSanitized = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])(value, this.baseClasses, this.mapping);
          this._classNames = value;
          Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["appendClasses"])(this._renderer, this._elementRef, this._classNamesSanitized);
        }
      }]);

      return MappedStyles;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/

  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-dropdown.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-dropdown.js ***!
    \******************************************************************************/

  /*! exports provided: NxDropdownModule, NxDropdownSelectChange, SELECT_PANEL_MAX_HEIGHT, NxDropdownComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownGroupComponent, ɵb, ɵa */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxDropdownJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownModule", function () {
      return NxDropdownModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownSelectChange", function () {
      return NxDropdownSelectChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_MAX_HEIGHT", function () {
      return SELECT_PANEL_MAX_HEIGHT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownComponent", function () {
      return NxDropdownComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownItemChange", function () {
      return NxDropdownItemChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownItemComponent", function () {
      return NxDropdownItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownGroupComponent", function () {
      return NxDropdownGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return NxDropdownClosedLabelDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return NxDropdownControl;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _allianz_ngx_ndbx_checkbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/checkbox */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-checkbox.js");
    /* harmony import */


    var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/a11y */
    "./node_modules/@angular/cdk/esm2015/a11y.js");
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */


    var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/overlay */
    "./node_modules/@angular/cdk/esm2015/overlay.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/formfield */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! @angular/cdk/observers */
    "./node_modules/@angular/cdk/esm2015/observers.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * \@docs-private
     * @return {?}
     */


    function getNxDropdownNonArrayValueError() {
      return Error('Value must be an array in multiselect mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     * @return {?}
     */


    function getNxDropdownNonFunctionValueError() {
      return Error('`compareWith` must be a function.');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var NxDropdownControl =
    /*#__PURE__*/
    function (_allianz_ngx_ndbx_for) {
      _inherits(NxDropdownControl, _allianz_ngx_ndbx_for);

      function NxDropdownControl() {
        var _this17;

        _classCallCheck(this, NxDropdownControl);

        _this17 = _possibleConstructorReturn(this, _getPrototypeOf(NxDropdownControl).apply(this, arguments));
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */

        _this17.isMultiSelect = false;
        return _this17;
      }

      return NxDropdownControl;
    }(_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_8__["NxFormfieldControl"]);

    NxDropdownControl.propDecorators = {
      isMultiSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxIsMultiselect']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownGroupComponent = function NxDropdownGroupComponent() {
      _classCallCheck(this, NxDropdownGroupComponent);
    };

    NxDropdownGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Component"],
      args: [{
        selector: 'nx-dropdown-group',
        template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background-color:rgba(236,236,236,.5)}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-style:italic;padding:24px 32px 16px;font-weight:700;font-size:12px;line-height:16px}"]
      }]
    }];
    NxDropdownGroupComponent.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxLabel']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownItemChange =
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    function NxDropdownItemChange(item) {
      var isUserInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, NxDropdownItemChange);

      this.item = item;
      this.isUserInput = isUserInput;
    };
    /**
     * the unique id counter
     * @type {?}
     */


    var nextId = 0;

    var NxDropdownItemComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _dropdown
       * @param {?} group
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
        var _this18 = this;

        _classCallCheck(this, NxDropdownItemComponent);

        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = "nx-dropdown-item-".concat(nextId++);
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */

        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix

        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */

        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();

        /** @type {?} */
        this._dropdown.filterChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          _this18._showOrHideByFilter(value);
        }); // reset the hidden state when dropdown closes that on next open the user is seeing the full list again


        /** @type {?} */
        this._dropdown._closedStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
        /**
        * @return {?}
        */
        function () {
          _this18._hidden = false;
        });
      }
      /**
       * The unique ID of the option.
       * @return {?}
       */


      _createClass(NxDropdownItemComponent, [{
        key: "ngAfterViewChecked",

        /**
         * @return {?}
         */
        value: function ngAfterViewChecked() {
          // Since the parent dropdown component could be using the item's label to display the selected values
          // and it doesn't have a way of knowing if the item's label has changed
          // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
          // relatively cheap, however we still limit them only to selected options in order to avoid
          // hitting the DOM too often.
          if (this._selected) {
            /** @type {?} */
            var viewValue = this.viewValue;

            if (viewValue !== this._mostRecentViewValue) {
              this._mostRecentViewValue = viewValue;

              this._stateChanges.next();
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();

          this._destroy.next();

          this._destroy.complete();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onClick",
        value: function _onClick(event) {
          /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
          event.preventDefault();
          event.stopPropagation();

          this._selectViaInteraction();
        }
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */

      }, {
        key: "_selectViaInteraction",
        value: function _selectViaInteraction() {
          this._selected = this.multiselect ? !this._selected : true;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent(true);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "show",
        value: function show() {
          this._hidden = false;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide() {
          this._hidden = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @param {?} search
         * @return {?}
         */

      }, {
        key: "_showOrHideByFilter",
        value: function _showOrHideByFilter(search) {
          /** @type {?} */
          var constraint =
          /** @type {?} */
          this._dropdown.filterFn(search, this.viewValue);

          this._hidden = constraint ? false : true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "select",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function select() {
          if (!this._selected) {
            this._selected = true;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "deselect",
        value: function deselect() {
          if (this._selected) {
            this._selected = false;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          this._elementRef.nativeElement.focus();
        }
        /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */

      }, {
        key: "_emitSelectionChangeEvent",
        value: function _emitSelectionChangeEvent() {
          var isUserInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setActiveStyles",
        value: function setActiveStyles() {
          this._active = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setInactiveStyles",
        value: function setInactiveStyles() {
          this._active = false;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getLabel",
        value: function getLabel() {
          return this.value;
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "_isContentEmpty",
        value: function _isContentEmpty(element) {
          return element.children.length === 0 && !element.textContent.trim();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_onLabelChange",
        value: function _onLabelChange() {
          // trigger change detection when the label content changes for the case that ng-content was empty before.
          // this is also important when the label comes in deferred, e.g. by a delayed observable,
          // then first the default label derived from the value is shown
          // and after the value from the async observable is ready we need to trigger change detection that the derived label
          // gets hidden again.
          // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
          // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
          this._changeDetectorRef.detectChanges();
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * Whether the item is selected.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * Whether the item is active.
         * @return {?}
         */

      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * \@docs-private
         * Whether the parent dropdown is in multiselect mode.
         * @return {?}
         */

      }, {
        key: "multiselect",
        get: function get() {
          return this._dropdown && this._dropdown.isMultiSelect;
        }
      }, {
        key: "_formattedValue",
        get: function get() {
          return (
            /** @type {?} */
            this._dropdown.valueFormatter(this.value)
          );
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "viewValue",
        get: function get() {
          return (this._elementRef.nativeElement.textContent || '').trim();
        }
      }]);

      return NxDropdownItemComponent;
    }();

    NxDropdownItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Component"],
      args: [{
        selector: 'nx-dropdown-item',
        template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[id]': 'id',
          'role': 'option',
          '[attr.aria-selected]': 'selected.toString()',
          '[class.nx-hidden]': '_hidden',
          '[class.nx-dropdown-item--active]': 'active',
          '[class.nx-selected]': 'selected',
          '[class.nx-multiselect]': 'multiselect',
          '(click)': '_onClick($event)'
        },
        styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-multiselect) ::ng-deep .nx-checkbox__label{height:28px;display:flex;align-items:center}:host(.nx-dropdown-item--active),:host:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active),:host:hover{color:highlightText}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}.nx-dropdown-results__option-checkicon{opacity:0;width:16px;height:16px;margin-right:8px}.nx-dropdown-results__option-checkicon nx-icon{font-size:16px}:host-context([data-whatinput=keyboard]).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
      }]
    }];
    /** @nocollapse */

    NxDropdownItemComponent.ctorParameters = function () {
      return [{
        type: NxDropdownControl,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Inject"],
          args: [NxDropdownControl]
        }]
      }, {
        type: NxDropdownGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Optional"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ElementRef"]
      }];
    };

    NxDropdownItemComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxValue']
      }],
      onSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"]
      }],
      containerElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['container']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-template and project it into the required destination.

    var NxDropdownClosedLabelDirective =
    /**
     * @param {?} templateRef
     */
    function NxDropdownClosedLabelDirective(templateRef) {
      _classCallCheck(this, NxDropdownClosedLabelDirective);

      this.templateRef = templateRef;
    };

    NxDropdownClosedLabelDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Directive"],
      args: [{
        selector: '[nxClosedLabel]'
      }]
    }];
    /** @nocollapse */

    NxDropdownClosedLabelDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */


    var NxDropdownSelectChange =
    /**
     * @param {?} source
     * @param {?} value
     */
    function NxDropdownSelectChange(source, value) {
      _classCallCheck(this, NxDropdownSelectChange);

      this.source = source;
      this.value = value;
    }; // used in calculation of scrolltop to correctly show some space to the top of the panel

    /** @type {?} */


    var itemPadding = 16; // Max-height: 6 items x 44px + 16px padding before first item

    /** @type {?} */

    var SELECT_PANEL_MAX_HEIGHT = 280;

    var NxDropdownComponent =
    /*#__PURE__*/
    function (_NxDropdownControl) {
      _inherits(NxDropdownComponent, _NxDropdownControl);

      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       * @param {?} _ngZone
       * @param {?} tabIndex
       * @param {?} formFieldComponent
       * @param {?} ngControl
       * @param {?} _parentForm
       * @param {?} _parentFormGroup
       */
      function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        var _this19;

        _classCallCheck(this, NxDropdownComponent);

        _this19 = _possibleConstructorReturn(this, _getPrototypeOf(NxDropdownComponent).call(this));
        _this19._changeDetectorRef = _changeDetectorRef;
        _this19._elementRef = _elementRef;
        _this19._ngZone = _ngZone;
        _this19.formFieldComponent = formFieldComponent;
        _this19.ngControl = ngControl;
        _this19._parentForm = _parentForm;
        _this19._parentFormGroup = _parentFormGroup; // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here

        _this19.readonly = false;
        _this19._disabled = false;
        _this19._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */

        _this19._panelOpen = false;
        /**
         * \@docs-private
         */

        _this19.errorState = false;
        /**
         * The scroltop of the panelBody.
         */

        _this19._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */

        _this19._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */

        _this19.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */

        _this19._optionIds = '';
        _this19._tabIndex = 0;
        /**
         * \@docs-private
         */

        _this19.currentFilter = '';
        /**
         * Label to describe the component.
         */

        _this19._ariaLabel = '';
        _this19._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */

        _this19._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */

        _this19.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */

        _this19.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */

        _this19.openedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
        /**
         * Event emitted when the select has been opened.
         */

        _this19._openedStream = _this19.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(
        /**
        * @param {?} o
        * @return {?}
        */
        function (o) {
          return o;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(
        /**
        * @return {?}
        */
        function () {}));
        /**
         * Event emitted when the select has been closed.
         */

        _this19._closedStream = _this19.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(
        /**
        * @param {?} o
        * @return {?}
        */
        function (o) {
          return !o;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(
        /**
        * @return {?}
        */
        function () {}));
        /**
         * Event emitted when the user types in the filter input.
         */

        _this19.filterChanges = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */

        _this19.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
        /**
         * Event emitted when the selected value has been changed.
         */

        _this19.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
        /**
         * \@docs-private
         */

        _this19.optionSelectionChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["defer"])(
        /**
        * @return {?}
        */
        function () {
          if (_this19.options) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"]).apply(void 0, _toConsumableArray(_this19.options.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.onSelectionChange;
            })));
          }

          return _this19._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            return _this19.optionSelectionChanges;
          }));
        });
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */

        _this19._positions = [{
          originX: 'start',
          originY: 'top',
          overlayX: 'start',
          overlayY: 'top'
        }, {
          originX: 'start',
          originY: 'center',
          overlayX: 'start',
          overlayY: 'center'
        }, {
          originX: 'start',
          originY: 'bottom',
          overlayX: 'start',
          overlayY: 'bottom'
        }];
        /**
         * Emits whenever the component is destroyed.
         */

        _this19._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */

        _this19.valueFormatter =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return value == null ? '' : value.toString();
        };
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */


        _this19._compareWith =
        /**
        * @param {?} o1
        * @param {?} o2
        * @return {?}
        */
        function (o1, o2) {
          return o1 === o2;
        };

        _this19._filterFn =
        /**
        * @param {?} search
        * @param {?} itemValue
        * @return {?}
        */
        function (search, itemValue) {
          return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        };
        /**
         * `View -> model callback called when value changes`
         */


        _this19._onChange =
        /**
        * @return {?}
        */
        function () {};
        /**
         * `View -> model callback called when select has been touched`
         */


        _this19._onTouched =
        /**
        * @return {?}
        */
        function () {};

        if (_this19.ngControl) {
          // Note: we provide the value accessor through here, instead of
          // the `providers` to avoid running into a circular import.
          _this19.ngControl.valueAccessor = _assertThisInitialized(_this19);
        }

        _this19.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this19;
      }
      /**
       * @return {?}
       */


      _createClass(NxDropdownComponent, [{
        key: "ngDoCheck",

        /**
         * @return {?}
         */
        value: function ngDoCheck() {
          if (this.ngControl) {
            this.updateErrorState();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__["SelectionModel"](this.isMultiSelect);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this20 = this;

          this._closedDropdownLabel = this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;

          this._initKeyManager();

          this._selectionModel.onChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            event.added.forEach(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.select();
            });
            event.removed.forEach(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.deselect();
            });
          });

          this.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this20._resetOptions();

            _this20._initializeSelection();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy.next();

          this._destroy.complete();
        }
        /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "isErrorState",
        value: function isErrorState(control, form) {
          return !!(control && control.invalid && (control.touched || form && form.submitted));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updateErrorState",
        value: function updateErrorState() {
          /** @type {?} */
          var oldState = this.errorState;
          /** @type {?} */

          var parent = this._parentFormGroup || this._parentForm;
          /** @type {?} */

          var control = this.ngControl ?
          /** @type {?} */
          this.ngControl.control : null;
          /** @type {?} */

          var newState = this.isErrorState(control, parent);

          if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
          }
        }
        /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_initKeyManager",
        value: function _initKeyManager() {
          var _this21 = this;

          this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__["ActiveDescendantKeyManager"](this.options).withTypeAhead().withWrap().withVerticalOrientation().withHorizontalOrientation('ltr').skipPredicate(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item._hidden;
          });

          this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            _this21.closePanel();
          });

          this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            if (_this21._panelOpen && _this21.panel) {
              // Delay the auto scrolling until all items have settled otherwise the item containers might
              // not exist yet
              _this21._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(
              /**
              * @return {?}
              */
              function () {
                return _this21._scrollActiveOptionIntoView();
              });
            } else if (!_this21._panelOpen && !_this21.isMultiSelect && _this21._keyManager.activeItem) {
              _this21._keyManager.activeItem._selectViaInteraction();
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_resetOptions",
        value: function _resetOptions() {
          var _this22 = this;

          /** @type {?} */
          var changedOrDestroyed = Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"])(this.options.changes, this._destroy);
          this.optionSelectionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            _this22._onSelect(event.item, event.isUserInput);

            if (event.isUserInput && !_this22.isMultiSelect && _this22._panelOpen) {
              _this22.closePanel();
            }
          }); // Listen to changes in the internal state of the options and react accordingly.
          // Handles cases like the labels of the selected options changing.

          Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"]).apply(void 0, _toConsumableArray(this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._stateChanges;
          }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout(
            /**
            * @return {?}
            */
            function () {
              _this22._changeDetectorRef.markForCheck();

              _this22.stateChanges.next();
            });
          });

          this._setOptionIds();
        }
        /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */

      }, {
        key: "_setOptionIds",
        value: function _setOptionIds() {
          this._optionIds = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option.id;
          }).join(' ');
        }
        /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */

      }, {
        key: "_onSelect",
        value: function _onSelect(option, isUserInput) {
          /** @type {?} */
          var wasSelected = this._selectionModel.isSelected(option);

          if (option.value == null && !this.isMultiSelect) {
            option.deselect();

            this._selectionModel.clear();

            this._propagateChanges(option.value);
          } else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);

            if (isUserInput) {
              this._keyManager.setActiveItem(option);
            }

            if (this.isMultiSelect) {
              this._sortValues();

              if (isUserInput) {
                // In case the user selected the option with their mouse, we
                // want to restore focus back to the trigger, in order to
                // prevent the select keyboard controls from clashing with
                // the ones from `mat-option`.
                this.focus();
              }
            }
          }

          if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
          }

          this.stateChanges.next();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_initializeSelection",
        value: function _initializeSelection() {
          var _this23 = this;

          // Defer setting the value in order to avoid the "Expression
          // has changed after it was checked" errors from Angular.
          Promise.resolve().then(
          /**
          * @return {?}
          */
          function () {
            _this23._setSelectionByValue(_this23.ngControl ? _this23.ngControl.value : _this23._value);
          });
        }
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setSelectionByValue",
        value: function _setSelectionByValue(value) {
          var _this24 = this;

          if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
              throw getNxDropdownNonArrayValueError();
            }

            this._selectionModel.clear();

            value.forEach(
            /**
            * @param {?} currentValue
            * @return {?}
            */
            function (currentValue) {
              return _this24._selectValue(currentValue);
            });

            this._sortValues();
          } else {
            this._selectionModel.clear();
            /** @type {?} */


            var correspondingOption = this._selectValue(value); // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.


            if (correspondingOption) {
              this._keyManager.setActiveItem(correspondingOption);
            }
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */

      }, {
        key: "_selectValue",
        value: function _selectValue(value) {
          var _this25 = this;

          /** @type {?} */
          var correspondingOption = this.options.find(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            try {
              // Treat null as a special reset value.
              return option.value != null && _this25._compareWith(option.value, value);
            } catch (error) {
              if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_11__["isDevMode"])()) {
                // Notify developers of errors in their comparator.
                console.warn(error);
              }

              return false;
            }
          });

          if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
          }

          return correspondingOption;
        }
        /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */

      }, {
        key: "_propagateChanges",
        value: function _propagateChanges(fallbackValue) {
          /** @type {?} */
          var valueToEmit = null;

          if (this.isMultiSelect) {
            valueToEmit =
            /** @type {?} */
            this.selected.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.value;
            });
          } else {
            valueToEmit = this.selected ?
            /** @type {?} */
            this.selected.value : fallbackValue;
          }

          this._value = valueToEmit;
          this.valueChange.emit(valueToEmit);

          this._onChange(valueToEmit);

          this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_sortValues",
        value: function _sortValues() {
          if (this.isMultiSelect) {
            /** @type {?} */
            var options = this.options.toArray();

            this._selectionModel.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function (a, b) {
              return options.indexOf(a) - options.indexOf(b);
            });

            this.stateChanges.next();
          }
        }
        /**
         * Focuses the select element.
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          this._elementRef.nativeElement.focus();
        }
        /**
         * Opens the panel of the dropdown.
         * @return {?}
         */

      }, {
        key: "openPanel",
        value: function openPanel() {
          if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
          }

          this._panelOpen = true;
          this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();

          this._keyManager.withHorizontalOrientation(null);

          this._highlightCorrectOption();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Closes the panel of the dropdown.
         * @return {?}
         */

      }, {
        key: "closePanel",
        value: function closePanel() {
          var _this26 = this;

          if (this._panelOpen) {
            this._panelOpen = false;

            this._keyManager.withHorizontalOrientation('ltr');

            this._changeDetectorRef.markForCheck();

            this._onTouched();

            this.openedChange.emit(false); // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors

            setTimeout(
            /**
            * @return {?}
            */
            function () {
              return _this26.focus();
            });
          }
        } // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_calculateScrollTop",
        value: function _calculateScrollTop() {
          // reset the scrolltop to make calculation easier
          this.panelBody.nativeElement.scrollTop = 0;
          this._scrollTop = 0;

          if (!this.empty) {
            /** @type {?} */
            var offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */


            var panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */

            var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */

            var middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */

            var activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();

            if (offset > middleOfPanel) {
              // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
              // target position for the item and subtract it from the offset (which is now always relative to the viewport)
              // to middle out the text a bit more add half of the height
              // (this is still a few pixels off because the container is a bit larger than the font)
              this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
              this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
          }
        }
        /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollActiveOptionIntoView",
        value: function _scrollActiveOptionIntoView() {
          if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
          }
          /** @type {?} */


          var activeOptionIndex = this._keyManager.activeItemIndex || 0;
          /** @type {?} */

          var itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
          /** @type {?} */


          var labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);

          this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
        }
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} options
         * @param {?} optionGroups
         * @return {?}
         */

      }, {
        key: "_countGroupLabelsBeforeOption",
        value: function _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
          if (optionGroups.length) {
            /** @type {?} */
            var optionsArray = options.toArray();
            /** @type {?} */

            var groups = optionGroups.toArray();
            /** @type {?} */

            var groupCounter = 0;

            for (var i = 0; i < optionIndex + 1; i++) {
              if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                groupCounter++;
              }
            }

            return groupCounter;
          }

          return 0;
        }
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} optionHeight
         * @param {?} currentScrollPosition
         * @param {?} panelHeight
         * @return {?}
         */

      }, {
        key: "_getOptionScrollPosition",
        value: function _getOptionScrollPosition(optionIndex, optionHeight, currentScrollPosition, panelHeight) {
          /** @type {?} */
          var optionOffset = optionIndex * optionHeight + itemPadding;

          if (this.showFilter) {
            /** @type {?} */
            var filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
          }

          if (optionOffset < currentScrollPosition) {
            return optionOffset;
          }

          if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
          }

          return currentScrollPosition;
        }
        /**
         * @private
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_getItemOffset",
        value: function _getItemOffset(item) {
          /** @type {?} */
          var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
          return itemRect.top;
        }
        /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */

      }, {
        key: "setDescribedByIds",
        value: function setDescribedByIds(ids) {
          this.ariaDescribedby = ids.join(' ');
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(value) {
          this._ariaLabel = value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "_getAriaLabel",
        value: function _getAriaLabel() {
          return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
        }
        /**
         * \@docs-private
         * Whether the select has a value.
         * @return {?}
         */

      }, {
        key: "writeValue",

        /** End Formfield */

        /** ControlValueAccessor */

        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        value: function writeValue(value) {
          if (this.options) {
            this._setSelectionByValue(value);
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;

          this._changeDetectorRef.markForCheck();

          this.stateChanges.next();
        }
        /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleKeydown",
        value: function _handleKeydown(event) {
          this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleClosedKeydown",
        value: function _handleClosedKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode;
          /** @type {?} */

          var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["LEFT_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["RIGHT_ARROW"];
          /** @type {?} */

          var isOpenKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SPACE"]; // Open the select on ALT + arrow key to match the native <select>

          if (isOpenKey || (this.isMultiSelect || event.altKey) && isArrowKey) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space

            this.openPanel();
          } else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
          }
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleOpenKeydown",
        value: function _handleOpenKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode; // all events other than the listed ones should be ignored or handled in _onFilter()

          if (!([_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["END"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["LEFT_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["RIGHT_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SHIFT"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SPACE"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["TAB"]].indexOf(keyCode) >= 0)) {
            return;
          }
          /** @type {?} */


          var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"];
          /** @type {?} */

          var manager = this._keyManager;
          /** @type {?} */

          var allHidden = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._hidden;
          }).every(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return Boolean(option);
          });

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["END"]) {
            event.preventDefault();
            keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
          } else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] && manager.activeItem && !allHidden) {
            event.preventDefault();

            manager.activeItem._selectViaInteraction();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] && allHidden) {
            event.preventDefault();
            this.closePanel();
          } else if (!this.showFilter && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["SPACE"] && manager.activeItem) {
            event.preventDefault();

            manager.activeItem._selectViaInteraction();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["TAB"]) {
            this.closePanel();
          } else {
            /** @type {?} */
            var previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);

            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem && manager.activeItemIndex !== previouslyFocusedIndex) {
              manager.activeItem._selectViaInteraction();
            }
          }
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "formatValue",
        value: function formatValue(value) {
          return this.valueFormatter(value);
        }
        /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onFilter",
        value: function _onFilter(event) {
          event.preventDefault();
          this.currentFilter = event.target.value;
          this.filterChanges.next(event.target.value);
          /** @type {?} */

          var allHidden = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._hidden;
          }).every(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return Boolean(option);
          });

          if (allHidden) {
            this._keyManager.setActiveItem(null);
          } else {
            this._keyManager.setFirstItemActive();
          }
        }
        /**
         * \@docs-private
         * The value displayed in the trigger.
         * @return {?}
         */

      }, {
        key: "_highlightCorrectOption",

        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        value: function _highlightCorrectOption() {
          if (this._keyManager) {
            if (this.empty) {
              this._keyManager.setFirstItemActive();
            } else {
              this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
          }
        }
        /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */

      }, {
        key: "_onAttached",
        value: function _onAttached() {
          var _this27 = this;

          this._changeDetectorRef.markForCheck();

          this.overlayDir.positionChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this27.panelBody.nativeElement.focus();

            if (_this27._keyManager.activeItem) {
              _this27._calculateScrollTop();
            }

            _this27._changeDetectorRef.markForCheck();

            _this27.openedChange.emit(true);

            if (_this27.showFilter) {
              _this27.filterInput.nativeElement.focus();
            }
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "_onFocus",
        value: function _onFocus() {
          if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
          }
        }
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */

      }, {
        key: "_onBlur",
        value: function _onBlur() {
          this._focused = false;

          if (this.filterInput && this.showFilter) {
            this._clearFilter();
          }

          if (!this.disabled && !this.panelOpen) {
            this._onTouched();

            this._changeDetectorRef.markForCheck();

            this.stateChanges.next();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_clearFilter",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _clearFilter() {
          this.filterInput.nativeElement.value = '';
          this.currentFilter = '';
          this.filterChanges.next('');
        }
        /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */

      }, {
        key: "_getAriaActiveDescendant",
        value: function _getAriaActiveDescendant() {
          if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
          }

          return null;
        }
      }, {
        key: "tabIndex",
        get: function get() {
          return this.disabled ? -1 : this._tabIndex;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          // If the specified tabIndex value is null or undefined, fall back to the default value.
          this._tabIndex = value != null ? value : 0;
        }
        /**
         * Selected value
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;

            this._onChange(newValue);
          }
        }
        /**
         * Whether the dropdown is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabled = value;
        }
        /**
         * If set to 'negative', the component is displayed with the negative set of styles.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "styles",
        set: function set(value) {
          if (this._style === value) {
            return;
          }

          this._style = value;
          this._negative = !!this._style.match(/negative/);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "closedDropdownLabel",
        get: function get() {
          return this._closedDropdownLabel;
        }
        /**
         * \@docs-private
         * The currently selected option.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "panelOpen",
        get: function get() {
          return this._panelOpen;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._panelOpen = value;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "label",
        get: function get() {
          return this.formFieldComponent ? this.formFieldComponent.label : '';
        }
        /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         * @return {?}
         */

      }, {
        key: "compareWith",
        get: function get() {
          return this._compareWith;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
          }

          this._compareWith = fn;

          if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
          }
        }
        /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         * @return {?}
         */

      }, {
        key: "filterFn",
        get: function get() {
          return this._filterFn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
          }

          this._filterFn = fn;
        }
        /**
         * \@docs-private
         * Whether the select is focused.
         * @return {?}
         */

      }, {
        key: "focused",
        get: function get() {
          return this._focused || this.panelOpen;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }, {
        key: "empty",
        get: function get() {
          return !this._selectionModel || this._selectionModel.isEmpty();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hasValue",
        get: function get() {
          return this._selectionModel.hasValue();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "shouldLabelFloat",
        get: function get() {
          return this.focused || !this.empty;
        }
      }, {
        key: "triggerValue",
        get: function get() {
          if (this.empty) {
            return '';
          }

          if (this.isMultiSelect) {
            /** @type {?} */
            var selectedOptions = this._selectionModel.selected.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.viewValue;
            });

            return selectedOptions.join(', ');
          }

          return this._selectionModel.selected[0].viewValue;
        }
      }, {
        key: "isFilterEmpty",
        get: function get() {
          return this.currentFilter.length === 0;
        }
      }]);

      return NxDropdownComponent;
    }(NxDropdownControl);

    NxDropdownComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Component"],
      args: [{
        selector: 'nx-dropdown',
        template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: NxDropdownControl,
          useExisting: NxDropdownComponent
        }, {
          provide: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_8__["NxFormfieldControl"],
          useExisting: NxDropdownComponent
        }],
        host: {
          'role': 'button',
          '[class.nx-dropdown]': 'true',
          '[class.is-filled]': 'hasValue',
          '[class.has-focus]': 'focused',
          '[class.nx-dropdown--negative]': '_negative',
          '[class.nx-dropdown--disabled]': 'disabled',
          '[attr.aria-describedby]': 'ariaDescribedby || null',
          '[attr.aria-required]': 'required',
          '[attr.aria-label]': '_getAriaLabel()',
          '[attr.aria-haspopup]': '"listbox"',
          '[attr.aria-expanded]': 'panelOpen',
          '[attr.disabled]': 'disabled || null',
          '[attr.tabindex]': 'tabIndex',
          '(keydown)': '_handleKeydown($event)',
          '(focus)': '_onFocus()',
          '(blur)': '_onBlur()',
          '(click)': 'openPanel()'
        },
        styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
      }]
    }];
    /** @nocollapse */

    NxDropdownComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["NgZone"]
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Attribute"],
          args: ['tabindex']
        }]
      }, {
        type: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_8__["NxFormfieldComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_7__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_7__["NgForm"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_7__["FormGroupDirective"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Optional"]
        }]
      }];
    };

    NxDropdownComponent.propDecorators = {
      tabIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"]
      }],
      _ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxAriaLabel']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxValue']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxDisabled']
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxRequired']
      }],
      styles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxStyle']
      }],
      showFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxShowFilter']
      }],
      filterPlaceholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxFilterPlaceholder']
      }],
      openedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"]
      }],
      _openedStream: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"],
        args: ['opened']
      }],
      _closedStream: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"],
        args: ['closed']
      }],
      filterChanges: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"],
        args: ['filterInput']
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"],
        args: ['nxValueChange']
      }],
      selectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Output"]
      }],
      panel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['panel']
      }],
      panelBody: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['panelBody']
      }],
      trigger: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['trigger']
      }],
      filterInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['filterInput']
      }],
      overlayDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["CdkConnectedOverlay"]]
      }],
      options: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ContentChildren"],
        args: [NxDropdownItemComponent, {
          descendants: true
        }]
      }],
      groups: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ContentChildren"],
        args: [NxDropdownGroupComponent]
      }],
      _customClosedDropdownLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ContentChild"],
        args: [NxDropdownClosedLabelDirective]
      }],
      _defaultClosedDropdownLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["ViewChild"],
        args: ['defaultClosedDropdownLabel']
      }],
      valueFormatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"],
        args: ['nxValueFormatter']
      }],
      compareWith: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"]
      }],
      filterFn: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownModule = function NxDropdownModule() {
      _classCallCheck(this, NxDropdownModule);
    };

    NxDropdownModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_11__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_8__["NxFormfieldModule"], _allianz_ngx_ndbx_checkbox__WEBPACK_IMPORTED_MODULE_2__["NxCheckboxModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__["A11yModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_0__["NxIconModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_12__["ObserversModule"]],
        declarations: [NxDropdownComponent, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective],
        exports: [NxDropdownComponent, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js ***!
    \*******************************************************************************/

  /*! exports provided: NxFormfieldErrorDirective, NxFormfieldLabelDirective, NxFormfieldModule, FORMFIELD_DEFAULT_OPTIONS, NxFormfieldComponent, NxFormfieldControl, ɵe, ɵa, ɵb, ɵd, ɵc */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxFormfieldJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFormfieldErrorDirective", function () {
      return NxFormfieldErrorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFormfieldLabelDirective", function () {
      return NxFormfieldLabelDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFormfieldModule", function () {
      return NxFormfieldModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FORMFIELD_DEFAULT_OPTIONS", function () {
      return FORMFIELD_DEFAULT_OPTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFormfieldComponent", function () {
      return NxFormfieldComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFormfieldControl", function () {
      return NxFormfieldControl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵe", function () {
      return NxFormfieldAppendixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return NxFormfieldHintDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return NxFormfieldNoteDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return NxFormfieldPrefixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return NxFormfieldSuffixDirective;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var uniqueId = 0;

    var NxFormfieldErrorDirective = function NxFormfieldErrorDirective() {
      _classCallCheck(this, NxFormfieldErrorDirective);

      // create a unique id to be used by aria-described-by

      /**
       * Sets the id of the formfield error.
       */
      this.id = "nx-formfield-error-".concat(uniqueId++);
    };

    NxFormfieldErrorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldError], [nxError]',
        host: {
          role: 'alert',
          '[attr.id]': 'id'
        }
      }]
    }];
    NxFormfieldErrorDirective.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A directive for passing more complex custom label content.
     */

    var NxFormfieldLabelDirective = function NxFormfieldLabelDirective() {
      _classCallCheck(this, NxFormfieldLabelDirective);
    };

    NxFormfieldLabelDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-formfield-label'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var uniqueId$1 = 0; // This Directive solely purpose is to mark given ng-content and project it into the required destination.

    var NxFormfieldHintDirective = function NxFormfieldHintDirective() {
      _classCallCheck(this, NxFormfieldHintDirective);

      /**
       * Sets the id of the formfield hint.
       */
      this.id = "nx-formfield-hint-".concat(uniqueId$1++);
    };

    NxFormfieldHintDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldHint]',
        host: {
          '[attr.id]': 'id'
        }
      }]
    }];
    NxFormfieldHintDirective.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var uniqueId$2 = 0; // This Directive solely purpose is to mark given ng-content and project it into the required destination.

    var NxFormfieldNoteDirective = function NxFormfieldNoteDirective() {
      _classCallCheck(this, NxFormfieldNoteDirective);

      /**
       * Sets the id of the formfield note.
       */
      this.id = "nx-formfield-note-".concat(uniqueId$2++);
    };

    NxFormfieldNoteDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldNote]',
        host: {
          '[attr.id]': 'id'
        }
      }]
    }];
    NxFormfieldNoteDirective.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     * @abstract
     * @template T
     */

    var NxFormfieldControl = function NxFormfieldControl() {
      _classCallCheck(this, NxFormfieldControl);
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-content and project it into the required destination.


    var NxFormfieldSuffixDirective = function NxFormfieldSuffixDirective() {
      _classCallCheck(this, NxFormfieldSuffixDirective);
    };

    NxFormfieldSuffixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldSuffix]'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-content and project it into the required destination.

    var NxFormfieldPrefixDirective = function NxFormfieldPrefixDirective() {
      _classCallCheck(this, NxFormfieldPrefixDirective);
    };

    NxFormfieldPrefixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldPrefix]'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var uniqueId$3 = 0; // This Directive solely purpose is to mark given ng-content and project it into the required destination.

    var NxFormfieldAppendixDirective = function NxFormfieldAppendixDirective() {
      _classCallCheck(this, NxFormfieldAppendixDirective);

      /**
       * Sets the id of the formfield appendix.
       */
      this.id = "nx-formfield-appendix-".concat(uniqueId$3++);
    };

    NxFormfieldAppendixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[nxFormfieldAppendix]',
        host: {
          '[attr.id]': 'id'
        }
      }]
    }];
    NxFormfieldAppendixDirective.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NX_STYLES = {
      'negative': 'nx-formfield--negative'
    };
    /** @type {?} */

    var FORMFIELD_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('FORMFIELD_DEFAULT_OPTIONS');

    var NxFormfieldComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} renderer
       * @param {?} _changeDetectorRef
       * @param {?} _defaultOptions
       */
      function NxFormfieldComponent(elementRef, renderer, _changeDetectorRef, _defaultOptions) {
        _classCallCheck(this, NxFormfieldComponent);

        this.elementRef = elementRef;
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._defaultOptions = _defaultOptions;
        this._styles = '';
        this._subscriptions = [];
      }
      /**
       * Whether the label should float once the input is focused or filled (auto, default)
       * or force it to always float with a value of always to simulate a more static form.
       * @return {?}
       */


      _createClass(NxFormfieldComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this28 = this;

          /** @type {?} */
          var subscription;
          /** @type {?} */

          var subscriptions = [];

          this._validateControlChild(); // Subscribe to changes in the child control state in order to update the form field UI.


          subscription = this._control.stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["startWith"])(null)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this28._syncDescribedByIds();

            _this28._changeDetectorRef.markForCheck();
          });
          subscriptions.push(subscription); // Re-validate when the number of hints changes.

          subscription = this._hintChildren.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["startWith"])(null)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this28._changeDetectorRef.markForCheck();
          });
          subscriptions.push(subscription); // Update the aria-described by when the number of errors changes.

          subscription = this._errorChildren.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["startWith"])(null)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this28._syncDescribedByIds();

            _this28._changeDetectorRef.markForCheck();
          });
          subscriptions.push(subscription);
          this._subscriptions = subscriptions;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentChecked",
        value: function ngAfterContentChecked() {
          this._validateControlChild();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._subscriptions.forEach(
          /**
          * @param {?} subscription
          * @return {?}
          */
          function (subscription) {
            return subscription.unsubscribe();
          });
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getDisplayedMessage",
        value: function getDisplayedMessage() {
          if (this._control.errorState && this._errorChildren && this._errorChildren.length > 0) {
            return 'error';
          }

          return 'hint';
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_syncDescribedByIds",
        value: function _syncDescribedByIds() {
          if (this._control) {
            /** @type {?} */
            var ids = [];
            ids = this._noteChildren.map(
            /**
            * @param {?} hint
            * @return {?}
            */
            function (hint) {
              return hint.id;
            });

            if (this.getDisplayedMessage() === 'hint') {
              ids = [].concat(_toConsumableArray(this._hintChildren.map(
              /**
              * @param {?} hint
              * @return {?}
              */
              function (hint) {
                return hint.id;
              })), _toConsumableArray(ids));
            } else if (this._errorChildren) {
              ids = [].concat(_toConsumableArray(this._errorChildren.map(
              /**
              * @param {?} error
              * @return {?}
              */
              function (error) {
                return error.id;
              })), _toConsumableArray(ids));
            }

            this._control.setDescribedByIds(ids);
          }
        } // Fail if the required control is missing.

        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_validateControlChild",
        value: function _validateControlChild() {
          if (!this._control) {
            throw new Error('Formfield must contain a NxFormfieldControl like input[nxInput] or a custom implementation');
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getConnectedOverlayOrigin",
        value: function getConnectedOverlayOrigin() {
          return this._connectionContainerRef || this.elementRef;
        }
      }, {
        key: "floatLabel",
        get: function get() {
          return this._floatLabel || this._defaultOptions && this._defaultOptions.nxFloatLabel || 'auto';
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== this._floatLabel) {
            this._floatLabel = value || 'auto';

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * Sets the styling of the formfield.
         * If 'negative', a negative set of stylings is used.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "styles",
        set: function set(value) {
          var _this29 = this;

          if (this._styles === value) {
            return;
          }
          /** @type {?} */


          var classNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_2__["getClassNameList"])(value, NX_STYLES);
          classNames.forEach(
          /**
          * @param {?} classStr
          * @return {?}
          */
          function (classStr) {
            _this29.renderer.addClass(_this29.elementRef.nativeElement, classStr);
          });
          this._styles = value;
        }
        /**
         * **NDBX Expert option**
         *
         * Sets the appearance of the formfield.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "appearance",
        set: function set(value) {
          if (this._appearance !== value) {
            this._appearance = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._appearance || this._defaultOptions && this._defaultOptions.appearance || 'auto';
        }
        /**
         * @return {?}
         */

      }, {
        key: "_shouldAlwaysFloat",
        get: function get() {
          return this.floatLabel === 'always';
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "shouldLabelFloat",
        get: function get() {
          return this._control.shouldLabelFloat || this._shouldAlwaysFloat;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "control",
        get: function get() {
          return this._control;
        }
      }]);

      return NxFormfieldComponent;
    }();

    NxFormfieldComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"],
      args: [{
        selector: 'nx-formfield',
        template: "<!--\nWe are building the following structure.\n\n+-----------------------------+ +-----------+\n| Prefix |   Input   | Suffix | |  Appendix |\n+-----------------------------+ +-----------+\n|-----------------Border--------------------|\n+-------------------------------------------+\n|                 Hints                     |\n+-------------------------------------------+\n|                                           |\n|                Messages                   |\n|                                           |\n+-------------------------------------------+\n\n-->\n\n<div class=\"nx-formfield__wrapper\">\n\n\n  <!-- Give a flex context to properly align suffix, input & postfix -->\n  <div class=\"nx-formfield__row\"  #connectionContainer>\n    <div class=\"nx-formfield__flexfield\">\n      <div class=\"nx-formfield__prefix\" *ngIf=\"_prefixChildren.length\">\n          <ng-content select=\"[nxFormfieldPrefix]\"></ng-content>\n      </div>\n\n      <div class=\"nx-formfield__input\">\n        <ng-content></ng-content>\n\n        <!-- This handles the floating whole behavior -->\n        <span class=\"nx-formfield__label-holder\">\n          <label\n            class=\"nx-formfield__label\"\n            [attr.aria-owns]=\"_control.id\"\n            [attr.for]=\"_control.id\">\n            <ng-container *ngIf=\"!_labelChild\">\n              {{ label }}\n            </ng-container>\n            <ng-content select=\"nx-formfield-label\"></ng-content>\n          </label>\n        </span>\n      </div>\n\n      <div class=\"nx-formfield__suffix\" *ngIf=\"_suffixChildren.length\">\n          <ng-content select=\"[nxFormfieldSuffix]\"></ng-content>\n      </div>\n    </div>\n\n    <!-- Appendix is similar to a suffix but visibly outside of the input  -->\n    <div class=\"nx-formfield__appendix\" *ngIf=\"_appendixChildren.length\">\n      <ng-content select=\"[nxFormfieldAppendix]\"></ng-content>\n    </div>\n  </div>\n\n  <!-- Space to render the hints below the textfield -->\n  <div class=\"nx-formfield__hints\" *ngIf=\"_hintChildren.length\">\n      <ng-content select=\"[nxFormfieldHint]\"></ng-content>\n  </div>\n\n  <!-- In case we got some additional information we render them below the given input -->\n  <div class=\"nx-formfield__messages\" [ngSwitch]=\"getDisplayedMessage()\">\n    <div *ngSwitchCase=\"'error'\">\n      <ng-content select=\"[nxFormfieldError]\"></ng-content>\n    </div>\n\n    <div *ngSwitchCase=\"'hint'\">\n      <ng-content select=\"[nxFormfieldNote]\"></ng-content>\n    </div>\n  </div>\n</div>\n\n\n",
        host: {
          '[class.nx-formfield]': 'true',
          '[class.is-disabled]': 'this._control.disabled',
          '[class.is-readonly]': 'this._control.readonly',
          '[class.is-filled]': 'this._control.empty === false',
          '[class.is-focused]': 'this._control.focused',
          '[class.is-floating]': 'this.shouldLabelFloat',
          '[class.has-error]': 'this._control.errorState',
          '[class.has-outline]': 'this.appearance === "outline"'
        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
        styles: [".nx-formfield{display:block;font-size:20px;color:#414141;text-align:left}.nx-formfield__wrapper{padding-bottom:24px}.nx-formfield__input{position:relative;line-height:28px;letter-spacing:.2px;flex:auto;min-width:0}.nx-formfield__label-holder{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;pointer-events:none;z-index:10;top:-16px;padding-top:16px}.nx-formfield__label{color:inherit;display:block;position:absolute;left:0;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;-webkit-transform-origin:0 0;transform-origin:0 0;transition:transform .15s ease-out,font-size .15s ease-out,-webkit-transform .15s ease-out;font-weight:300;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%;letter-spacing:.2px}.nx-formfield__flexfield{display:inline-flex;align-items:flex-end;width:100%;border-bottom:1px solid currentColor;margin-top:16px;padding-bottom:3px}.nx-formfield__row{display:flex;align-items:center;width:100%}.nx-formfield__input textarea[nxInput]{vertical-align:bottom}.nx-formfield__appendix,.nx-formfield__prefix,.nx-formfield__suffix{flex:none;white-space:nowrap;color:#414141;font-weight:600;letter-spacing:.2px}.nx-formfield__appendix nx-icon.nx-icon--auto,.nx-formfield__prefix nx-icon.nx-icon--auto,.nx-formfield__suffix nx-icon.nx-icon--auto{font-size:24px;font-weight:400}.nx-formfield__appendix nx-icon,.nx-formfield__prefix nx-icon,.nx-formfield__suffix nx-icon{display:block;color:#006192;height:24px}.nx-formfield__appendix nx-password-toggle nx-icon,.nx-formfield__prefix nx-password-toggle nx-icon,.nx-formfield__suffix nx-password-toggle nx-icon{color:#414141}.nx-formfield__prefix,.nx-formfield__suffix{line-height:28px;height:28px;display:inline-flex;align-items:center}.nx-formfield__appendix{margin-left:8px;margin-top:16px;display:flex;border-bottom:1px solid transparent;padding-bottom:3px;align-items:center}.nx-formfield__prefix{margin-right:8px}.nx-formfield__suffix{margin-left:8px}.nx-formfield__hints{text-align:right;color:#414141;font-size:12px;line-height:16px;letter-spacing:.5px;padding-top:8px}.nx-formfield__messages{margin-top:4px}.nx-formfield.is-focused .nx-formfield__label{text-overflow:ellipsis;font-weight:600;font-size:12px}.nx-formfield.is-focused:not(.nx-formfield--negative):not(.has-error){color:#006192}.nx-formfield.is-focused:not(.nx-formfield--negative):not(.has-error) .nx-formfield__label{color:#414141}.nx-formfield.is-focused:not(.nx-formfield--negative):not(.has-error) .nx-formfield__flexfield{border-bottom-color:#007ab3}.nx-formfield.is-focused:not(.nx-formfield--negative):not(.has-error).nx-formfield--negative{color:#fff}.nx-formfield.is-focused:not(.nx-formfield--negative):not(.has-error) nx-password-toggle nx-icon{color:#007ab3}.nx-formfield.is-focused:not(.nx-formfield--negative).has-outline .nx-formfield__flexfield{border-color:#006192;box-shadow:0 0 0 2px #009de6}.nx-formfield.is-focused:not(.nx-formfield--negative).has-outline.has-error .nx-formfield__flexfield{border-color:#dc3149}.nx-formfield.is-focused:not(.nx-formfield--negative).has-outline nx-password-toggle nx-icon{color:#007ab3}.nx-formfield.has-outline{font-size:16px;line-height:24px}.nx-formfield.has-outline .nx-formfield__flexfield{border:1px solid #767676;border-radius:4px;margin-top:28px;min-height:40px;align-items:center;padding-bottom:0}.nx-formfield.has-outline .nx-formfield__label{padding-left:7px;padding-right:7px}.nx-formfield.has-outline .nx-formfield__input{margin-top:0;padding-bottom:0;line-height:38px}.nx-formfield.has-outline .nx-formfield__input input[nxInput],.nx-formfield.has-outline .nx-formfield__input textarea[nxInput]{font-weight:400}.nx-formfield.has-outline .nx-formfield__input textarea[nxInput]{min-height:38px;line-height:24px;padding:7px}.nx-formfield.has-outline .nx-formfield__input input[nxInput]{padding-right:7px;padding-left:7px;line-height:normal}.nx-formfield.has-outline nx-dropdown .nx-dropdown__icon{display:flex}.nx-formfield.has-outline nx-dropdown .nx-dropdown__container{padding-left:7px;height:38px}.nx-formfield.has-outline nx-datepicker-toggle .nx-datepicker-toggle-button{padding:0}.nx-formfield.has-outline .nx-formfield__appendix,.nx-formfield.has-outline .nx-formfield__prefix,.nx-formfield.has-outline .nx-formfield__suffix{font-weight:400}.nx-formfield.has-outline .nx-formfield__prefix,.nx-formfield.has-outline .nx-formfield__suffix{height:38px;line-height:38px}.nx-formfield.has-outline .nx-formfield__prefix{margin-left:7px;margin-right:0}.nx-formfield.has-outline .nx-formfield__suffix{margin-right:7px;margin-left:0}.nx-formfield.has-outline .nx-formfield__appendix{margin-left:8px;display:flex;margin-top:28px;border-top:1px solid transparent;border-bottom:1px solid transparent;padding-bottom:0}.nx-formfield.has-outline .nx-formfield__hints{text-align:left;font-size:16px}.nx-formfield.has-outline.is-readonly .nx-formfield__flexfield{border-color:#c2c2c2;background-color:#f5f5f5}.nx-formfield.is-floating .nx-formfield__label{-webkit-transform:translateY(-22px);transform:translateY(-22px);font-size:12px;font-weight:600;letter-spacing:.5px}.nx-formfield.is-floating.has-outline .nx-formfield__label-holder{top:-24px;padding-top:24px}.nx-formfield.is-floating.has-outline .nx-formfield__label{padding-top:0;-webkit-transform:translateX(-8px) translateY(-29px);transform:translateX(-8px) translateY(-29px);font-size:16px;line-height:24px}.nx-formfield.is-floating.has-outline .nx-formfield__prefix~.nx-formfield__input .nx-formfield__label{-webkit-transform:translateY(-29px);transform:translateY(-29px)}.nx-formfield.has-error{color:#dc3149}.nx-formfield.has-error .nx-formfield__label{font-weight:700}.nx-formfield.has-error.is-floating .nx-formfield__label{color:#414141;font-weight:600}.nx-formfield.has-error.has-outline{color:#414141}.nx-formfield.has-error.has-outline .nx-formfield__flexfield{border-color:#dc3149}.nx-formfield.has-error nx-password-toggle nx-icon{color:#dc3149}.nx-formfield.is-disabled{color:#c2c2c2;cursor:not-allowed;-webkit-text-fill-color:#c2c2c2}.nx-formfield.is-disabled .nx-formfield__hints{color:inherit}.nx-formfield.is-disabled .nx-formfield__flexfield{border-bottom-color:#c2c2c2}.nx-formfield.is-disabled.has-outline .nx-formfield__flexfield{border-color:#c2c2c2}.nx-formfield--negative{color:#fff}.nx-formfield--negative .nx-formfield__hints{color:inherit}.nx-formfield--negative.has-outline .nx-formfield__flexfield{border-color:#fff}.nx-formfield--negative nx-password-toggle nx-icon{color:#fff}", ".c-input{text-align:inherit;font-size:inherit;background:0 0;color:inherit;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;line-height:28px;height:28px}.c-input::-ms-clear{display:none}.c-input::-webkit-search-cancel-button,.c-input::-webkit-search-decoration,.c-input::-webkit-search-results-button,.c-input::-webkit-search-results-decoration{display:none;-webkit-appearance:none}textarea.c-input{min-height:28px;height:auto;font-family:inherit}.c-input.is-focused{border:none;outline:0;box-shadow:none}.c-input.is-filled{font-weight:600}.c-input.is-disabled{cursor:not-allowed}textarea.nx-input-element{resize:vertical;overflow:auto}.c-input:invalid,.c-input:required{box-shadow:none}"]
      }]
    }];
    /** @nocollapse */

    NxFormfieldComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [FORMFIELD_DEFAULT_OPTIONS]
        }]
      }];
    };

    NxFormfieldComponent.propDecorators = {
      _control: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"],
        args: [NxFormfieldControl]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['nxLabel']
      }],
      _labelChild: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"],
        args: [NxFormfieldLabelDirective]
      }],
      _hintChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldHintDirective]
      }],
      _noteChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldNoteDirective]
      }],
      _errorChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldErrorDirective]
      }],
      _suffixChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldSuffixDirective]
      }],
      _prefixChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldPrefixDirective]
      }],
      _appendixChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"],
        args: [NxFormfieldAppendixDirective]
      }],
      _connectionContainerRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"],
        args: ['connectionContainer']
      }],
      floatLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['nxFloatLabel']
      }],
      styles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['nxStyle']
      }],
      appearance: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxFormfieldModule = function NxFormfieldModule() {
      _classCallCheck(this, NxFormfieldModule);
    };

    NxFormfieldModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"]],
        declarations: [NxFormfieldComponent, NxFormfieldHintDirective, NxFormfieldErrorDirective, NxFormfieldNoteDirective, NxFormfieldPrefixDirective, NxFormfieldSuffixDirective, NxFormfieldAppendixDirective, NxFormfieldLabelDirective],
        exports: [NxFormfieldComponent, NxFormfieldHintDirective, NxFormfieldErrorDirective, NxFormfieldNoteDirective, NxFormfieldPrefixDirective, NxFormfieldSuffixDirective, NxFormfieldAppendixDirective, NxFormfieldLabelDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-grid.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-grid.js ***!
    \**************************************************************************/

  /*! exports provided: NxColComponent, NxLayoutComponent, NxRowComponent, NxGridModule */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxGridJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxColComponent", function () {
      return NxColComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxLayoutComponent", function () {
      return NxLayoutComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRowComponent", function () {
      return NxRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxGridModule", function () {
      return NxGridModule;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} value
     * @return {?}
     */


    function isEmptyArray(value) {
      return value === undefined || value.length === 0;
    }
    /**
     * add space and return mapClassNames (css)
     * @param {?} aux
     * @param {?} map
     * @return {?}
     */


    function addStyles(aux, map) {
      return ' ' + Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])(aux, [], map);
    }
    /**
     * input='small,medium,large'
     *  map = MAPPING
     * @param {?} input
     * @param {?} map
     * @return {?}
     */


    function addStylesFromDimensions(input, map) {
      /** @type {?} */
      var aux = processSplit(input);
      /** @type {?} */

      var output = '';

      if (aux.length >= 1 && aux.length <= 4) {
        /** @type {?} */
        var auxTiny = addStyles(aux[0], map).replace('-{tier}', '');
        /** @type {?} */

        var auxSmall = '';
        /** @type {?} */

        var auxMedium = '';
        /** @type {?} */

        var auxLarge = '';

        switch (aux.length) {
          case 1:
            auxSmall = addStyles(aux[0], map).replace('{tier}', 'small');
            auxMedium = addStyles(aux[0], map).replace('{tier}', 'medium');
            auxLarge = addStyles(aux[0], map).replace('{tier}', 'large');
            break;

          case 2:
            auxSmall = addStyles(aux[1], map).replace('{tier}', 'small');
            auxMedium = addStyles(aux[1], map).replace('{tier}', 'medium');
            auxLarge = addStyles(aux[1], map).replace('{tier}', 'large');
            break;

          case 3:
            auxSmall = addStyles(aux[1], map).replace('{tier}', 'small');
            auxMedium = addStyles(aux[2], map).replace('{tier}', 'medium');
            auxLarge = addStyles(aux[2], map).replace('{tier}', 'large');
            break;

          default:
            auxSmall = addStyles(aux[1], map).replace('{tier}', 'small');
            auxMedium = addStyles(aux[2], map).replace('{tier}', 'medium');
            auxLarge = addStyles(aux[3], map).replace('{tier}', 'large');
            break;
        }

        output += ' ' + auxTiny.trim() + ' ' + auxSmall.trim() + ' ' + auxMedium.trim() + ' ' + auxLarge.trim();
      }

      return output;
    } // Simple split

    /**
     * @param {?} aux
     * @param {?=} char
     * @return {?}
     */


    function processSplit(aux) {
      var char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';
      return aux.split(char).map(
      /**
      * @param {?} item
      * @return {?}
      */
      function (item) {
        return item.trim();
      });
    }
    /**
     * @param {?} el
     * @param {?} aux
     * @return {?}
     */


    function validateClassInElement(el, aux) {
      return el.hasAttribute(aux);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var MAPPING = {
      '': 'nx-grid__column-',
      'xs': 'nx-grid__column-',
      'sm': 'nx-grid__column-small-',
      'md': 'nx-grid__column-medium-',
      'lg': 'nx-grid__column-large-'
    };
    /** @type {?} */

    var MAPPING_ALIGN_SELF = {
      'auto': 'nx-align-self-{tier}-auto',
      'start': 'nx-align-self-{tier}-start',
      'end': 'nx-align-self-{tier}-end',
      'center': 'nx-align-self-{tier}-center',
      'baseline': 'nx-align-self-{tier}-baseline',
      'stretch': 'nx-align-self-{tier}-stretch'
    };
    /** @type {?} */

    var MAPPING_ORDER = {
      'first': 'nx-flex-{tier}-first',
      'last': 'nx-flex-{tier}-last',
      'unordered': 'nx-flex-{tier}-unordered'
    };
    /** @type {?} */

    var OFFSET_MAPPING = {
      '': 'nx-grid--offset-',
      'xs': 'nx-grid--offset-',
      'sm': 'nx-grid--offset-small-',
      'md': 'nx-grid--offset-medium-',
      'lg': 'nx-grid--offset-large-'
    };
    /** @type {?} */

    var MIN = 0;
    /** @type {?} */

    var MAX = 12;

    var NxColComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} el
       */
      function NxColComponent(el) {
        _classCallCheck(this, NxColComponent);

        this.el = el;
        this._classNames = [];
        /**
         * Number of columns used.
         *
         * Values: 1 - 12, default value: 12.
         */

        this.col = '';
        /**
         * The number of columns the column should be offset.
         *
         * Values: 1 - 12, default value: 12.
         */

        this.offset = '';
        /**
         * The alignment for a column inside the flexible container.
         */

        this.itemSelf = null;
        /**
         * Order of the column within the row.
         */

        this.order = null;
      }
      /**
       * @return {?}
       */


      _createClass(NxColComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          if (validateClassInElement(this.el.nativeElement.parentElement, 'nxRow')) {
            // create an array of all classes to not worry about the spaces between the classes
            // in all logic functions all the time :)
            // gets joined in get _columnClasses()
            this._classNames = [].concat(_toConsumableArray(this._getColClasses()), _toConsumableArray(this._getOffsetClasses()), _toConsumableArray(this._getAlignSelfClasses()), _toConsumableArray(this._getOrderClasses()), _toConsumableArray(this.el.nativeElement.className.split(' ')));
          } else {
            this.generateError('Exception: NxColDirective. nxRow don\'t exist');
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getColClasses",
        value: function _getColClasses() {
          /** @type {?} */
          var columnClasses = this._mapTiers(this.col, [], MAPPING, ['0']);

          if (columnClasses.length === 0) {
            this.generateError('Exception: NxColDirective. Empty nxCol attribute.');
          }

          return columnClasses;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getAlignSelfClasses",
        value: function _getAlignSelfClasses() {
          /** if itemSelf contains values */
          if (this.itemSelf) {
            /** Values: auto, start, end, center, baseline, stretch */
            return addStylesFromDimensions(this.itemSelf, MAPPING_ALIGN_SELF).split(' ');
          }

          return [];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOrderClasses",
        value: function _getOrderClasses() {
          /** if order-flex */
          if (this.order) {
            /** Values: first, last or unordered */
            return addStylesFromDimensions(this.order, MAPPING_ORDER).split(' ');
          }

          return [];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOffsetClasses",
        value: function _getOffsetClasses() {
          return this._mapTiers(this.offset, [], OFFSET_MAPPING);
        }
        /**
         * @private
         * @param {?} input
         * @param {?=} defaults
         * @param {?=} mapping
         * @param {?=} exclude
         * @return {?}
         */

      }, {
        key: "_mapTiers",
        value: function _mapTiers(input, defaults, mapping, exclude) {
          /** @type {?} */
          var givenTiers = processSplit(input);
          /** @type {?} */

          var mappedClasses = [];

          if (input && !isEmptyArray(givenTiers) && this.checkNotAllowedValues(givenTiers, exclude)) {
            switch (givenTiers.length) {
              case 1:
                this.validateInput(givenTiers[0]);
                mappedClasses = [Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('', defaults, mapping) + givenTiers[0]];
                break;

              case 2:
                this.validateInput(givenTiers[0], givenTiers[1]);
                mappedClasses = [Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('xs', defaults, mapping) + givenTiers[0], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('sm', defaults, mapping) + givenTiers[1], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('md', defaults, mapping) + givenTiers[1], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('lg', defaults, mapping) + givenTiers[1]];
                break;

              case 3:
                this.validateInput(givenTiers[0], givenTiers[1], givenTiers[2]);
                mappedClasses = [Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('xs', defaults, mapping) + givenTiers[0], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('sm', defaults, mapping) + givenTiers[1], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('md', defaults, mapping) + givenTiers[2], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('lg', defaults, mapping) + givenTiers[2]];
                break;

              case 4:
                this.validateInput(givenTiers[0], givenTiers[1], givenTiers[2], givenTiers[3]);
                mappedClasses = [Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('xs', defaults, mapping) + givenTiers[0], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('sm', defaults, mapping) + givenTiers[1], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('md', defaults, mapping) + givenTiers[2], Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('lg', defaults, mapping) + givenTiers[3]];
                break;

              default:
                mappedClasses = [Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])('', defaults, mapping) + '12'];
                break;
            }
          }

          return mappedClasses;
        }
        /**
         * \@docs-private
         * @param {?} min
         * @param {?} max
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isValueBetween",
        value: function isValueBetween(min, max, value) {
          try {
            /** @type {?} */
            var parsed = parseInt(value, 10);
            return max >= parsed && min <= parsed;
          } catch (error) {
            this.generateError('Exception: NxColDirective. One argument is not number');
          }
        }
        /**
         * \@docs-private
         * @param {?} values
         * @param {?} excludes
         * @return {?}
         */

      }, {
        key: "checkNotAllowedValues",
        value: function checkNotAllowedValues(values, excludes) {
          if (!excludes) {
            return true;
          }
          /** @type {?} */


          var found = values.find(
          /**
          * @param {?} val
          * @return {?}
          */
          function (val) {
            return excludes.indexOf(val) > -1;
          });

          if (found) {
            this.generateError("Exception: NxColDirective. Incorrect parameter. ".concat(found, " is not allowed here"));
          }

          return !found;
        }
        /**
         * \@docs-private
         * @param {?} err
         * @return {?}
         */

      }, {
        key: "generateError",
        value: function generateError(err) {
          throw new Error(err);
        }
        /**
         * \@docs-private
         * @param {...?} value
         * @return {?}
         */

      }, {
        key: "validateInput",
        value: function validateInput() {
          var _this30 = this;

          for (var _len = arguments.length, value = new Array(_len), _key = 0; _key < _len; _key++) {
            value[_key] = arguments[_key];
          }

          value.forEach(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            if (!_this30.isValueBetween(MIN, MAX, element)) {
              _this30.generateError("Exception: NxColDirective. Incorrect parameters, values must be between ".concat(MIN, " and ").concat(MAX));
            }
          });
        }
      }, {
        key: "_columnClasses",
        get: function get() {
          return this._classNames.join(' ').trim();
        }
      }]);

      return NxColComponent;
    }();

    NxColComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: '[nxCol]',
        template: '<ng-content></ng-content>',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class]': '_columnClasses'
        },
        styles: [":host(.nx-grid__column),:host(.nx-grid__column-1),:host(.nx-grid__column-10),:host(.nx-grid__column-11),:host(.nx-grid__column-12),:host(.nx-grid__column-2),:host(.nx-grid__column-3),:host(.nx-grid__column-4),:host(.nx-grid__column-5),:host(.nx-grid__column-6),:host(.nx-grid__column-7),:host(.nx-grid__column-8),:host(.nx-grid__column-9),:host(.nx-grid__column-fit),:host(.nx-grid__column-large),:host(.nx-grid__column-large-1),:host(.nx-grid__column-large-10),:host(.nx-grid__column-large-11),:host(.nx-grid__column-large-12),:host(.nx-grid__column-large-2),:host(.nx-grid__column-large-3),:host(.nx-grid__column-large-4),:host(.nx-grid__column-large-5),:host(.nx-grid__column-large-6),:host(.nx-grid__column-large-7),:host(.nx-grid__column-large-8),:host(.nx-grid__column-large-9),:host(.nx-grid__column-large-fit),:host(.nx-grid__column-medium),:host(.nx-grid__column-medium-1),:host(.nx-grid__column-medium-10),:host(.nx-grid__column-medium-11),:host(.nx-grid__column-medium-12),:host(.nx-grid__column-medium-2),:host(.nx-grid__column-medium-3),:host(.nx-grid__column-medium-4),:host(.nx-grid__column-medium-5),:host(.nx-grid__column-medium-6),:host(.nx-grid__column-medium-7),:host(.nx-grid__column-medium-8),:host(.nx-grid__column-medium-9),:host(.nx-grid__column-medium-fit),:host(.nx-grid__column-small),:host(.nx-grid__column-small-1),:host(.nx-grid__column-small-10),:host(.nx-grid__column-small-11),:host(.nx-grid__column-small-12),:host(.nx-grid__column-small-2),:host(.nx-grid__column-small-3),:host(.nx-grid__column-small-4),:host(.nx-grid__column-small-5),:host(.nx-grid__column-small-6),:host(.nx-grid__column-small-7),:host(.nx-grid__column-small-8),:host(.nx-grid__column-small-9),:host(.nx-grid__column-small-fit){position:relative;width:100%;min-height:1px;padding-right:8px;padding-left:8px}:host(.nx-grid__column){flex-basis:0;flex-grow:1;max-width:100%}:host(.nx-grid__column-fit){flex:0 0 auto;width:auto}:host(.nx-grid__column-1){flex:0 0 8.33333%;max-width:8.33333%}:host(.nx-grid__column-2){flex:0 0 16.66667%;max-width:16.66667%}:host(.nx-grid__column-3){flex:0 0 25%;max-width:25%}:host(.nx-grid__column-4){flex:0 0 33.33333%;max-width:33.33333%}:host(.nx-grid__column-5){flex:0 0 41.66667%;max-width:41.66667%}:host(.nx-grid__column-6){flex:0 0 50%;max-width:50%}:host(.nx-grid__column-7){flex:0 0 58.33333%;max-width:58.33333%}:host(.nx-grid__column-8){flex:0 0 66.66667%;max-width:66.66667%}:host(.nx-grid__column-9){flex:0 0 75%;max-width:75%}:host(.nx-grid__column-10){flex:0 0 83.33333%;max-width:83.33333%}:host(.nx-grid__column-11){flex:0 0 91.66667%;max-width:91.66667%}:host(.nx-grid__column-12){flex:0 0 100%;max-width:100%}.pull-0{right:auto}.pull-1{right:8.33333%}.pull-2{right:16.66667%}.pull-3{right:25%}.pull-4{right:33.33333%}.pull-5{right:41.66667%}.pull-6{right:50%}.pull-7{right:58.33333%}.pull-8{right:66.66667%}.pull-9{right:75%}.pull-10{right:83.33333%}.pull-11{right:91.66667%}.pull-12{right:100%}.push-0{left:auto}.push-1{left:8.33333%}.push-2{left:16.66667%}.push-3{left:25%}.push-4{left:33.33333%}.push-5{left:41.66667%}.push-6{left:50%}.push-7{left:58.33333%}.push-8{left:66.66667%}.push-9{left:75%}.push-10{left:83.33333%}.push-11{left:91.66667%}.push-12{left:100%}:host(.nx-grid--offset-1){margin-left:8.33333%}:host(.nx-grid--offset-2){margin-left:16.66667%}:host(.nx-grid--offset-3){margin-left:25%}:host(.nx-grid--offset-4){margin-left:33.33333%}:host(.nx-grid--offset-5){margin-left:41.66667%}:host(.nx-grid--offset-6){margin-left:50%}:host(.nx-grid--offset-7){margin-left:58.33333%}:host(.nx-grid--offset-8){margin-left:66.66667%}:host(.nx-grid--offset-9){margin-left:75%}:host(.nx-grid--offset-10){margin-left:83.33333%}:host(.nx-grid--offset-11){margin-left:91.66667%}:host(.nx-flex-first){order:-1}:host(.nx-flex-last){order:1}:host(.nx-flex-unordered){order:0}:host(.nx-align-self-auto){-ms-grid-row-align:auto!important;align-self:auto!important}:host(.nx-align-self-start){align-self:flex-start!important}:host(.nx-align-self-end){align-self:flex-end!important}:host(.nx-align-self-center){-ms-grid-row-align:center!important;align-self:center!important}:host(.nx-align-self-baseline){align-self:baseline!important}:host(.nx-align-self-stretch){-ms-grid-row-align:stretch!important;align-self:stretch!important}@media (min-width:320px){:host(.nx-grid__column),:host(.nx-grid__column-1),:host(.nx-grid__column-10),:host(.nx-grid__column-11),:host(.nx-grid__column-12),:host(.nx-grid__column-2),:host(.nx-grid__column-3),:host(.nx-grid__column-4),:host(.nx-grid__column-5),:host(.nx-grid__column-6),:host(.nx-grid__column-7),:host(.nx-grid__column-8),:host(.nx-grid__column-9),:host(.nx-grid__column-fit),:host(.nx-grid__column-large),:host(.nx-grid__column-large-1),:host(.nx-grid__column-large-10),:host(.nx-grid__column-large-11),:host(.nx-grid__column-large-12),:host(.nx-grid__column-large-2),:host(.nx-grid__column-large-3),:host(.nx-grid__column-large-4),:host(.nx-grid__column-large-5),:host(.nx-grid__column-large-6),:host(.nx-grid__column-large-7),:host(.nx-grid__column-large-8),:host(.nx-grid__column-large-9),:host(.nx-grid__column-large-fit),:host(.nx-grid__column-medium),:host(.nx-grid__column-medium-1),:host(.nx-grid__column-medium-10),:host(.nx-grid__column-medium-11),:host(.nx-grid__column-medium-12),:host(.nx-grid__column-medium-2),:host(.nx-grid__column-medium-3),:host(.nx-grid__column-medium-4),:host(.nx-grid__column-medium-5),:host(.nx-grid__column-medium-6),:host(.nx-grid__column-medium-7),:host(.nx-grid__column-medium-8),:host(.nx-grid__column-medium-9),:host(.nx-grid__column-medium-fit),:host(.nx-grid__column-small),:host(.nx-grid__column-small-1),:host(.nx-grid__column-small-10),:host(.nx-grid__column-small-11),:host(.nx-grid__column-small-12),:host(.nx-grid__column-small-2),:host(.nx-grid__column-small-3),:host(.nx-grid__column-small-4),:host(.nx-grid__column-small-5),:host(.nx-grid__column-small-6),:host(.nx-grid__column-small-7),:host(.nx-grid__column-small-8),:host(.nx-grid__column-small-9),:host(.nx-grid__column-small-fit){padding-right:8px;padding-left:8px}:host(.nx-grid__column-small){flex-basis:0;flex-grow:1;max-width:100%}:host(.nx-grid__column-small-fit){flex:0 0 auto;width:auto}:host(.nx-grid__column-small-1){flex:0 0 8.33333%;max-width:8.33333%}:host(.nx-grid__column-small-2){flex:0 0 16.66667%;max-width:16.66667%}:host(.nx-grid__column-small-3){flex:0 0 25%;max-width:25%}:host(.nx-grid__column-small-4){flex:0 0 33.33333%;max-width:33.33333%}:host(.nx-grid__column-small-5){flex:0 0 41.66667%;max-width:41.66667%}:host(.nx-grid__column-small-6){flex:0 0 50%;max-width:50%}:host(.nx-grid__column-small-7){flex:0 0 58.33333%;max-width:58.33333%}:host(.nx-grid__column-small-8){flex:0 0 66.66667%;max-width:66.66667%}:host(.nx-grid__column-small-9){flex:0 0 75%;max-width:75%}:host(.nx-grid__column-small-10){flex:0 0 83.33333%;max-width:83.33333%}:host(.nx-grid__column-small-11){flex:0 0 91.66667%;max-width:91.66667%}:host(.nx-grid__column-small-12){flex:0 0 100%;max-width:100%}.pull-small-0{right:auto}.pull-small-1{right:8.33333%}.pull-small-2{right:16.66667%}.pull-small-3{right:25%}.pull-small-4{right:33.33333%}.pull-small-5{right:41.66667%}.pull-small-6{right:50%}.pull-small-7{right:58.33333%}.pull-small-8{right:66.66667%}.pull-small-9{right:75%}.pull-small-10{right:83.33333%}.pull-small-11{right:91.66667%}.pull-small-12{right:100%}.push-small-0{left:auto}.push-small-1{left:8.33333%}.push-small-2{left:16.66667%}.push-small-3{left:25%}.push-small-4{left:33.33333%}.push-small-5{left:41.66667%}.push-small-6{left:50%}.push-small-7{left:58.33333%}.push-small-8{left:66.66667%}.push-small-9{left:75%}.push-small-10{left:83.33333%}.push-small-11{left:91.66667%}.push-small-12{left:100%}:host(.nx-grid--offset-small-0){margin-left:0}:host(.nx-grid--offset-small-1){margin-left:8.33333%}:host(.nx-grid--offset-small-2){margin-left:16.66667%}:host(.nx-grid--offset-small-3){margin-left:25%}:host(.nx-grid--offset-small-4){margin-left:33.33333%}:host(.nx-grid--offset-small-5){margin-left:41.66667%}:host(.nx-grid--offset-small-6){margin-left:50%}:host(.nx-grid--offset-small-7){margin-left:58.33333%}:host(.nx-grid--offset-small-8){margin-left:66.66667%}:host(.nx-grid--offset-small-9){margin-left:75%}:host(.nx-grid--offset-small-10){margin-left:83.33333%}:host(.nx-grid--offset-small-11){margin-left:91.66667%}:host(.nx-flex-small-first){order:-1}:host(.nx-flex-small-last){order:1}:host(.nx-flex-small-unordered){order:0}:host(.nx-align-self-small-auto){-ms-grid-row-align:auto!important;align-self:auto!important}:host(.nx-align-self-small-start){align-self:flex-start!important}:host(.nx-align-self-small-end){align-self:flex-end!important}:host(.nx-align-self-small-center){-ms-grid-row-align:center!important;align-self:center!important}:host(.nx-align-self-small-baseline){align-self:baseline!important}:host(.nx-align-self-small-stretch){-ms-grid-row-align:stretch!important;align-self:stretch!important}}@media (min-width:704px){:host(.nx-grid__column),:host(.nx-grid__column-1),:host(.nx-grid__column-10),:host(.nx-grid__column-11),:host(.nx-grid__column-12),:host(.nx-grid__column-2),:host(.nx-grid__column-3),:host(.nx-grid__column-4),:host(.nx-grid__column-5),:host(.nx-grid__column-6),:host(.nx-grid__column-7),:host(.nx-grid__column-8),:host(.nx-grid__column-9),:host(.nx-grid__column-fit),:host(.nx-grid__column-large),:host(.nx-grid__column-large-1),:host(.nx-grid__column-large-10),:host(.nx-grid__column-large-11),:host(.nx-grid__column-large-12),:host(.nx-grid__column-large-2),:host(.nx-grid__column-large-3),:host(.nx-grid__column-large-4),:host(.nx-grid__column-large-5),:host(.nx-grid__column-large-6),:host(.nx-grid__column-large-7),:host(.nx-grid__column-large-8),:host(.nx-grid__column-large-9),:host(.nx-grid__column-large-fit),:host(.nx-grid__column-medium),:host(.nx-grid__column-medium-1),:host(.nx-grid__column-medium-10),:host(.nx-grid__column-medium-11),:host(.nx-grid__column-medium-12),:host(.nx-grid__column-medium-2),:host(.nx-grid__column-medium-3),:host(.nx-grid__column-medium-4),:host(.nx-grid__column-medium-5),:host(.nx-grid__column-medium-6),:host(.nx-grid__column-medium-7),:host(.nx-grid__column-medium-8),:host(.nx-grid__column-medium-9),:host(.nx-grid__column-medium-fit),:host(.nx-grid__column-small),:host(.nx-grid__column-small-1),:host(.nx-grid__column-small-10),:host(.nx-grid__column-small-11),:host(.nx-grid__column-small-12),:host(.nx-grid__column-small-2),:host(.nx-grid__column-small-3),:host(.nx-grid__column-small-4),:host(.nx-grid__column-small-5),:host(.nx-grid__column-small-6),:host(.nx-grid__column-small-7),:host(.nx-grid__column-small-8),:host(.nx-grid__column-small-9),:host(.nx-grid__column-small-fit){padding-right:16px;padding-left:16px}:host(.nx-grid__column-medium){flex-basis:0;flex-grow:1;max-width:100%}:host(.nx-grid__column-medium-fit){flex:0 0 auto;width:auto}:host(.nx-grid__column-medium-1){flex:0 0 8.33333%;max-width:8.33333%}:host(.nx-grid__column-medium-2){flex:0 0 16.66667%;max-width:16.66667%}:host(.nx-grid__column-medium-3){flex:0 0 25%;max-width:25%}:host(.nx-grid__column-medium-4){flex:0 0 33.33333%;max-width:33.33333%}:host(.nx-grid__column-medium-5){flex:0 0 41.66667%;max-width:41.66667%}:host(.nx-grid__column-medium-6){flex:0 0 50%;max-width:50%}:host(.nx-grid__column-medium-7){flex:0 0 58.33333%;max-width:58.33333%}:host(.nx-grid__column-medium-8){flex:0 0 66.66667%;max-width:66.66667%}:host(.nx-grid__column-medium-9){flex:0 0 75%;max-width:75%}:host(.nx-grid__column-medium-10){flex:0 0 83.33333%;max-width:83.33333%}:host(.nx-grid__column-medium-11){flex:0 0 91.66667%;max-width:91.66667%}:host(.nx-grid__column-medium-12){flex:0 0 100%;max-width:100%}.pull-medium-0{right:auto}.pull-medium-1{right:8.33333%}.pull-medium-2{right:16.66667%}.pull-medium-3{right:25%}.pull-medium-4{right:33.33333%}.pull-medium-5{right:41.66667%}.pull-medium-6{right:50%}.pull-medium-7{right:58.33333%}.pull-medium-8{right:66.66667%}.pull-medium-9{right:75%}.pull-medium-10{right:83.33333%}.pull-medium-11{right:91.66667%}.pull-medium-12{right:100%}.push-medium-0{left:auto}.push-medium-1{left:8.33333%}.push-medium-2{left:16.66667%}.push-medium-3{left:25%}.push-medium-4{left:33.33333%}.push-medium-5{left:41.66667%}.push-medium-6{left:50%}.push-medium-7{left:58.33333%}.push-medium-8{left:66.66667%}.push-medium-9{left:75%}.push-medium-10{left:83.33333%}.push-medium-11{left:91.66667%}.push-medium-12{left:100%}:host(.nx-grid--offset-medium-0){margin-left:0}:host(.nx-grid--offset-medium-1){margin-left:8.33333%}:host(.nx-grid--offset-medium-2){margin-left:16.66667%}:host(.nx-grid--offset-medium-3){margin-left:25%}:host(.nx-grid--offset-medium-4){margin-left:33.33333%}:host(.nx-grid--offset-medium-5){margin-left:41.66667%}:host(.nx-grid--offset-medium-6){margin-left:50%}:host(.nx-grid--offset-medium-7){margin-left:58.33333%}:host(.nx-grid--offset-medium-8){margin-left:66.66667%}:host(.nx-grid--offset-medium-9){margin-left:75%}:host(.nx-grid--offset-medium-10){margin-left:83.33333%}:host(.nx-grid--offset-medium-11){margin-left:91.66667%}:host(.nx-flex-medium-first){order:-1}:host(.nx-flex-medium-last){order:1}:host(.nx-flex-medium-unordered){order:0}:host(.nx-align-self-medium-auto){-ms-grid-row-align:auto!important;align-self:auto!important}:host(.nx-align-self-medium-start){align-self:flex-start!important}:host(.nx-align-self-medium-end){align-self:flex-end!important}:host(.nx-align-self-medium-center){-ms-grid-row-align:center!important;align-self:center!important}:host(.nx-align-self-medium-baseline){align-self:baseline!important}:host(.nx-align-self-medium-stretch){-ms-grid-row-align:stretch!important;align-self:stretch!important}}@media (min-width:992px){:host(.nx-grid__column),:host(.nx-grid__column-1),:host(.nx-grid__column-10),:host(.nx-grid__column-11),:host(.nx-grid__column-12),:host(.nx-grid__column-2),:host(.nx-grid__column-3),:host(.nx-grid__column-4),:host(.nx-grid__column-5),:host(.nx-grid__column-6),:host(.nx-grid__column-7),:host(.nx-grid__column-8),:host(.nx-grid__column-9),:host(.nx-grid__column-fit),:host(.nx-grid__column-large),:host(.nx-grid__column-large-1),:host(.nx-grid__column-large-10),:host(.nx-grid__column-large-11),:host(.nx-grid__column-large-12),:host(.nx-grid__column-large-2),:host(.nx-grid__column-large-3),:host(.nx-grid__column-large-4),:host(.nx-grid__column-large-5),:host(.nx-grid__column-large-6),:host(.nx-grid__column-large-7),:host(.nx-grid__column-large-8),:host(.nx-grid__column-large-9),:host(.nx-grid__column-large-fit),:host(.nx-grid__column-medium),:host(.nx-grid__column-medium-1),:host(.nx-grid__column-medium-10),:host(.nx-grid__column-medium-11),:host(.nx-grid__column-medium-12),:host(.nx-grid__column-medium-2),:host(.nx-grid__column-medium-3),:host(.nx-grid__column-medium-4),:host(.nx-grid__column-medium-5),:host(.nx-grid__column-medium-6),:host(.nx-grid__column-medium-7),:host(.nx-grid__column-medium-8),:host(.nx-grid__column-medium-9),:host(.nx-grid__column-medium-fit),:host(.nx-grid__column-small),:host(.nx-grid__column-small-1),:host(.nx-grid__column-small-10),:host(.nx-grid__column-small-11),:host(.nx-grid__column-small-12),:host(.nx-grid__column-small-2),:host(.nx-grid__column-small-3),:host(.nx-grid__column-small-4),:host(.nx-grid__column-small-5),:host(.nx-grid__column-small-6),:host(.nx-grid__column-small-7),:host(.nx-grid__column-small-8),:host(.nx-grid__column-small-9),:host(.nx-grid__column-small-fit){padding-right:16px;padding-left:16px}:host(.nx-grid__column-large){flex-basis:0;flex-grow:1;max-width:100%}:host(.nx-grid__column-large-fit){flex:0 0 auto;width:auto}:host(.nx-grid__column-large-1){flex:0 0 8.33333%;max-width:8.33333%}:host(.nx-grid__column-large-2){flex:0 0 16.66667%;max-width:16.66667%}:host(.nx-grid__column-large-3){flex:0 0 25%;max-width:25%}:host(.nx-grid__column-large-4){flex:0 0 33.33333%;max-width:33.33333%}:host(.nx-grid__column-large-5){flex:0 0 41.66667%;max-width:41.66667%}:host(.nx-grid__column-large-6){flex:0 0 50%;max-width:50%}:host(.nx-grid__column-large-7){flex:0 0 58.33333%;max-width:58.33333%}:host(.nx-grid__column-large-8){flex:0 0 66.66667%;max-width:66.66667%}:host(.nx-grid__column-large-9){flex:0 0 75%;max-width:75%}:host(.nx-grid__column-large-10){flex:0 0 83.33333%;max-width:83.33333%}:host(.nx-grid__column-large-11){flex:0 0 91.66667%;max-width:91.66667%}:host(.nx-grid__column-large-12){flex:0 0 100%;max-width:100%}.pull-large-0{right:auto}.pull-large-1{right:8.33333%}.pull-large-2{right:16.66667%}.pull-large-3{right:25%}.pull-large-4{right:33.33333%}.pull-large-5{right:41.66667%}.pull-large-6{right:50%}.pull-large-7{right:58.33333%}.pull-large-8{right:66.66667%}.pull-large-9{right:75%}.pull-large-10{right:83.33333%}.pull-large-11{right:91.66667%}.pull-large-12{right:100%}.push-large-0{left:auto}.push-large-1{left:8.33333%}.push-large-2{left:16.66667%}.push-large-3{left:25%}.push-large-4{left:33.33333%}.push-large-5{left:41.66667%}.push-large-6{left:50%}.push-large-7{left:58.33333%}.push-large-8{left:66.66667%}.push-large-9{left:75%}.push-large-10{left:83.33333%}.push-large-11{left:91.66667%}.push-large-12{left:100%}:host(.nx-grid--offset-large-0){margin-left:0}:host(.nx-grid--offset-large-1){margin-left:8.33333%}:host(.nx-grid--offset-large-2){margin-left:16.66667%}:host(.nx-grid--offset-large-3){margin-left:25%}:host(.nx-grid--offset-large-4){margin-left:33.33333%}:host(.nx-grid--offset-large-5){margin-left:41.66667%}:host(.nx-grid--offset-large-6){margin-left:50%}:host(.nx-grid--offset-large-7){margin-left:58.33333%}:host(.nx-grid--offset-large-8){margin-left:66.66667%}:host(.nx-grid--offset-large-9){margin-left:75%}:host(.nx-grid--offset-large-10){margin-left:83.33333%}:host(.nx-grid--offset-large-11){margin-left:91.66667%}:host(.nx-flex-large-first){order:-1}:host(.nx-flex-large-last){order:1}:host(.nx-flex-large-unordered){order:0}:host(.nx-align-self-large-auto){-ms-grid-row-align:auto!important;align-self:auto!important}:host(.nx-align-self-large-start){align-self:flex-start!important}:host(.nx-align-self-large-end){align-self:flex-end!important}:host(.nx-align-self-large-center){-ms-grid-row-align:center!important;align-self:center!important}:host(.nx-align-self-large-baseline){align-self:baseline!important}:host(.nx-align-self-large-stretch){-ms-grid-row-align:stretch!important;align-self:stretch!important}}"]
      }]
    }];
    /** @nocollapse */

    NxColComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    NxColComponent.propDecorators = {
      col: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxCol']
      }],
      offset: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxColOffset']
      }],
      itemSelf: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxAlignSelf']
      }],
      order: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxColOrder']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxLayoutComponent =
    /*#__PURE__*/
    function () {
      function NxLayoutComponent() {
        _classCallCheck(this, NxLayoutComponent);

        this._classNames = '';
        /**
         * \@docs-private
         */

        this.grid = true;
      }
      /**
       * Type of layout.
       *
       * Values: grid | grid nogutters | grid maxwidth. Default value: grid.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxLayoutComponent, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;
          this.grid = !!this._classNames.match(/grid/);
          this.noGutters = !!this._classNames.match(/nogutters/);
          this.maxWidth = !!this._classNames.match(/maxwidth/);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
      }]);

      return NxLayoutComponent;
    }();

    NxLayoutComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: '[nxLayout]',
        template: '<ng-content></ng-content>',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-grid]': 'grid',
          '[class.nx-grid--no-gutters]': 'noGutters',
          '[class.nx-grid--max-width]': 'maxWidth'
        },
        styles: [":host(.nx-grid){position:relative;margin-left:auto;margin-right:auto;padding-right:8px;padding-left:8px}@media (min-width:704px){:host(.nx-grid){padding-right:32px;padding-left:32px}}:host(.nx-grid--no-gutters) ::ng-deep{padding-left:0;padding-right:0}:host(.nx-grid--no-gutters) ::ng-deep .nx-grid__row{margin-left:0;margin-right:0}:host(.nx-grid--no-gutters) ::ng-deep .nx-grid__row>[class*=nx-grid__column]{padding-left:0;padding-right:0}:host(.nx-grid--max-width){width:100%}@media (min-width:992px){:host(.nx-grid--max-width){width:1184px;max-width:100%}}"]
      }]
    }];
    NxLayoutComponent.propDecorators = {
      classNames: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxLayout']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var MAPPING_JUSTIFY = {
      'start': 'nx-justify-content-{tier}-start',
      'end': 'nx-justify-content-{tier}-end',
      'center': 'nx-justify-content-{tier}-center',
      'between': 'nx-justify-content-{tier}-between',
      'around': 'nx-justify-content-{tier}-around'
    };
    /** @type {?} */

    var MAPPING_ALIGN_ITEMS = {
      'start': 'nx-align-items-{tier}-start',
      'end': 'nx-align-items-{tier}-end',
      'center': 'nx-align-items-{tier}-center',
      'baseline': 'nx-align-items-{tier}-baseline',
      'stretch': 'nx-align-items-{tier}-stretch'
    };
    /** @type {?} */

    var MAPPING_ALIGN_CONTENT = {
      'start': 'nx-align-content-{tier}-start',
      'end': 'nx-align-content-{tier}-end',
      'center': 'nx-align-content-{tier}-center',
      'between': 'nx-align-content-{tier}-between',
      'around': 'nx-align-content-{tier}-around',
      'stretch': 'nx-align-content-{tier}-stretch'
    };
    /** @type {?} */

    var MAPPING_WRAP = {
      'wrap': 'nx-flex-{tier}-wrap',
      'nowrap': 'nx-flex-{tier}-nowrap',
      'reverse': 'nx-flex-{tier}-wrap-reverse'
    };
    /** @type {?} */

    var MAPPING_LAYOUT = {
      'row': 'nx-grid__row',
      'row-reverse': 'nx-grid__row-reverse'
    };

    var NxRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} el
       */
      function NxRowComponent(el) {
        _classCallCheck(this, NxRowComponent);

        this.el = el;
        this.ROW = 'row';
        this.ROW_RESERVE = 'row-reverse';
        this._classNames = '';
        /**
         * General
         */

        this._nxRow = this.ROW;
        /* Input row variables */

        /**
         * Align items on the main axis (horizontally).
         */

        this.nxRowJustify = null;
        /**
         * Similar to nxRowAlignItems, but instead of aligning flex items, it aligns flex lines.
         */

        this.nxRowAlignContent = null;
        /**
         * The default alignment for items inside the flexible container.
         */

        this.nxRowAlignItems = null;
        /**
         * How the flexible items should be wrapped.
         */

        this.nxRowWrap = null;
      }
      /**
       * Values: row | row-reverse
       *
       * Default value: row
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRowComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          if (this._nxRow === this.ROW || this._nxRow === this.ROW_RESERVE) {
            /** add row style */
            this._classNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_0__["mapClassNames"])(this._nxRow, [], MAPPING_LAYOUT);
            /** if not empty nxRowWrap, split input and add style */

            if (this.nxRowWrap) {
              /** possibles atributes: wrap,reverse,no-wrap */
              this._classNames += addStylesFromDimensions(this.nxRowWrap, MAPPING_WRAP);
            }
            /** if not empty nxRowJustify, add style */


            if (this.nxRowJustify) {
              /** possibles atributes: start,end,center,between,around */
              this._classNames += addStylesFromDimensions(this.nxRowJustify, MAPPING_JUSTIFY);
            }
            /** if not empty nxRowAlignContent, add style */


            if (this.nxRowAlignContent) {
              /** possibles atributes: start,end,center,between,stetch */
              this._classNames += addStylesFromDimensions(this.nxRowAlignContent, MAPPING_ALIGN_CONTENT);
            }
            /** if not empty nxRowAlignItems, add style */


            if (this.nxRowAlignItems) {
              /** possibles atributes: start,end,center,around,stetch */
              this._classNames += addStylesFromDimensions(this.nxRowAlignItems, MAPPING_ALIGN_ITEMS);
            }

            this._classNames += ' ' + this.el.nativeElement.className;
            this._classNames = this._classNames.trim();
          } else {
            throw new Error('nxRow is incorrect');
          }
        }
      }, {
        key: "nxRow",
        set: function set(value) {
          if (value !== '') {
            this._nxRow = value;
          }
        }
      }]);

      return NxRowComponent;
    }();

    NxRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: '[nxRow]',
        template: '<ng-content></ng-content>',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class]': '_classNames'
        },
        styles: [":host{display:flex;flex-wrap:wrap;margin-right:-8px;margin-left:-8px;position:relative}:host(.nx-flex-row){flex-direction:row!important}:host(.nx-flex-column){flex-direction:column!important}:host(.nx-flex-row-reverse){flex-direction:row-reverse!important}:host(.nx-flex-column-reverse){flex-direction:column-reverse!important}:host(.nx-flex-wrap){flex-wrap:wrap!important}:host(.nx-flex-nowrap){flex-wrap:nowrap!important}:host(.nx-flex-wrap-reverse){flex-wrap:wrap-reverse!important}:host(.nx-justify-content-start){justify-content:flex-start!important}:host(.nx-justify-content-end){justify-content:flex-end!important}:host(.nx-justify-content-center){justify-content:center!important}:host(.nx-justify-content-between){justify-content:space-between!important}:host(.nx-justify-content-around){justify-content:space-around!important}:host(.nx-align-items-start){align-items:flex-start!important}:host(.nx-align-items-end){align-items:flex-end!important}:host(.nx-align-items-center){align-items:center!important}:host(.nx-align-items-baseline){align-items:baseline!important}:host(.nx-align-items-stretch){align-items:stretch!important}:host(.nx-align-content-start){align-content:flex-start!important}:host(.nx-align-content-end){align-content:flex-end!important}:host(.nx-align-content-center){align-content:center!important}:host(.nx-align-content-between){align-content:space-between!important}:host(.nx-align-content-around){align-content:space-around!important}:host(.nx-align-content-stretch){align-content:stretch!important}@media (min-width:320px){:host{margin-right:-8px;margin-left:-8px;position:relative}:host(.nx-flex-small-row){flex-direction:row!important}:host(.nx-flex-small-column){flex-direction:column!important}:host(.nx-flex-small-row-reverse){flex-direction:row-reverse!important}:host(.nx-flex-small-column-reverse){flex-direction:column-reverse!important}:host(.nx-flex-small-wrap){flex-wrap:wrap!important}:host(.nx-flex-small-nowrap){flex-wrap:nowrap!important}:host(.nx-flex-small-wrap-reverse){flex-wrap:wrap-reverse!important}:host(.nx-justify-content-small-start){justify-content:flex-start!important}:host(.nx-justify-content-small-end){justify-content:flex-end!important}:host(.nx-justify-content-small-center){justify-content:center!important}:host(.nx-justify-content-small-between){justify-content:space-between!important}:host(.nx-justify-content-small-around){justify-content:space-around!important}:host(.nx-align-items-small-start){align-items:flex-start!important}:host(.nx-align-items-small-end){align-items:flex-end!important}:host(.nx-align-items-small-center){align-items:center!important}:host(.nx-align-items-small-baseline){align-items:baseline!important}:host(.nx-align-items-small-stretch){align-items:stretch!important}:host(.nx-align-content-small-start){align-content:flex-start!important}:host(.nx-align-content-small-end){align-content:flex-end!important}:host(.nx-align-content-small-center){align-content:center!important}:host(.nx-align-content-small-between){align-content:space-between!important}:host(.nx-align-content-small-around){align-content:space-around!important}:host(.nx-align-content-small-stretch){align-content:stretch!important}}@media (min-width:704px){:host{margin-right:-16px;margin-left:-16px;position:relative}:host(.nx-flex-medium-row){flex-direction:row!important}:host(.nx-flex-medium-column){flex-direction:column!important}:host(.nx-flex-medium-row-reverse){flex-direction:row-reverse!important}:host(.nx-flex-medium-column-reverse){flex-direction:column-reverse!important}:host(.nx-flex-medium-wrap){flex-wrap:wrap!important}:host(.nx-flex-medium-nowrap){flex-wrap:nowrap!important}:host(.nx-flex-medium-wrap-reverse){flex-wrap:wrap-reverse!important}:host(.nx-justify-content-medium-start){justify-content:flex-start!important}:host(.nx-justify-content-medium-end){justify-content:flex-end!important}:host(.nx-justify-content-medium-center){justify-content:center!important}:host(.nx-justify-content-medium-between){justify-content:space-between!important}:host(.nx-justify-content-medium-around){justify-content:space-around!important}:host(.nx-align-items-medium-start){align-items:flex-start!important}:host(.nx-align-items-medium-end){align-items:flex-end!important}:host(.nx-align-items-medium-center){align-items:center!important}:host(.nx-align-items-medium-baseline){align-items:baseline!important}:host(.nx-align-items-medium-stretch){align-items:stretch!important}:host(.nx-align-content-medium-start){align-content:flex-start!important}:host(.nx-align-content-medium-end){align-content:flex-end!important}:host(.nx-align-content-medium-center){align-content:center!important}:host(.nx-align-content-medium-between){align-content:space-between!important}:host(.nx-align-content-medium-around){align-content:space-around!important}:host(.nx-align-content-medium-stretch){align-content:stretch!important}}@media (min-width:992px){:host{margin-right:-16px;margin-left:-16px;position:relative}:host(.nx-flex-large-row){flex-direction:row!important}:host(.nx-flex-large-column){flex-direction:column!important}:host(.nx-flex-large-row-reverse){flex-direction:row-reverse!important}:host(.nx-flex-large-column-reverse){flex-direction:column-reverse!important}:host(.nx-flex-large-wrap){flex-wrap:wrap!important}:host(.nx-flex-large-nowrap){flex-wrap:nowrap!important}:host(.nx-flex-large-wrap-reverse){flex-wrap:wrap-reverse!important}:host(.nx-justify-content-large-start){justify-content:flex-start!important}:host(.nx-justify-content-large-end){justify-content:flex-end!important}:host(.nx-justify-content-large-center){justify-content:center!important}:host(.nx-justify-content-large-between){justify-content:space-between!important}:host(.nx-justify-content-large-around){justify-content:space-around!important}:host(.nx-align-items-large-start){align-items:flex-start!important}:host(.nx-align-items-large-end){align-items:flex-end!important}:host(.nx-align-items-large-center){align-items:center!important}:host(.nx-align-items-large-baseline){align-items:baseline!important}:host(.nx-align-items-large-stretch){align-items:stretch!important}:host(.nx-align-content-large-start){align-content:flex-start!important}:host(.nx-align-content-large-end){align-content:flex-end!important}:host(.nx-align-content-large-center){align-content:center!important}:host(.nx-align-content-large-between){align-content:space-between!important}:host(.nx-align-content-large-around){align-content:space-around!important}:host(.nx-align-content-large-stretch){align-content:stretch!important}}"]
      }]
    }];
    /** @nocollapse */

    NxRowComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    NxRowComponent.propDecorators = {
      nxRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      nxRowJustify: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxRowJustify']
      }],
      nxRowAlignContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxRowAlignContent']
      }],
      nxRowAlignItems: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxRowAlignItems']
      }],
      nxRowWrap: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['nxRowWrap']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxGridModule = function NxGridModule() {
      _classCallCheck(this, NxGridModule);
    };

    NxGridModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [NxLayoutComponent, NxRowComponent, NxColComponent],
        exports: [NxLayoutComponent, NxRowComponent, NxColComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-input.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-input.js ***!
    \***************************************************************************/

  /*! exports provided: NxInputModule, NX_INPUT_VALUE_ACCESSOR, NxInputDirective, NxPasswordToggleComponent */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxInputJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxInputModule", function () {
      return NxInputModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NX_INPUT_VALUE_ACCESSOR", function () {
      return NX_INPUT_VALUE_ACCESSOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxInputDirective", function () {
      return NxInputDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPasswordToggleComponent", function () {
      return NxPasswordToggleComponent;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/cdk/platform */
    "./node_modules/@angular/cdk/esm2015/platform.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/formfield */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js");
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var NX_INPUT_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_7__["InjectionToken"]('NX_INPUT_VALUE_ACCESSOR');
    /** @type {?} */

    var INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];

    var ɵ0 =
    /**
    * @param {?} t
    * @return {?}
    */
    function ɵ0(t) {
      return Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__["getSupportedInputTypes"])().has(t);
    };
    /** @type {?} */


    var NEVER_EMPTY = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(ɵ0);
    /** @type {?} */

    var nextUniqueId = 0;

    var NxInputDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _elementRef
       * @param {?} ngControl
       * @param {?} _parentForm
       * @param {?} _parentFormGroup
       * @param {?} _errorStateMatcher
       * @param {?} inputValueAccessor
       */
      function NxInputDirective(_elementRef, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor) {
        _classCallCheck(this, NxInputDirective);

        this._elementRef = _elementRef;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._errorStateMatcher = _errorStateMatcher;
        this._type = 'text';
        this._uid = "nx-input-".concat(nextUniqueId++);
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        /**
         * \@docs-private
         */

        this.errorState = false;
        /**
         * \@docs-private
         */

        this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * \@docs-private
         */

        this.focused = false;
        this.id = this.id; // This will enable other directives to plugin itself as the value accessor
        // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
        // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
        // See the datefield for details.

        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
        this._previousNativeValue = this.value;
      }
      /**
       * The id of the input.
       * @return {?}
       */


      _createClass(NxInputDirective, [{
        key: "_onInput",

        /**
         * @return {?}
         */
        value: function _onInput() {} // force to to run change detection so we know about changes in the native form input

        /**
         * @param {?} isFocused
         * @return {?}
         */

      }, {
        key: "_focusChanged",
        value: function _focusChanged(isFocused) {
          if (isFocused !== this.focused && !this.readonly) {
            this.focused = isFocused;
            this.stateChanges.next();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this.stateChanges.next();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.stateChanges.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
          } else {
            // When the input isn't used together with `@angular/forms`, we need to check manually for
            // changes to the native `value` property in order to update the floating label.
            this._dirtyCheckNativeValue();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updateErrorState",
        value: function updateErrorState() {
          /** @type {?} */
          var oldState = this.errorState;
          /** @type {?} */

          var parent = this._parentFormGroup || this._parentForm;
          /** @type {?} */

          var control = this.ngControl ?
          /** @type {?} */
          this.ngControl.control : null;
          /** @type {?} */

          var newState = this._errorStateMatcher.isErrorState(control, parent);

          if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
          }
        }
        /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         * @param {?} ids
         * @return {?}
         */

      }, {
        key: "setDescribedByIds",
        value: function setDescribedByIds(ids) {
          this._ariaDescribedby = ids.join(' ');
        } // allow to set a arial label value in case there
        // is not possibility to display a proper label

        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(value) {
          this._ariaLabel = value;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_isBadInput",
        value: function _isBadInput() {
          // The `validity` property won't be present on platform-server.

          /** @type {?} */
          var validity =
          /** @type {?} */
          this._elementRef.nativeElement.validity;
          return validity && validity.badInput;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_isNeverEmpty",

        /**
         * @protected
         * @return {?}
         */
        value: function _isNeverEmpty() {
          return NEVER_EMPTY.indexOf(this._type) > -1;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_isTextarea",
        value: function _isTextarea() {
          /** @type {?} */
          var nativeElement = this._elementRef.nativeElement;
          return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_validateType",
        value: function _validateType() {
          if (INVALID_TYPES.indexOf(this._type) > -1) {
            throw new Error("Input of type '".concat(this._type, "' is not supported"));
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_dirtyCheckNativeValue",

        /**
         * @protected
         * @return {?}
         */
        value: function _dirtyCheckNativeValue() {
          /** @type {?} */
          var newValue = this.value;

          if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
          }
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._id = value || this._uid;
        }
        /**
         * The input element's value.
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._inputValueAccessor.value;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== this.value) {
            this._inputValueAccessor.value = value;
          }
        }
        /**
         * Whether the element is readonly.
         * @return {?}
         */

      }, {
        key: "readonly",
        get: function get() {
          return this._readonly;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._readonly = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
          this.stateChanges.next();
        }
        /**
         * Whether the input is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
          }

          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); // Browsers may not fire the blur event if the input is disabled too quickly.
          // Reset from here to ensure that the element doesn't become stuck.

          if (this.focused) {
            this.focused = false;
            this.stateChanges.next();
          }
        }
        /**
         * Whether the element is required.
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
        }
        /**
         * Sets the type of the input element (e.g. password, text etc).
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          return this._type;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._type = value || 'text';

          this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native
          // input element. To ensure that bindings for `type` work, we need to sync the setter
          // with the native property. Textarea elements don't support the type property or attribute.


          if (!this._isTextarea() && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__["getSupportedInputTypes"])().has(this._type)) {
            this._elementRef.nativeElement.type = this._type;
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }, {
        key: "empty",
        get: function get() {
          return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput();
        }
      }, {
        key: "shouldLabelFloat",
        get: function get() {
          return this.focused || !this.empty;
        }
      }]);

      return NxInputDirective;
    }();

    NxInputDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Directive"],
      args: [{
        selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
        host: {
          '[class.c-input]': 'true',
          '[attr.id]': 'id',
          '[class.is-filled]': 'empty === false',
          '[class.is-disabled]': 'disabled',
          '[class.has-error]': 'errorState',
          '[class.is-focused]': 'focused',
          '[attr.aria-label]': '_ariaLabel || null',
          '[attr.aria-describedby]': '_ariaDescribedby || null',
          '[attr.aria-invalid]': 'errorState',
          '[attr.aria-required]': 'required.toString()',
          '(blur)': '_focusChanged(false)',
          '(focus)': '_focusChanged(true)',
          '(input)': '_onInput()'
        },
        providers: [{
          provide: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_5__["NxFormfieldControl"],
          useExisting: NxInputDirective
        }]
      }]
    }];
    /** @nocollapse */

    NxInputDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["ElementRef"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Self"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NgForm"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormGroupDirective"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Optional"]
        }]
      }, {
        type: _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_6__["ErrorStateMatcher"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Inject"],
          args: [NX_INPUT_VALUE_ACCESSOR]
        }]
      }];
    };

    NxInputDirective.propDecorators = {
      _ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"],
        args: ['nxAriaLabel']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      readonly: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var visibilityIcons = {
      show: 'password-show-o',
      hide: 'password-hide-o'
    };

    var NxPasswordToggleComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxPasswordToggleComponent(_changeDetectorRef) {
        _classCallCheck(this, NxPasswordToggleComponent);

        this._changeDetectorRef = _changeDetectorRef;
        /**
         * \@docs-private
         */

        this._currentIcon = visibilityIcons['show'];
        /**
         * \@docs-private
         */

        this._pressed = false;
        this._ariaLabel = 'Show password';
      }
      /**
       * Sets the aria-label needed for accessibility.
       * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
       * E.g if you have an `input[type=password]` at the beginning then the
       * password will be hidden and the correct aria-label would be 'Show password.'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxPasswordToggleComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          if (!this.control) {
            console.warn('You need to pass an input as a control to the password toggle.');
          } else {
            // show the right icon according to the initial type of the input
            this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
          }
        }
        /**
         * Toggles the type of the input.
         * @return {?}
         */

      }, {
        key: "toggleInputType",
        value: function toggleInputType() {
          if (this.control) {
            this.control.type = this.control.type === 'password' ? 'text' : 'password';
            this._pressed = !this._pressed;
            this.toggleIcon();

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "toggleIcon",
        value: function toggleIcon() {
          this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
        }
        /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */

      }, {
        key: "_onKeydown",
        value: function _onKeydown($event) {
          if ($event && ($event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["ENTER"] || $event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["SPACE"])) {
            this.toggleInputType();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "ariaLabel",
        set: function set(value) {
          if (value !== this._ariaLabel) {
            this._ariaLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._ariaLabel;
        }
      }, {
        key: "tabindex",
        get: function get() {
          if (this.control) {
            return this.control.disabled ? -1 : 0;
          }

          return null;
        }
      }]);

      return NxPasswordToggleComponent;
    }();

    NxPasswordToggleComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Component"],
      args: [{
        selector: 'nx-password-toggle',
        template: "<nx-icon\n      aria-hidden=\"true\"\n      [name]=\"_currentIcon\">\n    </nx-icon>",
        host: {
          '[attr.aria-label]': 'ariaLabel',
          '[attr.tabindex]': 'tabindex',
          '[attr.aria-pressed]': '_pressed',
          'role': 'button',
          '(click)': 'toggleInputType()',
          '(keydown)': '_onKeydown($event)'
        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_7__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}:host:focus{outline:0}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}:host-context(.is-disabled){pointer-events:none}"]
      }]
    }];
    /** @nocollapse */

    NxPasswordToggleComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["ChangeDetectorRef"]
      }];
    };

    NxPasswordToggleComponent.propDecorators = {
      control: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxInputModule = function NxInputModule() {
      _classCallCheck(this, NxInputModule);
    };

    NxInputModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_7__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_5__["NxFormfieldModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_9__["NxIconModule"]],
        declarations: [NxInputDirective, NxPasswordToggleComponent],
        exports: [_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_5__["NxFormfieldModule"], NxInputDirective, NxPasswordToggleComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-message.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-message.js ***!
    \*****************************************************************************/

  /*! exports provided: NxMessageModule, NxMessageComponent */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxMessageJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxMessageModule", function () {
      return NxMessageModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxMessageComponent", function () {
      return NxMessageComponent;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ICONS = {
      info: 'info-circle',
      error: 'exclamation-circle',
      success: 'check-circle',
      warning: 'exclamation-triangle'
    };

    var NxMessageComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxMessageComponent(_changeDetectorRef) {
        _classCallCheck(this, NxMessageComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._context = 'regular';
        this._showIcon = false;
        this._closable = false;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Event emitted when the close icon of the message has been clicked.
         */

        this.closeEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
      }
      /**
       * Sets the context of the message.
       * The message box will color accordingly. Default: 'regular'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxMessageComponent, [{
        key: "_emitCloseEvent",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _emitCloseEvent() {
          this.closeEvent.emit();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getIconName",
        value: function getIconName() {
          if (this._context === 'info') {
            return ICONS.info;
          } else if (this._context === 'error') {
            return ICONS.error;
          } else if (this._context === 'success') {
            return ICONS.success;
          } else if (this._context === 'warning') {
            return ICONS.warning;
          }

          return '';
        }
      }, {
        key: "context",
        set: function set(value) {
          if (value !== this._context) {
            this._context = value;
            this._icon = this.getIconName();

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._context;
        }
        /**
         * Whether an icon that belongs to the context of the message should be displayed.
         * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
         * \@deletion-target 9.0.0
         *
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "showIcon",
        set: function set(value) {
          this._showIcon = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._showIcon;
        }
        /**
         * Whether a message should have a close icon in order to be dismissed.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closable",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);

          if (newValue !== this._closable) {
            this._closable = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closable;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this._icon;
        }
        /**
         * Sets the label of the close button of the message.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closeButtonLabel",
        set: function set(value) {
          if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closeButtonLabel;
        }
      }]);

      return NxMessageComponent;
    }();

    NxMessageComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
      args: [{
        selector: 'nx-message',
        template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxMessage',
        host: {
          '[class.context-info]': 'context === "info"',
          '[class.context-error]': 'context === "error"',
          '[class.context-success]': 'context === "success"',
          '[class.context-warning]': 'context === "warning"',
          '[class.nx-message--closable]': 'closable'
        },
        styles: [":host{width:100%;color:#414141;display:flex;align-items:flex-start;position:relative;background-color:#fff;border:1px solid;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;margin:12px 0;font-size:16px;line-height:24px}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141}:host(.context-info){border-color:#496ebd}:host(.context-info) .nx-message__icon{color:#496ebd}:host(.context-error){border-color:#dc3149}:host(.context-error) .nx-message__icon{color:#dc3149}:host(.context-success){border-color:#1e8927}:host(.context-success) .nx-message__icon{color:#1e8927}:host(.context-warning){border-color:#efbe25}:host(.context-warning) .nx-message__icon{color:#efbe25}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{font-size:16px;color:nx-colors(grey-tones,grey-tone-1)}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
      }]
    }];
    /** @nocollapse */

    NxMessageComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"]
      }];
    };

    NxMessageComponent.propDecorators = {
      context: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"],
        args: ['nxContext']
      }],
      showIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      closable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      closeButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
      }],
      closeEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"],
        args: ['close']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxMessageModule = function NxMessageModule() {
      _classCallCheck(this, NxMessageModule);
    };

    NxMessageModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_1__["NxIconModule"]],
        declarations: [NxMessageComponent],
        exports: [NxMessageComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-natural-language-form.js":
  /*!*******************************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-natural-language-form.js ***!
    \*******************************************************************************************/

  /*! exports provided: NxNaturalLanguageFormModule, NxNaturalLanguageFormComponent, NxWordComponent */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxNaturalLanguageFormJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNaturalLanguageFormModule", function () {
      return NxNaturalLanguageFormModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNaturalLanguageFormComponent", function () {
      return NxNaturalLanguageFormComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxWordComponent", function () {
      return NxWordComponent;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/input */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-input.js");
    /* harmony import */


    var _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/formfield */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js");
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /* harmony import */


    var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/overlay */
    "./node_modules/@angular/cdk/esm2015/overlay.js");
    /* harmony import */


    var _allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/popover */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-popover.js");
    /* harmony import */


    var _allianz_ngx_ndbx_dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/dropdown */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-dropdown.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxWordComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} _changeDetectorRef
       * @param {?} _renderer
       * @param {?} _overlay
       */
      function NxWordComponent(elementRef, _changeDetectorRef, _renderer, _overlay) {
        _classCallCheck(this, NxWordComponent);

        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this.subscription = rxjs__WEBPACK_IMPORTED_MODULE_7__["Subscription"].EMPTY;
        this.subscriptionValues = rxjs__WEBPACK_IMPORTED_MODULE_7__["Subscription"].EMPTY;
        /**
         * \@docs-private
         */

        this.hasErrors = false;
        /**
         * \@docs-private
         */

        this.inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"]();
        /**
         * \@docs-private
         */

        this.currentTextWidth = 0; // this will apply different min-widths to our component through our styles

        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         */

        this.size = 'regular';
      }
      /**
       * @return {?}
       */


      _createClass(NxWordComponent, [{
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this31 = this;

          this._validateControlChild();

          this.subscription = this._control.stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["startWith"])(null)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this31.hasErrors = _this31._control.errorState;

            _this31._changeDetectorRef.markForCheck();
          }); // if we have a ngcontrol available stick to its valueChanges subject

          if (this._control.ngControl) {
            this.subscriptionValues = this._control.ngControl.valueChanges.subscribe(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              _this31.updateCurrentTextWidth();

              _this31.inputChanges.next();
            }); // in any other case it is a bre input and input changes are signaled through simple state changes
          } else {
            this.subscriptionValues = this._control.stateChanges.subscribe(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              _this31.updateCurrentTextWidth();

              _this31.inputChanges.next();
            });
          }

          this._control.setAriaLabel(this.label);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subscription.unsubscribe();
        }
        /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */

      }, {
        key: "updateCurrentTextWidth",
        value: function updateCurrentTextWidth() {
          // provide the canvas only lazy
          if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
          }
          /** @type {?} */


          var ctx = this.measureCanvas.getContext('2d');
          /** @type {?} */

          var inputRef = this._control.elementRef;
          /** @type {?} */

          var styles = window.getComputedStyle(inputRef.nativeElement);
          ctx.font = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_2__["getFontShorthand"])(styles);
          /** @type {?} */

          var metrics = ctx.measureText(this._control.value); // add 1px (cursor width) to prevent jumping of the text on blur.

          /** @type {?} */

          var newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1; // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
          // Works as promised as long as there is not other tag around the word. Not expected but possible.

          /** @type {?} */

          var parent = this.elementRef.nativeElement.parentElement;
          /** @type {?} */

          var parentMeasurement = parent.getBoundingClientRect(); // Limit to own given minimal width

          this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth); // Limit to container width

          this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);

          this._popover.updatePosition();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "repositionError",
        value: function repositionError() {
          if (this._popover) {
            this._popover.updatePosition();
          }
        } // Fail if the required control is missing.

        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_validateControlChild",
        value: function _validateControlChild() {
          if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getConnectedOverlayOrigin",
        value: function getConnectedOverlayOrigin() {
          return this.elementRef;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isFocused",
        get: function get() {
          return this._control.focused;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isFilled",
        get: function get() {
          return !this._control.empty;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hasDropdown",
        get: function get() {
          return Boolean(this._dropdown);
        }
      }]);

      return NxWordComponent;
    }();

    NxWordComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Component"],
      args: [{
        selector: 'nx-word',
        template: "<div\n  class=\"nx-word__input-wrapper\"\n  [nxPopoverTriggerFor]=\"popoverHover\"\n  nxPopoverTrigger='manual'\n  nxPopoverCloseable=\"false\"\n  nxPopoverDirection=\"top\"\n  [nxPopoverShow]=\"hasErrors && _errorChildren.length > 0\">\n\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popoverHover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n",
        host: {
          '[class.size-short]': 'size == "short"',
          '[class.size-regular]': 'size == "regular"',
          '[class.size-long]': 'size == "long"',
          '[class.has-error]': 'hasErrors',
          '[class.is-focused]': 'isFocused',
          '[class.is-filled]': 'isFilled',
          '[class.has-dropdown]': 'hasDropdown'
        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none;border-bottom-width:2px}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.is-filled{border-color:#007ab3;color:#006192}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;border-color:#dc3149}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px}:host-context(.nx-natural-language-form--small) ::ng-deep nx-dropdown .nx-dropdown__container{margin-bottom:2px}"]
      }]
    }];
    /** @nocollapse */

    NxWordComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Renderer2"]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["Overlay"]
      }];
    };

    NxWordComponent.propDecorators = {
      _control: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ContentChild"],
        args: [_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_1__["NxFormfieldControl"]]
      }],
      _errorChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ContentChildren"],
        args: [_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_1__["NxFormfieldErrorDirective"]]
      }],
      _popover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ViewChild"],
        args: [_allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_4__["NxPopoverTriggerDirective"]]
      }],
      _dropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ContentChild"],
        args: [_allianz_ngx_ndbx_dropdown__WEBPACK_IMPORTED_MODULE_5__["NxDropdownComponent"]]
      }],
      currentTextWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["HostBinding"],
        args: ['style.width.px']
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Input"],
        args: ['nxSize']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Input"],
        args: ['nxLabel']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_SIZE = 'large';

    var NxNaturalLanguageFormComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxNaturalLanguageFormComponent(_changeDetectorRef) {
        _classCallCheck(this, NxNaturalLanguageFormComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        /**
         * \@docs-private
         */

        this.resizeEvent$ = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"]();
        /**
         * \@docs-private
         */

        this.updatePopoversSubscription = rxjs__WEBPACK_IMPORTED_MODULE_7__["Subscription"].EMPTY;
        /**
         * \@docs-private
         */

        this._size = DEFAULT_SIZE;
      }
      /**
       * Whether the negative set of stylings should be used.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxNaturalLanguageFormComponent, [{
        key: "onResize",

        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        value: function onResize(event) {
          this.resizeEvent$.next();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this32 = this;

          // Collect all words and listen for changes so we can update any open error popover
          // which would otherwise get wrongly positioned.

          /** @type {?} */
          var subjects = this._words.map(
          /**
          * @param {?} word
          * @return {?}
          */
          function (word) {
            return word.inputChanges;
          });
          /** @type {?} */


          var source = Object(rxjs__WEBPACK_IMPORTED_MODULE_7__["merge"]).apply(void 0, _toConsumableArray(subjects));
          this.updatePopoversSubscription = source.subscribe(
          /**
          * @return {?}
          */
          function () {
            _this32.updatePositionPopovers();
          });
          this.resizeObservable = this.resizeEvent$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["throttleTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["delay"])(100));
          this.resizeObservable.subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this32.resizeWords();
          });
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "resizeWords",
        value: function resizeWords() {
          this._words.forEach(
          /**
          * @param {?} word
          * @return {?}
          */
          function (word) {
            word.updateCurrentTextWidth();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.updatePopoversSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updatePositionPopovers",
        value: function updatePositionPopovers() {
          if (this._words) {
            this._words.forEach(
            /**
            * @param {?} word
            * @return {?}
            */
            function (word) {
              word.repositionError();
            });
          }
        }
      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the size of the NLF. Default value: large
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "size",
        set: function set(value) {
          this._size = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._size;
        }
      }]);

      return NxNaturalLanguageFormComponent;
    }();

    NxNaturalLanguageFormComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Component"],
      args: [{
        selector: 'nx-natural-language-form',
        template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.is-negative]': 'negative',
          '[class.nx-natural-language-form--small]': 'size === "small"',
          '[class.nx-natural-language-form--large]': 'size === "large"'
        },
        styles: [":host{display:block;padding-top:72px;padding-bottom:80px;color:#414141;font-weight:300;font-size:40px;line-height:52px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;line-height:36px}}@media (max-width:703px){:host{font-size:26px}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;line-height:32px;letter-spacing:.3px}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
      }]
    }];
    /** @nocollapse */

    NxNaturalLanguageFormComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ChangeDetectorRef"]
      }];
    };

    NxNaturalLanguageFormComponent.propDecorators = {
      _words: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["ContentChildren"],
        args: [NxWordComponent]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Input"],
        args: ['nxNegative']
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["Input"]
      }],
      onResize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["HostListener"],
        args: ['window:orientationchange', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["HostListener"],
        args: ['window:resize', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxNaturalLanguageFormModule = function NxNaturalLanguageFormModule() {
      _classCallCheck(this, NxNaturalLanguageFormModule);
    };

    NxNaturalLanguageFormModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_9__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"], _allianz_ngx_ndbx_input__WEBPACK_IMPORTED_MODULE_0__["NxInputModule"], _allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_4__["NxPopoverModule"]],
        declarations: [NxNaturalLanguageFormComponent, NxWordComponent],
        exports: [NxNaturalLanguageFormComponent, NxWordComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-popover.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-popover.js ***!
    \*****************************************************************************/

  /*! exports provided: NxPopoverModule, NxPopoverComponent, NxPopoverTriggerDirective, NxPopoverContentDirective */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxPopoverJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverModule", function () {
      return NxPopoverModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverComponent", function () {
      return NxPopoverComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverTriggerDirective", function () {
      return NxPopoverTriggerDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverContentDirective", function () {
      return NxPopoverContentDirective;
    });
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/esm2015/portal.js");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/platform-browser */
    "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/overlay */
    "./node_modules/@angular/cdk/esm2015/overlay.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Popover content that will be rendered lazily
     * after the popover is opened for the first time.
     */


    var NxPopoverContentDirective =
    /**
     * @param {?} _template
     */
    function NxPopoverContentDirective(_template) {
      _classCallCheck(this, NxPopoverContentDirective);

      this._template = _template;
    };

    NxPopoverContentDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Directive"],
      args: [{
        selector: 'ng-template[nxPopoverContent]'
      }]
    }];
    /** @nocollapse */

    NxPopoverContentDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxPopoverComponent =
    /*#__PURE__*/
    function () {
      function NxPopoverComponent() {
        _classCallCheck(this, NxPopoverComponent);

        /**
         * Event emitted when the popover is closed.
         */
        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_5__["EventEmitter"]();
        /**
         * \@docs-private
         */

        this.closeButtonClick = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * \@docs-private
         */

        this.showCloseButton = false;
        /**
         * \@docs-private
         */

        this.arrowStyle = {};
      }
      /**
       * @return {?}
       */


      _createClass(NxPopoverComponent, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.closed.complete();
        } // emit to notify the popover trigger directive that the close button was clicked

        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "emitButtonClick",
        value: function emitButtonClick() {
          this.closeButtonClick.next();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "emitClosedEvent",
        value: function emitClosedEvent() {
          this.closed.emit();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "classList",
        get: function get() {
          if (this.direction) {
            return ["nx-popover--".concat(this.direction)];
          }
        }
      }]);

      return NxPopoverComponent;
    }();

    NxPopoverComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Component"],
      args: [{
        selector: 'nx-popover',
        template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\">\n    <div class=\"nx-popover__content\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span aria-hidden=\"true\" class=\"nx-popover__close-icon\" (click)=\"emitButtonClick()\"\n            *ngIf=\"showCloseButton\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_5__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxPopover',
        styles: [".nx-popover__content{background-color:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block;font-size:16px}.nx-popover__close-icon{position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;line-height:16px}[data-whatintent=mouse] .nx-popover__content:focus{outline:0}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-left:1px solid #d9d9d9}.nx-popover--top .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(225deg);transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(-45deg);transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(45deg);transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(135deg);transform:translate(0,-50%) rotate(135deg);right:-5px}"]
      }]
    }];
    /** @nocollapse */

    NxPopoverComponent.ctorParameters = function () {
      return [];
    };

    NxPopoverComponent.propDecorators = {
      templateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["ViewChild"],
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_5__["TemplateRef"]]
      }],
      _lazyContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["ContentChild"],
        args: [NxPopoverContentDirective]
      }],
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Output"],
        args: ['nxClosed']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId = 0;
    /** @type {?} */

    var fallbacks = [{
      originX: 'start',
      originY: 'bottom',
      overlayX: 'start',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'top',
      overlayX: 'end',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }, {
      originX: 'center',
      originY: 'bottom',
      overlayX: 'center',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'bottom',
      overlayX: 'end',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'center',
      overlayX: 'start',
      overlayY: 'center',
      offsetX: 16,
      offsetY: 0
    }, {
      originX: 'start',
      originY: 'center',
      overlayX: 'end',
      overlayY: 'center',
      offsetX: -16,
      offsetY: 0
    }, {
      originX: 'center',
      originY: 'top',
      overlayX: 'center',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }, {
      originX: 'start',
      originY: 'top',
      overlayX: 'start',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }];

    var NxPopoverTriggerDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} overlay
       * @param {?} elementRef
       * @param {?} viewContainerRef
       * @param {?} eventManager
       */
      function NxPopoverTriggerDirective(overlay, elementRef, viewContainerRef, eventManager) {
        _classCallCheck(this, NxPopoverTriggerDirective);

        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._show = false;
        this._closeable = null;
        /**
         * \@docs-private
         */

        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */

        this.changeShow = new _angular_core__WEBPACK_IMPORTED_MODULE_5__["EventEmitter"]();
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */

        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */

        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */

        this.visibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_5__["EventEmitter"]();
        /**
         * Whether the popover opens in modal state.
         */

        this.modal = false; // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.

        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */

        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */

        this.scrollStrategy = 'close';
        this._documentClickObservable = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document, 'click');
      }
      /**
       * Whether to show or hide the popover.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxPopoverTriggerDirective, [{
        key: "onMouseEnter",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function onMouseEnter() {
          if (this.trigger === 'hover') {
            this.openPopover();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "onMouseExit",
        value: function onMouseExit() {
          if (this.trigger === 'hover') {
            this.closePopover();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.popover.showCloseButton = this.isCloseable();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this33 = this;

          this.popover.id = this.id;
          this.eventManager.addGlobalEventListener('window', 'keyup.esc',
          /**
          * @return {?}
          */
          function () {
            _this33.closePopover();
          });
          this.popover.closeButtonClick.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this33.closePopover();
          });

          if (this.popoverInitialVisible || this._show) {
            this.openPopover();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.closePopover();

          this._destroyed.next();

          this._destroyed.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isCloseable",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function isCloseable() {
          return this.trigger === 'click' && this._closeable === null || this._closeable;
        }
        /**
         * Update the popover with the given position strategy.
         * @return {?}
         */

      }, {
        key: "updatePosition",
        value: function updatePosition() {
          if (this._positionStrategy) {
            this._positionStrategy.apply();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "handleClick",
        value: function handleClick() {
          if (this.trigger === 'click') {
            if (this.isOpen) {
              this.closePopover();
            } else {
              this.openPopover();
            }
          }
        }
        /**
         * Open the popover instance.
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          this.show = true;
        }
        /**
         * Close the popover instance.
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.show = false;
        }
        /**
         * Toggle the popover instance.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.show = !this.show;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "openPopover",
        value: function openPopover() {
          if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);

            if (!this.modal && this.trigger === 'click') {
              this.waitForClose();
            }
          }
        } // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "closePopover",
        value: function closePopover() {
          if (this.overlayRef) {
            this.overlayRef.detach();
            this._embeddedViewRef = null;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "createOverlay",
        value: function createOverlay() {
          if (!this.overlayRef) {
            this.portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["TemplatePortal"](this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */

            var overlayState = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;

            if (this.scrollStrategy === 'reposition') {
              overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            } else {
              overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }

            overlayState.scrollStrategy.enable();

            if (this.modal && this.trigger === 'click') {
              overlayState.hasBackdrop = true;
            }

            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions(
            /** @type {?} */
            overlayState.positionStrategy);

            this._subscribeToDetach();

            if (this.modal) {
              this._subscribeToBackdropClick();
            }
          }

          return this.overlayRef;
        }
        /**
         * @private
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "subscribeToPositions",
        value: function subscribeToPositions(position) {
          var _this34 = this;

          position.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @param {?} change
          * @return {?}
          */
          function (change) {
            /** @type {?} */
            var pair = change.connectionPair;

            _this34.positionOverlay(pair);

            _this34.positionArrow(pair); // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.


            if (_this34._embeddedViewRef && !_this34._embeddedViewRef.destroyed) {
              _this34._embeddedViewRef.detectChanges();
            }
          });
        } // for modal popovers close the popover on backdrop clicks

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToBackdropClick",
        value: function _subscribeToBackdropClick() {
          var _this35 = this;

          this.overlayRef.backdropClick().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            _this35.closePopover();
          });
        } // Emit the nxClosed event on the popover component when the overlay detaches

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToDetach",
        value: function _subscribeToDetach() {
          var _this36 = this;

          this.overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this36.popover.emitClosedEvent();
          });
        } // subscribe to document clicks when trigger='click' to close the popover on clicks on the background

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "waitForClose",
        value: function waitForClose() {
          var _this37 = this;

          return this._documentClickObservable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            return event.target;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
          /**
          * @param {?} target
          * @return {?}
          */
          function (target) {
            return !_this37.elementRef.nativeElement.contains(target);
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this.popover.closed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this37.closePopover();
          });
        }
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */

      }, {
        key: "positionOverlay",
        value: function positionOverlay(pair) {
          if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
          } else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
          } else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
          } else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
          }
        }
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */

      }, {
        key: "positionArrow",
        value: function positionArrow(pair) {
          /** @type {?} */
          var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
          /** @type {?} */

          var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
          /** @type {?} */

          var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
          /** @type {?} */

          var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft; // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.

          /** @type {?} */

          var targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);

          if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */

            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
          }

          if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = {
              left: targetPosition + 'px'
            };
          }

          if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = {
              top: '50%'
            };
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          /** @type {?} */
          var positions;
          /** @type {?} */

          var offsetX = 0;
          /** @type {?} */

          var offsetY = 0;

          if (this.direction === 'top') {
            positions = [{
              overlayX: 'center',
              overlayY: 'bottom',
              originX: 'center',
              originY: 'top'
            }];
            offsetX = 0;
            offsetY = -20;
          } else if (this.direction === 'right') {
            positions = [{
              overlayX: 'start',
              overlayY: 'center',
              originX: 'end',
              originY: 'center'
            }];
            offsetX = 20;
            offsetY = 0;
          } else if (this.direction === 'bottom') {
            positions = [{
              overlayX: 'center',
              overlayY: 'top',
              originX: 'center',
              originY: 'bottom'
            }];
            offsetX = 0;
            offsetY = 20;
          } else if (this.direction === 'left') {
            positions = [{
              overlayX: 'end',
              overlayY: 'center',
              originX: 'start',
              originY: 'center'
            }];
            offsetX = -20;
            offsetY = 0;
          }

          return this.overlay.position().flexibleConnectedTo(this.elementRef).withPositions([].concat(_toConsumableArray(positions), fallbacks)).withDefaultOffsetX(offsetX).withDefaultOffsetY(offsetY);
        }
      }, {
        key: "show",
        set: function set(value) {
          value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);

          if (this._show !== value) {
            this._show = value;

            if (this._show) {
              this.openPopover();
            } else {
              this.closePopover();
            }

            this.changeShow.emit(this._show);
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._show;
        }
        /**
         * Whether to show a close button. By default a close icon is only shown for trigger type click.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closeable",
        set: function set(value) {
          this._closeable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);

          if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closeable;
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this.overlayRef && this.createOverlay().hasAttached();
        }
      }]);

      return NxPopoverTriggerDirective;
    }();

    NxPopoverTriggerDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Directive"],
      args: [{
        selector: '[nxPopoverTriggerFor]',
        exportAs: 'nxPopoverTrigger',
        host: {
          '(click)': 'handleClick()',
          'aria-haspopup': 'true',
          '[attr.aria-expanded]': 'isOpen',
          '[attr.aria-describedby]': 'isOpen ? id : null'
        }
      }]
    }];
    /** @nocollapse */

    NxPopoverTriggerDirective.ctorParameters = function () {
      return [{
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["ViewContainerRef"]
      }, {
        type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__["EventManager"]
      }];
    };

    NxPopoverTriggerDirective.propDecorators = {
      changeShow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Output"],
        args: ['nxPopoverShowChange']
      }],
      show: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverShow']
      }],
      closeable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverCloseable']
      }],
      popover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverTriggerFor']
      }],
      direction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverDirection']
      }],
      popoverInitialVisible: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverInitialVisible']
      }],
      visibleChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverVisibleChange']
      }],
      modal: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverModal']
      }],
      trigger: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverTrigger']
      }],
      scrollStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["Input"],
        args: ['nxPopoverScrollStrategy']
      }],
      onMouseEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["HostListener"],
        args: ['mouseenter']
      }],
      onMouseExit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["HostListener"],
        args: ['mouseleave']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["HostListener"],
        args: ['touchstart']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPopoverModule = function NxPopoverModule() {
      _classCallCheck(this, NxPopoverModule);
    };

    NxPopoverModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_8__["NxIconModule"]],
        declarations: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective],
        exports: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js ***!
    \***************************************************************************/

  /*! exports provided: isString, pad, formatDate, formatDateHuman, mapClassNames, getClassNameList, appendClasses, removeClasses, parseDate, getFontShorthand, numberOfDecimals, clamp, ErrorStateMatcher */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxUtilsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isString", function () {
      return isString;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pad", function () {
      return pad;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formatDate", function () {
      return formatDate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formatDateHuman", function () {
      return formatDateHuman;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mapClassNames", function () {
      return mapClassNames;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getClassNameList", function () {
      return getClassNameList;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "appendClasses", function () {
      return appendClasses;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "removeClasses", function () {
      return removeClasses;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseDate", function () {
      return parseDate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getFontShorthand", function () {
      return getFontShorthand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "numberOfDecimals", function () {
      return numberOfDecimals;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "clamp", function () {
      return clamp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ErrorStateMatcher", function () {
      return ErrorStateMatcher;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} value
     * @return {?}
     */


    function isString(value) {
      return typeof value === 'string';
    }
    /**
     * @param {?} str
     * @param {?=} length
     * @param {?=} padCharacter
     * @return {?}
     */


    function pad(str) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var padCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';

      if (!isString(str) || str.length >= length) {
        return str;
      }

      while (str.length < length) {
        str = padCharacter + str;
      }

      return str;
    } // DATE -> YYYY-MM-DD

    /**
     * @param {?} date
     * @return {?}
     */


    function formatDate(date) {
      /** @type {?} */
      var dateOfBirth = [String(date.getFullYear()), pad(String(date.getMonth() + 1)), pad(String(date.getDate()))].join('-');
      return dateOfBirth;
    }
    /**
     * @param {?} date
     * @return {?}
     */


    function formatDateHuman(date) {
      /** @type {?} */
      var dateOfBirth = [pad(String(date.getDate())), pad(String(date.getMonth() + 1)), String(date.getFullYear())].join('-');
      return dateOfBirth;
    }
    /*
      Purpose of this function is to allow a list of short keywords
      expand to longer bem class names with will then be applied to the classname value.
    
      This function will map a list of keys to values in a MAPPING list.
      Whatever value is found will replace the keyword.
      Every keyword not found will just transfered wiithmout modifying.
    */

    /**
     * @param {?} value
     * @param {?=} DEFAULTS
     * @param {?=} MAPPING
     * @return {?}
     */


    function mapClassNames(value) {
      var DEFAULTS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var MAPPING = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      /** @type {?} */
      var sanitizedList = _toConsumableArray(DEFAULTS);

      if (typeof value === 'string') {
        /** @type {?} */
        var mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [].concat(_toConsumableArray(sanitizedList), _toConsumableArray(mappedClasses));
      }

      return sanitizedList.join(' ').trim();
    }
    /**
     * @param {?} value
     * @param {?=} MAPPING
     * @return {?}
     */


    function getClassNameList(value) {
      var MAPPING = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      /** @type {?} */
      var mappedClasses = [];

      if (typeof value === 'string') {
        /** @type {?} */
        var classNames = value.split(' ');
        /** @type {?} */

        var keys = Object.keys(MAPPING);
        mappedClasses = classNames.map(
        /**
        * @param {?} className
        * @return {?}
        */
        function (className) {
          if (keys.indexOf(className) > -1) {
            return MAPPING[className];
          } else {
            return className;
          }
        });
      }

      return mappedClasses;
    }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} classes
     * @return {?}
     */


    function appendClasses(renderer, element, classes) {
      if (renderer && element && classes) {
        classes.split(' ').forEach(
        /**
        * @param {?} item
        * @return {?}
        */
        function (item) {
          renderer.addClass(element.nativeElement, item);
        });
      }
    }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} classes
     * @return {?}
     */


    function removeClasses(renderer, element, classes) {
      if (renderer && element && classes) {
        classes.split(' ').forEach(
        /**
        * @param {?} item
        * @return {?}
        */
        function (item) {
          renderer.removeClass(element.nativeElement, item);
        });
      }
    } // YYYY-MM-DD -> DATE

    /**
     * @param {?} dateString
     * @return {?}
     */


    function parseDate(dateString) {
      return new Date(dateString);
    } // Manually compose a font shorthand defintion as it's not
    // guaranteed to be given by the computed style object.

    /**
     * @param {?} style
     * @return {?}
     */


    function getFontShorthand(style) {
      var font = style.font,
          fontStyle = style.fontStyle,
          fontVariant = style.fontVariant,
          fontWeight = style.fontWeight,
          fontSize = style.fontSize,
          lineHeight = style.lineHeight,
          fontFamily = style.fontFamily;

      if (font.length > 0) {
        return font;
      }

      return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSize, "/").concat(lineHeight, " ").concat(fontFamily);
    }
    /**
     * @param {?} number
     * @return {?}
     */


    function numberOfDecimals(number) {
      /** @type {?} */
      var parsed = Number(number);

      if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
      }
      /** @type {?} */


      var match = parsed.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);

      if (!match[1]) {
        return 0;
      }

      return match[1].length;
    }
    /**
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */


    function clamp(value) {
      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return Math.max(min, Math.min(max, value));
    }
    /**
     * Provider that defines when form controls have an error.
     */


    var ErrorStateMatcher =
    /*#__PURE__*/
    function () {
      function ErrorStateMatcher() {
        _classCallCheck(this, ErrorStateMatcher);
      }

      _createClass(ErrorStateMatcher, [{
        key: "isErrorState",

        /**
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        value: function isErrorState(control, form) {
          return !!(control && control.invalid && (control.touched || form && form.submitted));
        }
      }]);

      return ErrorStateMatcher;
    }();

    ErrorStateMatcher.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    ErrorStateMatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["defineInjectable"])({
      factory: function ErrorStateMatcher_Factory() {
        return new ErrorStateMatcher();
      },
      token: ErrorStateMatcher,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx.js ***!
    \*********************************************************************/

  /*! exports provided: NdbxModule, NxButtonModule, NxButtonComponent, NxIconButtonComponent, NxCheckboxModule, NxCheckboxChangeEvent, NxCheckboxGroupComponent, NxCheckboxComponent, NxRadioModule, NxRadioGroupComponent, NxRadioComponent, NxCopytextModule, NxCopytextComponent, NxHeadlineModule, NxHeadlineComponent, NxLinkModule, NxLinkComponent, NxCircleToggleModule, NxMobileToggleButtonComponent, ToggleChangeEvent, NxCircleToggleComponent, NxIconToggleButtonComponent, NxCircleToggleGroupComponent, NxListModule, NxListComponent, NxRadioToggleModule, NxRadioToggleComponent, NxCheckboxCircleModule, NxCheckboxCircleComponent, NxSpinnerComponent, NxSpinnerModule, NxModalModule, NxModalActionsDirective, NxModalContentDirective, NxModalComponent, NxOpenModalOnClickDirective, NxModalService, NxSwitcherModule, NxSwitcherComponent, NxPopoverModule, NxPopoverComponent, NxPopoverTriggerDirective, NxPopoverContentDirective, NxTaglistModule, NxTaglistComponent, NxImageModule, NxFigureComponent, NxImageDirective, NxRadioCircleModule, NxRadioCircleComponent, NxRadioCircleSvgButtonComponent, NxRadioCircleIconButtonComponent, NxVideoModule, NxVideoComponent, NxDropdownModule, NxDropdownSelectChange, SELECT_PANEL_MAX_HEIGHT, NxDropdownComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownGroupComponent, NxAutocompleteModule, NxAutocompleteOptionSelected, NxAutocompleteOptionComponent, NxAutocompleteSelectedEvent, NxAutocompleteComponent, getNxAutocompleteMissingPanelError, NX_AUTOCOMPLETE_VALUE_ACCESSOR, NxAutocompleteTriggerDirective, NxNaturalLanguageFormModule, NxNaturalLanguageFormComponent, NxWordComponent, NxMessageModule, NxMessageComponent, NxPageSearchModule, NxPageSearchComponent, NxRatingModule, NxRatingComponent, NxNumberStepperModule, NxNumberStepperComponent, NxNumberStepperPrefixDirective, NxNumberStepperSuffixDirective, NxNumberStepperIntl, NxPaginationModule, NxPaginationComponent, DefaultPaginationTexts, NX_PAGINATION_TEXTS, NxPaginationUtils, NxDynamicTableModule, NxDynamicTableComponent, NxExpansionPanelComponent, NxAccordionDirective, NxAccordionModule, NxTabsModule, NxTabComponent, NxTabChangeEvent, NxTabGroupComponent, NxTabHeaderComponent, NxTabBodyComponent, NxTabLabelDirective, NxTabNavBarComponent, NxTabLinkDirective, BREAKPOINT_MOBILE, BREAKPOINT_TABLET, BREAKPOINT_DESKTOP, MappedStyles, NxCardComponent, NxCardModule, ɵp, ɵq, ɵs, ɵr, ɵt, ɵa, ɵb, ɵc, ɵn, ɵm, ɵd, ɵg, ɵh, ɵj, ɵi, ɵo, ɵl, ɵe, ɵf, ɵu, ɵk */

  /***/
  function node_modulesAllianzNgxNdbxFesm2015AllianzNgxNdbxJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NdbxModule", function () {
      return NdbxModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxButtonModule", function () {
      return NxButtonModule$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxButtonComponent", function () {
      return NxButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxIconButtonComponent", function () {
      return NxIconButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxModule", function () {
      return NxCheckboxModule$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxChangeEvent", function () {
      return NxCheckboxChangeEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxGroupComponent", function () {
      return NxCheckboxGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxComponent", function () {
      return NxCheckboxComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioModule", function () {
      return NxRadioModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioGroupComponent", function () {
      return NxRadioGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioComponent", function () {
      return NxRadioComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCopytextModule", function () {
      return NxCopytextModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCopytextComponent", function () {
      return NxCopytextComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxHeadlineModule", function () {
      return NxHeadlineModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxHeadlineComponent", function () {
      return NxHeadlineComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxLinkModule", function () {
      return NxLinkModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxLinkComponent", function () {
      return NxLinkComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCircleToggleModule", function () {
      return NxCircleToggleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxMobileToggleButtonComponent", function () {
      return NxMobileToggleButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ToggleChangeEvent", function () {
      return ToggleChangeEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCircleToggleComponent", function () {
      return NxCircleToggleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxIconToggleButtonComponent", function () {
      return NxIconToggleButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCircleToggleGroupComponent", function () {
      return NxCircleToggleGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxListModule", function () {
      return NxListModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxListComponent", function () {
      return NxListComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioToggleModule", function () {
      return NxRadioToggleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioToggleComponent", function () {
      return NxRadioToggleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxCircleModule", function () {
      return NxCheckboxCircleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCheckboxCircleComponent", function () {
      return NxCheckboxCircleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxSpinnerComponent", function () {
      return NxSpinnerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxSpinnerModule", function () {
      return NxSpinnerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxModalModule", function () {
      return NxModalModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxModalActionsDirective", function () {
      return NxModalActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxModalContentDirective", function () {
      return NxModalContentDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxModalComponent", function () {
      return NxModalComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxOpenModalOnClickDirective", function () {
      return NxOpenModalOnClickDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxModalService", function () {
      return NxModalService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxSwitcherModule", function () {
      return NxSwitcherModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxSwitcherComponent", function () {
      return NxSwitcherComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverModule", function () {
      return NxPopoverModule$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverComponent", function () {
      return NxPopoverComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverTriggerDirective", function () {
      return NxPopoverTriggerDirective$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPopoverContentDirective", function () {
      return NxPopoverContentDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTaglistModule", function () {
      return NxTaglistModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTaglistComponent", function () {
      return NxTaglistComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxImageModule", function () {
      return NxImageModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxFigureComponent", function () {
      return NxFigureComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxImageDirective", function () {
      return NxImageDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioCircleModule", function () {
      return NxRadioCircleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioCircleComponent", function () {
      return NxRadioCircleComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioCircleSvgButtonComponent", function () {
      return NxRadioCircleSvgButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRadioCircleIconButtonComponent", function () {
      return NxRadioCircleIconButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxVideoModule", function () {
      return NxVideoModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxVideoComponent", function () {
      return NxVideoComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownModule", function () {
      return NxDropdownModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownSelectChange", function () {
      return NxDropdownSelectChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_MAX_HEIGHT", function () {
      return SELECT_PANEL_MAX_HEIGHT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownComponent", function () {
      return NxDropdownComponent$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownItemChange", function () {
      return NxDropdownItemChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownItemComponent", function () {
      return NxDropdownItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDropdownGroupComponent", function () {
      return NxDropdownGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteModule", function () {
      return NxAutocompleteModule$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteOptionSelected", function () {
      return NxAutocompleteOptionSelected;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteOptionComponent", function () {
      return NxAutocompleteOptionComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteSelectedEvent", function () {
      return NxAutocompleteSelectedEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteComponent", function () {
      return NxAutocompleteComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getNxAutocompleteMissingPanelError", function () {
      return getNxAutocompleteMissingPanelError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NX_AUTOCOMPLETE_VALUE_ACCESSOR", function () {
      return NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAutocompleteTriggerDirective", function () {
      return NxAutocompleteTriggerDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNaturalLanguageFormModule", function () {
      return NxNaturalLanguageFormModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNaturalLanguageFormComponent", function () {
      return NxNaturalLanguageFormComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxWordComponent", function () {
      return NxWordComponent$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxMessageModule", function () {
      return NxMessageModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxMessageComponent", function () {
      return NxMessageComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPageSearchModule", function () {
      return NxPageSearchModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPageSearchComponent", function () {
      return NxPageSearchComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRatingModule", function () {
      return NxRatingModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxRatingComponent", function () {
      return NxRatingComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNumberStepperModule", function () {
      return NxNumberStepperModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNumberStepperComponent", function () {
      return NxNumberStepperComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNumberStepperPrefixDirective", function () {
      return NxNumberStepperPrefixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNumberStepperSuffixDirective", function () {
      return NxNumberStepperSuffixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxNumberStepperIntl", function () {
      return NxNumberStepperIntl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPaginationModule", function () {
      return NxPaginationModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPaginationComponent", function () {
      return NxPaginationComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultPaginationTexts", function () {
      return DefaultPaginationTexts;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NX_PAGINATION_TEXTS", function () {
      return NX_PAGINATION_TEXTS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxPaginationUtils", function () {
      return NxPaginationUtils;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDynamicTableModule", function () {
      return NxDynamicTableModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxDynamicTableComponent", function () {
      return NxDynamicTableComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxExpansionPanelComponent", function () {
      return NxExpansionPanelComponent$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAccordionDirective", function () {
      return NxAccordionDirective$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxAccordionModule", function () {
      return NxAccordionModule$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabsModule", function () {
      return NxTabsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabComponent", function () {
      return NxTabComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabChangeEvent", function () {
      return NxTabChangeEvent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabGroupComponent", function () {
      return NxTabGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabHeaderComponent", function () {
      return NxTabHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabBodyComponent", function () {
      return NxTabBodyComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabLabelDirective", function () {
      return NxTabLabelDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabNavBarComponent", function () {
      return NxTabNavBarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxTabLinkDirective", function () {
      return NxTabLinkDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_MOBILE", function () {
      return BREAKPOINT_MOBILE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_TABLET", function () {
      return BREAKPOINT_TABLET;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BREAKPOINT_DESKTOP", function () {
      return BREAKPOINT_DESKTOP;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MappedStyles", function () {
      return MappedStyles$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCardComponent", function () {
      return NxCardComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NxCardModule", function () {
      return NxCardModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵp", function () {
      return nxAccordionAnimations;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵq", function () {
      return NxExpansionPanelBodyDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵs", function () {
      return NxExpansionPanelDescriptionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵr", function () {
      return NxExpansionPanelHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵt", function () {
      return NxExpansionPanelTitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return NX_BUTTON_HOST_BINDINGS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return NxButtonBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return ToggleButton;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵn", function () {
      return NxDropdownClosedLabelDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵm", function () {
      return NxDropdownControl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return NxListIconComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵg", function () {
      return fadeIn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵh", function () {
      return fadeOut;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵj", function () {
      return scaleDown;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵi", function () {
      return scaleUp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵo", function () {
      return NxAutoResizeDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵl", function () {
      return NxRadioCircleButton;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵe", function () {
      return NxRadioToggleButtonBaseComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵf", function () {
      return NxRadioToggleButtonComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵu", function () {
      return NxTabGroupBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵk", function () {
      return NxTagComponent;
    });
    /* harmony import */


    var _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/base */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-base.js");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/platform-browser */
    "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
    /* harmony import */


    var _allianz_ngx_ndbx_checkbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/checkbox */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-checkbox.js");
    /* harmony import */


    var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/observers */
    "./node_modules/@angular/cdk/esm2015/observers.js");
    /* harmony import */


    var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/bidi */
    "./node_modules/@angular/cdk/esm2015/bidi.js");
    /* harmony import */


    var _allianz_ngx_ndbx_natural_language_form__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/natural-language-form */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-natural-language-form.js");
    /* harmony import */


    var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/overlay */
    "./node_modules/@angular/cdk/esm2015/overlay.js");
    /* harmony import */


    var _allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/popover */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-popover.js");
    /* harmony import */


    var _allianz_ngx_ndbx_dropdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/dropdown */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-dropdown.js");
    /* harmony import */


    var _allianz_ngx_ndbx_grid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/grid */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-grid.js");
    /* harmony import */


    var _allianz_ngx_ndbx_autocomplete__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/autocomplete */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-autocomplete.js");
    /* harmony import */


    var _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/formfield */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-formfield.js");
    /* harmony import */


    var _allianz_ngx_ndbx_button__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/button */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-button.js");
    /* harmony import */


    var _allianz_ngx_ndbx_input__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/input */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-input.js");
    /* harmony import */


    var _allianz_ngx_ndbx_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/core */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-core.js");
    /* harmony import */


    var decimal_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! decimal.js */
    "./node_modules/decimal.js/decimal.js");
    /* harmony import */


    var decimal_js__WEBPACK_IMPORTED_MODULE_15___default =
    /*#__PURE__*/
    __webpack_require__.n(decimal_js__WEBPACK_IMPORTED_MODULE_15__);
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var _angular_cdk_table__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! @angular/cdk/table */
    "./node_modules/@angular/cdk/esm2015/table.js");
    /* harmony import */


    var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! @angular/cdk/scrolling */
    "./node_modules/@angular/cdk/esm2015/scrolling.js");
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /* harmony import */


    var _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! @angular/cdk/accordion */
    "./node_modules/@angular/cdk/esm2015/accordion.js");
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! @angular/animations */
    "./node_modules/@angular/animations/fesm2015/animations.js");
    /* harmony import */


    var _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/icon */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-icon.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/esm2015/portal.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _allianz_ngx_ndbx_accordion__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/accordion */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-accordion.js");
    /* harmony import */


    var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! @angular/cdk/a11y */
    "./node_modules/@angular/cdk/esm2015/a11y.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /* harmony import */


    var _allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! @allianz/ngx-ndbx/utils */
    "./node_modules/@allianz/ngx-ndbx/fesm2015/allianz-ngx-ndbx-utils.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NdbxModule =
    /*#__PURE__*/
    function () {
      function NdbxModule() {
        _classCallCheck(this, NdbxModule);
      }

      _createClass(NdbxModule, null, [{
        key: "forRoot",

        /**
         * @return {?}
         */
        value: function forRoot() {
          return {
            ngModule: NdbxModule
          };
        }
      }]);

      return NdbxModule;
    }();

    NdbxModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{}]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_SIZE = 'medium';
    /** @type {?} */

    var DEFAULT_TYPE = 'primary';
    /** @type {?} */

    var NX_BUTTON_HOST_BINDINGS = {
      '[class.nx-button--primary]': 'type === "primary"',
      '[class.nx-button--secondary]': 'type === "secondary"',
      '[class.nx-button--tertiary]': 'type === "tertiary"',
      '[class.nx-button--cta]': 'type === "cta"',
      '[class.nx-button--emphasis]': 'type === "emphasis"',
      '[class.nx-button--large]': 'size === "large"',
      '[class.nx-button--medium]': 'size === "medium"',
      '[class.nx-button--small-medium]': 'size === "small-medium"',
      '[class.nx-button--small]': 'size === "small"',
      '[class.nx-button--block]': 'block',
      '[class.nx-button--negative]': 'negative'
    };
    /**
     * \@docs-private
     */

    var NxButtonBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxButtonBase(_changeDetectorRef, _elementRef) {
        _classCallCheck(this, NxButtonBase);

        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * \@docs-private
         */

        this.type = DEFAULT_TYPE;
        /**
         * \@docs-private
         */

        this.size = DEFAULT_SIZE;
        /**
         * \@docs-private
         */

        this.negative = false;
        /**
         * \@docs-private
         */

        this.block = false;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(NxButtonBase, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;

          var _ref9 = this._classNames.match(/primary|secondary|tertiary|cta|emphasis/) || [DEFAULT_TYPE],
              _ref10 = _slicedToArray(_ref9, 1),
              _ref10$ = _ref10[0],
              type = _ref10$ === void 0 ? null : _ref10$;

          this.type =
          /** @type {?} */
          type;

          var _ref11 = this._classNames.match(/small-medium|small|medium|large/) || [DEFAULT_SIZE],
              _ref12 = _slicedToArray(_ref11, 1),
              _ref12$ = _ref12[0],
              size = _ref12$ === void 0 ? null : _ref12$;

          this.size =
          /** @type {?} */
          size;
          this.negative = /negative/.test(this._classNames);
          this.block = /block/.test(this._classNames);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
        /**
         * \@docs-private
         * getter used for the modal component as a quickfix
         * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
         * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
         * way to reach the elementRef of the component until the modal gets refactored.
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }]);

      return NxButtonBase;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxButtonComponent =
    /*#__PURE__*/
    function (_NxButtonBase3) {
      _inherits(NxButtonComponent, _NxButtonBase3);

      /**
       * @param {?} changeDetectorRef
       * @param {?} elementRef
       */
      function NxButtonComponent(changeDetectorRef, elementRef) {
        _classCallCheck(this, NxButtonComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(NxButtonComponent).call(this, changeDetectorRef, elementRef));
      }

      return NxButtonComponent;
    }(NxButtonBase);

    NxButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
        // tslint:disable-next-line:component-selector
        selector: 'button[nxButton]',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: NX_BUTTON_HOST_BINDINGS,
        inputs: ['classNames:nxButton'],
        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
      }]
    }];
    /** @nocollapse */

    NxButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxIconButtonComponent =
    /*#__PURE__*/
    function (_NxButtonBase4) {
      _inherits(NxIconButtonComponent, _NxButtonBase4);

      /**
       * @param {?} changeDetectorRef
       * @param {?} elementRef
       */
      function NxIconButtonComponent(changeDetectorRef, elementRef) {
        _classCallCheck(this, NxIconButtonComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(NxIconButtonComponent).call(this, changeDetectorRef, elementRef));
      }

      return NxIconButtonComponent;
    }(NxButtonBase);

    NxIconButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'button[nxIconButton]',
        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: NX_BUTTON_HOST_BINDINGS,
        inputs: ['classNames:nxIconButton'],
        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
      }]
    }];
    /** @nocollapse */

    NxIconButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxButtonModule$1 = function NxButtonModule$1() {
      _classCallCheck(this, NxButtonModule$1);
    };

    NxButtonModule$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxButtonComponent, NxIconButtonComponent],
        exports: [NxButtonComponent, NxIconButtonComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId = 0;

    var NxCheckboxChangeEvent =
    /**
     * @param {?} checked
     * @param {?} value
     * @param {?} checkbox
     */
    function NxCheckboxChangeEvent(checked, value, checkbox) {
      _classCallCheck(this, NxCheckboxChangeEvent);

      this.checked = checked;
      this.value = value;
      this.checkbox = checkbox;
    };

    var NxCheckboxGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} ngControl
       */
      function NxCheckboxGroupComponent(_changeDetectorRef, ngControl) {
        _classCallCheck(this, NxCheckboxGroupComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._id = "nx-checkbox-group-".concat(nextId++);
        this._disabled = false;
        this._negative = false;

        this._onChange =
        /**
        * @return {?}
        */
        function () {};

        this._onTouched =
        /**
        * @return {?}
        */
        function () {};

        if (this.ngControl) {
          // Note: we provide the value accessor through here, instead of
          // the `providers` to avoid running into a circular import.
          this.ngControl.valueAccessor = this;
        }
      }
      /**
       * Sets the Id of the checkbox group.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCheckboxGroupComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this38 = this;

          if (this.ngControl) {
            this._value = this._checkboxes.filter(
            /**
            * @param {?} checkbox
            * @return {?}
            */
            function (checkbox) {
              return checkbox.checked;
            }).map(
            /**
            * @param {?} cb
            * @return {?}
            */
            function (cb) {
              return cb.value;
            }); // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.

            Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              _this38._onChange(_this38._value);
            });
          }

          this._updateSelectedCheckboxFromValue();

          this._checkboxes.changes.subscribe(
          /**
          * @return {?}
          */
          function () {
            _this38._value = _this38._checkboxes.filter(
            /**
            * @param {?} checkbox
            * @return {?}
            */
            function (checkbox) {
              return checkbox.checked;
            }).map(
            /**
            * @param {?} cb
            * @return {?}
            */
            function (cb) {
              return cb.value;
            });

            if (_this38.ngControl) {
              _this38.ngControl.control.setValue(_this38._value);
            }

            _this38._updateSelectedCheckboxFromValue();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (this._value) {
            this._value = value;
          }

          this._updateSelectedCheckboxFromValue();
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateSelectedCheckboxFromValue",
        value: function _updateSelectedCheckboxFromValue() {
          var _this39 = this;

          if (this._checkboxes !== null) {
            if (this._value) {
              this._checkboxes.map(
              /**
              * @param {?} checkbox
              * @return {?}
              */
              function (checkbox) {
                if (_this39._value.indexOf(checkbox.value) !== -1) {
                  checkbox.checked = true;
                }
              });
            }
          }
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "change",
        value: function change(value) {
          value = this._checkboxes.filter(
          /**
          * @param {?} checkbox
          * @return {?}
          */
          function (checkbox) {
            return checkbox.checked;
          }).map(
          /**
          * @param {?} cb
          * @return {?}
          */
          function (cb) {
            return cb.value;
          });

          this._onChange(value);

          if (this._onTouched) {
            this._onTouched();
          }

          this.selectionChange.emit(new NxCheckboxChangeEvent(value.checked, value.value, value));
        }
      }, {
        key: "id",
        set: function set(value) {
          if (this._id !== value) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Sets the name of the checkboxes inside the nx-checkbox-group.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          this._name = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
        /**
         * Disables all checkboxes inside the nx-checkbox-group.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._label) {
            this._label.disabled = this._disabled;
          }

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Set the negative styles for all the checkboxes inside the nx-checkbox-group
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the label size of the checkboxes inside the group
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          this._labelSize = value;

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelSize;
        }
        /**
         * Whether the nx-checkbox-group are required.
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
      }]);

      return NxCheckboxGroupComponent;
    }();

    NxCheckboxGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-checkbox-group',
        template: "<div>\n  <div class=\"nx-checkbox-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-checkbox-group]': 'true',
          '[class.nx-checkbox-group--negative]': 'negative',
          '[attr.id]': 'id',
          '[attr.required]': 'required',
          '[attr.disabled]': 'disabled || null',
          '[attr.aria-labelledby]': 'this._label?.id  || null',
          '[attr.role]': '"group"'
        },
        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}:host.nx-checkbox-group--negative ::ng-deep nx-error,:host.nx-checkbox-group--negative ::ng-deep nx-icon.nx-error__icon,:host.nx-checkbox-group--negative ::ng-deep nx-label{color:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxCheckboxGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Self"]
        }]
      }];
    };

    NxCheckboxGroupComponent.propDecorators = {
      _checkboxes: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return NxCheckboxComponent;
        }), {
          descendants: true
        }]
      }],
      _label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_0__["NxLabelComponent"];
        }), {}]
      }],
      selectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };

    var NxCheckboxComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} checkboxGroup
       */
      function NxCheckboxComponent(_changeDetectorRef, checkboxGroup) {
        _classCallCheck(this, NxCheckboxComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.checkboxGroup = checkboxGroup;
        this._id = (nextId++).toString();
        this._disabled = false;
        this._negative = false;
        this._labelSize = 'small';
        this._checked = false;
        this._name = null;
        this._indeterminate = false;
        /**
         * An event emitted when the indeterminate value has changed
         */

        this.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"](false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits the boolean checked value of the changed checkbox.
         */

        this.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"](false);
        /**
         * An event emitted when the checked value has changed.
         *
         * Emits a NxCheckboxChangeEvent.
         */

        this.checkboxChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();

        this.onChangeCallback =
        /**
        * @param {?} _
        * @return {?}
        */
        function (_) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Id of the checkbox.
       *
       * If not set, the checkbox gets an incremented value by default.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCheckboxComponent, [{
        key: "_controlInvalid",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _controlInvalid() {
          return !!(this.checkboxGroup && this.checkboxGroup.ngControl && this.checkboxGroup.ngControl.invalid && this.checkboxGroup.ngControl.touched);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this40 = this;

          if (this.checkboxGroup) {
            this.name = this.checkboxGroup.name; // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update

            this._parentChangeSubscription = this.checkboxGroup._stateChanges.subscribe(
            /**
            * @return {?}
            */
            function () {
              _this40._changeDetectorRef.markForCheck();
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setIndeterminate",
        value: function _setIndeterminate(value) {
          this._indeterminate = value;
          this.indeterminateChange.emit(this._indeterminate);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setChecked",
        value: function _setChecked(value) {
          this._checked = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.checked = !this.checked;
          this.onChangeCallback(this.checked);

          if (this.checkboxGroup !== null) {
            this.checkboxGroup.change(this);
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value === null) {
            value = false;
          }

          if (value !== this.checked) {
            this.checked = value;
          }
        }
        /**
         * @param {?} onChange
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChange) {
          this.onChangeCallback = onChange;
        }
        /**
         * @param {?} onTouched
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouched) {
          this.onTouchedCallback = onTouched;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "touch",
        value: function touch() {
          this.onTouchedCallback();
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onInputClick",
        value: function _onInputClick(event) {
          // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
          event.stopPropagation();

          if (!this.disabled) {
            this.toggle();
            this.checkedChange.emit(this._checked);
            this.checkboxChange.emit(this._createChangeEvent(this._checked));
          }
        }
        /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */

      }, {
        key: "_createChangeEvent",
        value: function _createChangeEvent(checkedValue) {
          /** @type {?} */
          var event = new NxCheckboxChangeEvent(checkedValue, this.value, this);
          event.checked = checkedValue;
          event.value = this.value;
          event.checkbox = this;
          return event;
        }
      }, {
        key: "id",
        set: function set(value) {
          if (value !== this._id) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return "nx-checkbox-".concat(this._id);
        }
        /**
         * Name of the checkbox.
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(name) {
          this._name = name;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.name ? this.checkboxGroup.name : this._name;
        }
        /**
         * Whether the checkbox is disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this._disabled) {
            this._disabled = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.disabled ? this.checkboxGroup.disabled : this._disabled;
        }
        /**
         * Sets the label size of the checkbox. Default value: small
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          this._labelSize = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.labelSize ? this.checkboxGroup.labelSize : this._labelSize;
        }
        /**
         * Whether the checkbox has negative styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this._negative) {
            this._negative = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.checkboxGroup && this.checkboxGroup.negative ? this.checkboxGroup.negative : this._negative;
        }
        /**
         * Whether the checkbox is checked.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "checked",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this._checked) {
            if (this._indeterminate) {
              this._setIndeterminate(false);
            }

            this._setChecked(newValue);
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._checked;
        }
        /**
         * Whether the checkbox is indeterminated.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "indeterminate",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._indeterminate !== newValue) {
            if (this._checked) {
              this._setChecked(false);
            }

            this._setIndeterminate(newValue);
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._indeterminate;
        }
        /**
         * Whether the checkbox is required.
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
        /**
         * Sets the value of the checkbox. Default value is the checked status.
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value ? this._value : this.checked.toString();
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._value = value;

          this._changeDetectorRef.markForCheck();
        }
      }]);

      return NxCheckboxComponent;
    }();

    NxCheckboxComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-checkbox',
        template: "<input\n  type=\"checkbox\"\n  [id]=\"id\"\n  [name]=\"name\"\n  [checked]=\"checked\"\n  [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  [attr.aria-labelledby]=\"id + '-label'\"\n  (click)=\"_onInputClick($event)\"\n  class=\"nx-checkbox__input\"\n  [value]=\"value\"\n>\n\n<label [id]=\"id + '-label'\" [attr.for]=\"id\" class=\"nx-checkbox__label\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"checked\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n        <div *ngIf=\"indeterminate\" class=\"nx-checkbox__indeterminate-indicator\"></div>\n    </span>\n    <div class=\"nx-checkbox__label-text\">\n        <ng-content></ng-content>\n    </div>\n</label>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-checkbox]': 'true',
          '[class.disabled]': 'disabled',
          '[class.nx-checkbox--label-large]': 'labelSize === "large"',
          '[class.nx-checkbox--negative]': 'negative',
          '[attr.required]': 'required',
          '[class.has-error]': '_controlInvalid() || null',
          '[attr.aria-invalid]': '_controlInvalid() || null'
        },
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCheckboxComponent;
          }),
          multi: true
        }],
        styles: [":host{display:block;position:relative;margin-bottom:16px}:host.has-error .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control,:host.ng-invalid .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#dc3149;border-color:#dc3149}:host.has-error .nx-checkbox__control,:host.ng-invalid .nx-checkbox__control{border-color:#dc3149}:host.has-error .nx-checkbox__indeterminate-indicator,:host.ng-invalid .nx-checkbox__indeterminate-indicator{background-color:#dc3149}.nx-checkbox__input{opacity:0;position:absolute}.nx-checkbox__label{font-size:16px;line-height:24px;cursor:pointer;display:flex}:host(.nx-checkbox--label-large) .nx-checkbox__label{font-size:20px;line-height:28px;letter-spacing:.2px}.nx-checkbox__label-text{padding:0;margin-left:12px}.nx-checkbox__control{background-color:#fff;border:2px solid #767676;border-radius:4px;color:#fff;font-size:20px;height:24px;width:24px;min-width:24px;display:flex;justify-content:center;align-items:center;z-index:0;cursor:pointer}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-radius:4px}.nx-checkbox__indeterminate-indicator{background-color:#007ab3;height:2px;width:10px}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#007ab3;border-color:#007ab3}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#ececec;border-color:#c2c2c2;cursor:not-allowed}.nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label{cursor:not-allowed;color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#c2c2c2}:host(.nx-checkbox--negative) .nx-checkbox__control{border-color:#fff;background-color:transparent}:host(.nx-checkbox--negative) .nx-checkbox__label{color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{color:#000;background-color:#fff;border-color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{color:rgba(255,255,255,.4);border-color:transparent;background-color:rgba(194,194,194,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label{color:rgba(255,255,255,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:rgba(153,153,153,.4);border-color:rgba(217,217,217,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:rgba(217,217,217,.4)}@media screen and (-ms-high-contrast:active){.nx-checkbox__input:focus+.nx-checkbox__label{color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control::after{background-color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-color:#fff}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{border-color:#ff0;color:#ff0}.nx-checkbox__input:focus:checked+.nx-checkbox__label .nx-checkbox__control{background-color:none;border-color:#fff;color:#fff}.nx-checkbox__label{color:#ff0}.nx-checkbox__input:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#ff0}.nx-checkbox__input:indeterminate:focus+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#fff}}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#075994}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#003781}:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxCheckboxComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: NxCheckboxGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }];
    };

    NxCheckboxComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      indeterminate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      indeterminateChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      checkedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      checkboxChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCheckboxModule$1 = function NxCheckboxModule$1() {
      _classCallCheck(this, NxCheckboxModule$1);
    };

    NxCheckboxModule$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxCheckboxComponent, NxCheckboxGroupComponent],
        exports: [NxCheckboxComponent, NxCheckboxGroupComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"], _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_0__["NxLabelModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The change event object emitted by the radio group and radio button.
     */

    var NxRadioChange =
    /**
     * The NxRadioComponent that emits the change event. NxRadioChange object can be instantiated with source radio component and a value.
     * @param {?} source
     * @param {?} value
     */
    function NxRadioChange(source, value) {
      _classCallCheck(this, NxRadioChange);

      this.source = source;
      this.value = value;
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nextId$1 = 0;

    var NxRadioGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} ngControl
       * @param {?} _parentForm
       * @param {?} _parentFormGroup
       */
      function NxRadioGroupComponent(_changeDetectorRef, ngControl, _parentForm, _parentFormGroup) {
        _classCallCheck(this, NxRadioGroupComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup; // emits when the internal state changes on properties which are relevant
        // for the radio buttons so that they can mark themself for check

        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this._id = "nx-radio-group-".concat(nextId$1++);
        this._disabled = false;
        this._negative = false;
        this._required = false;
        /**
         * An event is dispatched on each group value change.
         */

        this.groupValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._name = "nx-radio-group-".concat(nextId$1++);
        this._value = null; // The currently selected radio button; should match _value

        this._selected = null;

        this._onChange =
        /**
        * @return {?}
        */
        function () {};

        this._onTouched =
        /**
        * @return {?}
        */
        function () {};

        if (this.ngControl) {
          // Note: we provide the value accessor through here, instead of
          // the `providers` to avoid running into a circular import.
          this.ngControl.valueAccessor = this;
        }
      }
      /**
       * Sets the Id of the radio group.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRadioGroupComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          this._updateSelectedRadioFromValue();

          this._checkSelectedRadioButton();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.value = value;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "change",
        value: function change(value) {
          this.value = value;

          this._onChange(value);

          this.groupValueChange.emit(new NxRadioChange(this._selected, this._value));
        }
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group.
         * @return {?}
         */

      }, {
        key: "touch",
        value: function touch() {
          if (this._onTouched) {
            this._onTouched();
          }
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateSelectedRadioFromValue",
        value: function _updateSelectedRadioFromValue() {
          var _this41 = this;

          // If the value already matches the selected radio, do nothing.

          /** @type {?} */
          var isAlreadySelected = this._selected != null && this._selected.value === this._value;

          if (this._radios != null && !isAlreadySelected) {
            this._selected = null;

            this._radios.forEach(
            /**
            * @param {?} radio
            * @return {?}
            */
            function (radio) {
              radio.checked = _this41.value === radio.value;

              if (radio.checked) {
                _this41._selected = radio;
              }
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_checkSelectedRadioButton",
        value: function _checkSelectedRadioButton() {
          if (this._selected && !this._selected.checked) {
            this._selected.checked = true;
          }
        }
      }, {
        key: "id",
        set: function set(value) {
          if (this._id !== value) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Whether every radio button in this group should be disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value); // inform childs about the change where CD should be triggered

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Whether the radio group should have negative styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets if at least an option should be selected.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "required",
        set: function set(value) {
          this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._required;
        }
        /**
         * @return {?}
         */

      }, {
        key: "name",
        get: function get() {
          return this._name;
        } // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix

        /**
         * Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null).
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._name = value;

          this._stateChanges.next();
        }
        /**
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * Sets the value of the selected radion button in this group (Default: null).
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._value !== newValue) {
            // Set this before proceeding to ensure no circular loop occurs with selection.
            this._value = newValue;

            this._updateSelectedRadioFromValue();

            this._checkSelectedRadioButton();
          }
        }
      }]);

      return NxRadioGroupComponent;
    }();

    NxRadioGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-group',
        template: "<div>\n  <div class=\"nx-radio-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          'role': 'radiogroup',
          '[attr.id]': 'id',
          '[attr.required]': 'required',
          '[class.nx-radio-group--negative]': 'negative',
          '[attr.aria-labelledby]': 'this._label?.id  || null'
        },
        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}"]
      }]
    }];
    /** @nocollapse */

    NxRadioGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Self"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NgForm"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["FormGroupDirective"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }];
    };

    NxRadioGroupComponent.propDecorators = {
      _label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return _allianz_ngx_ndbx_base__WEBPACK_IMPORTED_MODULE_0__["NxLabelComponent"];
        }), {}]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['id']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      groupValueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxGroupValueChange']
      }],
      _radios: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
        /**
        * @return {?}
        */
        function () {
          return NxRadioComponent;
        }), {
          descendants: true
        }]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }]
    };

    var NxRadioComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} radioGroup
       * @param {?} _changeDetectorRef
       */
      function NxRadioComponent(radioGroup, _changeDetectorRef) {
        _classCallCheck(this, NxRadioComponent);

        this.radioGroup = radioGroup;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = "nx-radio-".concat(nextId$1++);
        this._name = null;
        this._labelSize = 'big';
        this._negative = false;
        /**
         * An event is dispatched on each value change.
         */

        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._value = null;
        this._checked = false;
        this._disabled = false;
        this._required = false;

        this.onChangeCallback =
        /**
        * @param {?} _
        * @return {?}
        */
        function (_) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Sets the id of the radio component.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRadioComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          var _this42 = this;

          if (this.radioGroup) {
            this.name = this.radioGroup.name; // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update

            this._parentChangeSubscription = this.radioGroup._stateChanges.subscribe(
            /**
            * @return {?}
            */
            function () {
              _this42._changeDetectorRef.markForCheck();
            });

            if (this.radioGroup.value === this._value) {
              this._checked = true;
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value === this._value) {
            this._checked = true;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @param {?} onChange
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChange) {
          this.onChangeCallback = onChange;
        }
        /**
         * @param {?} onTouched
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouched) {
          this.onTouchedCallback = onTouched;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "touch",
        value: function touch() {
          this.onTouchedCallback();

          if (this.radioGroup) {
            this.radioGroup.touch();
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onInputChange",
        value: function _onInputChange(event) {
          event.stopPropagation();
          this._checked = true;
          this.valueChange.emit(new NxRadioChange(this, this._value));
          this.onChangeCallback(this.value);

          if (this.radioGroup && this.value !== this.radioGroup.value) {
            this.radioGroup.change(this.value);
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onInputClick",
        value: function _onInputClick(event) {
          // make sure click event propagation on the visually hidden input
          // are stopped to prevent multiple events bubbling up.
          event.stopPropagation();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_controlInvalid",
        value: function _controlInvalid() {
          /** @type {?} */
          var form = this.radioGroup && (this.radioGroup._parentFormGroup || this.radioGroup._parentForm);
          return !!(this.radioGroup && this.radioGroup.ngControl && this.radioGroup.ngControl.invalid && (this.radioGroup.ngControl.touched || form && form.submitted));
        }
      }, {
        key: "id",
        set: function set(value) {
          if (this._id !== value) {
            this._id = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "inputId",
        get: function get() {
          return "".concat(this.id, "-input");
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "labelId",
        get: function get() {
          return "".concat(this.id, "-label");
        } // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix

        /**
         * Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null).
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          if (this._name !== value) {
            this._name = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.radioGroup && this.radioGroup.name ? this.radioGroup.name : this._name;
        }
        /**
         * Sets the label size of the radio button.
         * The default value is `big`.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          if (this._labelSize !== value) {
            this._labelSize = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelSize;
        }
        /**
         * Whether the negative set of styles should be used.
         *
         * If the radio button is placed in a radio group, the negative value
         * is overwritten by the group's negative value.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._negative !== newValue) {
            this._negative = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.radioGroup ? this.radioGroup.negative : this._negative;
        }
        /**
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * Sets the value of the form control element (Default: null).
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== this._value) {
            this._value = value;
            this.onChangeCallback(value);
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "checked",
        get: function get() {
          return this._checked;
        }
        /**
         * Whether the radio component is selected.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._checked !== value) {
            this._checked = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled || this.radioGroup && this.radioGroup.disabled;
        }
        /**
         * Whether the radio button should be disabled or not.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required || this.radioGroup && this.radioGroup.required;
        }
        /**
         * Sets if at least a radio button should be selected.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._required = value; // needed when the outer component is set to onPush because it is a native property
          // on the host element

          this._changeDetectorRef.markForCheck();
        }
      }]);

      return NxRadioComponent;
    }();

    NxRadioComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio',
        template: "<input\n  type=\"radio\"\n  [id]=\"inputId\"\n  [attr.name]=\"name\"\n  [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  (change)=\"_onInputChange($event)\"\n  (click)=\"_onInputClick($event)\"\n  [checked]=\"checked\"\n  [attr.aria-labelledby]=\"labelId\"\n  class=\"nx-radio__input\">\n<label [id]=\"labelId\" [attr.for]=\"inputId\" class=\"nx-radio__label\">\n    <div class=\"nx-radio__circle\">\n      <div class=\"nx-radio__dot\"></div>\n    </div>\n    <span class=\"nx-radio__label--text\"><ng-content></ng-content></span>\n</label>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioComponent;
          }),
          multi: true
        }],
        host: {
          '[attr.required]': 'required',
          '[class.nx-radio-button--small-label]': 'labelSize === "small"',
          '[class.nx-radio-button--big-label]': 'labelSize === "big"',
          '[class.nx-radio--negative]': 'negative',
          '[class.has-error]': '_controlInvalid() || null',
          '[attr.aria-invalid]': '_controlInvalid() || null'
        },
        styles: [":host{display:block;position:relative}:host.has-error .nx-radio__circle,:host.ng-invalid .nx-radio__circle{border-color:#dc3149}:host.has-error .nx-radio__input:checked+.nx-radio__label .nx-radio__dot,:host.ng-invalid .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#dc3149}.nx-radio__input{opacity:0;position:absolute}:host(.nx-radio-button--small-label) .nx-radio__label{font-size:16px;line-height:24px}:host(.nx-radio-button--big-label) .nx-radio__label{font-size:20px;line-height:28px}:host.nx-radio--negative .nx-radio__label--text{color:#fff}:host.nx-radio--negative .nx-radio__circle{border-color:#fff}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background:#fff}:host.nx-radio--negative .nx-radio__input:disabled+.nx-radio__label{opacity:.4}.nx-radio__label{color:#414141;cursor:pointer;display:inline-flex;position:relative;align-items:center}.nx-radio__circle{border:2px solid #007ab3;border-radius:50%;width:24px;min-width:24px;height:24px;margin-right:12px;position:relative;display:flex;justify-content:center;align-items:center}.nx-radio__dot{width:8px;height:8px;background-color:transparent;border-radius:50%;transition:background-color .2s}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#007ab3}.nx-radio__input:disabled+.nx-radio__label{cursor:not-allowed;color:#c2c2c2}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:#c2c2c2}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:#c2c2c2}:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#003781}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#003781}@media screen and (-ms-high-contrast:active){.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:windowText}.nx-radio__input:focus+.nx-radio__label{color:highlightText}.nx-radio__input:focus+.nx-radio__label .nx-radio__dot{background-color:highlightText}}"]
      }]
    }];
    /** @nocollapse */

    NxRadioComponent.ctorParameters = function () {
      return [{
        type: NxRadioGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxRadioComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['id']
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['name']
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxValueChange']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxChecked']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxRadioModule = function NxRadioModule() {
      _classCallCheck(this, NxRadioModule);
    };

    NxRadioModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxRadioComponent, NxRadioGroupComponent],
        exports: [NxRadioComponent, NxRadioGroupComponent],
        imports: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_TYPE$1 = 'normal';

    var NxCopytextComponent =
    /*#__PURE__*/
    function () {
      function NxCopytextComponent() {
        _classCallCheck(this, NxCopytextComponent);

        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE$1;
        /**
         * \@docs-private
         */

        this.negative = false;
      }
      /**
       * Sets the type and whether the negative set of styling should be used.
       *
       * You can combine the values of type NxCopytextType and 'negative'.
       *
       * Default type: 'normal'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCopytextComponent, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;

          var _ref13 = this._classNames.match(/small|medium|normal|large/) || [DEFAULT_TYPE$1],
              _ref14 = _slicedToArray(_ref13, 1),
              _ref14$ = _ref14[0],
              type = _ref14$ === void 0 ? null : _ref14$;

          this.type =
          /** @type {?} */
          type;
          this.negative = !!this._classNames.match(/negative/);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
      }]);

      return NxCopytextComponent;
    }();

    NxCopytextComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'p[nxCopytext]',
        template: "<ng-content></ng-content>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-copy]': 'true',
          '[class.nx-copy--small]': 'type === "small"',
          '[class.nx-copy--medium]': 'type === "medium"',
          '[class.nx-copy--normal]': 'type === "normal"',
          '[class.nx-copy--large]': 'type === "large"',
          '[class.nx-copy--negative]': 'negative'
        },
        styles: [":host{margin:0 0 32px;font-size:16px;font-size:var(--body-03-font-size,16px);line-height:24px;line-height:var(--body-03-line-height,24px);font-weight:400;font-weight:var(--body-03-font-weight,400);letter-spacing:0;letter-spacing:var(--body-03-letter-spacing,0)}:host.nx-copy.nx-copy{font-weight:400}:host(.nx-copy--negative){color:#fff}:host(.nx-copy--small){font-size:12px;font-size:var(--body-05-font-size,12px);line-height:16px;line-height:var(--body-05-line-height,16px);font-weight:600;font-weight:var(--body-05-font-weight,600);letter-spacing:.5px;letter-spacing:var(--body-05-letter-spacing,.5px)}:host(.nx-copy--medium){font-size:14px;font-size:var(--body-04-font-size,14px);line-height:20px;line-height:var(--body-04-line-height,20px);font-weight:600;font-weight:var(--body-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--body-04-letter-spacing,.2px)}:host(.nx-copy--large){font-size:18px;font-size:var(--body-02-font-size,18px);line-height:24px;line-height:var(--body-02-line-height,24px);font-weight:400;font-weight:var(--body-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--body-02-letter-spacing,.2px)}"]
      }]
    }];
    NxCopytextComponent.propDecorators = {
      classNames: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxCopytext']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCopytextModule = function NxCopytextModule() {
      _classCallCheck(this, NxCopytextModule);
    };

    NxCopytextModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxCopytextComponent],
        exports: [NxCopytextComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_TYPE$2 = 'section';

    var NxHeadlineComponent =
    /*#__PURE__*/
    function () {
      function NxHeadlineComponent() {
        _classCallCheck(this, NxHeadlineComponent);

        /**
         * \@docs-private
         */
        this.type = DEFAULT_TYPE$2;
        /**
         * \@docs-private
         */

        this.negative = false;
      }
      /**
       * Changes the type of the headline which affects the visual appearance.
       * You can combine a HeadlineType and 'negative'.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxHeadlineComponent, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;
          /** @type {?} */

          var typeRegex = /page-bold-caps|page|section|subsection-large|subsection-medium|subsection-small|subsection-xsmall/;

          var _ref15 = this._classNames.match(typeRegex) || [DEFAULT_TYPE$2],
              _ref16 = _slicedToArray(_ref15, 1),
              _ref16$ = _ref16[0],
              type = _ref16$ === void 0 ? null : _ref16$;

          this.type =
          /** @type {?} */
          type;
          this.negative = !!this._classNames.match(/negative/);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
      }]);

      return NxHeadlineComponent;
    }();

    NxHeadlineComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: '[nxHeadline]',
        template: "<ng-content></ng-content>",
        host: {
          '[class.nx-heading--page]': 'type === "page"',
          '[class.nx-heading--page-bold-caps]': 'type === "page-bold-caps"',
          '[class.nx-heading--section]': 'type === "section"',
          '[class.nx-heading--subsection-large]': 'type === "subsection-large"',
          '[class.nx-heading--subsection-medium]': 'type === "subsection-medium"',
          '[class.nx-heading--subsection-small]': 'type === "subsection-small"',
          '[class.nx-heading--subsection-xsmall]': 'type === "subsection-xsmall"',
          '[class.nx-heading--negative]': 'negative'
        },
        styles: [":host{margin:0}:host ::ng-deep nx-link,:host ::ng-deep nx-link a,:host a{color:#006192;font-size:inherit;font-weight:600;letter-spacing:inherit;text-decoration:none}:host(.nx-heading--page-bold-caps){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);font-weight:700;text-transform:uppercase;margin-bottom:8px}@media (max-width:703px){:host(.nx-heading--page-bold-caps){font-size:40px;font-size:var(--heading-01-small-font-size,40px);line-height:48px;line-height:var(--heading-01-small-line-height,48px)}}:host(.nx-heading--page){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:300;font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--page){font-size:40px;font-size:var(--heading-01-small-font-size,40px);line-height:48px;line-height:var(--heading-01-small-line-height,48px)}}:host(.nx-heading--section){font-size:40px;font-size:var(--heading-02-font-size,40px);line-height:48px;line-height:var(--heading-02-line-height,48px);font-weight:300;font-weight:var(--heading-02-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-letter-spacing,.3px);margin-bottom:48px}@media (max-width:703px){:host(.nx-heading--section){font-size:35px;font-size:var(--heading-02-small-font-size,35px);line-height:40px;line-height:var(--heading-02-small-line-height,40px)}}:host(.nx-heading--subsection-large){font-size:30px;font-size:var(--heading-03-font-size,30px);line-height:36px;line-height:var(--heading-03-line-height,36px);font-weight:300;font-weight:var(--heading-03-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-letter-spacing,.3px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-large){font-size:26px;font-size:var(--heading-03-small-font-size,26px);line-height:32px;line-height:var(--heading-03-small-line-height,32px)}}:host(.nx-heading--subsection-medium){font-size:26px;font-size:var(--heading-04-font-size,26px);line-height:32px;line-height:var(--heading-04-line-height,32px);font-weight:300;font-weight:var(--heading-04-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-04-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--subsection-medium){font-size:24px;font-size:var(--heading-04-small-font-size,24px);line-height:32px;line-height:var(--heading-04-small-line-height,32px)}}:host(.nx-heading--subsection-small){font-size:24px;font-size:var(--heading-05-font-size,24px);line-height:32px;line-height:var(--heading-05-line-height,32px);font-weight:600;font-weight:var(--heading-05-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-05-letter-spacing,.2px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-small){font-size:20px;font-size:var(--heading-05-small-font-size,20px);line-height:28px;line-height:var(--heading-05-small-line-height,28px)}}:host(.nx-heading--subsection-xsmall){font-size:20px;font-size:var(--heading-06-font-size,20px);line-height:28px;line-height:var(--heading-06-line-height,28px);font-weight:300;font-weight:var(--heading-06-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-letter-spacing,.2px);margin-bottom:24px}@media (max-width:703px){:host(.nx-heading--subsection-xsmall){font-size:18px;font-size:var(--heading-06-small-font-size,18px);line-height:28px;line-height:var(--heading-06-small-line-height,28px)}}:host(.nx-heading--negative){color:#fff}:host(.nx-heading--negative) ::ng-deep a{color:#fff}"]
      }]
    }];
    NxHeadlineComponent.propDecorators = {
      classNames: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxHeadline']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxHeadlineModule = function NxHeadlineModule() {
      _classCallCheck(this, NxHeadlineModule);
    };

    NxHeadlineModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxHeadlineComponent],
        exports: [NxHeadlineComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var MAPPING = {
      'black': 'nx-link--black',
      'negative': 'nx-link--negative',
      'text': 'nx-link--text',
      'block': 'nx-link--block',
      'icon-right': 'nx-link--icon-right'
    };
    /** @type {?} */

    var DEFAULT_CLASSES = ['nx-link'];

    var NxLinkComponent =
    /*#__PURE__*/
    function (_allianz_ngx_ndbx_cor) {
      _inherits(NxLinkComponent, _allianz_ngx_ndbx_cor);

      /**
       * @param {?} _elementRef
       * @param {?} _renderer
       */
      function NxLinkComponent(_elementRef, _renderer) {
        var _this43;

        _classCallCheck(this, NxLinkComponent);

        _this43 = _possibleConstructorReturn(this, _getPrototypeOf(NxLinkComponent).call(this, MAPPING, DEFAULT_CLASSES, _elementRef, _renderer));
        _this43._renderer = _renderer;
        return _this43;
      }
      /**
       * @return {?}
       */


      _createClass(NxLinkComponent, [{
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          // Add a specific link class that the css gets more specific than the nx-icon css

          /** @type {?} */
          var icons = this.elementRef.nativeElement.querySelectorAll('nx-icon');

          for (var i = 0; i < icons.length; i++) {
            this._renderer.addClass(icons[i], 'nx-link__icon');
          }
        }
        /**
         * \@docs-private
         * getter used for the modal component as a quickfix
         * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
         * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
         * way to reach the elementRef of the component until the modal gets refactored.
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }]);

      return NxLinkComponent;
    }(_allianz_ngx_ndbx_core__WEBPACK_IMPORTED_MODULE_14__["MappedStyles"]);

    NxLinkComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-link',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        template: '<ng-content></ng-content>',
        inputs: ['classNames: nxStyle'],
        styles: [":host{display:inline-block;color:#006192;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;position:relative;text-decoration:none;transition:color .2s,box-shadow .2s;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:24px}:host:hover{color:#008ed6}:host::ng-deep a:active{color:#003781}:host::ng-deep a{display:flex}:host-context([data-whatinput=keyboard])::ng-deep a:focus{border-radius:4px;outline:0;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-link--negative){color:#fff}:host(.nx-link--negative):hover{color:#c2c2c2}:host(.nx-link--negative)::ng-deep a:active{color:#999}:host(.nx-link--negative)::ng-deep a[aria-disabled],:host(.nx-link--negative)::ng-deep a[disabled]{color:rgba(255,255,255,.4)}:host(.nx-link--black){color:#414141}:host(.nx-link--black):hover{color:#999}:host(.nx-link--black)::ng-deep a:active{color:#5b5b5b}:host(.nx-link--black)::ng-deep a[aria-disabled],:host(.nx-link--black)::ng-deep a[disabled]{color:#c2c2c2}.nx-link--text{font-weight:700;text-transform:none;letter-spacing:normal;border-radius:4px}:host::ng-deep .c-icon,:host::ng-deep nx-icon.nx-link__icon{line-height:24px;font-size:24px;margin:0 8px 0 0}:host::ng-deep .c-icon::before,:host::ng-deep nx-icon.nx-link__icon::before{line-height:inherit;font-size:inherit;width:24px;height:24px}:host(.nx-link--icon-right)::ng-deep .c-icon,:host(.nx-link--icon-right)::ng-deep nx-icon.nx-link__icon{order:2;margin:0 0 0 8px}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{cursor:not-allowed;color:rgba(0,97,146,.4)}:host::ng-deep a[aria-disabled]:active,:host::ng-deep a[disabled]:active{color:#006192}:host::ng-deep a[aria-disabled]:focus,:host::ng-deep a[disabled]:focus{outline:0;box-shadow:none}"]
      }]
    }];
    /** @nocollapse */

    NxLinkComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }];
    };

    NxLinkComponent.propDecorators = {
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconComponent"]]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxLinkModule = function NxLinkModule() {
      _classCallCheck(this, NxLinkModule);
    };

    NxLinkModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxLinkComponent],
        exports: [NxLinkComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     * @abstract
     */

    var ToggleButton = function ToggleButton() {
      _classCallCheck(this, ToggleButton);
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nextId$2 = 0;

    var NxCircleToggleGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxCircleToggleGroupComponent(_changeDetectorRef) {
        _classCallCheck(this, NxCircleToggleGroupComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._id = "nx-circle-toggle-group-".concat(nextId$2++);
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * An event emitted when the selection changes. Outputs the value of the currently selected button.
         */

        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._name = "toggle-group-".concat(nextId$2++);
        this._negative = false;
        this._responsive = true;

        this.onChangeCallback =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Id of the circle toggle group.
       *
       * If not set, the circle toggle group gets an incremented value by default.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCircleToggleGroupComponent, [{
        key: "writeValue",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function writeValue(value) {
          if (this.value !== value) {
            this._value = value;
            this.notifySelectedChild(value);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroyed.next();

          this._destroyed.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this44 = this;

          this.subscribeToSelectionChanges(); // react if a content child is deleted, added etc.

          this.buttons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["startWith"])(this.buttons), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @param {?} toggles
          * @return {?}
          */
          function (toggles) {
            return toggles.length > 0;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["tap"])(
          /**
          * @param {?} toggles
          * @return {?}
          */
          function (toggles) {
            return Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              toggles.forEach(
              /**
              * @param {?} toggle
              * @return {?}
              */
              function (toggle) {
                return toggle.toggleButton.resetClasses();
              });

              _this44.buttons.first.toggleButton.setFirstButton();

              _this44.buttons.last.toggleButton.setLastButton();
            });
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this44.subscribeToSelectionChanges();
          });
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "subscribeToSelectionChanges",
        value: function subscribeToSelectionChanges() {
          var _this45 = this;

          /** @type {?} */
          var changedOrDestroyed = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(this.buttons.changes, this._destroyed);
          Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(this.buttons.map(
          /**
          * @param {?} button
          * @return {?}
          */
          function (button) {
            return button.selectionChange;
          }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @param {?} change
          * @return {?}
          */
          function (change) {
            _this45.onChangeCallback(change.value);

            _this45.valueChange.emit(change.value);
          });
        }
        /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "notifySelectedChild",
        value: function notifySelectedChild(newValue) {
          if (this.buttons) {
            /** @type {?} */
            var selected = this.buttons.find(
            /**
            * @param {?} button
            * @return {?}
            */
            function (button) {
              return button.value === newValue;
            });

            if (selected) {
              selected.setGroupSelection();
            }
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updateToggleButtonsNames",
        value: function updateToggleButtonsNames() {
          var _this46 = this;

          if (this.buttons) {
            this.buttons.forEach(
            /**
            * @param {?} button
            * @return {?}
            */
            function (button) {
              return button.name = _this46.name;
            });
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this.onChangeCallback = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this.onTouchedCallback = fn;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "id",
        set: function set(value) {
          this._id = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Name that is used for accessibility.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          this._name = value;
          this.updateToggleButtonsNames();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
        /**
         * Whether the circle toggle group is disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._disabled !== newValue) {
            this._disabled = newValue;

            this._changeDetectorRef.markForCheck();
          }

          if (this.buttons) {
            this.buttons.forEach(
            /**
            * @param {?} button
            * @return {?}
            */
            function (button) {
              return button.disabled = value;
            });
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Whether the circle toggle group uses the negative styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.negative !== newValue) {
            this._negative = newValue;
          }

          if (this.buttons) {
            this.buttons.forEach(
            /**
            * @param {?} button
            * @return {?}
            */
            function (button) {
              return button.negative = value;
            });
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * The value of the selected circle toggle in the circle toggle group.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "value",
        set: function set(value) {
          this.writeValue(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._value;
        }
        /**
         * Whether the circle toggle group has a responsive behavior.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "responsive",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this.responsive) {
            this._responsive = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._responsive;
        }
      }, {
        key: "selectedButton",
        get: function get() {
          return this.buttons ? this.buttons.find(
          /**
          * @param {?} button
          * @return {?}
          */
          function (button) {
            return button.checked;
          }) : null;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "buttons",
        get: function get() {
          return this._buttons;
        }
      }]);

      return NxCircleToggleGroupComponent;
    }();

    NxCircleToggleGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-circle-toggle-group',
        template: "<ng-content></ng-content>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCircleToggleGroupComponent;
          }),
          multi: true
        }],
        host: {
          '[class.is-responsive]': 'responsive',
          '[class.is-disabled]': 'disabled',
          '[attr.aria-disabled]': 'disabled',
          '[attr.aria-labelledby]': 'name',
          '[attr.name]': 'name',
          '[attr.id]': 'id',
          '[class.nx-circle-toggle-group]': 'true',
          'role': 'radiogroup'
        },
        styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
      }]
    }];
    /** @nocollapse */

    NxCircleToggleGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxCircleToggleGroupComponent.propDecorators = {
      _buttons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [ToggleButton]
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      responsive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxMobileToggleButtonComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxMobileToggleButtonComponent(_changeDetectorRef) {
        _classCallCheck(this, NxMobileToggleButtonComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this.checked = false;
        this.negative = false;
        this.disabled = false;
      }
      /**
       * \@docs-private
       * @return {?}
       */


      _createClass(NxMobileToggleButtonComponent, [{
        key: "setFirstButton",
        value: function setFirstButton() {
          this.isFirst = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setLastButton",
        value: function setLastButton() {
          this.isLast = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "resetClasses",
        value: function resetClasses() {
          this.isFirst = false;
          this.isLast = false;

          this._changeDetectorRef.markForCheck();
        }
      }]);

      return NxMobileToggleButtonComponent;
    }();

    NxMobileToggleButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-mobile-toggle-button',
        template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<span class=\"nx-toggle-button__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.is-disabled]': 'disabled',
          '[class.is-negative]': 'negative',
          '[class.is-first]': 'isFirst',
          '[class.is-last]': 'isLast',
          '[class.is-flipped]': 'checked'
        },
        styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;font-weight:nx-font-weights(light);line-height:20px;font-size:14px}.nx-toggle-button__label-text{padding-top:0;padding-right:4px;font-weight:600;color:#007ab3}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff}:host(.is-flipped.nx-toggle-button__mobile-check){opacity:1}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background:#007ab3}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}"]
      }]
    }];
    /** @nocollapse */

    NxMobileToggleButtonComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxMobileToggleButtonComponent.propDecorators = {
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      hint: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var ToggleChangeEvent =
    /**
     * @param {?} button
     * @param {?} value
     */
    function ToggleChangeEvent(button, value) {
      _classCallCheck(this, ToggleChangeEvent);

      this.button = button;
      this.value = value;
    };
    /** @type {?} */


    var nextId$3 = 0;

    var NxCircleToggleComponent =
    /*#__PURE__*/
    function (_ToggleButton) {
      _inherits(NxCircleToggleComponent, _ToggleButton);

      /**
       * @param {?} toggleGroup
       * @param {?} _checkedDispatcher
       * @param {?} _changeDetectorRef
       */
      function NxCircleToggleComponent(
      /** @docs-private */
      toggleGroup, _checkedDispatcher, _changeDetectorRef) {
        var _this47;

        _classCallCheck(this, NxCircleToggleComponent);

        _this47 = _possibleConstructorReturn(this, _getPrototypeOf(NxCircleToggleComponent).call(this));
        _this47.toggleGroup = toggleGroup;
        _this47._checkedDispatcher = _checkedDispatcher;
        _this47._changeDetectorRef = _changeDetectorRef;
        _this47._id = "toggle-button-".concat(nextId$3++);
        /**
         * \@docs-private
         */

        _this47.inGroup = false;
        _this47._name = null;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         */

        _this47.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         */

        _this47.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        _this47._checked = false;
        _this47._value = null;
        _this47._iconName = null;
        _this47._svg = null;
        _this47._svgChecked = null;
        _this47._label = null;
        _this47._hint = null;
        _this47._hover = false;
        /**
         * touched is set to true on touch devices.
         */

        _this47._touched = false;

        _this47._removeUniqueSelectionListener =
        /**
        * @return {?}
        */
        function () {};

        _this47.onChangeCallback =
        /**
        * @param {?} checked
        * @return {?}
        */
        function (checked) {};

        _this47.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};

        if (_this47.toggleGroup) {
          _this47.name = _this47.toggleGroup.name;
        }

        return _this47;
      }
      /**
       * Id of the circle toggle.
       *
       * If not set, the circle toggle gets an incremented value by default.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCircleToggleComponent, [{
        key: "onMouseEnter",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function onMouseEnter() {
          if (!this._touched) {
            this._hover = true;
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "onMouseLeave",
        value: function onMouseLeave() {
          if (!this._touched) {
            this._hover = false;
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "onTouchStart",
        value: function onTouchStart() {
          this._touched = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.toggleGroup) {
            this.attachListenerForGroup();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this48 = this;

          if (this.toggleGroup) {
            Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              _this48.inGroup = true;
              _this48.negative = _this48.toggleGroup.negative;
              _this48.disabled = _this48.toggleGroup.disabled;
              _this48.responsive = _this48.toggleGroup.responsive;
              _this48.id = _this48.toggleGroup.id + "-button-".concat(nextId$3++);
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          // function returned by the listener
          this._removeUniqueSelectionListener();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "attachListenerForGroup",
        value: function attachListenerForGroup() {
          var _this49 = this;

          this._removeUniqueSelectionListener = this._checkedDispatcher.listen(
          /**
          * @param {?} groupId
          * @param {?} buttonId
          * @return {?}
          */
          function (groupId, buttonId) {
            if (_this49.id !== buttonId && groupId === _this49.toggleGroup.id) {
              _this49.checked = false;
            }
          });
        }
        /**
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(newValue) {
          this.checked = newValue;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this.onChangeCallback = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this.onTouchedCallback = fn;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(event) {
          event.preventDefault();
          event.stopPropagation();

          if (this.toggleGroup && this.checked || this.disabled) {
            return;
          } else {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            this.selectionChange.emit(new ToggleChangeEvent(this, this.value));

            if (this.toggleGroup) {
              this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
          }
        }
        /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */

      }, {
        key: "setGroupSelection",
        value: function setGroupSelection() {
          // propagate changes only if the value in the group is different than the button checked value
          if (!this.checked) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);

            this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "handleEnterKey",

        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        value: function handleEnterKey(event) {
          if (!this.toggleGroup) {
            this.toggle(event);
          }
        }
      }, {
        key: "id",
        set: function set(value) {
          this._id = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Name that is used for accessibility.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          this._name = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
        /**
         * Whether the circle toggle is checked.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "checked",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.checked !== newValue) {
            this._checked = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._checked;
        }
        /**
         * The value that is used in the model.
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "value",
        set: function set(newValue) {
          this._value = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._value;
        }
        /**
         * Id of the icon that should be displayed.
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "iconName",
        set: function set(name) {
          this._iconName = name;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._iconName;
        }
        /**
         * SVG that is displayed if the circle toggle is unchecked.
         * @param {?} src
         * @return {?}
         */

      }, {
        key: "svg",
        set: function set(src) {
          this._svg = src;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._svg;
        }
        /**
         * SVG that is displayed if the circle toggle is checked.
         * @param {?} src
         * @return {?}
         */

      }, {
        key: "svgChecked",
        set: function set(src) {
          this._svgChecked = src;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._svgChecked;
        }
        /**
         * Label displayed below the circle.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "label",
        set: function set(value) {
          this._label = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._label;
        }
        /**
         * Additional hint displayed below the label.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "hint",
        set: function set(value) {
          this._hint = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._hint;
        }
        /**
         * Whether the circle toggle uses the negative set of styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.negative !== newValue) {
            this._negative = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Whether the circle toggle has a responsive behavior.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "responsive",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.responsive !== newValue) {
            this._responsive = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._responsive;
        }
        /**
         * Whether the circle toggle is disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.disabled !== newValue) {
            this._disabled = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
      }, {
        key: "svgButton",
        get: function get() {
          return !!this.svg && !!this.svgChecked;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "svgUrl",
        get: function get() {
          /** @type {?} */
          var useFilledSvg = this.checked || !this.disabled && this._hover;

          if (this.negative) {
            useFilledSvg = !useFilledSvg;
          }

          return useFilledSvg ? this.svgChecked : this.svg;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          return this.toggleGroup ? 'radio' : 'checkbox';
        }
      }]);

      return NxCircleToggleComponent;
    }(ToggleButton);

    NxCircleToggleComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-circle-toggle',
        template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\">\n    </nx-mobile-toggle-button>\n</label>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: ToggleButton,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCircleToggleComponent;
          })
        }, {
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCircleToggleComponent;
          }),
          multi: true
        }],
        host: {
          '[class.nx-toggle-circle]': 'true',
          '[class.in-group]': 'inGroup',
          '[class.is-disabled]': 'disabled',
          '[class.is-responsive]': 'responsive'
        },
        styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
      }]
    }];
    /** @nocollapse */

    NxCircleToggleComponent.ctorParameters = function () {
      return [{
        type: NxCircleToggleGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__["UniqueSelectionDispatcher"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxCircleToggleComponent.propDecorators = {
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checkedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      selectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      iconName: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['icon']
      }],
      svg: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      svgChecked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      hint: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      responsive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      toggleButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [NxMobileToggleButtonComponent]
      }],
      onMouseEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseenter']
      }],
      onMouseLeave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseleave']
      }],
      onTouchStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['touchstart']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxIconToggleButtonComponent = function NxIconToggleButtonComponent() {
      _classCallCheck(this, NxIconToggleButtonComponent);

      this.inGroup = true;
    };

    NxIconToggleButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-icon-toggle-button',
        template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-circle-button]': 'true',
          '[class.is-flipped]': 'checked',
          '[class.has-checkmark]': '!inGroup',
          '[class.is-disabled]': 'disabled',
          '[class.is-negative]': 'negative',
          '[class.is-touched]': 'touched'
        },
        styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer}:host .nx-toggle-circle__label-text{position:relative;display:inline-block;padding-top:12px;line-height:24px;font-size:16px;max-width:16rem;z-index:1;color:#414141}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-text{color:#fff}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border:2px solid #007ab3;display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s}:host .nx-toggle-circle__check-icon{background-color:#3da556;border-radius:50%;border:2px solid #fff;color:#fff;font-size:24px;width:32px;height:32px;margin-left:12px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__label-hint{color:#414141;display:inline-block;line-height:24px;font-size:16px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-hint{color:#fff}}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__label-hint{font-weight:300}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background:#007ab3}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;background:#006192}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;background:#007ab3}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}"]
      }]
    }];
    NxIconToggleButtonComponent.propDecorators = {
      inGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      hint: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      svgUrl: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['svg']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      touched: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCircleToggleModule = function NxCircleToggleModule() {
      _classCallCheck(this, NxCircleToggleModule);
    };

    NxCircleToggleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxCircleToggleGroupComponent, NxCircleToggleComponent, NxIconToggleButtonComponent, NxMobileToggleButtonComponent],
        exports: [NxCircleToggleGroupComponent, NxIconToggleButtonComponent, NxCircleToggleComponent, NxMobileToggleButtonComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_TYPE$3 = 'normal';

    var NxListComponent =
    /*#__PURE__*/
    function () {
      function NxListComponent() {
        _classCallCheck(this, NxListComponent);

        /**
         * \@docs-private
         */
        this.negative = false;
        /**
         * \@docs-private
         */

        this.orderedCircle = false;
      }
      /**
       * Sets the visual appearance of the list. You can combine different values:
       *
       * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
       * on modifiers. Defaults to normal.
       *
       * negative: Display the list with a negative set of styling.
       *
       * ordered-circle: Display the list item numbers in a color filled circle.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxListComponent, [{
        key: "classNames",
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;

          var _ref17 = this._classNames.match(/xsmall|small|normal/) || [DEFAULT_TYPE$3],
              _ref18 = _slicedToArray(_ref17, 1),
              _ref18$ = _ref18[0],
              type = _ref18$ === void 0 ? null : _ref18$;

          this.type =
          /** @type {?} */
          type;
          this.negative = !!this._classNames.match(/negative/);
          this.orderedCircle = !!this._classNames.match(/ordered-circle/);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
      }]);

      return NxListComponent;
    }();

    NxListComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'ul[nxList], ol[nxList]',
        template: '<ng-content></ng-content>',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-list--xsmall]': 'type === "xsmall"',
          '[class.nx-list--small]': 'type === "small"',
          '[class.nx-list--normal]': 'type === "normal"',
          '[class.nx-list--negative]': 'negative',
          '[class.nx-list--ordered-circle]': 'orderedCircle'
        },
        styles: [":host{color:#414141;list-style:none;margin-bottom:32px;padding:0;counter-reset:list}:host(.nx-list--normal){font-size:18px;line-height:24px;letter-spacing:.2px}:host(.nx-list--small){font-size:16px;line-height:24px}:host(.nx-list--xsmall){font-size:14px;line-height:20px;letter-spacing:.2px}:host(.nx-list--xsmall):not(ol)::ng-deep li:not([nxlisticon])::before{top:6px}:host(.nx-list--xsmall) ::ng-deep .nx-list__icon{top:-2px}:host(ol.nx-list--xsmall.nx-list--ordered-circle) ::ng-deep li:not([nxlisticon])::before{top:-2px}:host(ol.nx-list--xsmall.nx-list--ordered-circle) ::ng-deep li:not([nxlisticon])::after{top:-2px}:host(.nx-list--negative){color:#fff}:host(.nx-list--negative) ::ng-deep .nx-list__icon{color:#fff}:host ::ng-deep .nx-list__icon{position:absolute;left:0;top:0;font-size:24px;color:#5a5360}:host ::ng-deep li{margin-bottom:16px;padding-left:36px;position:relative}:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:#5a5360;border-radius:50%;content:\"\";display:inline-block;height:8px;width:8px;margin-right:16px;position:absolute;left:8px;top:8px}:host(ol) ::ng-deep>li:not([nxlisticon]):before{counter-increment:list;content:counter(list);position:absolute;font-size:inherit;font-weight:700;display:inline-block;width:24px;text-align:center;left:3px}:host ::ng-deep li>::ng-deep ol,:host ::ng-deep li>::ng-deep ul{margin-bottom:16px;margin-top:16px}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{width:24px;font-size:16px;line-height:24px;color:#fff;font-weight:400;left:0;z-index:2}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{border-radius:50%;width:24px;height:24px;background-color:#5a5360;left:0;top:0;content:'';position:absolute}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):after{background-color:#fff}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):before{color:#5a5360}:host(ul.nx-list--negative) ::ng-deep>li:not([nxlisticon]):before{background-color:#fff}"]
      }]
    }];
    NxListComponent.propDecorators = {
      classNames: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxList']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxListIconComponent = function NxListIconComponent() {
      _classCallCheck(this, NxListIconComponent);
    };

    NxListIconComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'li[nxListIcon]',
        template: "\n    <span class=\"nx-list__icon\">\n      <nx-icon [name]='name'></nx-icon>\n    </span>\n    <ng-content></ng-content>"
      }]
    }];
    NxListIconComponent.propDecorators = {
      viewRefPrefix: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['viewRefPrefix', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
        }]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxListIcon']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxListModule = function NxListModule() {
      _classCallCheck(this, NxListModule);
    };

    NxListModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxListComponent, NxListIconComponent],
        imports: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        exports: [NxListComponent, NxListIconComponent],
        bootstrap: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconComponent"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$4 = 0;
    /**
     * \@docs-private
     */

    var NxRadioToggleButtonBaseComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} renderer
       */
      function NxRadioToggleButtonBaseComponent(renderer) {
        _classCallCheck(this, NxRadioToggleButtonBaseComponent);

        this.renderer = renderer;
        /**
         * \@docs-private
         */

        this.toggleButtonId = 'nx-radio-toggle-button-' + nextId$4++;
      }
      /**
       * \@docs-private
       * @param {?} event
       * @return {?}
       */


      _createClass(NxRadioToggleButtonBaseComponent, [{
        key: "triggerInputClick",
        value: function triggerInputClick(event) {
          event.stopPropagation();
          this.toggleInput.nativeElement.click();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setFirstButton",
        value: function setFirstButton() {
          this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setLastButton",
        value: function setLastButton() {
          this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "resetClasses",
        value: function resetClasses() {
          Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["removeClasses"])(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
        }
      }]);

      return NxRadioToggleButtonBaseComponent;
    }();

    NxRadioToggleButtonBaseComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      labelContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['toggleButtonLabelContainer']
      }],
      toggleInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['toggleInput']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$5 = 0;
    /** @type {?} */

    var MAPPING$1 = {
      'negative': 'nx-radio-toggle--negative',
      'small': 'nx-radio-toggle--small'
    };

    var NxRadioToggleComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} renderer
       * @param {?} _changeDetectorRef
       */
      function NxRadioToggleComponent(renderer, _changeDetectorRef) {
        _classCallCheck(this, NxRadioToggleComponent);

        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleId = (nextId$5++).toString();
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this._disabled = false; // emits to signal children to run change detection

        this._disableChange = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * \@docs-private
         */

        this.toggleButtons = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["QueryList"]();

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};

        this.onChangeCallback =
        /**
        * @param {?} option
        * @return {?}
        */
        function (option) {};
      }
      /**
       * Sets the component to the disabled state.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRadioToggleComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this.subscribeToToggleButtonsChange();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this50 = this;

          /** @type {?} */
          var changedOrDestroyed = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(this.toggleButtons.changes, this._destroyed);
          Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(this.toggleButtons.map(
          /**
          * @param {?} button
          * @return {?}
          */
          function (button) {
            return button.onChecked;
          }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @param {?} change
          * @return {?}
          */
          function (change) {
            _this50._selection = change.value;

            _this50.onChangeCallback(_this50._selection);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroyed.next();

          this._destroyed.complete();

          this._disableChange.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "subscribeToToggleButtonsChange",
        value: function subscribeToToggleButtonsChange() {
          var _this51 = this;

          this.toggleButtons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["startWith"])(this.toggleButtons), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @param {?} toggles
          * @return {?}
          */
          function (toggles) {
            return toggles.length > 0;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @param {?} toggles
          * @return {?}
          */
          function (toggles) {
            toggles.forEach(
            /**
            * @param {?} toggle
            * @return {?}
            */
            function (toggle) {
              toggle.resetClasses();

              if (toggle.value === _this51.selection) {
                // We need to defer the selection for the edge case that the button with the value of this.selection
                // didn't exist yet but was added afterwards to prevent changed after checked errors
                setTimeout(
                /**
                * @return {?}
                */
                function () {
                  return toggle.select();
                });
              }
            });
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
          });
        }
        /**
         * @param {?} onChangeCallback
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChangeCallback) {
          this.onChangeCallback = onChangeCallback;
        }
        /**
         * @param {?} onTouchedCallback
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouchedCallback) {
          this.onTouchedCallback = onTouchedCallback;
        }
        /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          var _this52 = this;

          this._selection = value;
          /** @type {?} */

          var correspondingButton = this.toggleButtons.find(
          /**
          * @param {?} button
          * @return {?}
          */
          function (button) {
            return button.value === _this52._selection;
          });

          if (correspondingButton) {
            /** @type {?} */
            correspondingButton.select();
          }
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var coerced = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._disabled !== coerced) {
            this._disabled = coerced;

            this._disableChange.next();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Sets the name used for accessibility.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          if (this._name !== value) {
            this._name = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
      }, {
        key: "id",
        get: function get() {
          return "nx-radio-toggle-".concat(this._toggleId);
        }
        /**
         * Sets the modifiers for the component.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "style",
        set: function set(value) {
          var _this53 = this;

          /** @type {?} */
          var modifierClasses = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])(value, [], MAPPING$1);
          modifierClasses.split(' ').forEach(
          /**
          * @param {?} className
          * @return {?}
          */
          function (className) {
            return _this53.renderer.addClass(_this53.toggleContainer.nativeElement, className);
          });
        }
        /**
         * \@docs-private
         * @param {?} selection
         * @return {?}
         */

      }, {
        key: "selection",
        set: function set(selection) {
          this._selection = selection;
          this.onChangeCallback(selection);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._selection;
        }
      }]);

      return NxRadioToggleComponent;
    }();

    NxRadioToggleComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-toggle',
        template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioToggleComponent;
          }),
          multi: true
        }],
        styles: [".nx-radio-toggle{display:flex;height:100%}.nx-radio-toggle:focus+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}.nx-radio-toggle:hover+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#075994}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
      }]
    }];
    /** @nocollapse */

    NxRadioToggleComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxRadioToggleComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      toggleContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['toggleContainer']
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxName']
      }],
      toggleButtons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxRadioToggleButtonBaseComponent]
      }],
      writeValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSelection']
      }],
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStyle']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxRadioToggleButtonChange =
    /**
     * @param {?} source
     * @param {?} value
     */
    function NxRadioToggleButtonChange(source, value) {
      _classCallCheck(this, NxRadioToggleButtonChange);

      this.source = source;
      this.value = value;
    };

    var NxRadioToggleButtonComponent =
    /*#__PURE__*/
    function (_NxRadioToggleButtonB) {
      _inherits(NxRadioToggleButtonComponent, _NxRadioToggleButtonB);

      /**
       * @param {?} radioToggle
       * @param {?} renderer
       * @param {?} _changeDetectorRef
       * @param {?} _toggleDispatcher
       */
      function NxRadioToggleButtonComponent(radioToggle, renderer, _changeDetectorRef, _toggleDispatcher) {
        var _this54;

        _classCallCheck(this, NxRadioToggleButtonComponent);

        _this54 = _possibleConstructorReturn(this, _getPrototypeOf(NxRadioToggleButtonComponent).call(this, renderer));
        _this54.radioToggle = radioToggle;
        _this54._changeDetectorRef = _changeDetectorRef;
        _this54._toggleDispatcher = _toggleDispatcher;
        /**
         * \@docs-private
         */
        // emits when the button is checked to notify the group

        _this54.onChecked = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        _this54._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        _this54._disabled = false;
        _this54._selected = false;
        /**
         * Unregister function for _expansionDispatcher.
         */

        _this54._removeUniqueSelectionListener =
        /**
        * @return {?}
        */
        function () {};

        _this54._removeUniqueSelectionListener = _this54._toggleDispatcher.listen(
        /**
        * @param {?} id
        * @param {?} radioToggleId
        * @return {?}
        */
        function (id, radioToggleId) {
          if (_this54.radioToggle && _this54.radioToggle.id === radioToggleId && _this54.id !== id) {
            _this54._selected = false; // need to let change detector know in case that the select() function was called on another button

            _this54._changeDetectorRef.markForCheck();
          }
        });

        _this54.radioToggle._disableChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(_this54._destroyed)).subscribe(
        /**
        * @return {?}
        */
        function () {
          _this54._changeDetectorRef.markForCheck();
        });

        return _this54;
      }
      /**
       * \@docs-private
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRadioToggleButtonComponent, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._removeUniqueSelectionListener();

          this._destroyed.next();

          this._destroyed.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_notifySiblings",

        /**
         * @private
         * @return {?}
         */
        value: function _notifySiblings() {
          /** @type {?} */
          var toggleId = this.radioToggle ? this.radioToggle.id : this.id;

          this._toggleDispatcher.notify(this.id, toggleId);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_emitCheckedEvent",
        value: function _emitCheckedEvent() {
          this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
        } // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.

        /**
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          if (!this._selected) {
            this._selected = true;

            this._notifySiblings();
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onKeyupSpace",
        value: function onKeyupSpace() {
          this._selected = false;

          this._notifySiblings();
        }
      }, {
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled || this.radioToggle && this.radioToggle.disabled;
        }
        /**
         * Sets the checked state and notify siblings and the parent group about the change
         * @param {?} value
         * @return {?}
         */
        // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
        // To select a button without firing the event use the select() function

      }, {
        key: "selected",
        set: function set(value) {
          if (this._selected !== value) {
            this._selected = value;

            if (this._selected) {
              this._notifySiblings();

              this._emitCheckedEvent();
            }

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._selected;
        }
      }, {
        key: "toggleId",
        get: function get() {
          return this.radioToggle.id;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "id",
        get: function get() {
          return this.toggleButtonId;
        }
      }]);

      return NxRadioToggleButtonComponent;
    }(NxRadioToggleButtonBaseComponent);

    NxRadioToggleButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-toggle-button',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
        providers: [{
          provide: NxRadioToggleButtonBaseComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioToggleButtonComponent;
          })
        }],
        styles: [":host{display:flex;position:relative;flex-direction:row}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;border-color:#003781;color:#fff}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#b2d7e8;border-color:#b2d7e8;color:#fff;cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;border-color:#007ab3;color:#fff;cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#ff0;cursor:default;border-color:inherit}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{background-color:#000}}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;min-height:16px;padding:6px;text-transform:none;line-height:16px}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{line-height:24px;padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-radius:0 4px 4px 0;border-width:2px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}}.nx-radio-toggle__label-container{padding:10px 30px;border:2px solid #007ab3;border-radius:0;border-width:2px 0 2px 2px;color:#007ab3;cursor:pointer;flex-grow:1;font-size:16px;font-weight:600;line-height:24px;text-align:center;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#075994;border-color:#075994;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#d9d9d9}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
      }]
    }];
    /** @nocollapse */

    NxRadioToggleButtonComponent.ctorParameters = function () {
      return [{
        type: NxRadioToggleComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioToggleComponent;
          })]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__["UniqueSelectionDispatcher"]
      }];
    };

    NxRadioToggleButtonComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSelected']
      }],
      onKeyupSpace: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['keyup.space']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxRadioToggleModule = function NxRadioToggleModule() {
      _classCallCheck(this, NxRadioToggleModule);
    };

    NxRadioToggleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
        exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_16__["FormsModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$6 = 0;
    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */

    var NxCheckboxCircleComponent =
    /*#__PURE__*/
    function () {
      function NxCheckboxCircleComponent() {
        _classCallCheck(this, NxCheckboxCircleComponent);

        this._id = (nextId$6++).toString();
        /**
         * An event emitted when the checked value has changed.
         */

        this.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"](false);

        this.onChangeCallback =
        /**
        * @param {?} checked
        * @return {?}
        */
        function (checked) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};

        console.warn('`nx-checkbox-circle` is deprecated. Use `nx-circle-toggle` instead.');
      }
      /**
       * Id of the checkbox.
       * If not set, the checkbox gets an incremented value by default.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCheckboxCircleComponent, [{
        key: "writeValue",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function writeValue(value) {
          this.checked = value;
          this.checkedChange.emit(value);
        }
        /**
         * @param {?} onChange
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChange) {
          this.onChangeCallback = onChange;
        }
        /**
         * @param {?} onTouched
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouched) {
          this.onTouchedCallback = onTouched;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {}
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.writeValue(!this.checked);
          this.onChangeCallback(this.checked);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "id",
        set: function set(value) {
          if (value !== this._id) {
            this._id = value;
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return "nx-checkbox-circle-".concat(this._id);
        }
      }, {
        key: "svgButton",
        get: function get() {
          return !!this.svg && !!this.svgChecked;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "svgUrl",
        get: function get() {
          return this.checked ? this.svgChecked : this.svg;
        }
      }]);

      return NxCheckboxCircleComponent;
    }();

    NxCheckboxCircleComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-checkbox-circle',
        template: "<input [id]=\"id\" class=\"nx-checkbox-circle__input\" [name]=\"name\" [attr.aria-labelledby]=\"id + '-label'\"\n    type=\"checkbox\" [checked]=\"checked\" (click)=\"toggle()\">\n<label class=\"nx-checkbox-circle__label\" [for]=\"id\"\n  [id]=\"id + '-label'\">\n  <span class=\"nx-checkbox-circle__check-icon\">\n    <nx-icon name=\"check-circle\"></nx-icon>\n  </span>\n  <span class=\"nx-checkbox-circle__icon\">\n    <nx-icon *ngIf=\"iconName\" [name]=\"iconName\"></nx-icon>\n    <img *ngIf=\"svgButton\" class=\"nx-checkbox-circle__icon-image\" [src]=\"svgUrl\"\n    />\n  </span>\n  <span class=\"nx-checkbox-circle__label-text\">\n    {{label}}\n  </span>\n</label>\n",
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxCheckboxCircleComponent;
          }),
          multi: true
        }],
        host: {
          '[class.is-checked]': 'checked'
        },
        styles: [":host{display:inline-block;margin-right:65px;vertical-align:top;position:relative}.nx-checkbox-circle__icon-image{height:100%}.nx-checkbox-circle__label-text{display:inline-block;max-width:16rem}.nx-checkbox-circle__input{opacity:0;position:absolute}.nx-checkbox-circle__check-icon{background-color:#f5f5f5;border-radius:50%;color:#3da556;display:block;font-size:31px;text-align:center;line-height:1;width:32px;height:32px;margin-left:1.6rem;padding:0;position:absolute;top:0;left:50%;opacity:0;transition:opacity .3s;z-index:1}@media (max-width:703px){:host{margin-right:48px}.nx-checkbox-circle__check-icon{width:28px;height:28px;font-size:27px;left:45%}}:host(.is-checked) .nx-checkbox-circle__check-icon{opacity:1;transition:opacity .3s}.nx-checkbox-circle__icon{border:2px solid #007ab3;border-radius:50%;content:\"\";display:block;height:8rem;width:8rem;left:50%;margin-left:-4rem;position:absolute;top:5px;transition:background-color .2s,border-color .2s,box-shadow .2s}.nx-checkbox-circle__icon nx-icon{border-radius:50%;color:#007ab3;display:block;font-size:4.8rem;position:absolute;text-align:center;margin:1.4rem;z-index:1}.nx-checkbox-circle__icon:hover{border-color:#006192;cursor:pointer}.nx-checkbox-circle__icon:hover nx-icon{color:#006192}:host(.is-checked) .nx-checkbox-circle__icon{background-color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.is-checked) .nx-checkbox-circle__icon{color:#000}}:host(.is-checked) .nx-checkbox-circle__icon:hover{background-color:#006192;border-color:#006192}:host(.is-checked) .nx-checkbox-circle__icon nx-icon{color:#fff}.nx-checkbox-circle__label{display:inline-block;font-size:16px;font-weight:600;line-height:20px;margin-right:8px;padding:9.5rem 0 0;position:relative;text-align:center}@media (max-width:703px){.nx-checkbox-circle__icon{width:6.4rem;height:6.4rem;margin-left:-3.2rem}.nx-checkbox-circle__icon nx-icon{margin:1.1rem;font-size:4rem}.nx-checkbox-circle__label{margin-right:6px;padding:8rem 0 0;font-size:14px;line-height:16px}}.nx-checkbox-circle__text{display:block;position:absolute;text-align:center;left:0;top:5px;font-size:22px;line-height:8rem;width:8rem;height:8rem;color:#007ab3;border-radius:50%;border:2px solid #007ab3;z-index:0;cursor:pointer}.nx-checkbox-circle__text:hover{color:#006192;border-color:#006192}@media (max-width:703px){.nx-checkbox-circle__text{font-size:18px;line-height:6.4rem;width:6.4rem;height:6.4rem}}:host-context([data-whatinput=keyboard]) .nx-checkbox-circle__input:focus+.nx-checkbox-circle__label ::ng-deep .nx-checkbox-circle__icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxCheckboxCircleComponent.ctorParameters = function () {
      return [];
    };

    NxCheckboxCircleComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checkedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      iconName: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxIcon']
      }],
      svg: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSvg']
      }],
      svgChecked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSvgChecked']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabel']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCheckboxCircleModule = function NxCheckboxCircleModule() {
      _classCallCheck(this, NxCheckboxCircleModule);
    };

    NxCheckboxCircleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxCheckboxCircleComponent],
        exports: [NxCheckboxCircleComponent],
        imports: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"], _angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_SIZE$1 = 'small';

    var NxSpinnerComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxSpinnerComponent(_changeDetectorRef) {
        _classCallCheck(this, NxSpinnerComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._size = DEFAULT_SIZE$1;
        this._negative = false;
      }
      /**
       * Sets the size of the spinner. Default is 'small'.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxSpinnerComponent, [{
        key: "size",
        set: function set(value) {
          if (value !== this._size) {
            this._size = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._size;
        }
        /**
         * Whether the spinner should use a negative styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          if (value !== this._negative) {
            this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
      }]);

      return NxSpinnerComponent;
    }();

    NxSpinnerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-spinner',
        template: "<div class=\"nx-spinner__spin-block\">\n  <div class=\"nx-spinner__edge-left\"></div>\n  <div class=\"nx-spinner__edge-right\"></div>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-spinner--small]': 'size === "small"',
          '[class.nx-spinner--medium]': 'size === "medium"',
          '[class.nx-spinner--large]': 'size === "large"',
          '[class.nx-spinner--negative]': 'negative',
          '[attr.role]': '"status"',
          '[attr.aria-busy]': '"true"',
          '[attr.aria-live]': '"assertive"'
        },
        styles: ["@-webkit-keyframes spin{0%{-webkit-transform:rotate(45deg);transform:rotate(45deg)}100%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}}@keyframes spin{0%{-webkit-transform:rotate(45deg);transform:rotate(45deg)}100%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}}:host{position:relative;display:block}:host(.nx-spinner--small){width:16px;height:16px}:host(.nx-spinner--medium){width:24px;height:24px}:host(.nx-spinner--large){width:40px;height:40px}.nx-spinner__spin-block{width:100%;height:100%;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-style:solid;border-radius:50%;border-color:#007ab3 #ececec #ececec;-webkit-animation-name:spin;animation-name:spin;-webkit-animation-duration:.8s;animation-duration:.8s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}:host(.nx-spinner--small) .nx-spinner__spin-block{border-width:calc(1.6px)}:host(.nx-spinner--medium) .nx-spinner__spin-block{border-width:calc(2.4px)}:host(.nx-spinner--large) .nx-spinner__spin-block{border-width:calc(4px)}.nx-spinner__edge-left,.nx-spinner__edge-right{width:12%;height:12%;border-radius:50%;background-color:#007ab3;position:absolute;top:4%}.nx-spinner__edge-left{left:4%}.nx-spinner__edge-right{right:4%}:host(.nx-spinner--negative) .nx-spinner__spin-block{border-color:#fff rgba(250,247,239,.35) rgba(250,247,239,.35)}:host(.nx-spinner--negative) .nx-spinner__edge-left,:host(.nx-spinner--negative) .nx-spinner__edge-right{background-color:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxSpinnerComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxSpinnerComponent.propDecorators = {
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSize']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxSpinnerModule = function NxSpinnerModule() {
      _classCallCheck(this, NxSpinnerModule);
    };

    NxSpinnerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxSpinnerComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"]],
        exports: [NxSpinnerComponent],
        bootstrap: [],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxModalService =
    /*#__PURE__*/
    function () {
      function NxModalService() {
        _classCallCheck(this, NxModalService);

        this.subject = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this.close$ = this.subject.asObservable();
      }
      /**
       * @return {?}
       */


      _createClass(NxModalService, [{
        key: "close",
        value: function close() {
          this.subject.next();
        }
      }]);

      return NxModalService;
    }();

    NxModalService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var fadeIn = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animation"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      opacity: 0
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('300ms', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      opacity: 1
    }))]);
    /** @type {?} */

    var fadeOut = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animation"])(Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('300ms', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      opacity: 0
    })));
    /** @type {?} */

    var scaleUp = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animation"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      transform: 'scale(1)',
      opacity: 1
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('250ms', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      transform: 'scale(1.3)',
      opacity: 0
    }))]);
    /** @type {?} */

    var scaleDown = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animation"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      transform: 'scale(1.3)',
      opacity: 0
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('250ms', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
      transform: 'scale(1)',
      opacity: 1
    }))]);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Container for the action buttons in a modal. Has a fixed position at the bottom of the modal on scroll.
     */

    var NxModalActionsDirective = function NxModalActionsDirective() {
      _classCallCheck(this, NxModalActionsDirective);
    };

    NxModalActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxModalActions]',
        host: {
          '[class.nx-modal__actions]': 'true'
        }
      }]
    }];
    /**
     * Scrollable container for the content of a modal.
     */

    var NxModalContentDirective = function NxModalContentDirective() {
      _classCallCheck(this, NxModalContentDirective);
    };

    NxModalContentDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxModalContent]',
        host: {
          '[class.nx-modal__content]': 'true'
        }
      }]
    }];

    var NxModalComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} modalService
       * @param {?} eventManager
       * @param {?} _changeDetectorRef
       */
      function NxModalComponent(modalService, eventManager, _changeDetectorRef) {
        _classCallCheck(this, NxModalComponent);

        this.modalService = modalService;
        this.eventManager = eventManager;
        this._changeDetectorRef = _changeDetectorRef;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Whether the modal view should close when the user hits the escape key.
         * Default is true.
         */

        this.hideOnEsc = true;
        /**
         * Whether the modal view should close when the user clicks on the backdrop.
         * Default is true.
         */

        this.hideOnClickOutside = true;
        /**
         * Whether the modal view should have a close icon in the upper right corner.
         * Default is true.
         */

        this.showCloseIcon = true;
        /**
         * An event emitted when the user clicks on the backdrop or uses the built-in close button.
         * This event can be applied in conjunction with the custom open state handling
         * of a modal to close it when requested by the user.
         */

        this.closeEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this.closeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
      }
      /**
       * Sets the 'aria-label' of the modal close button needed for accessibility.
       *
       * Default value is 'Close dialog'.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxModalComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          var _this55 = this;

          this.closeSubscription = this.modalService.close$.subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this55.closeEvent.emit();
          });
          this.eventManager.addGlobalEventListener('window', 'keyup.esc',
          /**
          * @return {?}
          */
          function () {
            if (_this55.hideOnEsc) {
              _this55.modalService.close();
            }
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.closeSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "clickOutsideModal",
        value: function clickOutsideModal() {
          if (this.hideOnClickOutside) {
            this.modalService.close();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "closeButtonClick",
        value: function closeButtonClick() {
          this.modalService.close();
        }
        /**
         * \@docs-private
         * @param {?} evt
         * @return {?}
         */

      }, {
        key: "cancelClick",
        value: function cancelClick(evt) {
          evt.stopPropagation();
        }
      }, {
        key: "closeButtonLabel",
        set: function set(value) {
          if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closeButtonLabel;
        }
      }]);

      return NxModalComponent;
    }();

    NxModalComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-modal',
        template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n  <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n    <div class=\"nx-modal__position\">\n      <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n\n        <button\n          (click)=\"closeButtonClick()\"\n          *ngIf=\"showCloseIcon\"\n          [attr.aria-label]=\"closeButtonLabel\"\n          class=\"nx-modal__close\"\n          type=\"button\">\n          <nx-icon name=\"close\"></nx-icon>\n        </button>\n\n        <div class=\"nx-modal__content-wrapper\">\n          <ng-container *ngIf=\"body else projectContent\">\n            <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n          </ng-container>\n\n          <ng-template #projectContent>\n            <ng-content></ng-content>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        animations: [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["trigger"])('fadeInOut', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])(':enter', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["useAnimation"])(fadeIn), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["query"])('@scaleUpDown', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animateChild"])()])]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])(':leave', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["query"])('@scaleUpDown', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animateChild"])()]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["useAnimation"])(fadeOut)])]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["trigger"])('scaleUpDown', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])(':enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["useAnimation"])(scaleDown)), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])(':leave', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["useAnimation"])(scaleUp))])],
        host: {
          '[@fadeInOut]': '',
          '[class.nx-modal--fixed-width]': 'size === "fixed"'
        },
        styles: [".nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:100;align-items:center;justify-content:center;transition:opacity .3s}.nx-modal__backdrop{background-color:rgba(0,0,0,.35);height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;background:#fff;box-shadow:0 8px 24px rgba(65,65,65,.35)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width:703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;color:#414141;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:0;padding:0}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}@media (max-width:703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid #d9d9d9;display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;background:#fff;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 72px - 48px)}@media (max-width:703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 72px - 48px)}}"]
      }]
    }];
    /** @nocollapse */

    NxModalComponent.ctorParameters = function () {
      return [{
        type: NxModalService
      }, {
        type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["EventManager"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxModalComponent.propDecorators = {
      closeButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      body: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxBody']
      }],
      hideOnEsc: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxHideOnEsc']
      }],
      hideOnClickOutside: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxHideOnClickOutside']
      }],
      showCloseIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxShowCloseIcon']
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSize']
      }],
      closeEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxClose']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxOpenModalOnClickDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} templateRef
       * @param {?} viewContainer
       * @param {?} modalService
       */
      function NxOpenModalOnClickDirective(templateRef, viewContainer, modalService) {
        var _this56 = this;

        _classCallCheck(this, NxOpenModalOnClickDirective);

        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.modalService = modalService;
        /**
         * \@docs-private
         */

        this.clickHandler =
        /**
        * @param {?} event
        * @return {?}
        */
        function (event) {
          _this56.viewContainer.clear(); // instantiate the template onto which this directive is applied

          /** @type {?} */


          var viewRef = _this56.viewContainer.createEmbeddedView(_this56.templateRef); // we need to mark the viewRef explicitly if the modal is used inside another
          // component that is using onPush change detection


          viewRef.markForCheck();
          event.preventDefault();
          event.stopPropagation();
        };
      }
      /**
       * @return {?}
       */


      _createClass(NxOpenModalOnClickDirective, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this57 = this;

          this.subscription = this.modalService.close$.subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this57.viewContainer.clear();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this58 = this;

          this.elements.forEach(
          /**
          * @param {?} el
          * @return {?}
          */
          function (el) {
            if (el.removeEventListener) {
              el.removeEventListener('click', _this58.clickHandler);
            }
          });
          this.subscription.unsubscribe();
        }
        /**
         * One or multiple template reference variables pointing to elements
         * which should trigger opening the modal on click.
         *
         * Value: A single template reference variable or an array of template reference variables.
         * @param {?} elements
         * @return {?}
         */

      }, {
        key: "nxOpenModalOnClick",
        set: function set(elements) {
          var _this59 = this;

          // also support the case where only one element is passed, check for the length property to be sure elements is an array
          if (elements.length) {
            this.elements = elements;
          } else {
            this.elements = [elements];
          } // add a click event listener to any element passed as property to this directive


          this.elements.forEach(
          /**
          * @param {?} el
          * @return {?}
          */
          function (el) {
            if (el.addEventListener) {
              el.addEventListener('click', _this59.clickHandler); // workaround until refactoring: if the reference is a component
              // reference the component has to implement a getter to its own elementRef
            } else if (el.elementRef) {
              el.elementRef.nativeElement.addEventListener('click', _this59.clickHandler);
            } else {
              console.warn("nxOpenModalOnClick: Given Element doesn't appear to be an ElementRef.", el);
            }
          });
        }
      }]);

      return NxOpenModalOnClickDirective;
    }();

    NxOpenModalOnClickDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxOpenModalOnClick]'
      }]
    }];
    /** @nocollapse */

    NxOpenModalOnClickDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
      }, {
        type: NxModalService
      }];
    };

    NxOpenModalOnClickDirective.propDecorators = {
      nxOpenModalOnClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxModalModule =
    /*#__PURE__*/
    function () {
      function NxModalModule() {
        _classCallCheck(this, NxModalModule);
      }

      _createClass(NxModalModule, null, [{
        key: "forRoot",
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention

        /**
         * @return {?}
         */
        value: function forRoot() {
          return {
            ngModule: NxModalModule,
            providers: [NxModalService]
          };
        }
      }]);

      return NxModalModule;
    }();

    NxModalModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["A11yModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        declarations: [NxModalComponent, NxOpenModalOnClickDirective, NxModalActionsDirective, NxModalContentDirective],
        exports: [NxModalComponent, NxOpenModalOnClickDirective, NxModalActionsDirective, NxModalContentDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$7 = 0;

    var NxSwitcherComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxSwitcherComponent(_changeDetectorRef) {
        _classCallCheck(this, NxSwitcherComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._id = "nx-switcher-".concat(nextId$7++);
        this._labelPosition = 'right';
        this._name = null;
        this._checked = false;
        this._big = false;
        this._labelSize = 'large';
        this._negative = false;
        this._disabled = false;
        /**
         * An event is dispatched each time the switcher value is changed
         */

        this.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();

        this.onChangeCallback =
        /**
        * @param {?} _
        * @return {?}
        */
        function (_) {};

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Sets the id of the switcher
       * @param {?} value
       * @return {?}
       */


      _createClass(NxSwitcherComponent, [{
        key: "toggle",

        /**
         * Allows to toggle between the states
         * @return {?}
         */
        value: function toggle() {
          if (!this.disabled) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value === null) {
            value = false;
          }

          if (value !== this.checked) {
            this.checked = value;
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this.onChangeCallback = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this.onTouchedCallback = fn;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "touch",
        value: function touch() {
          this.onTouchedCallback();
        }
      }, {
        key: "id",
        set: function set(value) {
          this._id = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._id;
        }
        /**
         * Specifies the placement of the label
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelPosition",
        set: function set(value) {
          this._labelPosition = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelPosition;
        }
        /**
         * Sets the label text of the switcher
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "name",
        set: function set(value) {
          this._name = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._name;
        }
        /**
         * Whether the switcher is checked (on) or unchecked (off)
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "checked",
        set: function set(value) {
          this._checked = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._checked;
        }
        /**
         * Whether the big switcher is used
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "big",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
          this._big = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._big;
        }
        /**
         * Sets the size of the label
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelSize",
        set: function set(value) {
          this._labelSize = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelSize;
        }
        /**
         * Whether the style for a dark background is used
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
          this._negative = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Whether the switcher is in the disabled state
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
          this._disabled = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
      }]);

      return NxSwitcherComponent;
    }();

    NxSwitcherComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-switcher',
        template: "<input type=\"checkbox\" [id]=\"id\" [attr.name]=\"name\" [disabled]=\"disabled\" [checked]=\"checked\" (click)=\"toggle()\" (blur)=\"touch()\"\n  role=\"switch\"\n  [attr.aria-checked]=\"checked\"\n  class=\"nx-switcher__input\">\n<label [attr.for]=\"id\" class=\"nx-switcher__label\">\n    <div class=\"nx-switcher__toggle\">\n      <div class=\"nx-switcher__dot\">\n        <nx-icon *ngIf=\"big\" name=\"check\"></nx-icon>\n      </div>\n    </div>\n  <ng-content></ng-content>\n</label>\n\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxSwitcherComponent;
          }),
          multi: true
        }],
        host: {
          /* the host id should be set to null, otherwise nx-switcher and its <input> get the same id
              and on label click the input click is not triggered (double id problem) */
          '[attr.id]': 'null',
          '[class.is-negative]': 'negative',
          '[class.is-checked]': 'checked',
          '[class.is-big]': 'big',
          '[class.nx-switcher--small-label]': 'labelSize === "small"',
          '[class.is-disabled]': 'disabled',
          '[class.is-swapped]': 'labelPosition === "left"'
        },
        styles: [":host{position:relative;display:flex}:host(.is-swapped) .nx-switcher__label{flex-direction:row-reverse}:host(.is-swapped) .nx-switcher__label .nx-switcher__toggle{margin-left:12px}.nx-switcher__input{opacity:0;position:absolute}.nx-switcher__label{font-size:20px;font-size:var(--body-01-font-size,20px);line-height:28px;line-height:var(--body-01-line-height,28px);font-weight:400;font-weight:var(--body-01-font-weight,400);letter-spacing:.2px;letter-spacing:var(--body-01-letter-spacing,.2px);white-space:nowrap;cursor:pointer;display:flex;position:relative;align-items:center}.nx-switcher__toggle{position:relative;display:inline-block;width:48px;height:24px;background-color:#767676;border-radius:16px;transition:background-color .2s}@media screen and (-ms-high-contrast:active){.nx-switcher__label{color:#ff0}.nx-switcher__toggle{background-color:#c2c2c2;color:#ff0}}:host(:not(.is-swapped)) .nx-switcher__toggle{margin-right:12px}.nx-switcher__dot{position:absolute;height:20px;width:20px;left:2px;bottom:2px;background-color:#fff;border-radius:16px;-webkit-transform:translate(0);transform:translate(0);transition:transform .2s;transition:transform .2s,-webkit-transform .2s}:host(.is-checked) .nx-switcher__dot{-webkit-transform:translate(24px);transform:translate(24px)}:host(.is-checked) .nx-switcher__toggle{background-color:#007ab3;background-color:var(--interaction-primary,#007ab3)}@media screen and (-ms-high-contrast:active){:host(.is-checked) .nx-switcher__toggle{background-color:#ff0;color:#ff0}.nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{color:#fff}}:host(.is-checked.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host(.is-big) .nx-switcher__toggle{width:56px;height:32px}:host(.is-big) .nx-switcher__dot{height:28px;width:28px}:host(.is-big) nx-icon{position:absolute;top:2px;left:2px;font-size:24px;opacity:0;color:#007ab3;color:var(--interaction-primary,#007ab3)}:host(.is-big).is-checked nx-icon{opacity:1;transition:opacity .2s}:host(.nx-switcher--small-label) .nx-switcher__label{font-size:16px;font-size:var(--body-03-font-size,16px);line-height:24px;line-height:var(--body-03-line-height,24px);font-weight:400;font-weight:var(--body-03-font-weight,400);letter-spacing:0;letter-spacing:var(--body-03-letter-spacing,0)}:host(.is-negative) .nx-switcher__label{color:#fff}:host(.is-negative) .nx-switcher__dot{background-color:#fff}:host(.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.is-disabled) .nx-switcher__toggle{background-color:#c2c2c2;background-color:var(--disabled-01,#c2c2c2)}:host(.is-disabled) .nx-switcher__dot{background-color:#fff;opacity:.4}:host(.is-disabled) .nx-switcher__label{cursor:not-allowed;color:#c2c2c2;color:var(--disabled-01,#c2c2c2)}:host(.is-disabled) nx-icon{color:#c2c2c2;color:var(--disabled-01,#c2c2c2)}"]
      }]
    }];
    /** @nocollapse */

    NxSwitcherComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxSwitcherComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      labelPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      big: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxBig']
      }],
      labelSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxNegative']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      checkedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['checkedChange']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxSwitcherModule = function NxSwitcherModule() {
      _classCallCheck(this, NxSwitcherModule);
    };

    NxSwitcherModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxSwitcherComponent],
        exports: [NxSwitcherComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Popover content that will be rendered lazily
     * after the popover is opened for the first time.
     */

    var NxPopoverContentDirective =
    /**
     * @param {?} _template
     */
    function NxPopoverContentDirective(_template) {
      _classCallCheck(this, NxPopoverContentDirective);

      this._template = _template;
    };

    NxPopoverContentDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: 'ng-template[nxPopoverContent]'
      }]
    }];
    /** @nocollapse */

    NxPopoverContentDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxPopoverComponent =
    /*#__PURE__*/
    function () {
      function NxPopoverComponent() {
        _classCallCheck(this, NxPopoverComponent);

        /**
         * Event emitted when the popover is closed.
         */
        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * \@docs-private
         */

        this.closeButtonClick = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * \@docs-private
         */

        this.showCloseButton = false;
        /**
         * \@docs-private
         */

        this.arrowStyle = {};
      }
      /**
       * @return {?}
       */


      _createClass(NxPopoverComponent, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.closed.complete();
        } // emit to notify the popover trigger directive that the close button was clicked

        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "emitButtonClick",
        value: function emitButtonClick() {
          this.closeButtonClick.next();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "emitClosedEvent",
        value: function emitClosedEvent() {
          this.closed.emit();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "classList",
        get: function get() {
          if (this.direction) {
            return ["nx-popover--".concat(this.direction)];
          }
        }
      }]);

      return NxPopoverComponent;
    }();

    NxPopoverComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-popover',
        template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\">\n    <div class=\"nx-popover__content\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span aria-hidden=\"true\" class=\"nx-popover__close-icon\" (click)=\"emitButtonClick()\"\n            *ngIf=\"showCloseButton\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxPopover',
        styles: [".nx-popover__content{background-color:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block;font-size:16px}.nx-popover__close-icon{position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;line-height:16px}[data-whatintent=mouse] .nx-popover__content:focus{outline:0}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-left:1px solid #d9d9d9}.nx-popover--top .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(225deg);transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(-45deg);transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(45deg);transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(135deg);transform:translate(0,-50%) rotate(135deg);right:-5px}"]
      }]
    }];
    /** @nocollapse */

    NxPopoverComponent.ctorParameters = function () {
      return [];
    };

    NxPopoverComponent.propDecorators = {
      templateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]]
      }],
      _lazyContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [NxPopoverContentDirective]
      }],
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxClosed']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$8 = 0;
    /** @type {?} */

    var fallbacks = [{
      originX: 'start',
      originY: 'bottom',
      overlayX: 'start',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'top',
      overlayX: 'end',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }, {
      originX: 'center',
      originY: 'bottom',
      overlayX: 'center',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'bottom',
      overlayX: 'end',
      overlayY: 'top',
      offsetX: 0,
      offsetY: 16
    }, {
      originX: 'end',
      originY: 'center',
      overlayX: 'start',
      overlayY: 'center',
      offsetX: 16,
      offsetY: 0
    }, {
      originX: 'start',
      originY: 'center',
      overlayX: 'end',
      overlayY: 'center',
      offsetX: -16,
      offsetY: 0
    }, {
      originX: 'center',
      originY: 'top',
      overlayX: 'center',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }, {
      originX: 'start',
      originY: 'top',
      overlayX: 'start',
      overlayY: 'bottom',
      offsetX: 0,
      offsetY: -16
    }];

    var NxPopoverTriggerDirective$1 =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} overlay
       * @param {?} elementRef
       * @param {?} viewContainerRef
       * @param {?} eventManager
       */
      function NxPopoverTriggerDirective$1(overlay, elementRef, viewContainerRef, eventManager) {
        _classCallCheck(this, NxPopoverTriggerDirective$1);

        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this._show = false;
        this._closeable = null;
        /**
         * \@docs-private
         */

        this.id = 'nx-popover-' + nextId$8++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */

        this.changeShow = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */

        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */

        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */

        this.visibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Whether the popover opens in modal state.
         */

        this.modal = false; // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.

        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */

        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */

        this.scrollStrategy = 'close';
        this._documentClickObservable = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["fromEvent"])(document, 'click');
      }
      /**
       * Whether to show or hide the popover.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxPopoverTriggerDirective$1, [{
        key: "onMouseEnter",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function onMouseEnter() {
          if (this.trigger === 'hover') {
            this.openPopover();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "onMouseExit",
        value: function onMouseExit() {
          if (this.trigger === 'hover') {
            this.closePopover();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.popover.showCloseButton = this.isCloseable();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this60 = this;

          this.popover.id = this.id;
          this.eventManager.addGlobalEventListener('window', 'keyup.esc',
          /**
          * @return {?}
          */
          function () {
            _this60.closePopover();
          });
          this.popover.closeButtonClick.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this60.closePopover();
          });

          if (this.popoverInitialVisible || this._show) {
            this.openPopover();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.closePopover();

          this._destroyed.next();

          this._destroyed.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isCloseable",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function isCloseable() {
          return this.trigger === 'click' && this._closeable === null || this._closeable;
        }
        /**
         * Update the popover with the given position strategy.
         * @return {?}
         */

      }, {
        key: "updatePosition",
        value: function updatePosition() {
          if (this._positionStrategy) {
            this._positionStrategy.apply();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "handleClick",
        value: function handleClick() {
          if (this.trigger === 'click') {
            if (this.isOpen) {
              this.closePopover();
            } else {
              this.openPopover();
            }
          }
        }
        /**
         * Open the popover instance.
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          this.show = true;
        }
        /**
         * Close the popover instance.
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.show = false;
        }
        /**
         * Toggle the popover instance.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.show = !this.show;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "openPopover",
        value: function openPopover() {
          if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);

            if (!this.modal && this.trigger === 'click') {
              this.waitForClose();
            }
          }
        } // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "closePopover",
        value: function closePopover() {
          if (this.overlayRef) {
            this.overlayRef.detach();
            this._embeddedViewRef = null;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "createOverlay",
        value: function createOverlay() {
          if (!this.overlayRef) {
            this.portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["TemplatePortal"](this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */

            var overlayState = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;

            if (this.scrollStrategy === 'reposition') {
              overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            } else {
              overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }

            overlayState.scrollStrategy.enable();

            if (this.modal && this.trigger === 'click') {
              overlayState.hasBackdrop = true;
            }

            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions(
            /** @type {?} */
            overlayState.positionStrategy);

            this._subscribeToDetach();

            if (this.modal) {
              this._subscribeToBackdropClick();
            }
          }

          return this.overlayRef;
        }
        /**
         * @private
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "subscribeToPositions",
        value: function subscribeToPositions(position) {
          var _this61 = this;

          position.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @param {?} change
          * @return {?}
          */
          function (change) {
            /** @type {?} */
            var pair = change.connectionPair;

            _this61.positionOverlay(pair);

            _this61.positionArrow(pair); // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.


            if (_this61._embeddedViewRef && !_this61._embeddedViewRef.destroyed) {
              _this61._embeddedViewRef.detectChanges();
            }
          });
        } // for modal popovers close the popover on backdrop clicks

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToBackdropClick",
        value: function _subscribeToBackdropClick() {
          var _this62 = this;

          this.overlayRef.backdropClick().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            _this62.closePopover();
          });
        } // Emit the nxClosed event on the popover component when the overlay detaches

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToDetach",
        value: function _subscribeToDetach() {
          var _this63 = this;

          this.overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this63.popover.emitClosedEvent();
          });
        } // subscribe to document clicks when trigger='click' to close the popover on clicks on the background

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "waitForClose",
        value: function waitForClose() {
          var _this64 = this;

          return this._documentClickObservable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["map"])(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            return event.target;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @param {?} target
          * @return {?}
          */
          function (target) {
            return !_this64.elementRef.nativeElement.contains(target);
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this.popover.closed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this64.closePopover();
          });
        }
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */

      }, {
        key: "positionOverlay",
        value: function positionOverlay(pair) {
          if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
          } else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
          } else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
          } else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
          }
        }
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */

      }, {
        key: "positionArrow",
        value: function positionArrow(pair) {
          /** @type {?} */
          var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
          /** @type {?} */

          var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
          /** @type {?} */

          var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
          /** @type {?} */

          var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft; // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.

          /** @type {?} */

          var targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);

          if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */

            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
          }

          if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = {
              left: targetPosition + 'px'
            };
          }

          if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = {
              top: '50%'
            };
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getPosition",
        value: function getPosition() {
          /** @type {?} */
          var positions;
          /** @type {?} */

          var offsetX = 0;
          /** @type {?} */

          var offsetY = 0;

          if (this.direction === 'top') {
            positions = [{
              overlayX: 'center',
              overlayY: 'bottom',
              originX: 'center',
              originY: 'top'
            }];
            offsetX = 0;
            offsetY = -20;
          } else if (this.direction === 'right') {
            positions = [{
              overlayX: 'start',
              overlayY: 'center',
              originX: 'end',
              originY: 'center'
            }];
            offsetX = 20;
            offsetY = 0;
          } else if (this.direction === 'bottom') {
            positions = [{
              overlayX: 'center',
              overlayY: 'top',
              originX: 'center',
              originY: 'bottom'
            }];
            offsetX = 0;
            offsetY = 20;
          } else if (this.direction === 'left') {
            positions = [{
              overlayX: 'end',
              overlayY: 'center',
              originX: 'start',
              originY: 'center'
            }];
            offsetX = -20;
            offsetY = 0;
          }

          return this.overlay.position().flexibleConnectedTo(this.elementRef).withPositions([].concat(_toConsumableArray(positions), fallbacks)).withDefaultOffsetX(offsetX).withDefaultOffsetY(offsetY);
        }
      }, {
        key: "show",
        set: function set(value) {
          value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._show !== value) {
            this._show = value;

            if (this._show) {
              this.openPopover();
            } else {
              this.closePopover();
            }

            this.changeShow.emit(this._show);
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._show;
        }
        /**
         * Whether to show a close button. By default a close icon is only shown for trigger type click.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closeable",
        set: function set(value) {
          this._closeable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closeable;
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this.overlayRef && this.createOverlay().hasAttached();
        }
      }]);

      return NxPopoverTriggerDirective$1;
    }();

    NxPopoverTriggerDirective$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxPopoverTriggerFor]',
        exportAs: 'nxPopoverTrigger',
        host: {
          '(click)': 'handleClick()',
          'aria-haspopup': 'true',
          '[attr.aria-expanded]': 'isOpen',
          '[attr.aria-describedby]': 'isOpen ? id : null'
        }
      }]
    }];
    /** @nocollapse */

    NxPopoverTriggerDirective$1.ctorParameters = function () {
      return [{
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
      }, {
        type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["EventManager"]
      }];
    };

    NxPopoverTriggerDirective$1.propDecorators = {
      changeShow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxPopoverShowChange']
      }],
      show: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverShow']
      }],
      closeable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverCloseable']
      }],
      popover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverTriggerFor']
      }],
      direction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverDirection']
      }],
      popoverInitialVisible: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverInitialVisible']
      }],
      visibleChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverVisibleChange']
      }],
      modal: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverModal']
      }],
      trigger: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverTrigger']
      }],
      scrollStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPopoverScrollStrategy']
      }],
      onMouseEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseenter']
      }],
      onMouseExit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseleave']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['touchstart']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPopoverModule$1 = function NxPopoverModule$1() {
      _classCallCheck(this, NxPopoverModule$1);
    };

    NxPopoverModule$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        declarations: [NxPopoverTriggerDirective$1, NxPopoverComponent, NxPopoverContentDirective],
        exports: [NxPopoverTriggerDirective$1, NxPopoverComponent, NxPopoverContentDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTagComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxTagComponent(_changeDetectorRef) {
        _classCallCheck(this, NxTagComponent);

        this._changeDetectorRef = _changeDetectorRef;
        /**
         * An event is dispatched each time when the tag is clicked.
         */

        this.clicked = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event is dispatched each time when the tag is removed.
         */

        this.removed = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
      }
      /**
       * Whether the tag is removeable.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxTagComponent, [{
        key: "removeClickHandler",

        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        // Emit the removed event that the parent can remove the value
        value: function removeClickHandler(event) {
          event.stopPropagation();
          this.removed.emit(this.value);
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "removeKeyHandler",
        value: function removeKeyHandler(event) {
          if (this.removable && (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["DELETE"] || event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["BACKSPACE"])) {
            event.preventDefault();
            event.stopPropagation();
            this.removed.emit(this.value);
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "tagClickHandler",
        value: function tagClickHandler() {
          this.clicked.emit(this.value);
        }
      }, {
        key: "removable",
        set: function set(value) {
          this._removable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._removable;
        }
        /**
         * Sets the value of the tag.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "value",
        set: function set(value) {
          if (this._value !== value) {
            this._value = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._value;
        }
      }]);

      return NxTagComponent;
    }();

    NxTagComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tag',
        template: "{{ value }}\n<span role=\"link\" aria-label=\"close\" class=\"nx-tag__close\" *ngIf=\"removable\"\n    (click)=\"removeClickHandler($event)\">\n    <nx-icon class=\"nx-tag__close-icon\" name=\"close\"></nx-icon>\n</span>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '(click)': 'tagClickHandler()',
          '(keydown)': 'removeKeyHandler($event)',
          '[attr.tabIndex]': '0'
        },
        styles: [":host{height:auto;max-width:100%;font-size:14px;color:#767676;padding:6px 14px;line-height:16px;letter-spacing:1px;font-weight:600;display:flex;align-items:center;border:2px solid #d9d9d9;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .2s,box-shadow .2s;cursor:pointer}:host:hover{border-color:#c2c2c2;color:#5b5b5b;background-color:#ececec}:host:focus{outline:transparent solid 2px}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}.nx-tag__close-icon{outline:0;width:16px;height:16px;display:block;font-size:16px;line-height:14px}.nx-tag__close{margin-left:8px}:host-context(.nx-taglist--keyword){padding:14px 22px}"]
      }]
    }];
    /** @nocollapse */

    NxTagComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxTagComponent.propDecorators = {
      removable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      clicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      removed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTaglistComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxTaglistComponent(_changeDetectorRef) {
        _classCallCheck(this, NxTaglistComponent);

        this._changeDetectorRef = _changeDetectorRef;
        /**
         * An event is dispatched each time when the list of tags changed.
         */

        this.tagsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event is dispatched each time when a tag is clicked.
         */

        this.tagClickEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._tags = [];
        this._allowTagDeletion = true;
        this._isKeywordList = false;
        this._labelProperty = 'nxTaglistLabel';

        this._valueFormatterFn =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return value;
        };

        this._onChange =
        /**
        * @return {?}
        */
        function () {};

        this._onTouched =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * Sets the list of tags.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxTaglistComponent, [{
        key: "delete",

        /**
         * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        value: function _delete(index, value) {
          if (this.allowTagDeletion) {
            this.tags = [].concat(_toConsumableArray(this.tags.slice(0, index)), _toConsumableArray(this.tags.slice(index + 1)));

            this._onChange(this.tags);

            this.tagsChange.emit(this.tags);
          }
        }
        /**
         * Allows to add a tag. Takes tag object as an input
         * @param {?} tag
         * @return {?}
         */

      }, {
        key: "addTag",
        value: function addTag(tag) {
          var _this65 = this;

          if (!tag) {
            return;
          } // make sure tag is either string or has the configured label prop and is not yet in the list


          if (typeof tag === 'string' && this.tags.indexOf(tag) === -1 || tag[this.labelProp] && this.tags.filter(
          /**
          * @param {?} t
          * @return {?}
          */
          function (t) {
            return t[_this65.labelProp] === tag[_this65.labelProp];
          }).length < 1) {
            this.tags = [].concat(_toConsumableArray(this.tags), [tag]);

            this._onChange(this.tags);

            this.tagsChange.emit(this.tags);
          }
        }
        /**
         * Allows to clear the tag list.
         * @return {?}
         */

      }, {
        key: "clearTags",
        value: function clearTags() {
          this.tags = [];

          this._onChange(this.tags);

          this.tagsChange.emit(this.tags);
        }
        /**
         * \@docs-private
         * @param {?} tags
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(tags) {
          this.tags = tags;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * \@docs-private
         * @param {?} tag
         * @return {?}
         */

      }, {
        key: "renderTag",
        value: function renderTag(tag) {
          /** @type {?} */
          var tagStr = typeof tag === 'string' ? tag : tag[this.labelProp];
          return this.valueFormatter(tagStr);
        }
        /**
         * \@docs-private
         * @param {?} index
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "tagClick",
        value: function tagClick(index, value) {
          this.tagClickEvent.emit(this.tags[index]);
        }
      }, {
        key: "tags",
        set: function set(value) {
          this._tags = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._tags;
        }
        /**
         * Whether the tags can be removed from the list.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "allowTagDeletion",
        set: function set(value) {
          this._allowTagDeletion = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._allowTagDeletion;
        }
        /**
         * Whether the tags can be styled as keywords.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isKeywordList",
        set: function set(value) {
          this._isKeywordList = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._isKeywordList;
        }
        /**
         * Sets the label property, in case tags represent objects.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelProp",
        set: function set(value) {
          if (this._labelProperty !== value) {
            this._labelProperty = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._labelProperty;
        }
        /**
         * Sets the label property to improve accessibility.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "labelledby",
        set: function set(value) {
          if (this._ariaLabelledBy !== value) {
            this._ariaLabelledBy = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._ariaLabelledBy;
        }
        /**
         * Sets the customization function for tag value.
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "valueFormatter",
        set: function set(fn) {
          this._valueFormatterFn = fn;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._valueFormatterFn;
        }
      }]);

      return NxTaglistComponent;
    }();

    NxTaglistComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-taglist',
        template: "  <ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n      <nx-tag [value]=\"renderTag(tag)\" [removable]=\"allowTagDeletion\" (clicked)=\"tagClick(i, $event)\" (removed)=\"delete(i, $event)\"></nx-tag>\n  </li>\n  </ul>\n  <ng-content *ngIf=\"tags.length < 1\"></ng-content>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxTaglistComponent;
          }),
          multi: true
        }],
        host: {
          '[class.nx-taglist--keyword]': 'isKeywordList',
          '[attr.aria-labelledby]': 'labelledby || null'
        },
        styles: [":host{position:relative;min-height:32px;margin-bottom:32px;display:flex;justify-content:space-between}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}@media (max-width:703px){.nx-taglist--keyword{justify-content:center}}"]
      }]
    }];
    /** @nocollapse */

    NxTaglistComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxTaglistComponent.propDecorators = {
      tagsChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxTagsChange']
      }],
      tagClickEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxTagClick']
      }],
      tags: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxTags']
      }],
      allowTagDeletion: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAllowTagDeletion']
      }],
      isKeywordList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxIsKeywordList']
      }],
      labelProp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabelProperty']
      }],
      labelledby: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['aria-labelledby']
      }],
      valueFormatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValueFormatter']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTaglistModule = function NxTaglistModule() {
      _classCallCheck(this, NxTaglistModule);
    };

    NxTaglistModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxTaglistComponent, NxTagComponent],
        exports: [NxTaglistComponent, NxTagComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxImageDirective = function NxImageDirective() {
      _classCallCheck(this, NxImageDirective);

      console.warn('Directive nxImg which was used together with nxFigure ' + 'is now deprecated and not required anymore. Please remove it from your ' + 'tag. Check the documentation for more details.');
    };

    NxImageDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: 'img[nxImg]'
      }]
    }];
    /** @nocollapse */

    NxImageDirective.ctorParameters = function () {
      return [];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var DEFAULT_SIZE$2 = 'auto';

    var NxFigureComponent =
    /*#__PURE__*/
    function () {
      function NxFigureComponent() {
        _classCallCheck(this, NxFigureComponent);
      }

      _createClass(NxFigureComponent, [{
        key: "classNames",

        /**
         * Sets the type of the visual appearance of the image.
         * The default value  is 'auto'.
         * @param {?} value
         * @return {?}
         */
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          this._classNames = value;
          /** @type {?} */

          var sizeRegex = /^(auto|1by1|1dot8by1|1dot2by1|1by1dot1|2dot6by1)$/;

          var _ref19 = this._classNames.match(sizeRegex) || [DEFAULT_SIZE$2],
              _ref20 = _slicedToArray(_ref19, 1),
              _ref20$ = _ref20[0],
              size = _ref20$ === void 0 ? null : _ref20$;

          this.size =
          /** @type {?} */
          size;
          this.rounded = !!this._classNames.match(/rounded/);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._classNames;
        }
      }]);

      return NxFigureComponent;
    }();

    NxFigureComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        // tslint:disable-next-line:component-selector
        selector: 'figure[nxFigure]',
        template: '<ng-content></ng-content>',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.nx-image--auto]': 'size === "auto" && !rounded',
          '[class.nx-image--1by1]': 'size === "1by1"',
          '[class.nx-image--1dot8by1]': 'size === "1dot8by1"',
          '[class.nx-image--1dot2by1]': 'size === "1dot2by1"',
          '[class.nx-image--1by1dot1]': 'size === "1by1dot1"',
          '[class.nx-image--2dot6by1]': 'size === "2dot6by1"',
          '[class.nx-image--rounded]': 'rounded'
        },
        styles: [":host{display:block;position:relative;line-height:0}:host ::ng-deep img{display:block;font-family:\"object-fit: cover;\";-o-object-fit:cover;object-fit:cover;height:100%;width:100%}:host(.nx-image--auto) ::ng-deep img{height:auto}:host(:not(.nx-image--auto)) ::ng-deep img{position:absolute;top:0;left:0}:host(.nx-image--rounded){padding-top:100%}:host(.nx-image--rounded) ::ng-deep img{border-radius:50%;bottom:0;left:0;position:absolute;right:0;top:0}:host(.nx-image--1by1){padding-top:100%}:host(.nx-image--1dot8by1){padding-top:55.55556%}:host(.nx-image--1dot2by1){padding-top:83.33333%}:host(.nx-image--1by1dot1){padding-top:110%}:host(.nx-image--2dot6by1){padding-top:38.46154%}:host(.nx-image--1by1dot4){padding-top:140%}"]
      }]
    }];
    NxFigureComponent.propDecorators = {
      classNames: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxFigure']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxImageModule = function NxImageModule() {
      _classCallCheck(this, NxImageModule);
    };

    NxImageModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxFigureComponent, NxImageDirective],
        exports: [NxFigureComponent, NxImageDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$9 = 0;
    /**
     * @abstract
     */

    var NxRadioCircleButton =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} radioCircle
       */
      function NxRadioCircleButton(radioCircle) {
        _classCallCheck(this, NxRadioCircleButton);

        this.radioCircle = radioCircle;
        /**
         * \@docs-private
         */

        this.id = ++nextId$9;
      }
      /**
       * @return {?}
       */


      _createClass(NxRadioCircleButton, [{
        key: "ngOnChanges",
        value: function ngOnChanges() {
          if (!this.label) {
            console.warn("nx-radio-circle-icon-button/nx-radio-circle-svg-button: required field 'nxLabel' is not set");
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "checked",
        get: function get() {
          return this.radioCircle.selectedButton === this || null;
        }
        /**
         * Whether the item is preselected.
         * @param {?} checked
         * @return {?}
         */
        ,
        set: function set(checked) {
          if (checked) {
            this.radioCircle.selectedButton = this;
          } else {
            if (this.checked) {
              this.radioCircle.selectedButton = null;
            }
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "circleButtonId",
        get: function get() {
          return this.radioCircle.radioCircleId + '-' + this.id;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "radioCircleId",
        get: function get() {
          return this.radioCircle.radioCircleId;
        }
      }]);

      return NxRadioCircleButton;
    }();

    NxRadioCircleButton.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabel']
      }],
      hint: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxHint']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      labelElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['labelElement']
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSelected']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nextId$a = 0;
    /**
     * @deprecated Use `nx-circle-toggle-group` instead
     * \@deletion-target 8.0.0
     */

    var NxRadioCircleComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} renderer
       */
      function NxRadioCircleComponent(renderer) {
        _classCallCheck(this, NxRadioCircleComponent);

        this.renderer = renderer;
        this._id = nextId$a++;
        this._responsive = true;
        /**
         * An event emitted when the selection changes.
         */

        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Whether the radio circle is disabled.
         */

        this.disabled = false;

        this.onTouchedCallback =
        /**
        * @param {?} option
        * @return {?}
        */
        function (option) {};

        this.onChangeCallback =
        /**
        * @param {?} option
        * @return {?}
        */
        function (option) {};

        console.warn('`nx-radio-circle` is deprecated. Use `nx-circle-toggle-group` instead.');
      }
      /**
       * Whether the toggle behavior is disabled.
       *
       * @deprecated Use `nxResponsive` instead
       * \@deletion-target 7.0.0
       * @param {?} value
       * @return {?}
       */


      _createClass(NxRadioCircleComponent, [{
        key: "getResposiveToggle",

        /**
         * \@docs-private
         * @deprecated Use `responsive` getter
         * \@deletion-target 7.0.0
         * @return {?}
         */
        value: function getResposiveToggle() {
          console.warn('The method `getResponsiveToggle is deprecated. Use the `responsive` getter instead');
          return this._responsive;
        }
        /**
         * The id of the radio circle.
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          this.renderer.addClass(this._buttons.first.labelElement.nativeElement, "nx-radio-circle__label--first");
          this.renderer.addClass(this._buttons.last.labelElement.nativeElement, "nx-radio-circle__label--last");
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (this._buttons) {
            this._selectedButton = this._buttons.find(
            /**
            * @param {?} button
            * @return {?}
            */
            function (button) {
              return button.value === value;
            });
          }
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(callback) {
          this.onChangeCallback = callback;
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(callback) {
          this.onTouchedCallback = callback;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * @param {?} button
         * @return {?}
         */

      }, {
        key: "responsiveToggle",
        set: function set(value) {
          console.warn('`nxResponsiveToggle` is deprecated. Use `nxResponsive` instead.');
          this.responsive = value;
        }
        /**
         * Whether the radio circle should have a responsive behavior.
         *
         * On false the circles will stay even on mobile viewports.
         * Default: true.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "responsive",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this.responsive) {
            this._responsive = newValue;
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._responsive;
        }
        /**
         * Sets the value of the radio circle.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "value",
        set: function set(value) {
          this.writeValue(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._selectedButton ? this._selectedButton.value : null;
        }
      }, {
        key: "radioCircleId",
        get: function get() {
          return "radio-circle-".concat(this._id);
        }
      }, {
        key: "selectedButton",
        set: function set(button) {
          if (this.disabled) {
            return;
          }

          this._selectedButton = button;
          this.onChangeCallback(this.value);
          this.valueChange.emit(this.value);
        }
        /**
         * \@docs-private
         * @return {?}
         */
        ,
        get: function get() {
          return this._selectedButton;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "buttons",
        get: function get() {
          return this._buttons;
        }
      }]);

      return NxRadioCircleComponent;
    }();

    NxRadioCircleComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-circle',
        template: "<div [id]=\"radioCircleId\" class=\"nx-radio-circle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n  <ng-content></ng-content>\n</div>\n",
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioCircleComponent;
          }),
          multi: true
        }],
        host: {
          '[class.is-responsive]': 'responsive',
          '[class.is-disabled]': 'disabled',
          '[attr.aria-disabled]': 'disabled'
        },
        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxRadioCircleComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }];
    };

    NxRadioCircleComponent.propDecorators = {
      _buttons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxRadioCircleButton]
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxValueChange']
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxName']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['disabled']
      }],
      responsiveToggle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxResponsiveToggle']
      }],
      responsive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxResponsive']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */

    var NxRadioCircleIconButtonComponent =
    /*#__PURE__*/
    function (_NxRadioCircleButton) {
      _inherits(NxRadioCircleIconButtonComponent, _NxRadioCircleButton);

      /**
       * @param {?} radioCircle
       */
      function NxRadioCircleIconButtonComponent(radioCircle) {
        var _this66;

        _classCallCheck(this, NxRadioCircleIconButtonComponent);

        _this66 = _possibleConstructorReturn(this, _getPrototypeOf(NxRadioCircleIconButtonComponent).call(this, radioCircle));
        _this66.radioCircle = radioCircle;
        console.warn('`nx-radio-circle-icon-button` is deprecated. Use `nx-circle-toggle` instead.');
        return _this66;
      }

      return NxRadioCircleIconButtonComponent;
    }(NxRadioCircleButton);

    NxRadioCircleIconButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-circle-icon-button',
        template: "<input [id]=\"circleButtonId\" class=\"nx-radio-circle__input\" name=\"circle-icon\" type=\"radio\" [checked]=\"checked\"\n       (click)=\"checked = true\">\n<label #labelElement [for]=\"circleButtonId\" class=\"nx-radio-circle__label\" [class.nx-radio-circle--checked]=\"checked\">\n  <div class=\"nx-radio-circle__circle\">\n    <nx-icon class=\"nx-radio-circle__label--icon\" [name]=\"icon\"></nx-icon>    \n  </div>\n  <nx-icon class=\"nx-radio-circle__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n  <span class=\"nx-radio-circle__label-text\">{{label}}</span>\n  <span *ngIf=\"hint\" class=\"nx-radio-circle__label-info\">{{hint}}</span>\n</label>\n",
        providers: [{
          provide: NxRadioCircleButton,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioCircleIconButtonComponent;
          })
        }],
        host: {
          '[class.is-disabled]': 'radioCircle.disabled',
          '[attr.aria-disabled]': 'radioCircle.disabled'
        },
        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxRadioCircleIconButtonComponent.ctorParameters = function () {
      return [{
        type: NxRadioCircleComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioCircleComponent;
          })]
        }]
      }];
    };

    NxRadioCircleIconButtonComponent.propDecorators = {
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxIcon']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */

    var NxRadioCircleSvgButtonComponent =
    /*#__PURE__*/
    function (_NxRadioCircleButton2) {
      _inherits(NxRadioCircleSvgButtonComponent, _NxRadioCircleButton2);

      /**
       * @param {?} radioCircle
       */
      function NxRadioCircleSvgButtonComponent(radioCircle) {
        var _this67;

        _classCallCheck(this, NxRadioCircleSvgButtonComponent);

        _this67 = _possibleConstructorReturn(this, _getPrototypeOf(NxRadioCircleSvgButtonComponent).call(this, radioCircle));
        _this67._hover = false;
        console.warn('`nx-radio-circle-svg-button` is deprecated. Use `nx-circle-toggle` instead.');
        return _this67;
      }
      /**
       * \@docs-private
       * @return {?}
       */


      _createClass(NxRadioCircleSvgButtonComponent, [{
        key: "onMouseEnter",
        value: function onMouseEnter() {
          this._hover = true;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "onMouseLeave",
        value: function onMouseLeave() {
          this._hover = false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          if (!this.svg) {
            console.warn("nx-radio-circle-svg-button: required field 'nxSvg' is not set");
          }

          if (!this.svgChecked) {
            console.warn("nx-radio-circle-svg-button: required field 'nxSvgChecked' is not set");
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "svgUrl",
        get: function get() {
          return this.checked || this._hover ? this.svgChecked : this.svg;
        }
      }]);

      return NxRadioCircleSvgButtonComponent;
    }(NxRadioCircleButton);

    NxRadioCircleSvgButtonComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-radio-circle-svg-button',
        template: "<input [id]=\"circleButtonId\" class=\"nx-radio-circle__input\" type=\"radio\" [checked]=\"checked\"\n       (click)=\"checked = true\">\n<label #labelElement [for]=\"circleButtonId\" class=\"nx-radio-circle__label\" [class.nx-radio-circle--checked]=\"checked\">\n    <div class=\"nx-radio-circle__circle\">\n      <img [src]=\"svgUrl\" class=\"nx-radio-circle__label--icon\"/>\n    </div>\n  <nx-icon class=\"nx-radio-circle__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n  <span class=\"nx-radio-circle__label-text\">{{label}}</span>\n  <span *ngIf=\"hint\" class=\"nx-radio-circle__label-info\">{{hint}}</span>\n</label>\n",
        providers: [{
          provide: NxRadioCircleButton,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioCircleSvgButtonComponent;
          })
        }],
        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxRadioCircleSvgButtonComponent.ctorParameters = function () {
      return [{
        type: NxRadioCircleComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRadioCircleComponent;
          })]
        }]
      }];
    };

    NxRadioCircleSvgButtonComponent.propDecorators = {
      svg: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSvg']
      }],
      svgChecked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSvgChecked']
      }],
      onMouseEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseenter']
      }],
      onMouseLeave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['mouseleave']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxRadioCircleModule = function NxRadioCircleModule() {
      _classCallCheck(this, NxRadioCircleModule);
    };

    NxRadioCircleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxRadioCircleComponent, NxRadioCircleIconButtonComponent, NxRadioCircleSvgButtonComponent],
        exports: [NxRadioCircleComponent, NxRadioCircleIconButtonComponent, NxRadioCircleSvgButtonComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // note that this currently only supports youtube videos

    var NxVideoComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} sanitizer
       * @param {?} _changeDetectorRef
       */
      function NxVideoComponent(sanitizer, _changeDetectorRef) {
        _classCallCheck(this, NxVideoComponent);

        this.sanitizer = sanitizer;
        this._changeDetectorRef = _changeDetectorRef;
        this._videoId = null;
        this._altText = '';
        this._playButtonAriaLabel = '';
        this._previewImageSrc = null;
        this._showPlayerControls = true;
        this._allowFullScreen = true;
        this._interfaceLanguage = null;
        /**
         * \@docs-private
         */

        this.showPlayer = false;
      }
      /**
       * Sets the id of the YouTube video.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxVideoComponent, [{
        key: "select",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function select() {
          this.showPlayer = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Returns the safe resource URL of the YouTube video, given video id.
         * @return {?}
         */

      }, {
        key: "videoId",
        set: function set(value) {
          if (this._videoId !== value) {
            this._videoId = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._videoId;
        }
        /**
         * Sets the value of the alt attribute for the preview image.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "altText",
        set: function set(value) {
          if (this._altText !== value) {
            this._altText = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._altText;
        }
        /**
         * Sets the value of the aria-label attribute on the play button (Default: Play Video).
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "nxPlayButtonAriaLabel",
        set: function set(value) {
          if (this._playButtonAriaLabel !== value) {
            this._playButtonAriaLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._playButtonAriaLabel;
        }
        /**
         * Sets the preview image. If this is not provided, an image from YouTube will be used as default.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "previewImageSrc",
        set: function set(value) {
          if (this._previewImageSrc !== value) {
            this._previewImageSrc = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._previewImageSrc;
        }
        /**
         * Sets player controls. If set to false, player controls are not available.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "showPlayerControls",
        set: function set(value) {
          this._showPlayerControls = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._showPlayerControls;
        }
        /**
         * Sets fullscreen option. If set to false, fullscreen option is not available.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "allowFullScreen",
        set: function set(value) {
          this._allowFullScreen = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._allowFullScreen;
        }
        /**
         * Sets interface language. Can be used to override the interface language determined by YouTube.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "interfaceLanguage",
        set: function set(value) {
          if (this._interfaceLanguage !== value) {
            this._interfaceLanguage = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._interfaceLanguage;
        }
      }, {
        key: "videoSrc",
        get: function get() {
          /** @type {?} */
          var url = "https://www.youtube.com/embed/".concat(this.videoId, "?rel=0&showinfo=0&autoplay=1");

          if (!this.showPlayerControls) {
            url += '&controls=0';
          }

          if (!this.allowFullScreen) {
            url += '&fs=0';
          }

          if (this.interfaceLanguage) {
            url += "&hl=".concat(this.interfaceLanguage);
          }

          return this.sanitizer.bypassSecurityTrustResourceUrl(url);
        }
        /**
         * Returns the preview image source URL, given video id.
         * @return {?}
         */

      }, {
        key: "imgSrc",
        get: function get() {
          return this.previewImageSrc ? this.previewImageSrc : "https://img.youtube.com/vi/".concat(this.videoId, "/sddefault.jpg");
        }
        /**
         * Returns the labels for the control buttons.
         * @return {?}
         */

      }, {
        key: "playButtonAriaLabel",
        get: function get() {
          /** @type {?} */
          var defaultLabel = this.altText ? "".concat(this.altText, " - Play Video") : 'Play Video';
          return this.nxPlayButtonAriaLabel ? this.nxPlayButtonAriaLabel : defaultLabel;
        }
      }]);

      return NxVideoComponent;
    }();

    NxVideoComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-video',
        template: "<div class=\"nx-video\">\n  <div class=\"nx-video__iframe\">\n\n    <div *ngIf=\"!showPlayer\">\n\n      <button class=\"nx-video__play-button\"\n              (click)=\"select()\"\n              [attr.aria-label]=\"playButtonAriaLabel\"\n              (keydown.enter)=\"select()\">\n      </button>\n      <img [src]=\"imgSrc\" class=\"nx-video__thumbnail\"\n           [alt]=\"altText\"\n           (click)=\"select()\"\n           (keydown.enter)=\"select()\">\n\n    </div>\n    <div *ngIf=\"videoId && showPlayer\">\n      <iframe title=\"video\" class=\"nx-video__iframe\" [attr.allowfullscreen]=\"allowFullScreen\" [src]=\"videoSrc\"></iframe>\n    </div>\n\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [".nx-video{position:relative;padding-bottom:56.25%;overflow:hidden;width:100%;height:auto}.nx-video__iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.nx-video__thumbnail{position:absolute;cursor:pointer;width:100%;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);opacity:.7}.nx-video__play-button{border:none;background:url(play-button.svg) center no-repeat;cursor:pointer;position:absolute;width:88px;height:56px;z-index:1}.nx-video__play-button::-moz-focus-inner{border:0}.nx-video__play-button,.nx-video__play-button:before{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}"]
      }]
    }];
    /** @nocollapse */

    NxVideoComponent.ctorParameters = function () {
      return [{
        type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["DomSanitizer"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxVideoComponent.propDecorators = {
      videoId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxVideoId']
      }],
      altText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAltText']
      }],
      nxPlayButtonAriaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPlayButtonAriaLabel']
      }],
      previewImageSrc: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPreviewImageSrc']
      }],
      showPlayerControls: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxShowPlayerControls']
      }],
      allowFullScreen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAllowFullScreen']
      }],
      interfaceLanguage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxInterfaceLanguage']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxVideoModule = function NxVideoModule() {
      _classCallCheck(this, NxVideoModule);
    };

    NxVideoModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxVideoComponent],
        exports: [NxVideoComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * \@docs-private
     * @return {?}
     */

    function getNxDropdownNonArrayValueError() {
      return Error('Value must be an array in multiselect mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     * @return {?}
     */


    function getNxDropdownNonFunctionValueError() {
      return Error('`compareWith` must be a function.');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var NxDropdownControl =
    /*#__PURE__*/
    function (_allianz_ngx_ndbx_for2) {
      _inherits(NxDropdownControl, _allianz_ngx_ndbx_for2);

      function NxDropdownControl() {
        var _this68;

        _classCallCheck(this, NxDropdownControl);

        _this68 = _possibleConstructorReturn(this, _getPrototypeOf(NxDropdownControl).apply(this, arguments));
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */

        _this68.isMultiSelect = false;
        return _this68;
      }

      return NxDropdownControl;
    }(_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldControl"]);

    NxDropdownControl.propDecorators = {
      isMultiSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxIsMultiselect']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownGroupComponent = function NxDropdownGroupComponent() {
      _classCallCheck(this, NxDropdownGroupComponent);
    };

    NxDropdownGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-dropdown-group',
        template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background-color:rgba(236,236,236,.5)}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-style:italic;padding:24px 32px 16px;font-weight:700;font-size:12px;line-height:16px}"]
      }]
    }];
    NxDropdownGroupComponent.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabel']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownItemChange =
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    function NxDropdownItemChange(item) {
      var isUserInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, NxDropdownItemChange);

      this.item = item;
      this.isUserInput = isUserInput;
    };
    /**
     * the unique id counter
     * @type {?}
     */


    var nextId$b = 0;

    var NxDropdownItemComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _dropdown
       * @param {?} group
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
        var _this69 = this;

        _classCallCheck(this, NxDropdownItemComponent);

        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = "nx-dropdown-item-".concat(nextId$b++);
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */

        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix

        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */

        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();

        /** @type {?} */
        this._dropdown.filterChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          _this69._showOrHideByFilter(value);
        }); // reset the hidden state when dropdown closes that on next open the user is seeing the full list again


        /** @type {?} */
        this._dropdown._closedStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
        /**
        * @return {?}
        */
        function () {
          _this69._hidden = false;
        });
      }
      /**
       * The unique ID of the option.
       * @return {?}
       */


      _createClass(NxDropdownItemComponent, [{
        key: "ngAfterViewChecked",

        /**
         * @return {?}
         */
        value: function ngAfterViewChecked() {
          // Since the parent dropdown component could be using the item's label to display the selected values
          // and it doesn't have a way of knowing if the item's label has changed
          // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
          // relatively cheap, however we still limit them only to selected options in order to avoid
          // hitting the DOM too often.
          if (this._selected) {
            /** @type {?} */
            var viewValue = this.viewValue;

            if (viewValue !== this._mostRecentViewValue) {
              this._mostRecentViewValue = viewValue;

              this._stateChanges.next();
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();

          this._destroy.next();

          this._destroy.complete();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onClick",
        value: function _onClick(event) {
          /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
          event.preventDefault();
          event.stopPropagation();

          this._selectViaInteraction();
        }
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */

      }, {
        key: "_selectViaInteraction",
        value: function _selectViaInteraction() {
          this._selected = this.multiselect ? !this._selected : true;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent(true);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "show",
        value: function show() {
          this._hidden = false;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide() {
          this._hidden = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @param {?} search
         * @return {?}
         */

      }, {
        key: "_showOrHideByFilter",
        value: function _showOrHideByFilter(search) {
          /** @type {?} */
          var constraint =
          /** @type {?} */
          this._dropdown.filterFn(search, this.viewValue);

          this._hidden = constraint ? false : true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "select",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function select() {
          if (!this._selected) {
            this._selected = true;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "deselect",
        value: function deselect() {
          if (this._selected) {
            this._selected = false;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          this._elementRef.nativeElement.focus();
        }
        /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */

      }, {
        key: "_emitSelectionChangeEvent",
        value: function _emitSelectionChangeEvent() {
          var isUserInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setActiveStyles",
        value: function setActiveStyles() {
          this._active = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setInactiveStyles",
        value: function setInactiveStyles() {
          this._active = false;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getLabel",
        value: function getLabel() {
          return this.value;
        }
        /**
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "_isContentEmpty",
        value: function _isContentEmpty(element) {
          return element.children.length === 0 && !element.textContent.trim();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_onLabelChange",
        value: function _onLabelChange() {
          // trigger change detection when the label content changes for the case that ng-content was empty before.
          // this is also important when the label comes in deferred, e.g. by a delayed observable,
          // then first the default label derived from the value is shown
          // and after the value from the async observable is ready we need to trigger change detection that the derived label
          // gets hidden again.
          // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
          // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
          this._changeDetectorRef.detectChanges();
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * Whether the item is selected.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * Whether the item is active.
         * @return {?}
         */

      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * \@docs-private
         * Whether the parent dropdown is in multiselect mode.
         * @return {?}
         */

      }, {
        key: "multiselect",
        get: function get() {
          return this._dropdown && this._dropdown.isMultiSelect;
        }
      }, {
        key: "_formattedValue",
        get: function get() {
          return (
            /** @type {?} */
            this._dropdown.valueFormatter(this.value)
          );
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "viewValue",
        get: function get() {
          return (this._elementRef.nativeElement.textContent || '').trim();
        }
      }]);

      return NxDropdownItemComponent;
    }();

    NxDropdownItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-dropdown-item',
        template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[id]': 'id',
          'role': 'option',
          '[attr.aria-selected]': 'selected.toString()',
          '[class.nx-hidden]': '_hidden',
          '[class.nx-dropdown-item--active]': 'active',
          '[class.nx-selected]': 'selected',
          '[class.nx-multiselect]': 'multiselect',
          '(click)': '_onClick($event)'
        },
        styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-multiselect) ::ng-deep .nx-checkbox__label{height:28px;display:flex;align-items:center}:host(.nx-dropdown-item--active),:host:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active),:host:hover{color:highlightText}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}.nx-dropdown-results__option-checkicon{opacity:0;width:16px;height:16px;margin-right:8px}.nx-dropdown-results__option-checkicon nx-icon{font-size:16px}:host-context([data-whatinput=keyboard]).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
      }]
    }];
    /** @nocollapse */

    NxDropdownItemComponent.ctorParameters = function () {
      return [{
        type: NxDropdownControl,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [NxDropdownControl]
        }]
      }, {
        type: NxDropdownGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }];
    };

    NxDropdownItemComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      onSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      containerElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['container']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-template and project it into the required destination.

    var NxDropdownClosedLabelDirective =
    /**
     * @param {?} templateRef
     */
    function NxDropdownClosedLabelDirective(templateRef) {
      _classCallCheck(this, NxDropdownClosedLabelDirective);

      this.templateRef = templateRef;
    };

    NxDropdownClosedLabelDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxClosedLabel]'
      }]
    }];
    /** @nocollapse */

    NxDropdownClosedLabelDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */


    var NxDropdownSelectChange =
    /**
     * @param {?} source
     * @param {?} value
     */
    function NxDropdownSelectChange(source, value) {
      _classCallCheck(this, NxDropdownSelectChange);

      this.source = source;
      this.value = value;
    }; // used in calculation of scrolltop to correctly show some space to the top of the panel

    /** @type {?} */


    var itemPadding = 16; // Max-height: 6 items x 44px + 16px padding before first item

    /** @type {?} */

    var SELECT_PANEL_MAX_HEIGHT = 280;

    var NxDropdownComponent$1 =
    /*#__PURE__*/
    function (_NxDropdownControl2) {
      _inherits(NxDropdownComponent$1, _NxDropdownControl2);

      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       * @param {?} _ngZone
       * @param {?} tabIndex
       * @param {?} formFieldComponent
       * @param {?} ngControl
       * @param {?} _parentForm
       * @param {?} _parentFormGroup
       */
      function NxDropdownComponent$1(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        var _this70;

        _classCallCheck(this, NxDropdownComponent$1);

        _this70 = _possibleConstructorReturn(this, _getPrototypeOf(NxDropdownComponent$1).call(this));
        _this70._changeDetectorRef = _changeDetectorRef;
        _this70._elementRef = _elementRef;
        _this70._ngZone = _ngZone;
        _this70.formFieldComponent = formFieldComponent;
        _this70.ngControl = ngControl;
        _this70._parentForm = _parentForm;
        _this70._parentFormGroup = _parentFormGroup; // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here

        _this70.readonly = false;
        _this70._disabled = false;
        _this70._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */

        _this70._panelOpen = false;
        /**
         * \@docs-private
         */

        _this70.errorState = false;
        /**
         * The scroltop of the panelBody.
         */

        _this70._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */

        _this70._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */

        _this70.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */

        _this70._optionIds = '';
        _this70._tabIndex = 0;
        /**
         * \@docs-private
         */

        _this70.currentFilter = '';
        /**
         * Label to describe the component.
         */

        _this70._ariaLabel = '';
        _this70._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */

        _this70._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */

        _this70.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */

        _this70.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */

        _this70.openedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Event emitted when the select has been opened.
         */

        _this70._openedStream = _this70.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
        /**
        * @param {?} o
        * @return {?}
        */
        function (o) {
          return o;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["map"])(
        /**
        * @return {?}
        */
        function () {}));
        /**
         * Event emitted when the select has been closed.
         */

        _this70._closedStream = _this70.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
        /**
        * @param {?} o
        * @return {?}
        */
        function (o) {
          return !o;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["map"])(
        /**
        * @return {?}
        */
        function () {}));
        /**
         * Event emitted when the user types in the filter input.
         */

        _this70.filterChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */

        _this70.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Event emitted when the selected value has been changed.
         */

        _this70.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * \@docs-private
         */

        _this70.optionSelectionChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["defer"])(
        /**
        * @return {?}
        */
        function () {
          if (_this70.options) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(_this70.options.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.onSelectionChange;
            })));
          }

          return _this70._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            return _this70.optionSelectionChanges;
          }));
        });
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */

        _this70._positions = [{
          originX: 'start',
          originY: 'top',
          overlayX: 'start',
          overlayY: 'top'
        }, {
          originX: 'start',
          originY: 'center',
          overlayX: 'start',
          overlayY: 'center'
        }, {
          originX: 'start',
          originY: 'bottom',
          overlayX: 'start',
          overlayY: 'bottom'
        }];
        /**
         * Emits whenever the component is destroyed.
         */

        _this70._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */

        _this70.valueFormatter =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return value == null ? '' : value.toString();
        };
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */


        _this70._compareWith =
        /**
        * @param {?} o1
        * @param {?} o2
        * @return {?}
        */
        function (o1, o2) {
          return o1 === o2;
        };

        _this70._filterFn =
        /**
        * @param {?} search
        * @param {?} itemValue
        * @return {?}
        */
        function (search, itemValue) {
          return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        };
        /**
         * `View -> model callback called when value changes`
         */


        _this70._onChange =
        /**
        * @return {?}
        */
        function () {};
        /**
         * `View -> model callback called when select has been touched`
         */


        _this70._onTouched =
        /**
        * @return {?}
        */
        function () {};

        if (_this70.ngControl) {
          // Note: we provide the value accessor through here, instead of
          // the `providers` to avoid running into a circular import.
          _this70.ngControl.valueAccessor = _assertThisInitialized(_this70);
        }

        _this70.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this70;
      }
      /**
       * @return {?}
       */


      _createClass(NxDropdownComponent$1, [{
        key: "ngDoCheck",

        /**
         * @return {?}
         */
        value: function ngDoCheck() {
          if (this.ngControl) {
            this.updateErrorState();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__["SelectionModel"](this.isMultiSelect);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this71 = this;

          this._closedDropdownLabel = this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;

          this._initKeyManager();

          this._selectionModel.onChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            event.added.forEach(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.select();
            });
            event.removed.forEach(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.deselect();
            });
          });

          this.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this71._resetOptions();

            _this71._initializeSelection();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy.next();

          this._destroy.complete();
        }
        /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */

      }, {
        key: "isErrorState",
        value: function isErrorState(control, form) {
          return !!(control && control.invalid && (control.touched || form && form.submitted));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updateErrorState",
        value: function updateErrorState() {
          /** @type {?} */
          var oldState = this.errorState;
          /** @type {?} */

          var parent = this._parentFormGroup || this._parentForm;
          /** @type {?} */

          var control = this.ngControl ?
          /** @type {?} */
          this.ngControl.control : null;
          /** @type {?} */

          var newState = this.isErrorState(control, parent);

          if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
          }
        }
        /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_initKeyManager",
        value: function _initKeyManager() {
          var _this72 = this;

          this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["ActiveDescendantKeyManager"](this.options).withTypeAhead().withWrap().withVerticalOrientation().withHorizontalOrientation('ltr').skipPredicate(
          /**
          * @param {?} item
          * @return {?}
          */
          function (item) {
            return item._hidden;
          });

          this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            _this72.closePanel();
          });

          this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(this._destroy)).subscribe(
          /**
          * @return {?}
          */
          function () {
            if (_this72._panelOpen && _this72.panel) {
              // Delay the auto scrolling until all items have settled otherwise the item containers might
              // not exist yet
              _this72._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1)).subscribe(
              /**
              * @return {?}
              */
              function () {
                return _this72._scrollActiveOptionIntoView();
              });
            } else if (!_this72._panelOpen && !_this72.isMultiSelect && _this72._keyManager.activeItem) {
              _this72._keyManager.activeItem._selectViaInteraction();
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_resetOptions",
        value: function _resetOptions() {
          var _this73 = this;

          /** @type {?} */
          var changedOrDestroyed = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(this.options.changes, this._destroy);
          this.optionSelectionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            _this73._onSelect(event.item, event.isUserInput);

            if (event.isUserInput && !_this73.isMultiSelect && _this73._panelOpen) {
              _this73.closePanel();
            }
          }); // Listen to changes in the internal state of the options and react accordingly.
          // Handles cases like the labels of the selected options changing.

          Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._stateChanges;
          }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["takeUntil"])(changedOrDestroyed)).subscribe(
          /**
          * @return {?}
          */
          function () {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout(
            /**
            * @return {?}
            */
            function () {
              _this73._changeDetectorRef.markForCheck();

              _this73.stateChanges.next();
            });
          });

          this._setOptionIds();
        }
        /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */

      }, {
        key: "_setOptionIds",
        value: function _setOptionIds() {
          this._optionIds = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option.id;
          }).join(' ');
        }
        /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */

      }, {
        key: "_onSelect",
        value: function _onSelect(option, isUserInput) {
          /** @type {?} */
          var wasSelected = this._selectionModel.isSelected(option);

          if (option.value == null && !this.isMultiSelect) {
            option.deselect();

            this._selectionModel.clear();

            this._propagateChanges(option.value);
          } else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);

            if (isUserInput) {
              this._keyManager.setActiveItem(option);
            }

            if (this.isMultiSelect) {
              this._sortValues();

              if (isUserInput) {
                // In case the user selected the option with their mouse, we
                // want to restore focus back to the trigger, in order to
                // prevent the select keyboard controls from clashing with
                // the ones from `mat-option`.
                this.focus();
              }
            }
          }

          if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
          }

          this.stateChanges.next();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_initializeSelection",
        value: function _initializeSelection() {
          var _this74 = this;

          // Defer setting the value in order to avoid the "Expression
          // has changed after it was checked" errors from Angular.
          Promise.resolve().then(
          /**
          * @return {?}
          */
          function () {
            _this74._setSelectionByValue(_this74.ngControl ? _this74.ngControl.value : _this74._value);
          });
        }
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setSelectionByValue",
        value: function _setSelectionByValue(value) {
          var _this75 = this;

          if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
              throw getNxDropdownNonArrayValueError();
            }

            this._selectionModel.clear();

            value.forEach(
            /**
            * @param {?} currentValue
            * @return {?}
            */
            function (currentValue) {
              return _this75._selectValue(currentValue);
            });

            this._sortValues();
          } else {
            this._selectionModel.clear();
            /** @type {?} */


            var correspondingOption = this._selectValue(value); // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.


            if (correspondingOption) {
              this._keyManager.setActiveItem(correspondingOption);
            }
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */

      }, {
        key: "_selectValue",
        value: function _selectValue(value) {
          var _this76 = this;

          /** @type {?} */
          var correspondingOption = this.options.find(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            try {
              // Treat null as a special reset value.
              return option.value != null && _this76._compareWith(option.value, value);
            } catch (error) {
              if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["isDevMode"])()) {
                // Notify developers of errors in their comparator.
                console.warn(error);
              }

              return false;
            }
          });

          if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
          }

          return correspondingOption;
        }
        /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */

      }, {
        key: "_propagateChanges",
        value: function _propagateChanges(fallbackValue) {
          /** @type {?} */
          var valueToEmit = null;

          if (this.isMultiSelect) {
            valueToEmit =
            /** @type {?} */
            this.selected.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.value;
            });
          } else {
            valueToEmit = this.selected ?
            /** @type {?} */
            this.selected.value : fallbackValue;
          }

          this._value = valueToEmit;
          this.valueChange.emit(valueToEmit);

          this._onChange(valueToEmit);

          this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_sortValues",
        value: function _sortValues() {
          if (this.isMultiSelect) {
            /** @type {?} */
            var options = this.options.toArray();

            this._selectionModel.sort(
            /**
            * @param {?} a
            * @param {?} b
            * @return {?}
            */
            function (a, b) {
              return options.indexOf(a) - options.indexOf(b);
            });

            this.stateChanges.next();
          }
        }
        /**
         * Focuses the select element.
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          this._elementRef.nativeElement.focus();
        }
        /**
         * Opens the panel of the dropdown.
         * @return {?}
         */

      }, {
        key: "openPanel",
        value: function openPanel() {
          if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
          }

          this._panelOpen = true;
          this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();

          this._keyManager.withHorizontalOrientation(null);

          this._highlightCorrectOption();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Closes the panel of the dropdown.
         * @return {?}
         */

      }, {
        key: "closePanel",
        value: function closePanel() {
          var _this77 = this;

          if (this._panelOpen) {
            this._panelOpen = false;

            this._keyManager.withHorizontalOrientation('ltr');

            this._changeDetectorRef.markForCheck();

            this._onTouched();

            this.openedChange.emit(false); // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors

            setTimeout(
            /**
            * @return {?}
            */
            function () {
              return _this77.focus();
            });
          }
        } // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_calculateScrollTop",
        value: function _calculateScrollTop() {
          // reset the scrolltop to make calculation easier
          this.panelBody.nativeElement.scrollTop = 0;
          this._scrollTop = 0;

          if (!this.empty) {
            /** @type {?} */
            var offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */


            var panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */

            var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */

            var middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */

            var activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();

            if (offset > middleOfPanel) {
              // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
              // target position for the item and subtract it from the offset (which is now always relative to the viewport)
              // to middle out the text a bit more add half of the height
              // (this is still a few pixels off because the container is a bit larger than the font)
              this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
              this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
          }
        }
        /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollActiveOptionIntoView",
        value: function _scrollActiveOptionIntoView() {
          if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
          }
          /** @type {?} */


          var activeOptionIndex = this._keyManager.activeItemIndex || 0;
          /** @type {?} */

          var itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
          /** @type {?} */


          var labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);

          this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
        }
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} options
         * @param {?} optionGroups
         * @return {?}
         */

      }, {
        key: "_countGroupLabelsBeforeOption",
        value: function _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
          if (optionGroups.length) {
            /** @type {?} */
            var optionsArray = options.toArray();
            /** @type {?} */

            var groups = optionGroups.toArray();
            /** @type {?} */

            var groupCounter = 0;

            for (var i = 0; i < optionIndex + 1; i++) {
              if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                groupCounter++;
              }
            }

            return groupCounter;
          }

          return 0;
        }
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} optionHeight
         * @param {?} currentScrollPosition
         * @param {?} panelHeight
         * @return {?}
         */

      }, {
        key: "_getOptionScrollPosition",
        value: function _getOptionScrollPosition(optionIndex, optionHeight, currentScrollPosition, panelHeight) {
          /** @type {?} */
          var optionOffset = optionIndex * optionHeight + itemPadding;

          if (this.showFilter) {
            /** @type {?} */
            var filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
          }

          if (optionOffset < currentScrollPosition) {
            return optionOffset;
          }

          if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
          }

          return currentScrollPosition;
        }
        /**
         * @private
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "_getItemOffset",
        value: function _getItemOffset(item) {
          /** @type {?} */
          var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
          return itemRect.top;
        }
        /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */

      }, {
        key: "setDescribedByIds",
        value: function setDescribedByIds(ids) {
          this.ariaDescribedby = ids.join(' ');
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(value) {
          this._ariaLabel = value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "_getAriaLabel",
        value: function _getAriaLabel() {
          return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
        }
        /**
         * \@docs-private
         * Whether the select has a value.
         * @return {?}
         */

      }, {
        key: "writeValue",

        /** End Formfield */

        /** ControlValueAccessor */

        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        value: function writeValue(value) {
          if (this.options) {
            this._setSelectionByValue(value);
          }
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        }
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;

          this._changeDetectorRef.markForCheck();

          this.stateChanges.next();
        }
        /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleKeydown",
        value: function _handleKeydown(event) {
          this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleClosedKeydown",
        value: function _handleClosedKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode;
          /** @type {?} */

          var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["LEFT_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["RIGHT_ARROW"];
          /** @type {?} */

          var isOpenKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"]; // Open the select on ALT + arrow key to match the native <select>

          if (isOpenKey || (this.isMultiSelect || event.altKey) && isArrowKey) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space

            this.openPanel();
          } else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
          }
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleOpenKeydown",
        value: function _handleOpenKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode; // all events other than the listed ones should be ignored or handled in _onFilter()

          if (!([_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["DOWN_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["UP_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["HOME"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["END"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["LEFT_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["RIGHT_ARROW"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SHIFT"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"], _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["TAB"]].indexOf(keyCode) >= 0)) {
            return;
          }
          /** @type {?} */


          var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["DOWN_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["UP_ARROW"];
          /** @type {?} */

          var manager = this._keyManager;
          /** @type {?} */

          var allHidden = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._hidden;
          }).every(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return Boolean(option);
          });

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["HOME"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["END"]) {
            event.preventDefault();
            keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
          } else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] && manager.activeItem && !allHidden) {
            event.preventDefault();

            manager.activeItem._selectViaInteraction();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] && allHidden) {
            event.preventDefault();
            this.closePanel();
          } else if (!this.showFilter && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"] && manager.activeItem) {
            event.preventDefault();

            manager.activeItem._selectViaInteraction();
          } else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["TAB"]) {
            this.closePanel();
          } else {
            /** @type {?} */
            var previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);

            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem && manager.activeItemIndex !== previouslyFocusedIndex) {
              manager.activeItem._selectViaInteraction();
            }
          }
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "formatValue",
        value: function formatValue(value) {
          return this.valueFormatter(value);
        }
        /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onFilter",
        value: function _onFilter(event) {
          event.preventDefault();
          this.currentFilter = event.target.value;
          this.filterChanges.next(event.target.value);
          /** @type {?} */

          var allHidden = this.options.map(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return option._hidden;
          }).every(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            return Boolean(option);
          });

          if (allHidden) {
            this._keyManager.setActiveItem(null);
          } else {
            this._keyManager.setFirstItemActive();
          }
        }
        /**
         * \@docs-private
         * The value displayed in the trigger.
         * @return {?}
         */

      }, {
        key: "_highlightCorrectOption",

        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        value: function _highlightCorrectOption() {
          if (this._keyManager) {
            if (this.empty) {
              this._keyManager.setFirstItemActive();
            } else {
              this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
          }
        }
        /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */

      }, {
        key: "_onAttached",
        value: function _onAttached() {
          var _this78 = this;

          this._changeDetectorRef.markForCheck();

          this.overlayDir.positionChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this78.panelBody.nativeElement.focus();

            if (_this78._keyManager.activeItem) {
              _this78._calculateScrollTop();
            }

            _this78._changeDetectorRef.markForCheck();

            _this78.openedChange.emit(true);

            if (_this78.showFilter) {
              _this78.filterInput.nativeElement.focus();
            }
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "_onFocus",
        value: function _onFocus() {
          if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
          }
        }
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */

      }, {
        key: "_onBlur",
        value: function _onBlur() {
          this._focused = false;

          if (this.filterInput && this.showFilter) {
            this._clearFilter();
          }

          if (!this.disabled && !this.panelOpen) {
            this._onTouched();

            this._changeDetectorRef.markForCheck();

            this.stateChanges.next();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "_clearFilter",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _clearFilter() {
          this.filterInput.nativeElement.value = '';
          this.currentFilter = '';
          this.filterChanges.next('');
        }
        /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */

      }, {
        key: "_getAriaActiveDescendant",
        value: function _getAriaActiveDescendant() {
          if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
          }

          return null;
        }
      }, {
        key: "tabIndex",
        get: function get() {
          return this.disabled ? -1 : this._tabIndex;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          // If the specified tabIndex value is null or undefined, fall back to the default value.
          this._tabIndex = value != null ? value : 0;
        }
        /**
         * Selected value
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;

            this._onChange(newValue);
          }
        }
        /**
         * Whether the dropdown is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabled = value;
        }
        /**
         * If set to 'negative', the component is displayed with the negative set of styles.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "styles",
        set: function set(value) {
          if (this._style === value) {
            return;
          }

          this._style = value;
          this._negative = !!this._style.match(/negative/);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "closedDropdownLabel",
        get: function get() {
          return this._closedDropdownLabel;
        }
        /**
         * \@docs-private
         * The currently selected option.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "panelOpen",
        get: function get() {
          return this._panelOpen;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._panelOpen = value;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "label",
        get: function get() {
          return this.formFieldComponent ? this.formFieldComponent.label : '';
        }
        /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         * @return {?}
         */

      }, {
        key: "compareWith",
        get: function get() {
          return this._compareWith;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
          }

          this._compareWith = fn;

          if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
          }
        }
        /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         * @return {?}
         */

      }, {
        key: "filterFn",
        get: function get() {
          return this._filterFn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
          }

          this._filterFn = fn;
        }
        /**
         * \@docs-private
         * Whether the select is focused.
         * @return {?}
         */

      }, {
        key: "focused",
        get: function get() {
          return this._focused || this.panelOpen;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "elementRef",
        get: function get() {
          return this._elementRef;
        }
      }, {
        key: "empty",
        get: function get() {
          return !this._selectionModel || this._selectionModel.isEmpty();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hasValue",
        get: function get() {
          return this._selectionModel.hasValue();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "shouldLabelFloat",
        get: function get() {
          return this.focused || !this.empty;
        }
      }, {
        key: "triggerValue",
        get: function get() {
          if (this.empty) {
            return '';
          }

          if (this.isMultiSelect) {
            /** @type {?} */
            var selectedOptions = this._selectionModel.selected.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.viewValue;
            });

            return selectedOptions.join(', ');
          }

          return this._selectionModel.selected[0].viewValue;
        }
      }, {
        key: "isFilterEmpty",
        get: function get() {
          return this.currentFilter.length === 0;
        }
      }]);

      return NxDropdownComponent$1;
    }(NxDropdownControl);

    NxDropdownComponent$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-dropdown',
        template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: NxDropdownControl,
          useExisting: NxDropdownComponent$1
        }, {
          provide: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldControl"],
          useExisting: NxDropdownComponent$1
        }],
        host: {
          'role': 'button',
          '[class.nx-dropdown]': 'true',
          '[class.is-filled]': 'hasValue',
          '[class.has-focus]': 'focused',
          '[class.nx-dropdown--negative]': '_negative',
          '[class.nx-dropdown--disabled]': 'disabled',
          '[attr.aria-describedby]': 'ariaDescribedby || null',
          '[attr.aria-required]': 'required',
          '[attr.aria-label]': '_getAriaLabel()',
          '[attr.aria-haspopup]': '"listbox"',
          '[attr.aria-expanded]': 'panelOpen',
          '[attr.disabled]': 'disabled || null',
          '[attr.tabindex]': 'tabIndex',
          '(keydown)': '_handleKeydown($event)',
          '(focus)': '_onFocus()',
          '(blur)': '_onBlur()',
          '(click)': 'openPanel()'
        },
        styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
      }]
    }];
    /** @nocollapse */

    NxDropdownComponent$1.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgZone"]
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Attribute"],
          args: ['tabindex']
        }]
      }, {
        type: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NgControl"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NgForm"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["FormGroupDirective"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }];
    };

    NxDropdownComponent$1.propDecorators = {
      tabIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      _ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAriaLabel']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxRequired']
      }],
      styles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStyle']
      }],
      showFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxShowFilter']
      }],
      filterPlaceholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxFilterPlaceholder']
      }],
      openedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      _openedStream: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['opened']
      }],
      _closedStream: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['closed']
      }],
      filterChanges: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['filterInput']
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxValueChange']
      }],
      selectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      panel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['panel']
      }],
      panelBody: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['panelBody']
      }],
      trigger: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['trigger']
      }],
      filterInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['filterInput']
      }],
      overlayDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["CdkConnectedOverlay"]]
      }],
      options: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxDropdownItemComponent, {
          descendants: true
        }]
      }],
      groups: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxDropdownGroupComponent]
      }],
      _customClosedDropdownLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [NxDropdownClosedLabelDirective]
      }],
      _defaultClosedDropdownLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['defaultClosedDropdownLabel']
      }],
      valueFormatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValueFormatter']
      }],
      compareWith: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      filterFn: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDropdownModule = function NxDropdownModule() {
      _classCallCheck(this, NxDropdownModule);
    };

    NxDropdownModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldModule"], _allianz_ngx_ndbx_checkbox__WEBPACK_IMPORTED_MODULE_2__["NxCheckboxModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["A11yModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__["ObserversModule"]],
        declarations: [NxDropdownComponent$1, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective],
        exports: [NxDropdownComponent$1, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Option selected event
     */

    var NxAutocompleteOptionSelected =
    /**
     * @param {?} source
     * @param {?=} isUserInput
     */
    function NxAutocompleteOptionSelected(source) {
      var isUserInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, NxAutocompleteOptionSelected);

      this.source = source;
      this.isUserInput = isUserInput;
    };
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */


    var _uniqueIdCounter = 0;

    var NxAutocompleteOptionComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} _changeDetectorRef
       */
      function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
        _classCallCheck(this, NxAutocompleteOptionComponent);

        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = "nx-autocomplete-option-".concat(_uniqueIdCounter++);
        this._selected = false;
        this._active = false;
        this._disabled = false;
        /**
         * Event emitted when the option is selected or deselected.
         */

        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
      }
      /**
       * Id of the autocomplete option. By default it is set to an incremented value.
       * @return {?}
       */


      _createClass(NxAutocompleteOptionComponent, [{
        key: "_handleKeydown",

        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        value: function _handleKeydown(event) {
          if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] || event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"]) {
            this._selectViaInteraction(); // Prevent the page from scrolling down and form submits.


            event.preventDefault();
          }
        }
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */

      }, {
        key: "_selectViaInteraction",
        value: function _selectViaInteraction() {
          if (!this.disabled) {
            this._selected = true;

            this._changeDetectorRef.markForCheck();

            this._emitSelectionChangeEvent(true);
          }
        }
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */

      }, {
        key: "_getTabIndex",
        value: function _getTabIndex() {
          return this.disabled ? '-1' : '0';
        }
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */

      }, {
        key: "_emitSelectionChangeEvent",
        value: function _emitSelectionChangeEvent() {
          var isUserInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "setActiveStyles",

        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        value: function setActiveStyles() {
          if (!this._active) {
            this._active = true;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */

      }, {
        key: "setInactiveStyles",
        value: function setInactiveStyles() {
          if (this._active) {
            this._active = false;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */

      }, {
        key: "getLabel",
        value: function getLabel() {
          return this.viewValue;
        }
        /**
         * Selects the option.
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          this._selected = true;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent();
        }
        /**
         * Deselects the option.
         * @return {?}
         */

      }, {
        key: "deselect",
        value: function deselect() {
          this._selected = false;

          this._changeDetectorRef.markForCheck();

          this._emitSelectionChangeEvent();
        }
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          /** @type {?} */
          var element = this.elementRef.nativeElement;

          if (typeof element.focus === 'function') {
            element.focus();
          }
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * Whether or not the option is currently selected.
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * Whether or not the option is currently active and ready to be selected.
         * An active option displays styles as if it is focused, but the
         * focus is actually retained somewhere else. This comes in handy
         * for components like autocomplete where focus must remain on the input.
         * @return {?}
         */

      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * Whether the option is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._disabled !== newValue) {
            this._disabled = newValue;
          }
        }
      }, {
        key: "viewValue",
        get: function get() {
          return (this.elementRef.nativeElement.textContent || '').trim();
        }
      }]);

      return NxAutocompleteOptionComponent;
    }();

    NxAutocompleteOptionComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-autocomplete-option',
        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        host: {
          'role': 'option',
          '[attr.tabindex]': '_getTabIndex()',
          '[id]': 'id',
          '[attr.aria-selected]': 'selected.toString()',
          '[attr.aria-disabled]': 'disabled.toString()',
          '(click)': '_selectViaInteraction()',
          '(keydown)': '_handleKeydown($event)',
          '[class.nx-active]': 'active',
          '[class.nx-disabled]': 'disabled',
          '[style.display]': '\'block\'' // needed for to be able to calculate offset height

        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host:focus{outline:0}.nx-autocomplete-option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:highlightText}}.nx-autocomplete-option__label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteOptionComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxAutocompleteOptionComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      onSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */

    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */

    var NxAutocompleteSelectedEvent =
    /**
     * @param {?} source
     * @param {?} option
     */
    function NxAutocompleteSelectedEvent(source, option) {
      _classCallCheck(this, NxAutocompleteSelectedEvent);

      this.source = source;
      this.option = option;
    };

    var NxAutocompleteComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       */
      function NxAutocompleteComponent(_changeDetectorRef, _elementRef) {
        _classCallCheck(this, NxAutocompleteComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         */

        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /**
         * Event that is emitted whenever an option from the list is selected.
         */

        this.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Event that is emitted when the autocomplete panel is opened.
         */

        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Event that is emitted when the autocomplete panel is closed.
         */

        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._classList = {};
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         */

        this.id = "nx-autocomplete-".concat(_uniqueAutocompleteIdCounter++); // As autocomplete option can hold any value, we might need a converter
        // to get a string representation, which can be stored in input. Default value ? value.toString() : null.

        /**
         * Value to string converter.
         */

        this.valueFormatter =
        /**
        * @param {?} value
        * @return {?}
        */
        function (value) {
          return value ? value.toString() : null;
        };
      }
      /**
       * Whether the autocomplete panel is open.
       * @return {?}
       */


      _createClass(NxAutocompleteComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["ActiveDescendantKeyManager"](this.options).withWrap();

          this._setVisibility();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
          }
        }
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */

      }, {
        key: "_setScrollTop",
        value: function _setScrollTop(scrollTop) {
          if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
          }
        }
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */

      }, {
        key: "_getScrollTop",
        value: function _getScrollTop() {
          return this.panel ? this.panel.nativeElement.scrollTop : 0;
        }
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */

      }, {
        key: "_setVisibility",
        value: function _setVisibility() {
          this.showPanel = !!(this.options && this.options.length);
          this._classList['nx-autocomplete-visible'] = this.showPanel;
          this._classList['nx-autocomplete-hidden'] = !this.showPanel;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */

      }, {
        key: "_emitSelectEvent",
        value: function _emitSelectEvent(option) {
          /** @type {?} */
          var event = new NxAutocompleteSelectedEvent(this, option);
          this.optionSelected.emit(event);
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this._isOpen && this.showPanel;
        }
        /**
         * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "items",
        set: function set(val) {
          var _this79 = this;

          this._hasItems = true;

          if (Array.isArray(val)) {
            this._items = val;
          } else if (val instanceof rxjs__WEBPACK_IMPORTED_MODULE_25__["Observable"]) {
            if (this._itemsSubscription) {
              this._itemsSubscription.unsubscribe();
            }

            this._itemsSubscription = val.subscribe(
            /**
            * @param {?} itms
            * @return {?}
            */
            function (itms) {
              _this79._items = itms;

              _this79._changeDetectorRef.markForCheck(); // and check visibility in next cycle, when options are set


              setTimeout(
              /**
              * @return {?}
              */
              function () {
                return _this79._setVisibility();
              });
            });
          } else if (val === null) {
            this._items = val;
          } else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._items;
        }
        /**
         * \@docs-private
         * Is items observable set
         * @return {?}
         */

      }, {
        key: "hasItems",
        get: function get() {
          return this._hasItems;
        }
        /**
         * Autocomplete options
         * @return {?}
         */

      }, {
        key: "options",
        get: function get() {
          return this.hasItems ? this._vOptions : this._cOptions;
        }
        /**
         * Takes classes set on the host nx-autocomplete element and applies them to the panel
         * inside the overlay container to allow for easy styling.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "classList",
        set: function set(value) {
          var _this80 = this;

          if (value && value.length) {
            value.split(' ').forEach(
            /**
            * @param {?} className
            * @return {?}
            */
            function (className) {
              return _this80._classList[className.trim()] = true;
            });
            this._elementRef.nativeElement.className = '';
          }
        }
      }]);

      return NxAutocompleteComponent;
    }();

    NxAutocompleteComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-autocomplete',
        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxAutocomplete',
        host: {
          'class': 'nx-autocomplete'
        },
        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:24px;overflow-y:auto;overflow-x:hidden;max-height:336px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }];
    };

    NxAutocompleteComponent.propDecorators = {
      template: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]]
      }],
      panel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['panel']
      }],
      items: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      optionSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      opened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      _vOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChildren"],
        args: [NxAutocompleteOptionComponent]
      }],
      _cOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxAutocompleteOptionComponent, {
          descendants: true
        }]
      }],
      classList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['class']
      }],
      valueFormatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValueFormatter']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */

    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
      /**
      * @return {?}
      */
      function () {
        return NxAutocompleteTriggerDirective;
      }),
      multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */

    function getNxAutocompleteMissingPanelError() {
      return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' + 'Make sure that the id passed to the `nxAutocomplete` is correct and that ' + 'you\'re attempting to open it after the ngAfterContentInit hook.');
    }

    var NxAutocompleteTriggerDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       * @param {?} _overlay
       * @param {?} _viewContainerRef
       * @param {?} _zone
       * @param {?} _changeDetectorRef
       * @param {?} _dir
       * @param {?} _nxFormField
       * @param {?} _nxWordField
       * @param {?} _document
       * @param {?=} _viewportRuler
       */
      function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
        var _this81 = this;

        _classCallCheck(this, NxAutocompleteTriggerDirective);

        this._element = _element;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this._changeDetectorRef = _changeDetectorRef;
        this._dir = _dir;
        this._nxFormField = _nxFormField;
        this._nxWordField = _nxWordField;
        this._document = _document;
        this._viewportRuler = _viewportRuler;
        this._componentDestroyed = false;
        /**
         * Whether or not the label state is being overridden.
         */

        this._manuallyFloatingLabel = false;
        /**
         * Subscription to viewport size changes.
         */

        this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        /**
         * Stream of keyboard events that can close the panel.
         */

        this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * Value changes
         */

        this._valueChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        this._itemsCb = null;
        this._debounce = 400;
        this._autocompleteDisabled = false;
        this._overlayAttached = false;
        /**
         * Stream of autocomplete option selections.
         */

        this.optionSelections = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["defer"])(
        /**
        * @return {?}
        */
        function () {
          if (_this81.autocomplete && _this81.autocomplete.options) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(_this81.autocomplete.options.map(
            /**
            * @param {?} option
            * @return {?}
            */
            function (option) {
              return option.onSelectionChange;
            })));
          } // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
          // Return a stream that we'll replace with the real one once everything is in place.


          return _this81._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            return _this81.optionSelections;
          }));
        });
        /**
         * `View -> model callback called when value changes`
         */

        this._onChange =
        /**
        * @param {?} val
        * @return {?}
        */
        function (val) {
          _this81._valueChanges.next(val);
        };
        /**
         * `View -> model callback called when autocomplete has been touched`
         */


        this._onTouched =
        /**
        * @return {?}
        */
        function () {};
      }
      /**
       * The items callback. Called with input value, must return Observable of Array of strings
       * @param {?} val
       * @return {?}
       */


      _createClass(NxAutocompleteTriggerDirective, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._viewportSubscription.unsubscribe();

          this._componentDestroyed = true;

          this._destroyPanel();

          this._closeKeyEventStream.complete();

          if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
          }

          if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges() {
          this._bindAutocompleteItems();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this._bindAutocompleteItems();
        }
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */

      }, {
        key: "_bindAutocompleteItems",
        value: function _bindAutocompleteItems() {
          var _this82 = this;

          if (this._controlValueChangesSubscription) {
            this._controlValueChangesSubscription.unsubscribe();
          }

          if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
            /** @type {?} */
            var itemsSubject = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
            this.autocomplete.items = itemsSubject;
            /** @type {?} */

            var valueChanges = this._formField && this._formField._control && this._formField._control.ngControl && this._formField._control.ngControl.valueChanges ? this._formField._control.ngControl.valueChanges : this._valueChanges;
            this._controlValueChangesSubscription = valueChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["debounceTime"])(this._debounce)).subscribe(
            /**
            * @param {?} input
            * @return {?}
            */
            function (input) {
              if (_this82._itemsSubscription) {
                _this82._itemsSubscription.unsubscribe();
              }

              _this82._itemsSubscription = _this82._itemsCb(input).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["first"])()).subscribe(
              /**
              * @param {?} result
              * @return {?}
              */
              function (result) {
                itemsSubject.next(result);
              },
              /**
              * @param {?} err
              * @return {?}
              */
              function (err) {
                // On error reset
                // TODO: Log error?
                itemsSubject.next([]);
              });
            });
          }
        }
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */

      }, {
        key: "openPanel",
        value: function openPanel() {
          if (!this.autocompleteDisabled) {
            this._attachOverlay();

            this._floatLabel();
          }
        }
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */

      }, {
        key: "closePanel",
        value: function closePanel() {
          this._resetLabel();

          if (!this._overlayAttached) {
            return;
          }

          if (this.panelOpen) {
            // Only emit if the panel was visible.
            this.autocomplete.closed.emit();
          }

          this.autocomplete._isOpen = this._overlayAttached = false;

          if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();

            this._closingActionsSubscription.unsubscribe();
          } // Note that in some cases this can end up being called after the component is destroyed.
          // Add a check to ensure that we don't try to run change detection on a destroyed view.


          if (!this._componentDestroyed) {
            // We need to trigger change detection manually, because
            // `fromEvent` doesn't seem to do it at the proper time.
            // This ensures that the label is reset when the
            // user clicks outside.
            this._changeDetectorRef.detectChanges();
          }
        }
        /**
         * A stream of actions that should close the autocomplete panel, including
         * when an option is selected, on blur, and when TAB is pressed.
         * @return {?}
         */

      }, {
        key: "writeValue",
        // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} value
         * @return {?}
         */
        value: function writeValue(value) {
          var _this83 = this;

          Promise.resolve(null).then(
          /**
          * @return {?}
          */
          function () {
            return _this83._setTriggerValue(value);
          });
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChange = fn;
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouched = fn;
        } // Implemented as part of ControlValueAccessor.

        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this._element.nativeElement.disabled = isDisabled;
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleKeydown",
        value: function _handleKeydown(event) {
          /** @type {?} */
          var keyCode = event.keyCode; // Prevent the default action on all escape key presses. This is here primarily to bring IE
          // in line with other browsers. By default, pressing escape on IE will cause it to revert
          // the input value to the one that it had on focus, however it won't dispatch any events
          // which means that the model value will be out of sync with the view.

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ESCAPE"]) {
            event.preventDefault();
          } // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
          // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction


          if (this.panelOpen && (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ESCAPE"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["UP_ARROW"] && event.altKey)) {
            this._resetActiveItem();

            this._closeKeyEventStream.next();

            event.stopPropagation();
          } else if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] && this.panelOpen) {
            this.activeOption._selectViaInteraction();

            this._resetActiveItem();

            event.preventDefault();
          } else {
            /** @type {?} */
            var prevActiveItem = this.autocomplete._keyManager.activeItem;
            /** @type {?} */

            var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["DOWN_ARROW"];

            if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["TAB"]) {
              this.autocomplete._keyManager.onKeydown(event);
            } else if (isArrowKey && this._isFieldEnabled()) {
              this.openPanel();
            }

            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
              this._scrollToOption();
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_handleInput",
        value: function _handleInput(event) {
          /** @type {?} */
          var target =
          /** @type {?} */
          event.target;
          /** @type {?} */

          var value = target.value; // Based on `NumberValueAccessor` from forms.

          if (target.type === 'number') {
            value = value === '' ? null : parseFloat(value);
          } // If the input has a placeholder, IE will fire the `input` event on page load,
          // focus and blur, in addition to when the user actually changed the value. To
          // filter out all of the extra events, we save the value on focus and between
          // `input` events, and we check whether it changed.
          // See: https://connect.microsoft.com/IE/feedback/details/885747/


          if (this._isFieldEnabled() && this._previousValue !== value && document.activeElement === event.target) {
            this._previousValue = value;

            this._onChange(value);

            this.openPanel();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "_handleFocus",
        value: function _handleFocus() {
          if (this._isFieldEnabled()) {
            this._previousValue = this._element.nativeElement.value;
            this.openPanel();
          }
        }
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */

      }, {
        key: "_floatLabel",
        value: function _floatLabel() {
          if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
            this._nxFormField.floatLabel = 'always';
            this._manuallyFloatingLabel = true;
          }
        }
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetLabel",
        value: function _resetLabel() {
          if (this._manuallyFloatingLabel) {
            this._nxFormField.floatLabel = 'auto';
            this._manuallyFloatingLabel = false;
          }
        }
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollToOption",
        value: function _scrollToOption() {
          if (this.autocomplete.options.length === 0) {
            return;
          }
          /** @type {?} */


          var optionOffset = 0;
          /** @type {?} */

          var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;

          if (this.autocomplete._keyManager.activeItem) {
            optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
          }
          /** @type {?} */


          var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);

          this.autocomplete._setScrollTop(newScrollPosition);
        }
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToClosingActions",
        value: function _subscribeToClosingActions() {
          var _this84 = this;

          /** @type {?} */
          var firstStable = this._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1));
          /** @type {?} */


          var optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["tap"])(
          /**
          * @return {?}
          */
          function () {
            return _this84._positionStrategy.reapplyLastPosition();
          }), // Defer emitting to the stream until the next tick, because changing
          // bindings in here will cause "changed after checked" errors.
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["delay"])(0)); // When the zone is stable initially, and when the option list changes...

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(firstStable, optionChanges).pipe( // create a new stream of panelClosingActions, replacing any previous streams
          // that were created, and flatten it so our stream only emits closing events...
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["switchMap"])(
          /**
          * @return {?}
          */
          function () {
            _this84._resetActiveItem();

            _this84.autocomplete._setVisibility();

            return _this84.panelClosingActions;
          }), // when the first closing event occurs...
          Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1)) // set the value, close the panel, and complete.
          .subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            return _this84._setValueAndClose(event);
          });
        }
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_destroyPanel",
        value: function _destroyPanel() {
          if (this._overlayRef) {
            this.closePanel();

            this._overlayRef.dispose();

            this._overlayRef = null;
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setTriggerValue",
        value: function _setTriggerValue(value) {
          /** @type {?} */
          var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ? this.autocomplete.valueFormatter(value) : value; // Simply falling back to an empty string if the display value is falsy does not work properly.
          // The display value can also be the number zero and shouldn't fall back to an empty string.

          /** @type {?} */

          var inputValue = toDisplay != null ? toDisplay : ''; // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
          // through change detection.

          if (this._formField) {
            this._formField._control.value = inputValue;
          } else {
            this._element.nativeElement.value = inputValue;
          }
        }
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_setValueAndClose",
        value: function _setValueAndClose(event) {
          if (event && event.source) {
            this._clearPreviousSelectedOption(event.source);

            this._setTriggerValue(event.source.value);

            this._onChange(event.source.value);

            this._element.nativeElement.focus();

            this.autocomplete._emitSelectEvent(event.source);
          }

          this.closePanel();
        }
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */

      }, {
        key: "_clearPreviousSelectedOption",
        value: function _clearPreviousSelectedOption(skip) {
          this.autocomplete.options.forEach(
          /**
          * @param {?} option
          * @return {?}
          */
          function (option) {
            if (option !== skip && option.selected) {
              option.deselect();
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_attachOverlay",
        value: function _attachOverlay() {
          var _this85 = this;

          if (!this.autocomplete) {
            throw getNxAutocompleteMissingPanelError();
          }

          if (!this._overlayRef) {
            this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["TemplatePortal"](this.autocomplete.template, this._viewContainerRef);
            this._overlayRef = this._overlay.create(this._getOverlayConfig());

            if (this._viewportRuler) {
              this._viewportSubscription = this._viewportRuler.change().subscribe(
              /**
              * @return {?}
              */
              function () {
                if (_this85.panelOpen && _this85._overlayRef) {
                  _this85._overlayRef.updateSize({
                    minWidth: _this85._getHostWidth()
                  });
                }
              });
            }
          } else {
            /** Update the panel width, in case the host width has changed */
            this._overlayRef.updateSize({
              minWidth: this._getHostWidth()
            });
          }

          if (this._overlayRef && !this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._portal);

            this._closingActionsSubscription = this._subscribeToClosingActions();
          }
          /** @type {?} */


          var wasOpen = this.panelOpen;

          this.autocomplete._setVisibility();

          this.autocomplete._isOpen = this._overlayAttached = true; // We need to do an extra `panelOpen` check in here, because the
          // autocomplete won't be shown if there are no options.

          if (this.panelOpen && wasOpen !== this.panelOpen) {
            this.autocomplete.opened.emit();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOverlayConfig",
        value: function _getOverlayConfig() {
          return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]({
            positionStrategy: this._getOverlayPosition(),
            scrollStrategy: this._scrollStrategy(),
            minWidth: this._getHostWidth(),
            direction: this._dir ? this._dir.value : 'ltr'
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getOverlayPosition",
        value: function _getOverlayPosition() {
          this._positionStrategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withViewportMargin(16).withPush(false).withPositions([{
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top'
          }, {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom'
          }]);
          return this._positionStrategy;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_scrollStrategy",
        value: function _scrollStrategy() {
          return this._overlay.scrollStrategies.reposition();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getConnectedElement",
        value: function _getConnectedElement() {
          return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
        }
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */

      }, {
        key: "_getHostWidth",
        value: function _getHostWidth() {
          return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
        }
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetActiveItem",
        value: function _resetActiveItem() {
          this.autocomplete._keyManager.setActiveItem(-1);
        }
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */

      }, {
        key: "_isFieldEnabled",
        value: function _isFieldEnabled() {
          /** @type {?} */
          var element = this._element.nativeElement;
          return !element.readOnly && !element.disabled;
        }
      }, {
        key: "itemsCb",
        set: function set(val) {
          if (typeof val === 'function') {
            this._itemsCb = val;
          } else {
            throw new Error('Wrong value type for nxAutocompleteItems');
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._itemsCb;
        }
        /**
         * Debounce in ms before items callback is triggered. Defaults to 400
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "debounce",
        set: function set(val) {
          this._debounce = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceNumberProperty"])(val);
        }
        /**
         * Whether autocomplete functionality is disabled.
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "autocompleteDisabled",
        set: function set(val) {
          this._autocompleteDisabled = val;

          this._bindAutocompleteItems();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._autocompleteDisabled;
        }
        /**
         * Whether or not the autocomplete panel is open.
         * @return {?}
         */

      }, {
        key: "panelOpen",
        get: function get() {
          return this._overlayAttached && this.autocomplete.showPanel;
        }
        /**
         * The currently active option, coerced to NxAutocompleteOptionComponent type.
         * @return {?}
         */

      }, {
        key: "activeOption",
        get: function get() {
          if (this.autocomplete && this.autocomplete._keyManager) {
            return this.autocomplete._keyManager.activeItem;
          }

          return null;
        }
        /**
         * Stream of clicks outside of the autocomplete panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_outsideClickStream",
        get: function get() {
          var _this86 = this;

          if (!this._document) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["of"])(null);
          }

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["fromEvent"])(this._document, 'click'), Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["fromEvent"])(this._document, 'touchend')).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            /** @type {?} */
            var clickTarget =
            /** @type {?} */
            event.target;
            /** @type {?} */

            var formField = _this86._formField ? _this86._formField.elementRef.nativeElement : null;
            return _this86._overlayAttached && clickTarget !== _this86._element.nativeElement && (!formField || !formField.contains(clickTarget)) && !!_this86._overlayRef && !_this86._overlayRef.overlayElement.contains(clickTarget);
          }));
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_formField",
        get: function get() {
          if (this._nxFormField) {
            return this._nxFormField;
          } else if (this._nxWordField) {
            return this._nxWordField;
          }
        }
      }, {
        key: "panelClosingActions",
        get: function get() {
          var _this87 = this;

          return Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @return {?}
          */
          function () {
            return _this87._overlayAttached;
          })), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ? this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
          /**
          * @return {?}
          */
          function () {
            return _this87._overlayAttached;
          })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["of"])());
        }
      }]);

      return NxAutocompleteTriggerDirective;
    }();

    NxAutocompleteTriggerDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
        host: {
          'role': 'combobox',
          'autocomplete': 'off',
          'aria-autocomplete': 'list',
          '[attr.aria-activedescendant]': 'activeOption?.id',
          '[attr.aria-expanded]': 'panelOpen.toString()',
          '[attr.aria-owns]': 'autocomplete?.id',
          // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
          // a little earlier. This avoids issues where IE delays the focusing of the input.
          '(focusin)': '_handleFocus()',
          '(blur)': '_onTouched()',
          '(input)': '_handleInput($event)',
          '(keydown)': '_handleKeydown($event)'
        },
        exportAs: 'nxAutocompleteTrigger',
        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
      }]
    }];
    /** @nocollapse */

    NxAutocompleteTriggerDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }]
      }, {
        type: _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Host"]
        }]
      }, {
        type: _allianz_ngx_ndbx_natural_language_form__WEBPACK_IMPORTED_MODULE_5__["NxWordComponent"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Host"]
        }]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["DOCUMENT"]]
        }]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["ViewportRuler"]
      }];
    };

    NxAutocompleteTriggerDirective.propDecorators = {
      autocomplete: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAutocomplete']
      }],
      itemsCb: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAutocompleteItems']
      }],
      debounce: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAutocompleteDebounce']
      }],
      autocompleteDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAutocompleteDisabled']
      }]
    };
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */

    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
      if (optionOffset < currentScrollPosition) {
        return optionOffset;
      }

      if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
        return Math.max(0, optionOffset - panelHeight + optionHeight);
      }

      return currentScrollPosition;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxAutocompleteModule$1 = function NxAutocompleteModule$1() {
      _classCallCheck(this, NxAutocompleteModule$1);
    };

    NxAutocompleteModule$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["A11yModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxWordComponent$1 =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} _changeDetectorRef
       * @param {?} _renderer
       * @param {?} _overlay
       */
      function NxWordComponent$1(elementRef, _changeDetectorRef, _renderer, _overlay) {
        _classCallCheck(this, NxWordComponent$1);

        this.elementRef = elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this.subscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        this.subscriptionValues = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        /**
         * \@docs-private
         */

        this.hasErrors = false;
        /**
         * \@docs-private
         */

        this.inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * \@docs-private
         */

        this.currentTextWidth = 0; // this will apply different min-widths to our component through our styles

        /**
         * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
         */

        this.size = 'regular';
      }
      /**
       * @return {?}
       */


      _createClass(NxWordComponent$1, [{
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this88 = this;

          this._validateControlChild();

          this.subscription = this._control.stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["startWith"])(null)).subscribe(
          /**
          * @return {?}
          */
          function () {
            _this88.hasErrors = _this88._control.errorState;

            _this88._changeDetectorRef.markForCheck();
          }); // if we have a ngcontrol available stick to its valueChanges subject

          if (this._control.ngControl) {
            this.subscriptionValues = this._control.ngControl.valueChanges.subscribe(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              _this88.updateCurrentTextWidth();

              _this88.inputChanges.next();
            }); // in any other case it is a bre input and input changes are signaled through simple state changes
          } else {
            this.subscriptionValues = this._control.stateChanges.subscribe(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              _this88.updateCurrentTextWidth();

              _this88.inputChanges.next();
            });
          }

          this._control.setAriaLabel(this.label);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.subscription.unsubscribe();
        }
        /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */

      }, {
        key: "updateCurrentTextWidth",
        value: function updateCurrentTextWidth() {
          // provide the canvas only lazy
          if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
          }
          /** @type {?} */


          var ctx = this.measureCanvas.getContext('2d');
          /** @type {?} */

          var inputRef = this._control.elementRef;
          /** @type {?} */

          var styles = window.getComputedStyle(inputRef.nativeElement);
          ctx.font = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["getFontShorthand"])(styles);
          /** @type {?} */

          var metrics = ctx.measureText(this._control.value); // add 1px (cursor width) to prevent jumping of the text on blur.

          /** @type {?} */

          var newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1; // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
          // Works as promised as long as there is not other tag around the word. Not expected but possible.

          /** @type {?} */

          var parent = this.elementRef.nativeElement.parentElement;
          /** @type {?} */

          var parentMeasurement = parent.getBoundingClientRect(); // Limit to own given minimal width

          this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth); // Limit to container width

          this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);

          this._popover.updatePosition();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "repositionError",
        value: function repositionError() {
          if (this._popover) {
            this._popover.updatePosition();
          }
        } // Fail if the required control is missing.

        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_validateControlChild",
        value: function _validateControlChild() {
          if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getConnectedOverlayOrigin",
        value: function getConnectedOverlayOrigin() {
          return this.elementRef;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isFocused",
        get: function get() {
          return this._control.focused;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isFilled",
        get: function get() {
          return !this._control.empty;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "hasDropdown",
        get: function get() {
          return Boolean(this._dropdown);
        }
      }]);

      return NxWordComponent$1;
    }();

    NxWordComponent$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-word',
        template: "<div\n  class=\"nx-word__input-wrapper\"\n  [nxPopoverTriggerFor]=\"popoverHover\"\n  nxPopoverTrigger='manual'\n  nxPopoverCloseable=\"false\"\n  nxPopoverDirection=\"top\"\n  [nxPopoverShow]=\"hasErrors && _errorChildren.length > 0\">\n\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popoverHover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n",
        host: {
          '[class.size-short]': 'size == "short"',
          '[class.size-regular]': 'size == "regular"',
          '[class.size-long]': 'size == "long"',
          '[class.has-error]': 'hasErrors',
          '[class.is-focused]': 'isFocused',
          '[class.is-filled]': 'isFilled',
          '[class.has-dropdown]': 'hasDropdown'
        },
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none;border-bottom-width:2px}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.is-filled{border-color:#007ab3;color:#006192}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;border-color:#dc3149}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px}:host-context(.nx-natural-language-form--small) ::ng-deep nx-dropdown .nx-dropdown__container{margin-bottom:2px}"]
      }]
    }];
    /** @nocollapse */

    NxWordComponent$1.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }, {
        type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]
      }];
    };

    NxWordComponent$1.propDecorators = {
      _control: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldControl"]]
      }],
      _errorChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [_allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldErrorDirective"]]
      }],
      _popover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_7__["NxPopoverTriggerDirective"]]
      }],
      _dropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [_allianz_ngx_ndbx_dropdown__WEBPACK_IMPORTED_MODULE_8__["NxDropdownComponent"]]
      }],
      currentTextWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostBinding"],
        args: ['style.width.px']
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxSize']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabel']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_SIZE$3 = 'large';

    var NxNaturalLanguageFormComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxNaturalLanguageFormComponent(_changeDetectorRef) {
        _classCallCheck(this, NxNaturalLanguageFormComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
        /**
         * \@docs-private
         */

        this.resizeEvent$ = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * \@docs-private
         */

        this.updatePopoversSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        /**
         * \@docs-private
         */

        this._size = DEFAULT_SIZE$3;
      }
      /**
       * Whether the negative set of stylings should be used.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxNaturalLanguageFormComponent, [{
        key: "onResize",

        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        value: function onResize(event) {
          this.resizeEvent$.next();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this89 = this;

          // Collect all words and listen for changes so we can update any open error popover
          // which would otherwise get wrongly positioned.

          /** @type {?} */
          var subjects = this._words.map(
          /**
          * @param {?} word
          * @return {?}
          */
          function (word) {
            return word.inputChanges;
          });
          /** @type {?} */


          var source = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(subjects));
          this.updatePopoversSubscription = source.subscribe(
          /**
          * @return {?}
          */
          function () {
            _this89.updatePositionPopovers();
          });
          this.resizeObservable = this.resizeEvent$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["throttleTime"])(500), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["delay"])(100));
          this.resizeObservable.subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this89.resizeWords();
          });
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "resizeWords",
        value: function resizeWords() {
          this._words.forEach(
          /**
          * @param {?} word
          * @return {?}
          */
          function (word) {
            word.updateCurrentTextWidth();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.updatePopoversSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "updatePositionPopovers",
        value: function updatePositionPopovers() {
          if (this._words) {
            this._words.forEach(
            /**
            * @param {?} word
            * @return {?}
            */
            function (word) {
              word.repositionError();
            });
          }
        }
      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the size of the NLF. Default value: large
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "size",
        set: function set(value) {
          this._size = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._size;
        }
      }]);

      return NxNaturalLanguageFormComponent;
    }();

    NxNaturalLanguageFormComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-natural-language-form',
        template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.is-negative]': 'negative',
          '[class.nx-natural-language-form--small]': 'size === "small"',
          '[class.nx-natural-language-form--large]': 'size === "large"'
        },
        styles: [":host{display:block;padding-top:72px;padding-bottom:80px;color:#414141;font-weight:300;font-size:40px;line-height:52px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;line-height:36px}}@media (max-width:703px){:host{font-size:26px}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;line-height:32px;letter-spacing:.3px}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
      }]
    }];
    /** @nocollapse */

    NxNaturalLanguageFormComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxNaturalLanguageFormComponent.propDecorators = {
      _words: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxWordComponent$1]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxNegative']
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      onResize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['window:orientationchange', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['window:resize', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxNaturalLanguageFormModule = function NxNaturalLanguageFormModule() {
      _classCallCheck(this, NxNaturalLanguageFormModule);
    };

    NxNaturalLanguageFormModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_input__WEBPACK_IMPORTED_MODULE_13__["NxInputModule"], _allianz_ngx_ndbx_popover__WEBPACK_IMPORTED_MODULE_7__["NxPopoverModule"]],
        declarations: [NxNaturalLanguageFormComponent, NxWordComponent$1],
        exports: [NxNaturalLanguageFormComponent, NxWordComponent$1]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var ICONS = {
      info: 'info-circle',
      error: 'exclamation-circle',
      success: 'check-circle',
      warning: 'exclamation-triangle'
    };

    var NxMessageComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxMessageComponent(_changeDetectorRef) {
        _classCallCheck(this, NxMessageComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._context = 'regular';
        this._showIcon = false;
        this._closable = false;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Event emitted when the close icon of the message has been clicked.
         */

        this.closeEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
      }
      /**
       * Sets the context of the message.
       * The message box will color accordingly. Default: 'regular'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxMessageComponent, [{
        key: "_emitCloseEvent",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function _emitCloseEvent() {
          this.closeEvent.emit();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getIconName",
        value: function getIconName() {
          if (this._context === 'info') {
            return ICONS.info;
          } else if (this._context === 'error') {
            return ICONS.error;
          } else if (this._context === 'success') {
            return ICONS.success;
          } else if (this._context === 'warning') {
            return ICONS.warning;
          }

          return '';
        }
      }, {
        key: "context",
        set: function set(value) {
          if (value !== this._context) {
            this._context = value;
            this._icon = this.getIconName();

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._context;
        }
        /**
         * Whether an icon that belongs to the context of the message should be displayed.
         * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
         * \@deletion-target 9.0.0
         *
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "showIcon",
        set: function set(value) {
          this._showIcon = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._showIcon;
        }
        /**
         * Whether a message should have a close icon in order to be dismissed.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closable",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this._closable) {
            this._closable = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closable;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this._icon;
        }
        /**
         * Sets the label of the close button of the message.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "closeButtonLabel",
        set: function set(value) {
          if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._closeButtonLabel;
        }
      }]);

      return NxMessageComponent;
    }();

    NxMessageComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-message',
        template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        exportAs: 'nxMessage',
        host: {
          '[class.context-info]': 'context === "info"',
          '[class.context-error]': 'context === "error"',
          '[class.context-success]': 'context === "success"',
          '[class.context-warning]': 'context === "warning"',
          '[class.nx-message--closable]': 'closable'
        },
        styles: [":host{width:100%;color:#414141;display:flex;align-items:flex-start;position:relative;background-color:#fff;border:1px solid;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;margin:12px 0;font-size:16px;line-height:24px}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141}:host(.context-info){border-color:#496ebd}:host(.context-info) .nx-message__icon{color:#496ebd}:host(.context-error){border-color:#dc3149}:host(.context-error) .nx-message__icon{color:#dc3149}:host(.context-success){border-color:#1e8927}:host(.context-success) .nx-message__icon{color:#1e8927}:host(.context-warning){border-color:#efbe25}:host(.context-warning) .nx-message__icon{color:#efbe25}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{font-size:16px;color:nx-colors(grey-tones,grey-tone-1)}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
      }]
    }];
    /** @nocollapse */

    NxMessageComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxMessageComponent.propDecorators = {
      context: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxContext']
      }],
      showIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      closable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      closeButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      closeEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['close']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxMessageModule = function NxMessageModule() {
      _classCallCheck(this, NxMessageModule);
    };

    NxMessageModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        declarations: [NxMessageComponent],
        exports: [NxMessageComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPageSearchComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxPageSearchComponent(_changeDetectorRef) {
        _classCallCheck(this, NxPageSearchComponent);

        this._changeDetectorRef = _changeDetectorRef;
        /**
         * An event emitted when the user clicks the search button.
         */

        this.buttonClick = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._buttonLabel = null;
        this._hideSearchButton = false;
        this._buttonLayout = '12,12,12,2';
        this._contentLayout = null;
      }
      /**
       * Sets the text label of the button.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxPageSearchComponent, [{
        key: "onButtonClick",

        /**
         * \@docs-private
         * @return {?}
         */
        value: function onButtonClick() {
          this.buttonClick.emit();
        }
      }, {
        key: "buttonLabel",
        set: function set(value) {
          if (this._buttonLabel !== value) {
            this._buttonLabel = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._buttonLabel;
        }
        /**
         * Whether the search button should be hidden.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "hideSearchButton",
        set: function set(value) {
          this._hideSearchButton = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._hideSearchButton;
        }
        /**
         * Layout of the search button inside of a NxGrid. Default: 12,12,12,2.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "buttonLayout",
        set: function set(value) {
          if (this._buttonLayout !== value) {
            this._buttonLayout = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._buttonLayout;
        }
        /**
         * Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden).
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "contentLayout",
        set: function set(value) {
          if (this._contentLayout !== value) {
            this._contentLayout = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          if (this._contentLayout) {
            return this._contentLayout;
          }

          return !this.hideSearchButton ? '12,12,12,10' : '12';
        }
      }]);

      return NxPageSearchComponent;
    }();

    NxPageSearchComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-page-search',
        template: "<div class=\"nx-pagesearch\">\n  <div nxLayout=\"grid\">\n    <div nxRow>\n      <div [nxCol]=\"contentLayout\" class=\"nx-pagesearch--content\">\n        <ng-content></ng-content>\n      </div>\n      <div [nxCol]=\"buttonLayout\" *ngIf=\"!hideSearchButton\" class=\"nx-pagesearch__actions\">\n        <button nxButton=\"primary medium\" (click)=\"onButtonClick()\">{{buttonLabel}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [".nx-pagesearch{padding:32px 0;background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5)}.nx-pagesearch ::ng-deep .nx-formfield__wrapper{padding-bottom:0}.nx-pagesearch ::ng-deep .c-input{font-size:30px;font-weight:300;line-height:32px;height:auto}.nx-pagesearch ::ng-deep .nx-formfield__prefix{color:#007ab3}.nx-pagesearch ::ng-deep button{margin:0}.nx-pagesearch ::ng-deep .nx-icon--auto{font-size:24px}.nx-pagesearch .nx-pagesearch__actions{display:flex;align-items:center}"]
      }]
    }];
    /** @nocollapse */

    NxPageSearchComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxPageSearchComponent.propDecorators = {
      buttonClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxButtonClick']
      }],
      buttonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxButtonLabel']
      }],
      hideSearchButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxHideSearchButton']
      }],
      buttonLayout: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxButtonLayout']
      }],
      contentLayout: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxContentLayout']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPageSearchModule = function NxPageSearchModule() {
      _classCallCheck(this, NxPageSearchModule);
    };

    NxPageSearchModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_autocomplete__WEBPACK_IMPORTED_MODULE_10__["NxAutocompleteModule"], _allianz_ngx_ndbx_formfield__WEBPACK_IMPORTED_MODULE_11__["NxFormfieldModule"], _allianz_ngx_ndbx_button__WEBPACK_IMPORTED_MODULE_12__["NxButtonModule"], _allianz_ngx_ndbx_grid__WEBPACK_IMPORTED_MODULE_9__["NxGridModule"]],
        declarations: [NxPageSearchComponent],
        exports: [NxPageSearchComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxRatingComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxRatingComponent(_changeDetectorRef) {
        _classCallCheck(this, NxRatingComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._value = 0;
        this._disabled = false;
        this._negative = false;
        this._startLabel = null;
        this._endLabel = null;
        this._ariaLabel = ['1/5', '2/5', '3/5', '4/5', '5/5'];
        /**
         * An event is dispatched each time when the rating changes.
         */

        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();

        this.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};

        this.onChangeCallback =
        /**
        * @param {?} option
        * @return {?}
        */
        function (option) {};
      }
      /**
       * Sets the selected rating 1 - 5.
       * @param {?} newValue
       * @return {?}
       */


      _createClass(NxRatingComponent, [{
        key: "isSelected",

        /**
         * Whether the given rating is selected.
         * @param {?} index
         * @return {?}
         */
        value: function isSelected(index) {
          return index <= this.value;
        }
        /**
         * Allows to set the rating.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setSelection",
        value: function setSelection(value) {
          if (!this.disabled) {
            this.value = value;
            this.valueChange.emit(value);
            this.onTouchedCallback();
            this.onChangeCallback(this.value);
          }
        }
        /**
         * \@docs-private
         * @param {?} event
         * @param {?} rating
         * @return {?}
         */

      }, {
        key: "handleKeyUp",
        value: function handleKeyUp(event, rating) {
          /** @type {?} */
          var keyCode = event.keyCode;
          event.preventDefault();
          event.stopPropagation();

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"]) {
            this.setSelection(rating);
          }

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["RIGHT_ARROW"]) {
            this.value = Math.min(this.value + 1, 5);
            /** @type {?} */

            var elementRef = this.icons.toArray()[this.value - 1];
            elementRef.nativeElement.focus();
          }

          if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["LEFT_ARROW"]) {
            this.value = Math.max(this.value - 1, 1);
            /** @type {?} */

            var _elementRef2 = this.icons.toArray()[this.value - 1];

            _elementRef2.nativeElement.focus();
          }
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.value = value;
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(callback) {
          this.onChangeCallback = callback;
        }
        /**
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(callback) {
          this.onTouchedCallback = callback;
        }
        /**
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */

      }, {
        key: "getAriaLabel",
        value: function getAriaLabel(rating) {
          return this.ariaLabel[rating - 1];
        }
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */

      }, {
        key: "getIconName",
        value: function getIconName(rating) {
          return 'star' + (!this.isSelected(rating) ? '-o' : '');
        }
      }, {
        key: "value",
        set: function set(newValue) {
          this._value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceNumberProperty"])(newValue);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._value;
        }
        /**
         * Whether the rating component should be disabled.
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(newValue) {
          if (this._disabled === newValue) {
            return;
          }

          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(newValue);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
        /**
         * Whether the negative colors be used.
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(newValue) {
          if (this._negative === newValue) {
            return;
          }

          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(newValue);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Sets the label painted at the start of the rating component.
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "startLabel",
        set: function set(newValue) {
          this._startLabel = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._startLabel;
        }
        /**
         * Sets the label painted at the end of the rating component.
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "endLabel",
        set: function set(newValue) {
          this._endLabel = newValue;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._endLabel;
        }
        /**
         * @param {?} newAriaLabels
         * @return {?}
         */

      }, {
        key: "ariaLabel",
        set: function set(newAriaLabels) {
          this._ariaLabel = newAriaLabels;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._ariaLabel;
        }
      }]);

      return NxRatingComponent;
    }();

    NxRatingComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-rating',
        template: "  <div class=\"nx-rating__container\" role=\"radiogroup\">\n    <nx-icon *ngFor=\"let rating of [1,2,3,4,5]\"\n      (click)=\"setSelection(rating)\"\n      (keyup)=\"handleKeyUp($event, rating)\"\n      role=\"radio\"\n      [attr.aria-label]=\"getAriaLabel(rating)\"\n      [attr.aria-checked]=\"isSelected(rating)\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      class=\"nx-rating__icon\"\n      [name]=\"getIconName(rating)\"\n      size=\"m\">\n    </nx-icon>\n  </div>\n  <div class=\"nx-rating__label\" *ngIf=\"startLabel || endLabel\">\n    <span class=\"nx-rating__label--start\">{{startLabel}}</span>\n    <span class=\"nx-rating__label--end\">{{endLabel}}</span>\n  </div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return NxRatingComponent;
          }),
          multi: true
        }],
        host: {
          '[class.nx-rating--negative]': 'negative',
          '[class.nx-rating--disabled]': 'disabled'
        },
        styles: [":host{display:inline-block}:host(.nx-rating--negative){color:#fff}:host(.nx-rating--disabled){cursor:not-allowed;color:#c2c2c2;outline:0}:host(.nx-rating--disabled) .nx-rating__label{color:#c2c2c2}:host(.nx-rating--disabled) .nx-rating__icon{cursor:not-allowed}.nx-rating__container{display:flex}.nx-rating__label{display:flex;font-size:16px}.nx-rating__label--end{margin-left:auto}.nx-rating__icon{font-size:40px;width:auto;height:40px;background:0 0;border:none;margin-right:16px;cursor:pointer;outline:0}.nx-rating__icon:last-child{margin-right:0}:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
      }]
    }];
    /** @nocollapse */

    NxRatingComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxRatingComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisabled']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxNegative']
      }],
      startLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStartLabel']
      }],
      endLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxEndLabel']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAriaLabel']
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxValueChange']
      }],
      icons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChildren"],
        args: [_allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconComponent"], {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxRatingModule = function NxRatingModule() {
      _classCallCheck(this, NxRatingModule);
    };

    NxRatingModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        declarations: [NxRatingComponent],
        exports: [NxRatingComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxNumberStepperIntl = function NxNumberStepperIntl() {
      _classCallCheck(this, NxNumberStepperIntl);

      /**
       * Stream that emits whenever the labels here are changed. Use this to notify
       * components if the labels have changed after initialization.
       */
      this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
      /**
       * The aria label for the decrement '-' button
       */

      this.decrementAriaLabel = 'Decrement';
      /**
       * The aria label for the increment '+' button
       */

      this.incrementAriaLabel = 'Increment';
    };

    NxNumberStepperIntl.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxAutoResizeDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       * @param {?} _renderer
       * @param {?} _cdr
       */
      function NxAutoResizeDirective(_element, _renderer, _cdr) {
        _classCallCheck(this, NxAutoResizeDirective);

        this._element = _element;
        this._renderer = _renderer;
        this._cdr = _cdr;
        this._resize = true;
        this.updateInputWidth = this.updateInputWidth.bind(this);
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(NxAutoResizeDirective, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          if (this.resize) {
            this._addEventListener();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._removeEventListener();
        }
        /**
         * @return {?}
         */

      }, {
        key: "updateInputWidth",
        value: function updateInputWidth() {
          /** @type {?} */
          var measureCanvas = this._renderer.createElement('canvas');
          /** @type {?} */


          var ctx = measureCanvas.getContext('2d');
          /** @type {?} */

          var styles = window.getComputedStyle(this._element.nativeElement);
          ctx.font = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["getFontShorthand"])(styles);
          /** @type {?} */

          var metrics = ctx.measureText(this._element.nativeElement.value);
          /** @type {?} */

          var padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
          /** @type {?} */

          var border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth); // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut

          /** @type {?} */

          var newWidth = metrics.width + padding + border + 16; // Limit to own given minimal width

          /** @type {?} */

          var parsed = parseFloat(styles.minWidth);
          this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth); // needed when the outer component is onPush

          this._cdr.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_addEventListener",
        value: function _addEventListener() {
          this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);

          this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "_removeEventListener",
        value: function _removeEventListener() {
          this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);

          this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
        }
        /**
         * @param {?} left
         * @param {?} right
         * @return {?}
         */

      }, {
        key: "sumStyles",
        value: function sumStyles(left, right) {
          left = parseInt(left, 10);
          right = parseInt(right, 10);
          left = Number.isNaN(left) ? 0 : left;
          right = Number.isNaN(right) ? 0 : right;
          return left + right;
        }
      }, {
        key: "resize",
        set: function set(value) {
          this._resize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._resize) {
            this._addEventListener();

            this.updateInputWidth();
          } else {
            this._removeEventListener();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._resize;
        }
      }]);

      return NxAutoResizeDirective;
    }();

    NxAutoResizeDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: 'input[nxAutoResize]'
      }]
    }];
    /** @nocollapse */

    NxAutoResizeDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxAutoResizeDirective.propDecorators = {
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostBinding"],
        args: ['style.width.px']
      }],
      resize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxAutoResize']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var SIZE_MAPPING = {
      big: 'nx-stepper--big',
      normal: ''
    };
    /** @type {?} */

    var STYLE_MAPPING = {
      regular: '',
      bold: 'nx-stepper__input--bold',
      light: 'nx-stepper__input--light'
    };
    /** @type {?} */

    var DEFAULT_CLASSES$1 = ['nx-stepper'];
    /** @type {?} */

    var INPUT_CLASSES = ['nx-stepper__input'];
    /** @type {?} */

    var ALLOWED_CHARACTERS = new RegExp(/^-?[0-9]\d*(\.\d+)?$/g);
    /** @type {?} */

    var CUSTOM_VALUE_ACCESSOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALUE_ACCESSOR"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
      /**
      * @return {?}
      */
      function () {
        return NxNumberStepperComponent;
      }),
      multi: true
    };
    /** @type {?} */

    var CUSTOM_VALIDATOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__["NG_VALIDATORS"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_31__["forwardRef"])(
      /**
      * @return {?}
      */
      function () {
        return NxNumberStepperComponent;
      }),
      multi: true
    };
    /** @type {?} */

    var nextUniqueId = 0;

    var NxNumberStepperComponent =
    /*#__PURE__*/
    function (_allianz_ngx_ndbx_cor2) {
      _inherits(NxNumberStepperComponent, _allianz_ngx_ndbx_cor2);

      /**
       * @param {?} _changeDetectorRef
       * @param {?} _renderer
       * @param {?} _elementRef
       * @param {?} _intl
       */
      function NxNumberStepperComponent(_changeDetectorRef, _renderer, _elementRef, _intl) {
        var _this90;

        _classCallCheck(this, NxNumberStepperComponent);

        _this90 = _possibleConstructorReturn(this, _getPrototypeOf(NxNumberStepperComponent).call(this, SIZE_MAPPING, DEFAULT_CLASSES$1, _elementRef, _renderer));
        _this90._changeDetectorRef = _changeDetectorRef;
        _this90._intl = _intl;
        _this90._step = 1;
        _this90._min = 0;
        _this90._max = 100;
        _this90._value = 0;
        _this90._label = null;
        _this90._resize = false;
        _this90._negative = false;
        _this90._leadingZero = true;
        /**
         * \@docs-private
         */

        _this90.inputClassNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])('regular', INPUT_CLASSES, STYLE_MAPPING);
        /**
         * \@docs-private
         */

        _this90.inputId = "nx-number-stepper-".concat(nextUniqueId++);
        /**
         * \@docs-private
         */

        _this90.ariaDescribedBy = null;
        /**
         * An event emitted on value change.
         */

        _this90.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();

        _this90.onChangeCallback =
        /**
        * @param {?} _
        * @return {?}
        */
        function (_) {};

        _this90.onTouchedCallback =
        /**
        * @return {?}
        */
        function () {};

        _this90._intlSubscription = _this90._intl.changes.subscribe(
        /**
        * @return {?}
        */
        function () {
          return _this90._changeDetectorRef.markForCheck();
        });
        return _this90;
      }
      /**
       * Whether the input should be resized. Default: false
       * @param {?} value
       * @return {?}
       */


      _createClass(NxNumberStepperComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this.setInputValue(this._value);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this91 = this;

          // defer to prevent checked after change errors
          if (this.resize) {
            setTimeout(
            /**
            * @return {?}
            */
            function () {
              return _this91.triggerResize();
            });
          }

          if (this.ngContentWrapper) {
            this.ariaDescribedBy = this.ngContentWrapper.nativeElement.children.length > 0 ? "label-for-".concat(this.inputId) : null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._intlSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setInputValue",
        value: function setInputValue(value) {
          if (this.leadingZero) {
            this.numberInput.nativeElement.value = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["pad"])(value.toString(), 2);
          } else {
            this.numberInput.nativeElement.value = value.toString();
          }
        }
        /* ControlValueAccessor Implementations */

        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.value = value;
        }
        /**
         * @param {?} onChange
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(onChange) {
          this.onChangeCallback = onChange;
        }
        /**
         * @param {?} onTouched
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(onTouched) {
          this.onTouchedCallback = onTouched;
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInputChange",
        value: function onInputChange(event) {
          if (!this.validateUserInput(event.target.value)) {
            this._value = null;
          } else {
            this._value = Number(event.target.value);
          }

          this.valueChange.emit(this._value);
          this.onChangeCallback(this._value);
        }
        /**
         * \@docs-private
         * @param {?} input
         * @return {?}
         */

      }, {
        key: "validateUserInput",
        value: function validateUserInput(input) {
          return !!input.match(ALLOWED_CHARACTERS);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "increment",
        value: function increment() {
          /** @type {?} */
          var newValue;

          if (this.isBetweenLimits(this._value)) {
            newValue = this.getNextGreaterValue(this._value);
          } else {
            newValue = this.enforceLimits(this._value);
          }

          this.value = newValue;
          this.valueChange.emit(this._value);
          this.onChangeCallback(this._value);
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "triggerResize",
        value: function triggerResize() {
          if (this.resize) {
            this.autoResize.updateInputWidth();

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "decrement",
        value: function decrement() {
          /** @type {?} */
          var newValue;

          if (this.isBetweenLimits(this._value)) {
            newValue = this.getNextLowerValue(this._value);
          } else {
            newValue = this.enforceLimits(this._value);
          }

          this.value = newValue;
          this.valueChange.emit(this._value);
          this.onChangeCallback(this._value);
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "enforceLimits",
        value: function enforceLimits(value) {
          if (value > this._max) {
            return this._max;
          } else if (value < this._min) {
            return this._min;
          }

          return value;
        }
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */

      }, {
        key: "getNextLowerValue",
        value: function getNextLowerValue(start) {
          // if there is an invalid input start is null
          if (!start) {
            start = 0;
          }
          /** @type {?} */


          var next;

          if (this.isValidStep(start)) {
            next = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](start).minus(new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](this._step)).toNumber();
          } else {
            next = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](start).toNearest(this._step, decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"].ROUND_DOWN).toNumber();
          }

          return this.enforceLimits(next);
        }
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */

      }, {
        key: "getNextGreaterValue",
        value: function getNextGreaterValue(start) {
          /** @type {?} */
          var next;

          if (!start) {
            start = 0;
          }

          if (this.isValidStep(start)) {
            next = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](start).plus(new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](this._step)).toNumber();
          } else {
            next = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](start).toNearest(this._step, decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"].ROUND_UP).toNumber();
          }

          return this.enforceLimits(next);
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isBetweenLimits",
        value: function isBetweenLimits(value) {
          return value <= this._max && value >= this._min;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isMinimum",
        value: function isMinimum() {
          return this._value === this._min;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isMaximum",
        value: function isMaximum() {
          return this._value === this._max;
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isValidStep",
        value: function isValidStep(value) {
          if (value === null) {
            value = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](0);
          }
          /** @type {?} */


          var min = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](this._min);
          /** @type {?} */

          var valueDec = new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](value);
          /** @type {?} */

          var checkValue = min.minus(valueDec).mod(new decimal_js__WEBPACK_IMPORTED_MODULE_15__["Decimal"](this._step)).toNumber();

          if (this.isBetweenLimits(value) && (this.isMinimum() || this.isMaximum() || checkValue === 0)) {
            return true;
          }

          return false;
        }
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "userInputToNumber",
        value: function userInputToNumber(value) {
          /** @type {?} */
          var current = value === '' ? 0 : value;
          return parseInt(current, 10);
        }
        /**
         * @return {?}
         */

      }, {
        key: "_validateFn",
        value: function _validateFn() {
          // the manual user input must match min + n * step, e.g. minimum 1 step 2: 1, 3, 5, 7 etc.
          if (!this.isValidStep(this._value)) {
            return {
              nxNumberStepperStepError: 'Value is not a valid step'
            };
          } else if (this._value === null) {
            return {
              nxNumberStepperFormatError: 'Not a valid number'
            };
          }

          return null;
        }
        /**
         * \@docs-private
         * @param {?} c
         * @return {?}
         */

      }, {
        key: "validate",
        value: function validate(c) {
          return this._validateFn();
        }
        /**
         * @return {?}
         */

      }, {
        key: "resize",
        set: function set(value) {
          this._resize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._resize;
        }
        /**
         * @return {?}
         */

      }, {
        key: "label",
        get: function get() {
          return this._label;
        }
        /**
         * Defines the the label shown above the stepper input.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._label !== value) {
            this._label = value;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "style",
        get: function get() {
          return this._style;
        }
        /**
         * Defines the font weight of the input.
         *
         * Possible values: regular, bold, light. Default value: regular
         *
         * @deprecated The style input is not available anymore, only default font-weight should be used.
         * \@deletion-target 8.0.0
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._style === value) {
            return;
          }

          this._style = value;
          this.inputClassNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])(value, INPUT_CLASSES, STYLE_MAPPING);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Sets the step size. Default: 1
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "step",
        set: function set(value) {
          // only internal changes no need to call markForCheck
          this._step = Number(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._step;
        }
        /**
         * Sets the minimum accepted number. Default: 0
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "min",
        set: function set(value) {
          this._min = Number(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._min;
        }
        /**
         * Sets the maximum accepted number. Default: 100
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "max",
        set: function set(value) {
          this._max = Number(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._max;
        }
        /**
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * Sets the value of the number-stepper.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._value = value;

          if (this._value !== null) {
            this.setInputValue(this._value);
          } else {
            this.setInputValue(0);
          }

          this.triggerResize();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Whether the negative set of styling should be used.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          if (this._negative !== value) {
            this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Whether the number stepper value should have a leading zero.
         *
         * Default value is true.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "leadingZero",
        set: function set(value) {
          if (this._leadingZero !== value) {
            this._leadingZero = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
            this.setInputValue(this.value);
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._leadingZero;
        }
      }, {
        key: "_buttonType",
        get: function get() {
          return 'secondary' + (this.negative ? ' negative' : '');
        }
      }]);

      return NxNumberStepperComponent;
    }(_allianz_ngx_ndbx_core__WEBPACK_IMPORTED_MODULE_14__["MappedStyles"]);

    NxNumberStepperComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-number-stepper',
        template: "<div *ngIf=\"label\" class=\"nx-stepper__label\">\n  <label [for]=\"inputId\">\n    {{label}}\n  </label>\n</div>\n<div #customLabel *ngIf=\"!label\" [id]=\"ariaDescribedBy\">\n  <ng-content></ng-content>\n</div>\n<div class=\"nx-stepper__input-container\">\n  <button\n    [attr.aria-label]=\"_intl.decrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__down nx-stepper__control\"\n    (click)=\"decrement()\"\n    [disabled]=\"value <= min\">\n    <nx-icon name=\"minus\" size=\"s\"></nx-icon>\n  </button>\n  <div class=\"nx-stepper__input-wrapper\">\n    <div class=\"nx-stepper__inner-wrapper\">\n        <ng-content select=\"nx-number-stepper-prefix\"></ng-content>\n\n        <input #numberInput [nxAutoResize]=\"resize\"\n        [attr.aria-describedby]=\"ariaDescribedBy\"\n        [id]=\"inputId\" [ngClass]=\"inputClassNames\"\n        (input)=\"onInputChange($event)\"\n        (keydown.arrowup)=\"increment()\"\n        (keydown.arrowdown)=\"decrement()\"/>\n\n        <ng-content select=\"nx-number-stepper-suffix\"></ng-content>\n    </div>\n    <div class=\"nx-stepper__input-underline\"></div>\n  </div>\n\n  <button\n    [attr.aria-label]=\"_intl.incrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__up nx-stepper__control\"\n    (click)=\"increment()\"\n    [disabled]=\"value >= max\">\n    <nx-icon name=\"plus\" size=\"s\"></nx-icon>\n  </button>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        inputs: ['classNames: nxSize'],
        host: {
          '[class.is-negative]': 'negative'
        },
        providers: [CUSTOM_VALUE_ACCESSOR, CUSTOM_VALIDATOR],
        styles: [":host{display:block}:host input{padding:0}.nx-stepper__input-container{align-items:flex-end;display:flex;margin-top:12px}.nx-stepper__label{display:flex;font-size:20px;line-height:28px}.nx-stepper__control{width:32px;height:32px;min-height:32px;font-size:24px;margin:0;padding:0}.nx-stepper__control:disabled{background-color:rgba(255,255,255,.4);border-color:#006192;color:#006192;opacity:.4}.nx-stepper__input{width:56px;min-width:56px}.nx-stepper__input,::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix{background:0 0;outline:0;border:0;text-align:center;color:#414141;font-size:20px;line-height:28px;height:28px}::ng-deep .nx-stepper__suffix{margin-left:4px}::ng-deep .nx-stepper__prefix{margin-right:4px}.nx-stepper__input-wrapper{display:flex;align-items:center;flex-direction:column;margin:0 16px}.nx-stepper__inner-wrapper{height:28px;display:flex;align-items:baseline}.nx-stepper__input-underline{width:100%;margin-top:2px;height:2px;background:#414141}:host.nx-stepper--big .nx-stepper__control{width:72px;min-height:48px;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input{width:72px;min-width:72px}:host.nx-stepper--big .nx-stepper__input,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{color:#414141;font-size:40px;line-height:48px;height:48px;letter-spacing:.3px;padding:0;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input-wrapper{margin:0 24px}:host.nx-stepper--big .nx-stepper__input-underline{margin-top:-2px}:host.nx-stepper--big .nx-stepper__inner-wrapper{height:48px}:host.is-negative .nx-stepper__label{color:#fff}:host.is-negative .nx-stepper__input{color:#fff}:host.is-negative .nx-stepper__input-underline{background:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxNumberStepperComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: NxNumberStepperIntl
      }];
    };

    NxNumberStepperComponent.propDecorators = {
      numberInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['numberInput']
      }],
      ngContentWrapper: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['customLabel']
      }],
      autoResize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [NxAutoResizeDirective]
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"],
        args: ['nxValueChange']
      }],
      resize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxResize']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxLabel']
      }],
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStyle']
      }],
      step: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStep']
      }],
      min: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxMin']
      }],
      max: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxMax']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxValue']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      leadingZero: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Directive used to pass a suffix to the number stepper.
     */

    var NxNumberStepperPrefixDirective = function NxNumberStepperPrefixDirective() {
      _classCallCheck(this, NxNumberStepperPrefixDirective);
    };

    NxNumberStepperPrefixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-number-stepper-prefix',
        host: {
          'class': 'nx-stepper__prefix'
        }
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Directive used to pass a suffix to the number stepper.
     */

    var NxNumberStepperSuffixDirective = function NxNumberStepperSuffixDirective() {
      _classCallCheck(this, NxNumberStepperSuffixDirective);
    };

    NxNumberStepperSuffixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-number-stepper-suffix',
        host: {
          'class': 'nx-stepper__suffix'
        }
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxNumberStepperModule = function NxNumberStepperModule() {
      _classCallCheck(this, NxNumberStepperModule);
    };

    NxNumberStepperModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_allianz_ngx_ndbx_input__WEBPACK_IMPORTED_MODULE_13__["NxInputModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_16__["FormsModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"], _allianz_ngx_ndbx_button__WEBPACK_IMPORTED_MODULE_12__["NxButtonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"]],
        exports: [NxNumberStepperComponent, NxAutoResizeDirective, NxNumberStepperPrefixDirective, NxNumberStepperSuffixDirective],
        declarations: [NxNumberStepperComponent, NxAutoResizeDirective, NxNumberStepperPrefixDirective, NxNumberStepperSuffixDirective],
        providers: [NxNumberStepperIntl]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DefaultPaginationTexts = {
      previous: 'Previous',
      next: 'Next',
      first: 'First',
      last: 'Last',
      ofLabel: 'of',
      ariaLabel: 'Please select your page'
    };
    /**
     * InjectionToken for pagination that can be used to override default locale code.
     * @type {?}
     */

    var NX_PAGINATION_TEXTS = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["InjectionToken"]('nx-pagination-texts');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxPaginationUtils =
    /*#__PURE__*/
    function () {
      function NxPaginationUtils() {
        _classCallCheck(this, NxPaginationUtils);

        this._pagesToShow = 3;
        this._elipsisText = '...';
        this._classExpanded = 'expanded-view';
      }
      /**
       * @param {?} currentPage
       * @param {?} totalPages
       * @return {?}
       */


      _createClass(NxPaginationUtils, [{
        key: "getPages",
        value: function getPages(currentPage, totalPages) {
          /** @type {?} */
          var pages = [];
          /** @type {?} */

          var start = [];
          /** @type {?} */

          var middle = [];
          /** @type {?} */

          var end = []; // First array -> start

          start = this.getStartArray(currentPage, totalPages); // Second array -> middle

          middle = this.getMiddleArray(currentPage, totalPages); // Third array -> end

          end = this.getEndArray(currentPage, totalPages);
          pages = [].concat(_toConsumableArray(start), _toConsumableArray(middle), _toConsumableArray(end));
          return pages;
        }
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */

      }, {
        key: "getMiddleArray",
        value: function getMiddleArray(currentPage, totalPages) {
          /** @type {?} */
          var pageNumber = currentPage < 6 ? 4 : currentPage - 1;
          /** @type {?} */

          var middle = [];

          while (middle.length < 3 && pageNumber >= 2 && pageNumber <= totalPages - 3 && pageNumber <= currentPage + 1 && pageNumber >= currentPage - 1) {
            middle.push(this.createPaginationItem(pageNumber, pageNumber));
            pageNumber++;
          }

          return middle;
        }
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */

      }, {
        key: "getEndArray",
        value: function getEndArray(currentPage, totalPages) {
          /** @type {?} */
          var end = [];
          /** @type {?} */

          var currentItemToShow = totalPages <= 3 ? totalPages + 1 : totalPages <= 6 ? totalPages - (totalPages - 4) : totalPages - 2;
          /** @type {?} */

          var showEllipsis = currentPage < totalPages - 4;

          while (currentItemToShow <= totalPages) {
            /** @type {?} */
            var endItem = end.length === 0 && showEllipsis ? this.createPaginationItem(this._elipsisText, currentItemToShow, true) : this.createPaginationItem(currentItemToShow, currentItemToShow, true);
            end.push(endItem);
            currentItemToShow++;
          }

          return end;
        }
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */

      }, {
        key: "getStartArray",
        value: function getStartArray(currentPage, totalPages) {
          /** @type {?} */
          var counterPages = 0;
          /** @type {?} */

          var start = [];
          /** @type {?} */

          var maxSizeArray = 3;

          while (counterPages < maxSizeArray && counterPages < totalPages) {
            /** @type {?} */
            var startItem = counterPages === 2 && currentPage > 5 ? this.createPaginationItem(this._elipsisText, counterPages, true) : this.createPaginationItem(counterPages + 1, counterPages + 1, true);
            start.push(startItem);
            counterPages++;
          }

          return start;
        }
        /**
         * @private
         * @param {?} label
         * @param {?} value
         * @param {?=} classExpanded
         * @return {?}
         */

      }, {
        key: "createPaginationItem",
        value: function createPaginationItem(label, value, classExpanded) {
          return {
            label: label,
            value: value,
            class: classExpanded ? this._classExpanded : ''
          };
        }
      }]);

      return NxPaginationUtils;
    }();

    NxPaginationUtils.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPaginationComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} paginationTexts
       * @param {?} paginationUtilsService
       * @param {?} _changeDetectorRef
       */
      function NxPaginationComponent(paginationTexts, paginationUtilsService, _changeDetectorRef) {
        _classCallCheck(this, NxPaginationComponent);

        this.paginationUtilsService = paginationUtilsService;
        this._changeDetectorRef = _changeDetectorRef;
        this._type = 'simple';
        /**
         * \@docs-private
         */

        this.totalNumberPages = 0;
        /**
         * An event emitted when the previous page button is clicked.
         */

        this.nxGoPrev = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event emitted when the next page button is clicked
         */

        this.nxGoNext = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event emitted when a page number is clicked.
         * Provides the number of the page as parameter.
         */

        this.nxGoPage = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this.paginationTexts = paginationTexts || DefaultPaginationTexts;
      }
      /**
       * @return {?}
       */


      _createClass(NxPaginationComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this.totalNumberPages = this.calculateTotalPages();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          if (this.type === 'advanced' && (!this.paginationTexts.last || !this.paginationTexts.first)) {
            console.warn('Please define aria labels for the last and first arrows.');
          }
        }
        /**
         * Returns the number of the first page.
         * @return {?}
         */

      }, {
        key: "getMin",
        value: function getMin() {
          return this._perPage * this._page - this._perPage + 1;
        }
        /**
         * Returns the number of the last page.
         * @return {?}
         */

      }, {
        key: "getMax",
        value: function getMax() {
          /** @type {?} */
          var max = this._perPage * this._page;

          if (max > this._count) {
            max = this._count;
          }

          return max;
        }
        /**
         * Returns the total number of pages
         * @return {?}
         */

      }, {
        key: "calculateTotalPages",
        value: function calculateTotalPages() {
          return Math.ceil(this._count / this._perPage) || 0;
        }
        /**
         * Directs to the page with number n.
         * @param {?} n
         * @return {?}
         */

      }, {
        key: "onPage",
        value: function onPage(n) {
          this.nxGoPage.emit(n);
        }
        /**
         * Directs to the previous page.
         * @return {?}
         */

      }, {
        key: "onPrev",
        value: function onPrev() {
          if (!this._isPaginationPreviousDisabled()) {
            this.nxGoPrev.emit();
          }
        }
        /**
         * Directs to the next page.
         * @return {?}
         */

      }, {
        key: "onNext",
        value: function onNext() {
          if (!this._isPaginationNextDisabled()) {
            this.nxGoNext.emit();
          }
        }
        /**
         * Directs to the first page.
         * @return {?}
         */

      }, {
        key: "onFirst",
        value: function onFirst() {
          if (!this._isPaginationPreviousDisabled()) {
            this.onPage(1);
          }
        }
        /**
         * Directs to the last page.
         * @return {?}
         */

      }, {
        key: "onLast",
        value: function onLast() {
          if (!this._isPaginationNextDisabled()) {
            this.onPage(this.totalNumberPages);
          }
        }
        /**
         * Returns if the current page is the last page.
         * @return {?}
         */

      }, {
        key: "lastPage",
        value: function lastPage() {
          return this._perPage * this._page >= this._count;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getPages",
        value: function getPages() {
          return this.paginationUtilsService.getPages(this._page, this.totalNumberPages);
        }
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */

      }, {
        key: "getPaginationItemClasses",
        value: function getPaginationItemClasses(page) {
          /** @type {?} */
          var classes = {
            'is-ellipsis': page.label === '...',
            'nx-pagination__item--expanded-view': page.class === 'expanded-view'
          };
          return classes;
        }
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */

      }, {
        key: "getPaginationNumberClasses",
        value: function getPaginationNumberClasses(page) {
          /** @type {?} */
          var classes = {
            'is-active': page.value === this.page,
            'nx-pagination__ellipsis': page.label === '...',
            'nx-pagination__link': page.label !== '...'
          };
          return classes;
        }
        /**
         * Returns true, if `nxCount` is greater than 0, else false.
         * @return {?}
         */

      }, {
        key: "isPaginationVisible",
        value: function isPaginationVisible() {
          return this.count > 0;
        }
        /**
         * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
         * @return {?}
         */

      }, {
        key: "isPaginationCompactVisible",
        value: function isPaginationCompactVisible() {
          return this.type.includes('simple') && this.count > 0;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isPaginationContainerVisible",
        value: function isPaginationContainerVisible() {
          return this.type.includes('advanced');
        }
        /**
         * @return {?}
         */

      }, {
        key: "_isPaginationPreviousDisabled",
        value: function _isPaginationPreviousDisabled() {
          return this.page === this.getMin();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_isPaginationNextDisabled",
        value: function _isPaginationNextDisabled() {
          return this.page === this.totalNumberPages;
        }
      }, {
        key: "page",
        get: function get() {
          return this._page;
        }
        /**
         * Sets the current page.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._page = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "count",
        get: function get() {
          return this._count;
        }
        /**
         * Number of total items over all pages.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._count = value;
          this.totalNumberPages = this.calculateTotalPages();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "perPage",
        get: function get() {
          return this._perPage;
        }
        /**
         * Sets the number of items you want to show per page.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._perPage = value;
          this.totalNumberPages = this.calculateTotalPages();

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          return this._type;
        }
        /**
         * Determines the type of pagination.
         *
         * Values: simple | advanced, default: simple.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._type = value;

          this._changeDetectorRef.markForCheck();
        }
      }]);

      return NxPaginationComponent;
    }();

    NxPaginationComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-pagination',
        template: "<nav *ngIf=\"isPaginationVisible()\"  aria-label=\"Page navigation\" class=\"nx-pagination\" >\n  <ul *ngIf=\"isPaginationContainerVisible()\"  [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination__container\">\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.first\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--first\"\n        (click)=\"onFirst()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-first\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-previous\">\n      <button\n        [attr.aria-label]=\"paginationTexts.previous\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--previous\"\n        (click)=\"onPrev()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n      </button>\n    </li>\n    <li *ngFor=\"let pageNum of getPages()\" class=\"nx-pagination__item\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        *ngIf=\"pageNum.label !== '...'\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-curent]=\"pageNum.value === page\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n      <span *ngIf=\"pageNum.label === '...'\">\n        {{ pageNum.label }}\n      </span>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-next\">\n      <button\n        [attr.aria-label]=\"paginationTexts.next\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--next\"\n        (click)=\"onNext()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.last\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--last\"\n        (click)=\"onLast()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-last\"></nx-icon>\n      </button>\n    </li>\n  </ul>\n</nav>\n<nav *ngIf=\"isPaginationCompactVisible()\" [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination-compact\" >\n  <button [attr.aria-label]=\"paginationTexts.previous\"\n    class=\"nx-pagination-compact__previous\"\n    [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n    [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n\n    (click)=\"onPrev()\">\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n    <span class=\"nx-pagination-compact__direction-label\">\n      {{ paginationTexts.previous }}\n    </span>\n  </button>\n  <div class=\"nx-pagination-compact__display\">\n      <span class=\"nx-pagination-compact__current-page\">{{ page }}</span>\n      <span class=\"nx-pagination-compact__page-separator\"> {{ paginationTexts.ofLabel }} </span>\n      <span class=\"nx-pagination-compact__total-pages\">{{ totalNumberPages }}</span>\n  </div>\n  <button\n    class=\"nx-pagination-compact__next\"\n    [class.is-disabled]=\"_isPaginationNextDisabled()\"\n    [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n    [attr.aria-label]=\"paginationTexts.next\"\n    (click)=\"onNext()\">\n    <span class=\"nx-pagination-compact__direction-label\"> {{ paginationTexts.next }} </span>\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n  </button>\n</nav>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host button:focus{outline:0}:host button::-moz-focus-inner{border:0}.nx-pagination__container{display:flex;font-size:16px;margin:8px 0;padding:0}@media (min-width:704px){.nx-pagination__container{margin:8px 0 40px}}.nx-pagination__item{margin:0 16px;list-style:none}.nx-pagination__item:first-child,.nx-pagination__item:last-child{margin:0}.nx-pagination__item.is-ellipsis{font-weight:700}.nx-pagination__item--expanded-view{display:block}.nx-pagination__link{color:#006192;font-weight:600;padding:0;text-decoration:none;background-color:#fff;border:0;cursor:pointer}.nx-pagination__link.is-active{color:#414141;font-weight:700;cursor:default}nx-icon.nx-pagination__arrow{font-size:24px}.nx-pagination-compact{display:flex;font-size:16px;margin:16px 0;padding:0}@media (min-width:704px){.nx-pagination-compact{margin:40px 0}}.nx-pagination-compact__display{color:#414141;display:flex;line-height:24px}.nx-pagination-compact__current-page{font-weight:700;margin-right:8px}.nx-pagination-compact__total-pages{margin-left:8px}.nx-pagination-compact__next,.nx-pagination-compact__previous,.nx-pagination__arrow-first,.nx-pagination__arrow-last{color:#006192;font-weight:600;text-decoration:none;text-transform:uppercase;display:flex;align-items:center;padding:0;background-color:#fff;cursor:pointer;border:0}.nx-pagination-compact__previous{margin-right:32px}.nx-pagination-compact__next{margin-left:32px}.nx-pagination-compact__direction-label{display:block;letter-spacing:1px}.nx-pagination-compact__direction-label:first-child{margin-right:8px}.nx-pagination-compact__direction-label:last-child{margin-left:8px}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:rgba(0,97,146,.4);cursor:not-allowed}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-pagination__link--first,.nx-pagination__link--last,.nx-pagination__link--next,.nx-pagination__link--previous{display:flex;align-items:center}.nx-pagination__item-next{margin-right:8px}.nx-pagination__item-previous{margin-left:8px}"]
      }]
    }];
    /** @nocollapse */

    NxPaginationComponent.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [NX_PAGINATION_TEXTS]
        }]
      }, {
        type: NxPaginationUtils
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxPaginationComponent.propDecorators = {
      page: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPage']
      }],
      count: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxCount']
      }],
      perPage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxPerPage']
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxType']
      }],
      nxGoPrev: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      nxGoNext: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      nxGoPage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxPaginationModule = function NxPaginationModule() {
      _classCallCheck(this, NxPaginationModule);
    };

    NxPaginationModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        declarations: [NxPaginationComponent],
        exports: [NxPaginationComponent],
        providers: [NxPaginationUtils]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var TableDataSource =
    /*#__PURE__*/
    function (_angular_cdk_collecti) {
      _inherits(TableDataSource, _angular_cdk_collecti);

      /**
       * @param {?} _datachange
       */
      function TableDataSource(_datachange) {
        var _this92;

        _classCallCheck(this, TableDataSource);

        _this92 = _possibleConstructorReturn(this, _getPrototypeOf(TableDataSource).call(this));
        _this92._datachange = _datachange;
        return _this92;
      }
      /**
       * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
       * @return {?}
       */


      _createClass(TableDataSource, [{
        key: "connect",
        value: function connect() {
          return this._datachange;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "disconnect",
        value: function disconnect() {}
      }]);

      return TableDataSource;
    }(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__["DataSource"]);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var MAPPING$2 = {
      light: 'nx-table--light',
      border: 'nx-table--light nx-table--with-border'
    };
    /** @type {?} */

    var DEFAULT_CLASSES$2 = ['nx-table '];

    var NxDynamicTableComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} el
       * @param {?} _changeDetectorRef
       */
      function NxDynamicTableComponent(el, _changeDetectorRef) {
        _classCallCheck(this, NxDynamicTableComponent);

        this.el = el;
        this._changeDetectorRef = _changeDetectorRef;
        this._tableStyles = '';
        this._dataChange = new rxjs__WEBPACK_IMPORTED_MODULE_25__["BehaviorSubject"]([]);
        this._classNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])('', DEFAULT_CLASSES$2, MAPPING$2);
        /**
         * An event is dispatched when a row is clicked.
         */

        this.nxRowClick = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
      }
      /**
       * Sets the data that it will show in the table.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxDynamicTableComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          if (!this._data) {
            this._data = [];

            this._dataChange.next(this._data);
          }

          this._dataSource = new TableDataSource(this._dataChange);
        }
        /**
         * \@docs-private
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "handleRowClick",
        value: function handleRowClick(row) {
          this.nxRowClick.emit(row);
        }
        /**
         * \@docs-private
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "isNumeric",
        value: function isNumeric(element) {
          if (element.type === 'numeric') {
            return true;
          }

          return false;
        }
      }, {
        key: "data",
        set: function set(value) {
          this._data = value.filter(
          /**
          * @param {?} element
          * @return {?}
          */
          function (element) {
            return element;
          }); // If user dont pass displayedColumns the table will show all data and the name of columns will be the key of data

          if (!this._displayedColumns) {
            /** @type {?} */
            var keys = [];
            /** @type {?} */

            var cArray = []; // For catch keys of data Objects and assing title, key and type string by default to displayedColumns

            this._data.forEach(
            /**
            * @param {?} element
            * @return {?}
            */
            function (element) {
              for (var key in element) {
                if (keys.indexOf(key) === -1) {
                  keys.push(key);
                  cArray.push({
                    title: key,
                    key: key,
                    type: 'string'
                  });
                }
              }
            });

            this._columnKeys = keys;
            this._displayedColumns = cArray; // need to call markForCheck as the setter changes displayedColumns here
            // sidenote: isn't needed for the data itself as it gets passed to the cdk-table
            // by the datasource observable

            this._changeDetectorRef.markForCheck();
          }

          this._dataChange.next(this._data);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._data;
        }
        /**
         * Sets the name order and type of columns.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "displayedColumns",
        set: function set(value) {
          this._displayedColumns = value;
          this._columnKeys = value.map(
          /**
          * @param {?} column
          * @return {?}
          */
          function (column) {
            return column.key;
          });

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._displayedColumns;
        }
        /**
         * @deprecated The default and light header styling will be removed.
         * \@deletion-target 8.0.0
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "styles",
        set: function set(value) {
          if (this._tableStyles === value) {
            return;
          }

          this._classNames = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])(value, DEFAULT_CLASSES$2, MAPPING$2);
          this._tableStyles = value;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "dataSource",
        get: function get() {
          return this._dataSource;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "classNames",
        get: function get() {
          return this._classNames;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "columnKeys",
        get: function get() {
          return this._columnKeys;
        }
      }]);

      return NxDynamicTableComponent;
    }();

    NxDynamicTableComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-dynamic-table',
        template: "<div class=\"nx-table__container\" *ngIf=\"data && data.length > 0\">\n  <div class=\"nx-table__scroll\">\n    <cdk-table [dataSource]=\"dataSource\" [ngClass]=\"classNames\">\n      <!-- Column Definition -->\n      <ng-container *ngFor=\"let element of displayedColumns\" cdkColumnDef=\"{{element.key}}\">\n        <cdk-header-cell *cdkHeaderCellDef class=\"nx-table__header-cell\"\n                         [ngClass]=\"{'nx-table__header-cell--number': isNumeric(element) }\">\n          <div class=\"nx-table__header-title--block\">\n            <span class=\"nx-table__header-title\"> {{element.title}}</span>\n          </div>\n        </cdk-header-cell>\n        <cdk-cell *cdkCellDef=\"let row\" class=\"nx-table__cell\"\n                  [ngClass]=\"{'nx-table__cell--number': isNumeric(element) }\" [innerHTML]=\"row[element.key]\"></cdk-cell>\n      </ng-container>\n\n      <!-- Header and Row Declarations -->\n      <cdk-header-row *cdkHeaderRowDef=\"columnKeys\" class=\"nx-table__header-row\"></cdk-header-row>\n      <cdk-row *cdkRowDef=\"let row; columns: columnKeys\" class=\"nx-table__row\"\n               (dblclick)=\"handleRowClick(row)\"></cdk-row>\n\n    </cdk-table>\n  </div>\n</div>\n<div class=\"nx-table__appendix\" *ngIf=\"data.length === 0\">\n  <ng-content></ng-content>\n</div>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [".nx-table{border-top:2px solid #d9d9d9;border-bottom:2px solid #414141;font-size:16px;text-align:left;width:100%;line-height:24px;color:#414141;display:table}.nx-table--light.nx-table{border-top:1px solid #d9d9d9}.nx-table__container{margin:32px 0}.nx-table__scroll{max-width:100%;overflow:hidden;overflow-x:auto}.nx-table__header-cell{background-color:#d9d9d9;border:1px solid #fff;border-right:none;color:#414141;padding:21px 16px 23px;position:relative;font-size:16px;line-height:24px;font-weight:700}.nx-table__header-row .nx-table__header-cell:last-child{border-right:1px solid #fff}.nx-table__header-row{background-color:#d9d9d9;border-spacing:1px none}.nx-table--light .nx-table__header-row{background-color:#fff;border-bottom:2px solid #414141;border-top:1px solid #d9d9d9}.nx-table__header-cell--number{display:flex;position:relative}.nx-table__header-cell--number .nx-table__header-title--block{justify-content:flex-end}.nx-table__cell{padding:24px 16px;vertical-align:top}.nx-table__cell--number,.nx-table__header-cell--number{text-align:right}.nx-table__row{background-color:#fff}.nx-table__header-row,.nx-table__row{display:table-row;vertical-align:inherit;border-color:inherit}.nx-table__row:nth-child(2n+1){background-color:#ececec}.nx-table--light.nx-table--with-border .nx-table__row{background-color:#fff}.nx-table--light .nx-table__header-cell{background-color:#fff;border:none;border-bottom:2px solid #414141;padding-top:23px;padding-bottom:22px}.nx-table--light.nx-table--with-border .nx-table__cell{padding-bottom:23px;border-bottom:1px solid #d9d9d9}.nx-table__row:last-child .nx-table__cell{padding-bottom:22px;border-bottom:none}.nx-table__cell,.nx-table__header-cell{display:table-cell;vertical-align:inherit}"]
      }]
    }];
    /** @nocollapse */

    NxDynamicTableComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxDynamicTableComponent.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxData']
      }],
      displayedColumns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxDisplayedColumns']
      }],
      styles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxType']
      }],
      nxRowClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxDynamicTableModule = function NxDynamicTableModule() {
      _classCallCheck(this, NxDynamicTableModule);
    };

    NxDynamicTableModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxDynamicTableComponent],
        exports: [NxDynamicTableComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_table__WEBPACK_IMPORTED_MODULE_17__["CdkTableModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_18__["ScrollDispatchModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DEFAULT_TYPE$4 = 'regular';

    var NxAccordionDirective$1 =
    /*#__PURE__*/
    function (_angular_cdk_accordio3) {
      _inherits(NxAccordionDirective$1, _angular_cdk_accordio3);

      function NxAccordionDirective$1() {
        var _this93;

        _classCallCheck(this, NxAccordionDirective$1);

        _this93 = _possibleConstructorReturn(this, _getPrototypeOf(NxAccordionDirective$1).apply(this, arguments));
        _this93._style = 'regular';
        _this93._negative = null;
        return _this93;
      }
      /**
       * Value for the styling that should be chosen.
       * Default value: 'regular'
       * @param {?} value
       * @return {?}
       */


      _createClass(NxAccordionDirective$1, [{
        key: "style",
        set: function set(value) {
          value = value ? value : DEFAULT_TYPE$4;

          var _ref21 = value.match(/regular|light/) || [DEFAULT_TYPE$4],
              _ref22 = _slicedToArray(_ref21, 1),
              newValue = _ref22[0];

          this._style =
          /** @type {?} */
          newValue;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._style;
        }
        /**
         * Whether the negative set of styles should be used.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
      }]);

      return NxAccordionDirective$1;
    }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_20__["CdkAccordion"]);

    NxAccordionDirective$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-accordion',
        host: {
          '[class.nx-accordion]': 'true',
          'role': 'presentation'
        }
      }]
    }];
    NxAccordionDirective$1.propDecorators = {
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStyle']
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var nxAccordionAnimations = {
      bodyExpansion: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["trigger"])('bodyExpansion', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["state"])('closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
        height: '0px',
        visibility: 'hidden'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["state"])('open', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
        height: '*',
        visibility: 'visible'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])('open <=> closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('.5s cubic-bezier(0.86, 0, 0.07, 1)'))]),
      indicatorRotate: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["trigger"])('indicatorRotate', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["state"])('closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
        transform: 'rotate(0deg)'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["state"])('open', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["style"])({
        transform: 'rotate(180deg)'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["transition"])('open <=> closed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_21__["animate"])('.3s ease'))])
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxExpansionPanelBodyDirective =
    /**
     * @param {?} _template
     */
    function NxExpansionPanelBodyDirective(_template) {
      _classCallCheck(this, NxExpansionPanelBodyDirective);

      this._template = _template;
    };

    NxExpansionPanelBodyDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxExpansionPanelBody]'
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelBodyDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nextId$c = 0;
    /** @type {?} */

    var DEFAULT_TYPE$5 = 'regular';
    var ɵ0 = undefined;

    var NxExpansionPanelComponent$1 =
    /*#__PURE__*/
    function (_angular_cdk_accordio4) {
      _inherits(NxExpansionPanelComponent$1, _angular_cdk_accordio4);

      /**
       * @param {?} accordion
       * @param {?} _changeDetectorRef
       * @param {?} _expansionDispatcher
       * @param {?} _viewContainerRef
       */
      function NxExpansionPanelComponent$1(accordion, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
        var _this94;

        _classCallCheck(this, NxExpansionPanelComponent$1);

        _this94 = _possibleConstructorReturn(this, _getPrototypeOf(NxExpansionPanelComponent$1).call(this, accordion, _changeDetectorRef, _expansionDispatcher));
        _this94._viewContainerRef = _viewContainerRef;
        _this94._negative = null;
        _this94._accordionStyle = DEFAULT_TYPE$5;
        _this94._style = null;
        _this94._headerId = "nx-expansion-panel-header-".concat(nextId$c++);
        /**
         * Stream that emits for changes in `\@Input` properties.
         */

        _this94._inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        _this94.accordion = accordion;
        return _this94;
      }
      /**
       * Whether the negative set of styles should be used.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxExpansionPanelComponent$1, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this95 = this;

          if (this.lazyContent) {
            // Render the content as soon as the panel becomes open.
            this.opened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
            /**
            * @return {?}
            */
            function () {
              return _this95.expanded && !_this95._portal;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["take"])(1)).subscribe(
            /**
            * @return {?}
            */
            function () {
              _this95._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["TemplatePortal"](_this95.lazyContent._template, _this95._viewContainerRef);
            });
          } // Inherit appearance given by the accordion (if any).


          if (Boolean(this.accordion)) {
            if (this.style === null && this.accordion.style !== null) {
              this.style = this.accordion.style;
            }

            if (this.negative === null && this.accordion.negative !== null) {
              this.negative = this.accordion.negative;
            }
          }
        }
        /**
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          this._inputChanges.next(changes);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          _get(_getPrototypeOf(NxExpansionPanelComponent$1.prototype), "ngOnDestroy", this).call(this);

          this._inputChanges.complete();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getOpenState",
        value: function getOpenState() {
          return this.expanded ? 'open' : 'closed';
        }
      }, {
        key: "negative",
        set: function set(value) {
          this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
        /**
         * Value for the styling that should be chosen.
         * Default value: 'regular'.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "style",
        set: function set(value) {
          value = value ? value : DEFAULT_TYPE$5;

          var _ref23 = value.match(/regular|light/) || [DEFAULT_TYPE$5],
              _ref24 = _slicedToArray(_ref23, 1),
              newValue = _ref24[0];

          this._style =
          /** @type {?} */
          newValue;
          this._accordionStyle =
          /** @type {?} */
          newValue;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._style;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "portal",
        get: function get() {
          return this._portal;
        }
      }]);

      return NxExpansionPanelComponent$1;
    }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_20__["CdkAccordionItem"]);

    NxExpansionPanelComponent$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-expansion-panel',
        exportAs: 'NxExpansionPanelComponent',
        template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        animations: [nxAccordionAnimations.bodyExpansion],
        host: {
          '[class.nx-expanded]': 'expanded',
          '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
          '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
          '[class.nx-expansion-panel--negative]': 'negative'
        },
        providers: [// Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
        // to the same accordion.
        {
          provide: NxAccordionDirective$1,
          useValue: ɵ0
        }],
        styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;line-height:24px;padding:24px 88px 32px 32px}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host:last-child ::ng-deep .nx-expansion-panel__header-content,:host:only-child ::ng-deep .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-content{border-top:1px solid #d9d9d9;border-bottom:none}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__body{padding-top:0}:host(.nx-expansion-panel--light):first-child ::ng-deep .nx-expansion-panel__header-content{border-top:none}"]
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelComponent$1.ctorParameters = function () {
      return [{
        type: NxAccordionDirective$1,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["SkipSelf"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_19__["UniqueSelectionDispatcher"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
      }];
    };

    NxExpansionPanelComponent$1.propDecorators = {
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"],
        args: ['nxStyle']
      }],
      lazyContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChild"],
        args: [NxExpansionPanelBodyDirective]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxExpansionPanelHeaderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} panel
       * @param {?} _changeDetectorRef
       */
      function NxExpansionPanelHeaderComponent(panel, _changeDetectorRef) {
        var _this96 = this;

        _classCallCheck(this, NxExpansionPanelHeaderComponent);

        this.panel = panel;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        this._parentChangeSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"])(panel.opened, panel.closed, panel._inputChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__["filter"])(
        /**
        * @param {?} changes
        * @return {?}
        */
        function (changes) {
          return !!(changes.hideToggle || changes.disabled);
        }))).subscribe(
        /**
        * @return {?}
        */
        function () {
          return _this96._changeDetectorRef.markForCheck();
        });
      }
      /**
       * @return {?}
       */


      _createClass(NxExpansionPanelHeaderComponent, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._parentChangeSubscription.unsubscribe();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "isExpanded",
        value: function isExpanded() {
          return this.panel.expanded;
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "getOpenState",
        value: function getOpenState() {
          return this.panel.getOpenState();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_getPanelId",
        value: function _getPanelId() {
          return this.panel.id;
        }
        /**
         * Toggle the expansion panel.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.panel.toggle();
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "keydown",
        value: function keydown(event) {
          switch (event.keyCode) {
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"]:
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"]:
              event.preventDefault();
              this.toggle();
              break;

            default:
              return;
          }
        }
      }]);

      return NxExpansionPanelHeaderComponent;
    }();

    NxExpansionPanelHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-expansion-panel-header',
        template: "<div class=\"nx-expansion-panel__header-content\">\n  <ng-content select=\"nx-expansion-panel-title\"></ng-content>\n  <ng-content select=\"nx-expansion-panel-description\"></ng-content>\n  <nx-icon\n    [@indicatorRotate]=\"getOpenState()\"\n    class=\"nx-expansion-panel__chevron\"\n    name=\"chevron-down\">\n  </nx-icon>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        animations: [nxAccordionAnimations.indicatorRotate],
        host: {
          '[class.nx-expanded]': 'isExpanded()',
          'class': 'nx-expansion-panel__header',
          'role': 'button',
          '[attr.id]': 'panel._headerId',
          '[attr.tabindex]': 'panel.disabled ? -1 : 0',
          '[attr.aria-controls]': '_getPanelId()',
          '[attr.aria-expanded]': 'isExpanded()',
          '[attr.aria-disabled]': 'panel.disabled',
          '(keydown)': 'keydown($event)',
          '(click)': 'toggle()'
        },
        styles: [":host:focus{outline:0}.nx-expansion-panel__header-content{width:100%;cursor:pointer;align-items:center;color:#414141;display:flex;justify-content:space-between;position:relative;padding:24px 32px;margin-top:16px;background:#f5f5f5;outline:0;border:none}::ng-deep .nx-expansion-panel__header-title{font-size:26px;font-weight:300;line-height:32px;letter-spacing:.3px;text-align:left;margin-right:32px}:host-context(.nx-expansion-panel--negative) .nx-expansion-panel__header-content{background-color:#fff}.nx-expansion-panel__chevron{color:#006192;pointer-events:none;font-size:24px}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__header-content{margin-top:0;background:0 0}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{color:#006192;letter-spacing:.2px;font-weight:400;font-size:20px;line-height:28px}@media (max-width:703px){.nx-expansion-panel__header-content{padding:16px;margin-top:0;border-top:1px solid #d9d9d9}::ng-deep .nx-expansion-panel__header-title{font-size:20px;line-height:28px;margin-right:16px;font-weight:400}:host(.nx-expanded) .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{line-height:24px;font-size:16px}:host-context(.nx-expansion-panel--light.nx-expanded) .nx-expansion-panel__header-content{border-bottom:none}}:host[aria-disabled=true] .nx-expansion-panel__header-content{cursor:not-allowed}:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__chevron,:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__header-title{color:#c2c2c2}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content{border-color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-title{color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__chevron{color:#fff}:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-top-color:transparent;z-index:1}"]
      }]
    }];
    /** @nocollapse */

    NxExpansionPanelHeaderComponent.ctorParameters = function () {
      return [{
        type: NxExpansionPanelComponent$1,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Host"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */


    var NxExpansionPanelDescriptionDirective = function NxExpansionPanelDescriptionDirective() {
      _classCallCheck(this, NxExpansionPanelDescriptionDirective);
    };

    NxExpansionPanelDescriptionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-expansion-panel-description',
        host: {
          class: 'nx-expansion-panel__header-description'
        }
      }]
    }];
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */

    var NxExpansionPanelTitleDirective = function NxExpansionPanelTitleDirective() {
      _classCallCheck(this, NxExpansionPanelTitleDirective);
    };

    NxExpansionPanelTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'nx-expansion-panel-title',
        host: {
          class: 'nx-expansion-panel__header-title'
        }
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxAccordionModule$1 = function NxAccordionModule$1() {
      _classCallCheck(this, NxAccordionModule$1);
    };

    NxAccordionModule$1.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["PortalModule"], _allianz_ngx_ndbx_icon__WEBPACK_IMPORTED_MODULE_22__["NxIconModule"]],
        exports: [NxAccordionDirective$1, NxExpansionPanelComponent$1, NxExpansionPanelHeaderComponent, NxExpansionPanelDescriptionDirective, NxExpansionPanelTitleDirective, NxExpansionPanelBodyDirective],
        declarations: [NxAccordionDirective$1, NxExpansionPanelComponent$1, NxExpansionPanelHeaderComponent, NxExpansionPanelDescriptionDirective, NxExpansionPanelTitleDirective, NxExpansionPanelBodyDirective],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     * @abstract
     */

    var NxTabGroupBase = function NxTabGroupBase() {
      _classCallCheck(this, NxTabGroupBase);
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxTabComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewContainerRef
       * @param {?} _tabGroup
       */
      function NxTabComponent(_viewContainerRef, _tabGroup) {
        _classCallCheck(this, NxTabComponent);

        this._viewContainerRef = _viewContainerRef;
        this._tabGroup = _tabGroup;
        /**
         * The portal that will be the hosted content of the tab
         */

        this._contentPortal = null;
        /**
         * Emits whenever the internal state of the tab changes.
         */

        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_25__["Subject"]();
        /**
         * Whether the tab is currently active.
         */

        this.isActive = false;

        if (!this._tabGroup) {
          throw Error("The nx-tab element has to be wrapped in a nx-tab-group to work.\n      Please provide a nx-tab-group element and place your tabs inside it.");
        }
      }
      /**
       * Sets the label of the tab shown in the tablist.
       * @return {?}
       */


      _createClass(NxTabComponent, [{
        key: "ngOnChanges",

        /**
         * @param {?} changes
         * @return {?}
         */
        value: function ngOnChanges(changes) {
          if (changes.hasOwnProperty('label')) {
            this._stateChanges.next();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this._contentPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["TemplatePortal"](this._implicitContent, this._viewContainerRef);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();
        }
      }, {
        key: "label",
        get: function get() {
          return this._label;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._label !== value) {
            this._label = value;
          }
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "content",
        get: function get() {
          return this._contentPortal;
        }
      }]);

      return NxTabComponent;
    }();

    NxTabComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tab',
        exportAs: 'nxTab',
        template: "<ng-template><ng-content></ng-content></ng-template>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush
      }]
    }];
    /** @nocollapse */

    NxTabComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewContainerRef"]
      }, {
        type: NxTabGroupBase,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Inject"],
          args: [NxTabGroupBase]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Host"]
        }]
      }];
    };

    NxTabComponent.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      _implicitContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_31__["TemplateRef"]]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxTabBodyComponent =
    /*#__PURE__*/
    function () {
      function NxTabBodyComponent() {
        _classCallCheck(this, NxTabBodyComponent);

        this._active = false;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(NxTabBodyComponent, [{
        key: "attach",

        /**
         * @return {?}
         */
        value: function attach() {
          if (!this.portalOutlet.hasAttached()) {
            this.portalOutlet.attach(this.content);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          if (this.portalOutlet.hasAttached()) {
            this.portalOutlet.detach();
          }
        }
      }, {
        key: "active",
        set: function set(value) {
          this._active = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (this._active) {
            this.attach();
          } else {
            this.detach();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._active;
        }
      }]);

      return NxTabBodyComponent;
    }();

    NxTabBodyComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tab-body',
        template: "<ng-template cdkPortalOutlet></ng-template>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:block}"]
      }]
    }];
    NxTabBodyComponent.propDecorators = {
      content: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      active: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      portalOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["CdkPortalOutlet"]]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */

    var NxTabLabelDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function NxTabLabelDirective(elementRef) {
        _classCallCheck(this, NxTabLabelDirective);

        this.elementRef = elementRef;
      }
      /**
       * @return {?}
       */


      _createClass(NxTabLabelDirective, [{
        key: "focus",
        value: function focus() {
          this.elementRef.nativeElement.focus();
        }
      }]);

      return NxTabLabelDirective;
    }();

    NxTabLabelDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxTabLabel]'
      }]
    }];
    /** @nocollapse */

    NxTabLabelDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@docs-private
     */


    var NxTabHeaderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxTabHeaderComponent(_changeDetectorRef) {
        _classCallCheck(this, NxTabHeaderComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this.indexFocused = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
      }
      /**
       * @return {?}
       */


      _createClass(NxTabHeaderComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {}
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_27__["FocusKeyManager"](this.labels).withHorizontalOrientation('ltr').withWrap();

          this._keyManager.updateActiveItemIndex(0);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @param {?} idx
         * @return {?}
         */

      }, {
        key: "_isValidIndex",
        value: function _isValidIndex(idx) {
          if (!this.labels) {
            return true;
          }

          return !!this.labels.toArray()[idx];
        }
        /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(event) {
          switch (event.keyCode) {
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["HOME"]:
              this._keyManager.setFirstItemActive();

              event.preventDefault();
              break;

            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["END"]:
              this._keyManager.setLastItemActive();

              event.preventDefault();
              break;

            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"]:
            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"]:
              this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
              event.preventDefault();
              break;

            default:
              this._keyManager.onKeydown(event);

          }

          if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
          } else if (event.keyCode !== _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["ENTER"] && event.keyCode !== _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_28__["SPACE"]) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
          }
        }
      }, {
        key: "selectedIndex",
        get: function get() {
          return this._selectedIndex;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._selectedIndex = value;

          if (this._keyManager) {
            this._keyManager.updateActiveItemIndex(value);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "focusIndex",
        get: function get() {
          return this._keyManager ? this._keyManager.activeItemIndex : 0;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
            return;
          }

          this._keyManager.setActiveItem(value);
        }
        /**
         * @return {?}
         */

      }, {
        key: "autoselect",
        get: function get() {
          return this._autoselect;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._autoselect = value;
        }
      }]);

      return NxTabHeaderComponent;
    }();

    NxTabHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tab-header',
        template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
      }]
    }];
    /** @nocollapse */

    NxTabHeaderComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxTabHeaderComponent.propDecorators = {
      selectedIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      autoselect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      selectFocusedIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      indexFocused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      labels: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxTabLabelDirective]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTabChangeEvent = function NxTabChangeEvent() {
      _classCallCheck(this, NxTabChangeEvent);
    };
    /** @type {?} */


    var nextId$d = 0;
    /** @type {?} */

    var MOBILE_BREAKPOINT = 480;

    var NxTabGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxTabGroupComponent(_changeDetectorRef) {
        _classCallCheck(this, NxTabGroupComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */

        this.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event emitted when the selected tab has changed.
         */

        this.selectedTabChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */

        this.focusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        /**
         * Subscription to tabs being added/removed.
         */

        this._tabsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */

        this._tabLabelSubscription = rxjs__WEBPACK_IMPORTED_MODULE_25__["Subscription"].EMPTY;
        this._groupId = nextId$d++;
      }
      /**
       * Sets the selected tab.
       * @return {?}
       */


      _createClass(NxTabGroupComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this._switchAppearance(window.innerWidth);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this97 = this;

          this._subscribeToTabLabels(); // Subscribe to changes in the amount of tabs, in order to be
          // able to re-render the content as new tabs are added or removed.


          this._tabsSubscription = this.tabs.changes.subscribe(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var indexToSelect = _this97._clampTabIndex(_this97._indexToSelect); // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.


            if (indexToSelect === _this97._selectedIndex) {
              /** @type {?} */
              var tabs = _this97.tabs.toArray();

              for (var i = 0; i < tabs.length; i++) {
                if (tabs[i].isActive) {
                  // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                  // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                  // adding a tab within the `selectedIndexChange` event.
                  _this97._indexToSelect = _this97._selectedIndex = i;
                  break;
                }
              }
            }

            _this97._changeDetectorRef.markForCheck();
          });
        }
        /**
         * After the content is checked, this component knows what tabs have been defined
         * and what the selected index should be.
         * @return {?}
         */

      }, {
        key: "ngAfterContentChecked",
        value: function ngAfterContentChecked() {
          var _this98 = this;

          // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
          // the amount of tabs changes before the actual change detection runs.

          /** @type {?} */
          var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect); // If there is a change in selected index, emit a change event. Should not trigger if
          // the selected index has not yet been initialized.


          if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            var isFirstRun = this._selectedIndex == null;

            if (!isFirstRun) {
              this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            } // Changing these values after change detection has run
            // since the checked content may contain references to them.


            Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              _this98.tabs.forEach(
              /**
              * @param {?} tab
              * @param {?} index
              * @return {?}
              */
              function (tab, index) {
                return tab.isActive = index === indexToSelect;
              });

              if (!isFirstRun) {
                _this98.selectedIndexChange.emit(indexToSelect);
              }
            });
          }

          if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._tabsSubscription.unsubscribe();

          this._tabLabelSubscription.unsubscribe();
        }
        /**
         * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
         * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
         * binding to be updated, we need to subscribe to changes in it and trigger change detection
         * manually.
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToTabLabels",
        value: function _subscribeToTabLabels() {
          var _this99 = this;

          if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
          }

          this._tabLabelSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_25__["merge"]).apply(void 0, _toConsumableArray(this.tabs.map(
          /**
          * @param {?} tab
          * @return {?}
          */
          function (tab) {
            return tab._stateChanges;
          }))).subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this99._changeDetectorRef.markForCheck();
          });
        }
        /**
         * Clamps the given index to the bounds of 0 and the tabs length.
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_clampTabIndex",
        value: function _clampTabIndex(index) {
          // Note the `|| 0`, which ensures that values like NaN can't get through
          // and which would otherwise throw the component into an infinite loop
          // (since Math.max(NaN, 0) === NaN).
          return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
        }
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "focusChanged",
        value: function focusChanged(index) {
          this.focusChange.emit(this._createChangeEvent(index));
        }
        /**
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_createChangeEvent",
        value: function _createChangeEvent(index) {
          /** @type {?} */
          var event = new NxTabChangeEvent();
          event.index = index;

          if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
          }

          return event;
        }
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "handleClick",
        value: function handleClick(index) {
          this.selectedIndex = this.tabHeader.focusIndex = index;
        }
        /**
         * \@docs-private
         * Returns the tabindex for a tab label
         * @param {?} tab
         * @param {?} idx
         * @return {?}
         */

      }, {
        key: "getTabIndex",
        value: function getTabIndex(tab, idx) {
          return this.selectedIndex === idx ? 0 : -1;
        }
        /**
         * Returns a unique id for each tab label element
         * @param {?} i
         * @return {?}
         */

      }, {
        key: "_getTabLabelId",
        value: function _getTabLabelId(i) {
          return "nx-tab-label-".concat(this._groupId, "-").concat(i);
        }
        /**
         * Returns a unique id for each tab content element
         * @param {?} i
         * @return {?}
         */

      }, {
        key: "_getTabContentId",
        value: function _getTabContentId(i) {
          return "nx-tab-content-".concat(this._groupId, "-").concat(i);
        }
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onResize",
        value: function onResize(event) {
          this._switchAppearance(event.target.innerWidth);
        }
        /**
         * @private
         * @param {?} viewPortWidth
         * @return {?}
         */

      }, {
        key: "_switchAppearance",
        value: function _switchAppearance(viewPortWidth) {
          if (!this._mobileAccordion) {
            return;
          }

          if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._showMobileVersion();
          } else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._showDesktopVersion();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_showMobileVersion",
        value: function _showMobileVersion() {
          this._showAccordion = true;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_showDesktopVersion",
        value: function _showDesktopVersion() {
          this._showAccordion = false;

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_panelOpened",
        value: function _panelOpened(index) {
          this.selectedIndex = index;
        }
      }, {
        key: "selectedIndex",
        get: function get() {
          return this._selectedIndex;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._indexToSelect = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceNumberProperty"])(value, null);
        }
        /**
         * Whether the negative set of styling should be used.
         * @return {?}
         */

      }, {
        key: "negative",
        get: function get() {
          return this._negative;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== this._negative) {
            this._negative = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
          }
        }
        /**
         * Whether the tab should be immediately selected on focus.
         * @return {?}
         */

      }, {
        key: "autoselect",
        get: function get() {
          return this._autoselect;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._autoselect = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
        /**
         * Whether the tabs should to accordion on mobile viewports.
         * @return {?}
         */

      }, {
        key: "mobileAccordion",
        get: function get() {
          return this._mobileAccordion;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._mobileAccordion = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);
        }
      }]);

      return NxTabGroupComponent;
    }();

    NxTabGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tab-group',
        template: "\n  <nx-tab-header *ngIf=\"!_showAccordion\"\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabel\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      {{tab.label}}\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(!_showAccordion && selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [content]=\"tab.content\"\n      [active]=\"!_showAccordion && selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n\n  <nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n    <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\">\n      <nx-expansion-panel-header>\n        <nx-expansion-panel-title>{{tab.label}}</nx-expansion-panel-title>\n      </nx-expansion-panel-header>\n      <ng-template [cdkPortalOutlet]=\"tab.content\"></ng-template>\n    </nx-expansion-panel>\n  </nx-accordion>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.is-negative]': 'negative'
        },
        providers: [{
          provide: NxTabGroupBase,
          useExisting: NxTabGroupComponent
        }],
        styles: [":host{display:block}.nx-tab-header__item{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px;outline:0}.nx-tab-header__item::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}"]
      }]
    }];
    /** @nocollapse */

    NxTabGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxTabGroupComponent.propDecorators = {
      tabs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ContentChildren"],
        args: [NxTabComponent]
      }],
      tabBodyChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChildren"],
        args: [NxTabBodyComponent]
      }],
      tabHeader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: ['tabHeader']
      }],
      panels: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChildren"],
        args: [_allianz_ngx_ndbx_accordion__WEBPACK_IMPORTED_MODULE_26__["NxExpansionPanelComponent"]]
      }],
      accordion: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ViewChild"],
        args: [_allianz_ngx_ndbx_accordion__WEBPACK_IMPORTED_MODULE_26__["NxAccordionDirective"]]
      }],
      selectedIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      autoselect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      mobileAccordion: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      selectedIndexChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      selectedTabChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      focusChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }],
      onResize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["HostListener"],
        args: ['window:resize', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTabNavBarComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       */
      function NxTabNavBarComponent(_changeDetectorRef) {
        _classCallCheck(this, NxTabNavBarComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
      }
      /**
       * Whether the tab nav bar has negative styling.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxTabNavBarComponent, [{
        key: "negative",
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this.negative) {
            this._negative = newValue;

            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._negative;
        }
      }]);

      return NxTabNavBarComponent;
    }();

    NxTabNavBarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        selector: 'nx-tab-nav-bar',
        template: "<ng-content></ng-content>",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          '[class.is-negative]': 'negative',
          'role': 'navigation'
        },
        styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host-context([data-whatinput=keyboard]) nx-tab-link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
      }]
    }];
    /** @nocollapse */

    NxTabNavBarComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }];
    };

    NxTabNavBarComponent.propDecorators = {
      negative: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };

    var NxTabLinkDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _tabNavBar
       */
      function NxTabLinkDirective(_tabNavBar) {
        _classCallCheck(this, NxTabLinkDirective);

        this._tabNavBar = _tabNavBar;
        this._active = false;

        if (!this._tabNavBar) {
          throw Error("The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.");
        }
      }
      /**
       * Whether the tab link is active and has the active styling.
       * @return {?}
       */


      _createClass(NxTabLinkDirective, [{
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          if (newValue !== this._active) {
            this._active = value;
          }
        }
      }]);

      return NxTabLinkDirective;
    }();

    NxTabLinkDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Directive"],
      args: [{
        selector: '[nxTabLink]',
        host: {
          '[class.nx-tab-link]': 'true',
          '[class.is-active]': 'active',
          '[attr.aria-current]': 'active'
        }
      }]
    }];
    /** @nocollapse */

    NxTabLinkDirective.ctorParameters = function () {
      return [{
        type: NxTabNavBarComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["SkipSelf"]
        }]
      }];
    };

    NxTabLinkDirective.propDecorators = {
      active: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxTabsModule = function NxTabsModule() {
      _classCallCheck(this, NxTabsModule);
    };

    NxTabsModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_24__["PortalModule"], _allianz_ngx_ndbx_accordion__WEBPACK_IMPORTED_MODULE_26__["NxAccordionModule"]],
        exports: [NxTabComponent, NxTabGroupComponent, NxTabLabelDirective, NxTabHeaderComponent, NxTabBodyComponent, NxTabNavBarComponent, NxTabLinkDirective],
        declarations: [NxTabComponent, NxTabGroupComponent, NxTabLabelDirective, NxTabHeaderComponent, NxTabBodyComponent, NxTabNavBarComponent, NxTabLinkDirective],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var BREAKPOINT_MOBILE = '(max-width: 703px)';
    /** @type {?} */

    var BREAKPOINT_TABLET = '(min-width: 704px) and (max-width: 992px)';
    /** @type {?} */

    var BREAKPOINT_DESKTOP = '(min-width: 993px)';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var MappedStyles$1 =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} mapping
       * @param {?=} baseClasses
       * @param {?=} _elementRef
       * @param {?=} _renderer
       */
      function MappedStyles$1(mapping) {
        var baseClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var _elementRef = arguments.length > 2 ? arguments[2] : undefined;

        var _renderer = arguments.length > 3 ? arguments[3] : undefined;

        _classCallCheck(this, MappedStyles$1);

        this.mapping = mapping;
        this.baseClasses = baseClasses;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.classNames = '';
      }
      /**
       * @return {?}
       */


      _createClass(MappedStyles$1, [{
        key: "classNames",
        get: function get() {
          return this._classNames;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._classNames === value) {
            return;
          }

          Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["removeClasses"])(this._renderer, this._elementRef, this._classNamesSanitized);
          this._classNamesSanitized = Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["mapClassNames"])(value, this.baseClasses, this.mapping);
          this._classNames = value;
          Object(_allianz_ngx_ndbx_utils__WEBPACK_IMPORTED_MODULE_29__["appendClasses"])(this._renderer, this._elementRef, this._classNamesSanitized);
        }
      }]);

      return MappedStyles$1;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var NxCardComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _changeDetectorRef
       * @param {?} tabindex
       */
      function NxCardComponent(_changeDetectorRef, tabindex) {
        _classCallCheck(this, NxCardComponent);

        this._changeDetectorRef = _changeDetectorRef;
        this._disabled = false;
        /**
         * Event emitted when the selected value has changed.
         */

        this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_31__["EventEmitter"]();
        this._tabindex = tabindex;
      }
      /**
       * Whether this card is selectable or not.
       * @param {?} value
       * @return {?}
       */


      _createClass(NxCardComponent, [{
        key: "_toggleSelected",

        /**
         * @return {?}
         */
        value: function _toggleSelected() {
          if (this.selectable && !this.disabled) {
            this.selected = !this.selected;
            this.selectedChange.emit(this.selected);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "_getTabindex",
        value: function _getTabindex() {
          if (this.disabled) {
            return '-1';
          }

          if (this.selectable) {
            return this._tabindex || '0';
          }

          return this._tabindex || '';
        }
      }, {
        key: "selectable",
        set: function set(value) {
          this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._selectable;
        }
        /**
         * Whether this card is selected or not.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selected",
        set: function set(value) {
          this._selected = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._selected;
        }
        /**
         * Whether the card is disabled.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_30__["coerceBooleanProperty"])(value);

          this._changeDetectorRef.markForCheck();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._disabled;
        }
      }]);

      return NxCardComponent;
    }();

    NxCardComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Component"],
      args: [{
        template: '<ng-content></ng-content>',
        selector: 'nx-card',
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectionStrategy"].OnPush,
        host: {
          'class': 'nx-card',
          '[class.is-selectable]': 'selectable',
          '[class.is-selected]': 'selected',
          '[class.is-disabled]': 'disabled',
          '[attr.aria-disabled]': 'disabled',
          '(click)': '_toggleSelected()',
          '(keydown.enter)': '_toggleSelected()',
          '[attr.tabindex]': '_getTabindex()'
        },
        styles: [":host{background:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:none;display:inline-block;margin-bottom:24px;padding:24px;transition:background-color .2s,box-shadow .2s}:host.is-selectable{cursor:pointer}:host.is-selectable:hover{background-color:#f5f5f5}:host.is-selectable:focus,:host.is-selectable:hover{outline:0}:host.is-selected{box-shadow:0 8px 24px rgba(65,65,65,.35);background-color:#f5f5f5}:host.is-disabled{cursor:not-allowed;opacity:.4}:host.is-disabled:hover{background-color:#fff}:host.is-disabled:focus{outline:0}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}@media screen and (-ms-high-contrast:active){:host.is-selectable:focus,:host.is-selectable:hover{border-color:highlight}:host.is-selected{box-shadow:0 0 0 2px windowText}:host.is-selected:focus,:host.is-selected:hover{box-shadow:0 0 0 2px highlight}}"]
      }]
    }];
    /** @nocollapse */

    NxCardComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["ChangeDetectorRef"]
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Attribute"],
          args: ['tabindex']
        }]
      }];
    };

    NxCardComponent.propDecorators = {
      selectable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Input"]
      }],
      selectedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var NxCardModule = function NxCardModule() {
      _classCallCheck(this, NxCardModule);
    };

    NxCardModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_31__["NgModule"],
      args: [{
        declarations: [NxCardComponent],
        exports: [NxCardComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_32__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/accordion.js":
  /*!********************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/accordion.js ***!
    \********************************************************/

  /*! exports provided: CdkAccordionItem, CdkAccordion, CdkAccordionModule */

  /***/
  function node_modulesAngularCdkEsm2015AccordionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkAccordionItem", function () {
      return CdkAccordionItem;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkAccordion", function () {
      return CdkAccordion;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkAccordionModule", function () {
      return CdkAccordionModule;
    });
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Used to generate unique ID for each accordion.
     * @type {?}
     */


    var nextId = 0;
    /**
     * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.
     */

    var CdkAccordion =
    /*#__PURE__*/
    function () {
      function CdkAccordion() {
        _classCallCheck(this, CdkAccordion);

        /**
         * Emits when the state of the accordion changes
         */
        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * Stream that emits true/false when openAll/closeAll is triggered.
         */

        this._openCloseAllActions = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * A readonly id value to use for unique selection coordination.
         */

        this.id = "cdk-accordion-".concat(nextId++);
        this._multi = false;
      }
      /**
       * Whether the accordion should allow multiple expanded accordion items simultaneously.
       * @return {?}
       */


      _createClass(CdkAccordion, [{
        key: "openAll",

        /**
         * Opens all enabled accordion items in an accordion where multi is enabled.
         * @return {?}
         */
        value: function openAll() {
          this._openCloseAll(true);
        }
        /**
         * Closes all enabled accordion items in an accordion where multi is enabled.
         * @return {?}
         */

      }, {
        key: "closeAll",
        value: function closeAll() {
          this._openCloseAll(false);
        }
        /**
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          this._stateChanges.next(changes);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._stateChanges.complete();
        }
        /**
         * @private
         * @param {?} expanded
         * @return {?}
         */

      }, {
        key: "_openCloseAll",
        value: function _openCloseAll(expanded) {
          if (this.multi) {
            this._openCloseAllActions.next(expanded);
          }
        }
      }, {
        key: "multi",
        get: function get() {
          return this._multi;
        }
        /**
         * @param {?} multi
         * @return {?}
         */
        ,
        set: function set(multi) {
          this._multi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(multi);
        }
      }]);

      return CdkAccordion;
    }();

    CdkAccordion.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'cdk-accordion, [cdkAccordion]',
        exportAs: 'cdkAccordion'
      }]
    }];
    CdkAccordion.propDecorators = {
      multi: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Used to generate unique ID for each accordion item.
     * @type {?}
     */

    var nextId$1 = 0;
    var ɵ0 = undefined;
    /**
     * An basic directive expected to be extended and decorated as a component.  Sets up all
     * events and attributes needed to be managed by a CdkAccordion parent.
     */

    var CdkAccordionItem =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} accordion
       * @param {?} _changeDetectorRef
       * @param {?} _expansionDispatcher
       */
      function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {
        var _this100 = this;

        _classCallCheck(this, CdkAccordionItem);

        this.accordion = accordion;
        this._changeDetectorRef = _changeDetectorRef;
        this._expansionDispatcher = _expansionDispatcher;
        /**
         * Subscription to openAll/closeAll events.
         */

        this._openCloseAllSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        /**
         * Event emitted every time the AccordionItem is closed.
         */

        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event emitted every time the AccordionItem is opened.
         */

        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event emitted when the AccordionItem is destroyed.
         */

        this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits whenever the expanded state of the accordion changes.
         * Primarily used to facilitate two-way binding.
         * \@docs-private
         */

        this.expandedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The unique AccordionItem id.
         */

        this.id = "cdk-accordion-child-".concat(nextId$1++);
        this._expanded = false;
        this._disabled = false;
        /**
         * Unregister function for _expansionDispatcher.
         */

        this._removeUniqueSelectionListener =
        /**
        * @return {?}
        */
        function () {};

        this._removeUniqueSelectionListener = _expansionDispatcher.listen(
        /**
        * @param {?} id
        * @param {?} accordionId
        * @return {?}
        */
        function (id, accordionId) {
          if (_this100.accordion && !_this100.accordion.multi && _this100.accordion.id === accordionId && _this100.id !== id) {
            _this100.expanded = false;
          }
        }); // When an accordion item is hosted in an accordion, subscribe to open/close events.

        if (this.accordion) {
          this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
        }
      }
      /**
       * Whether the AccordionItem is expanded.
       * @return {?}
       */


      _createClass(CdkAccordionItem, [{
        key: "ngOnDestroy",

        /**
         * Emits an event for the accordion item being destroyed.
         * @return {?}
         */
        value: function ngOnDestroy() {
          this.opened.complete();
          this.closed.complete();
          this.destroyed.emit();
          this.destroyed.complete();

          this._removeUniqueSelectionListener();

          this._openCloseAllSubscription.unsubscribe();
        }
        /**
         * Toggles the expanded state of the accordion item.
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          if (!this.disabled) {
            this.expanded = !this.expanded;
          }
        }
        /**
         * Sets the expanded state of the accordion item to false.
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.disabled) {
            this.expanded = false;
          }
        }
        /**
         * Sets the expanded state of the accordion item to true.
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          if (!this.disabled) {
            this.expanded = true;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_subscribeToOpenCloseAllActions",
        value: function _subscribeToOpenCloseAllActions() {
          var _this101 = this;

          return this.accordion._openCloseAllActions.subscribe(
          /**
          * @param {?} expanded
          * @return {?}
          */
          function (expanded) {
            // Only change expanded state if item is enabled
            if (!_this101.disabled) {
              _this101.expanded = expanded;
            }
          });
        }
      }, {
        key: "expanded",
        get: function get() {
          return this._expanded;
        }
        /**
         * @param {?} expanded
         * @return {?}
         */
        ,
        set: function set(expanded) {
          expanded = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(expanded); // Only emit events and update the internal value if the value changes.

          if (this._expanded !== expanded) {
            this._expanded = expanded;
            this.expandedChange.emit(expanded);

            if (expanded) {
              this.opened.emit();
              /**
               * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
               * the name value is the id of the accordion.
               * @type {?}
               */

              var accordionId = this.accordion ? this.accordion.id : this.id;

              this._expansionDispatcher.notify(this.id, accordionId);
            } else {
              this.closed.emit();
            } // Ensures that the animation will run when the value is set outside of an `@Input`.
            // This includes cases like the open, close and toggle methods.


            this._changeDetectorRef.markForCheck();
          }
        }
        /**
         * Whether the AccordionItem is disabled.
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} disabled
         * @return {?}
         */
        ,
        set: function set(disabled) {
          this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(disabled);
        }
      }]);

      return CdkAccordionItem;
    }();

    CdkAccordionItem.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'cdk-accordion-item, [cdkAccordionItem]',
        exportAs: 'cdkAccordionItem',
        providers: [// Provide CdkAccordion as undefined to prevent nested accordion items from registering
        // to the same accordion.
        {
          provide: CdkAccordion,
          useValue: ɵ0
        }]
      }]
    }];
    /** @nocollapse */

    CdkAccordionItem.ctorParameters = function () {
      return [{
        type: CdkAccordion,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["UniqueSelectionDispatcher"]
      }];
    };

    CdkAccordionItem.propDecorators = {
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      opened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      destroyed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      expandedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var CdkAccordionModule = function CdkAccordionModule() {
      _classCallCheck(this, CdkAccordionModule);
    };

    CdkAccordionModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        exports: [CdkAccordion, CdkAccordionItem],
        declarations: [CdkAccordion, CdkAccordionItem]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/bidi.js":
  /*!***************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/bidi.js ***!
    \***************************************************/

  /*! exports provided: Directionality, DIR_DOCUMENT, Dir, BidiModule, ɵa */

  /***/
  function node_modulesAngularCdkEsm2015BidiJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Directionality", function () {
      return Directionality;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DIR_DOCUMENT", function () {
      return DIR_DOCUMENT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Dir", function () {
      return Dir;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BidiModule", function () {
      return BidiModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return DIR_DOCUMENT_FACTORY;
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Injection token used to inject the document into Directionality.
     * This is used so that the value can be faked in tests.
     *
     * We can't use the real document in tests because changing the real `dir` causes geometry-based
     * tests in Safari to fail.
     *
     * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
     * themselves use things like `querySelector` in test code.
     *
     * This token is defined in a separate file from Directionality as a workaround for
     * https://github.com/angular/angular/issues/22559
     *
     * \@docs-private
     * @type {?}
     */


    var DIR_DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('cdk-dir-doc', {
      providedIn: 'root',
      factory: DIR_DOCUMENT_FACTORY
    });
    /**
     * \@docs-private
     * @return {?}
     */

    function DIR_DOCUMENT_FACTORY() {
      return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["inject"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__["DOCUMENT"]);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The directionality (LTR / RTL) context for the application (or a subtree of it).
     * Exposes the current direction and a stream of direction changes.
     */


    var Directionality =
    /*#__PURE__*/
    function () {
      /**
       * @param {?=} _document
       */
      function Directionality(_document) {
        _classCallCheck(this, Directionality);

        /**
         * The current 'ltr' or 'rtl' value.
         */
        this.value = 'ltr';
        /**
         * Stream that emits whenever the 'ltr' / 'rtl' state changes.
         */

        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();

        if (_document) {
          // TODO: handle 'auto' value -
          // We still need to account for dir="auto".
          // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
          // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now

          /** @type {?} */
          var bodyDir = _document.body ? _document.body.dir : null;
          /** @type {?} */

          var htmlDir = _document.documentElement ? _document.documentElement.dir : null;
          /** @type {?} */

          var value = bodyDir || htmlDir;
          this.value = value === 'ltr' || value === 'rtl' ? value : 'ltr';
        }
      }
      /**
       * @return {?}
       */


      _createClass(Directionality, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.change.complete();
        }
      }]);

      return Directionality;
    }();

    Directionality.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    Directionality.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DIR_DOCUMENT]
        }]
      }];
    };
    /** @nocollapse */


    Directionality.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function Directionality_Factory() {
        return new Directionality(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(DIR_DOCUMENT, 8));
      },
      token: Directionality,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Directive to listen for changes of direction of part of the DOM.
     *
     * Provides itself as Directionality such that descendant directives only need to ever inject
     * Directionality to get the closest direction.
     */

    var Dir =
    /*#__PURE__*/
    function () {
      function Dir() {
        _classCallCheck(this, Dir);

        /**
         * Normalized direction that accounts for invalid/unsupported values.
         */
        this._dir = 'ltr';
        /**
         * Whether the `value` has been set to its initial value.
         */

        this._isInitialized = false;
        /**
         * Event emitted when the direction changes.
         */

        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * \@docs-private
       * @return {?}
       */


      _createClass(Dir, [{
        key: "ngAfterContentInit",

        /**
         * Initialize once default value has been set.
         * @return {?}
         */
        value: function ngAfterContentInit() {
          this._isInitialized = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.change.complete();
        }
      }, {
        key: "dir",
        get: function get() {
          return this._dir;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          var old = this._dir;
          /** @type {?} */

          var normalizedValue = value ? value.toLowerCase() : value;
          this._rawDir = value;
          this._dir = normalizedValue === 'ltr' || normalizedValue === 'rtl' ? normalizedValue : 'ltr';

          if (old !== this._dir && this._isInitialized) {
            this.change.emit(this._dir);
          }
        }
        /**
         * Current layout direction of the element.
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this.dir;
        }
      }]);

      return Dir;
    }();

    Dir.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[dir]',
        providers: [{
          provide: Directionality,
          useExisting: Dir
        }],
        host: {
          '[attr.dir]': '_rawDir'
        },
        exportAs: 'dir'
      }]
    }];
    Dir.propDecorators = {
      change: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
        args: ['dirChange']
      }],
      dir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var BidiModule = function BidiModule() {
      _classCallCheck(this, BidiModule);
    };

    BidiModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        exports: [Dir],
        declarations: [Dir]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/collections.js":
  /*!**********************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/collections.js ***!
    \**********************************************************/

  /*! exports provided: UniqueSelectionDispatcher, ArrayDataSource, isDataSource, DataSource, getMultipleValuesInSingleSelectionError, SelectionModel */

  /***/
  function node_modulesAngularCdkEsm2015CollectionsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UniqueSelectionDispatcher", function () {
      return UniqueSelectionDispatcher;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ArrayDataSource", function () {
      return ArrayDataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDataSource", function () {
      return isDataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DataSource", function () {
      return DataSource;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getMultipleValuesInSingleSelectionError", function () {
      return getMultipleValuesInSingleSelectionError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SelectionModel", function () {
      return SelectionModel;
    });
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     * @template T
     */


    var DataSource = function DataSource() {
      _classCallCheck(this, DataSource);
    };
    /**
     * Checks whether an object is a data source.
     * @param {?} value
     * @return {?}
     */


    function isDataSource(value) {
      // Check if the value is a DataSource by observing if it has a connect function. Cannot
      // be checked as an `instanceof DataSource` since people could create their own sources
      // that match the interface, but don't extend DataSource.
      return value && typeof value.connect === 'function';
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * DataSource wrapper for a native array.
     * @template T
     */


    var ArrayDataSource =
    /*#__PURE__*/
    function (_DataSource) {
      _inherits(ArrayDataSource, _DataSource);

      /**
       * @param {?} _data
       */
      function ArrayDataSource(_data) {
        var _this102;

        _classCallCheck(this, ArrayDataSource);

        _this102 = _possibleConstructorReturn(this, _getPrototypeOf(ArrayDataSource).call(this));
        _this102._data = _data;
        return _this102;
      }
      /**
       * @return {?}
       */


      _createClass(ArrayDataSource, [{
        key: "connect",
        value: function connect() {
          return this._data instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__["Observable"] ? this._data : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__["of"])(this._data);
        }
        /**
         * @return {?}
         */

      }, {
        key: "disconnect",
        value: function disconnect() {}
      }]);

      return ArrayDataSource;
    }(DataSource);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Class to be used to power selecting one or more options from a list.
     * @template T
     */


    var SelectionModel =
    /*#__PURE__*/
    function () {
      /**
       * @param {?=} _multiple
       * @param {?=} initiallySelectedValues
       * @param {?=} _emitChanges
       */
      function SelectionModel() {
        var _this103 = this;

        var _multiple = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var initiallySelectedValues = arguments.length > 1 ? arguments[1] : undefined;

        var _emitChanges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        _classCallCheck(this, SelectionModel);

        this._multiple = _multiple;
        this._emitChanges = _emitChanges;
        /**
         * Currently-selected values.
         */

        this._selection = new Set();
        /**
         * Keeps track of the deselected options that haven't been emitted by the change event.
         */

        this._deselectedToEmit = [];
        /**
         * Keeps track of the selected options that haven't been emitted by the change event.
         */

        this._selectedToEmit = [];
        /**
         * Event emitted when the value has changed.
         */

        this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        /**
         * Event emitted when the value has changed.
         * @deprecated Use `changed` instead.
         * \@breaking-change 8.0.0 To be changed to `changed`
         */

        this.onChange = this.changed;

        if (initiallySelectedValues && initiallySelectedValues.length) {
          if (_multiple) {
            initiallySelectedValues.forEach(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              return _this103._markSelected(value);
            });
          } else {
            this._markSelected(initiallySelectedValues[0]);
          } // Clear the array in order to avoid firing the change event for preselected values.


          this._selectedToEmit.length = 0;
        }
      }
      /**
       * Selected values.
       * @return {?}
       */


      _createClass(SelectionModel, [{
        key: "select",

        /**
         * Selects a value or an array of values.
         * @param {...?} values
         * @return {?}
         */
        value: function select() {
          var _this104 = this;

          for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            values[_key2] = arguments[_key2];
          }

          this._verifyValueAssignment(values);

          values.forEach(
          /**
          * @param {?} value
          * @return {?}
          */
          function (value) {
            return _this104._markSelected(value);
          });

          this._emitChangeEvent();
        }
        /**
         * Deselects a value or an array of values.
         * @param {...?} values
         * @return {?}
         */

      }, {
        key: "deselect",
        value: function deselect() {
          var _this105 = this;

          for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            values[_key3] = arguments[_key3];
          }

          this._verifyValueAssignment(values);

          values.forEach(
          /**
          * @param {?} value
          * @return {?}
          */
          function (value) {
            return _this105._unmarkSelected(value);
          });

          this._emitChangeEvent();
        }
        /**
         * Toggles a value between selected and deselected.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(value) {
          this.isSelected(value) ? this.deselect(value) : this.select(value);
        }
        /**
         * Clears all of the selected values.
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          this._unmarkAll();

          this._emitChangeEvent();
        }
        /**
         * Determines whether a value is selected.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isSelected",
        value: function isSelected(value) {
          return this._selection.has(value);
        }
        /**
         * Determines whether the model does not have a value.
         * @return {?}
         */

      }, {
        key: "isEmpty",
        value: function isEmpty() {
          return this._selection.size === 0;
        }
        /**
         * Determines whether the model has a value.
         * @return {?}
         */

      }, {
        key: "hasValue",
        value: function hasValue() {
          return !this.isEmpty();
        }
        /**
         * Sorts the selected values based on a predicate function.
         * @param {?=} predicate
         * @return {?}
         */

      }, {
        key: "sort",
        value: function sort(predicate) {
          if (this._multiple && this.selected) {
            /** @type {?} */
            this._selected.sort(predicate);
          }
        }
        /**
         * Gets whether multiple values can be selected.
         * @return {?}
         */

      }, {
        key: "isMultipleSelection",
        value: function isMultipleSelection() {
          return this._multiple;
        }
        /**
         * Emits a change event and clears the records of selected and deselected values.
         * @private
         * @return {?}
         */

      }, {
        key: "_emitChangeEvent",
        value: function _emitChangeEvent() {
          // Clear the selected values so they can be re-cached.
          this._selected = null;

          if (this._selectedToEmit.length || this._deselectedToEmit.length) {
            this.changed.next({
              source: this,
              added: this._selectedToEmit,
              removed: this._deselectedToEmit
            });
            this._deselectedToEmit = [];
            this._selectedToEmit = [];
          }
        }
        /**
         * Selects a value.
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_markSelected",
        value: function _markSelected(value) {
          if (!this.isSelected(value)) {
            if (!this._multiple) {
              this._unmarkAll();
            }

            this._selection.add(value);

            if (this._emitChanges) {
              this._selectedToEmit.push(value);
            }
          }
        }
        /**
         * Deselects a value.
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_unmarkSelected",
        value: function _unmarkSelected(value) {
          if (this.isSelected(value)) {
            this._selection.delete(value);

            if (this._emitChanges) {
              this._deselectedToEmit.push(value);
            }
          }
        }
        /**
         * Clears out the selected values.
         * @private
         * @return {?}
         */

      }, {
        key: "_unmarkAll",
        value: function _unmarkAll() {
          var _this106 = this;

          if (!this.isEmpty()) {
            this._selection.forEach(
            /**
            * @param {?} value
            * @return {?}
            */
            function (value) {
              return _this106._unmarkSelected(value);
            });
          }
        }
        /**
         * Verifies the value assignment and throws an error if the specified value array is
         * including multiple values while the selection model is not supporting multiple values.
         * @private
         * @param {?} values
         * @return {?}
         */

      }, {
        key: "_verifyValueAssignment",
        value: function _verifyValueAssignment(values) {
          if (values.length > 1 && !this._multiple) {
            throw getMultipleValuesInSingleSelectionError();
          }
        }
      }, {
        key: "selected",
        get: function get() {
          if (!this._selected) {
            this._selected = Array.from(this._selection.values());
          }

          return this._selected;
        }
      }]);

      return SelectionModel;
    }();
    /**
     * Returns an error that reports that multiple values are passed into a selection model
     * with a single value.
     * \@docs-private
     * @return {?}
     */


    function getMultipleValuesInSingleSelectionError() {
      return Error('Cannot pass multiple values into SelectionModel with single-value mode.');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Class to coordinate unique selection based on name.
     * Intended to be consumed as an Angular service.
     * This service is needed because native radio change events are only fired on the item currently
     * being selected, and we still need to uncheck the previous selection.
     *
     * This service does not *store* any IDs and names because they may change at any time, so it is
     * less error-prone if they are simply passed through when the events occur.
     */


    var UniqueSelectionDispatcher =
    /*#__PURE__*/
    function () {
      function UniqueSelectionDispatcher() {
        _classCallCheck(this, UniqueSelectionDispatcher);

        this._listeners = [];
      }
      /**
       * Notify other items that selection for the given name has been set.
       * @param {?} id ID of the item.
       * @param {?} name Name of the item.
       * @return {?}
       */


      _createClass(UniqueSelectionDispatcher, [{
        key: "notify",
        value: function notify(id, name) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var listener = _step.value;
              listener(id, name);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
        /**
         * Listen for future changes to item selection.
         * @param {?} listener
         * @return {?} Function used to deregister listener
         */

      }, {
        key: "listen",
        value: function listen(listener) {
          var _this107 = this;

          this._listeners.push(listener);

          return (
            /**
            * @return {?}
            */
            function () {
              _this107._listeners = _this107._listeners.filter(
              /**
              * @param {?} registered
              * @return {?}
              */
              function (registered) {
                return listener !== registered;
              });
            }
          );
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._listeners = [];
        }
      }]);

      return UniqueSelectionDispatcher;
    }();

    UniqueSelectionDispatcher.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    UniqueSelectionDispatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function UniqueSelectionDispatcher_Factory() {
        return new UniqueSelectionDispatcher();
      },
      token: UniqueSelectionDispatcher,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/overlay.js":
  /*!******************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/overlay.js ***!
    \******************************************************/

  /*! exports provided: ViewportRuler, VIEWPORT_RULER_PROVIDER, CdkScrollable, ScrollDispatcher, Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, FlexibleConnectedPositionStrategy, OverlayConfig, validateVerticalPosition, validateHorizontalPosition, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OverlayModule, OVERLAY_PROVIDERS, ɵg, ɵf, ɵb, ɵa, ɵc, ɵe, ɵd */

  /***/
  function node_modulesAngularCdkEsm2015OverlayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Overlay", function () {
      return Overlay;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayContainer", function () {
      return OverlayContainer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkOverlayOrigin", function () {
      return CdkOverlayOrigin;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkConnectedOverlay", function () {
      return CdkConnectedOverlay;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FullscreenOverlayContainer", function () {
      return FullscreenOverlayContainer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayRef", function () {
      return OverlayRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayKeyboardDispatcher", function () {
      return OverlayKeyboardDispatcher;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayPositionBuilder", function () {
      return OverlayPositionBuilder;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GlobalPositionStrategy", function () {
      return GlobalPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectedPositionStrategy", function () {
      return ConnectedPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FlexibleConnectedPositionStrategy", function () {
      return FlexibleConnectedPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayConfig", function () {
      return OverlayConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "validateVerticalPosition", function () {
      return validateVerticalPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "validateHorizontalPosition", function () {
      return validateHorizontalPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectionPositionPair", function () {
      return ConnectionPositionPair;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollingVisibility", function () {
      return ScrollingVisibility;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectedOverlayPositionChange", function () {
      return ConnectedOverlayPositionChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollStrategyOptions", function () {
      return ScrollStrategyOptions;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RepositionScrollStrategy", function () {
      return RepositionScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CloseScrollStrategy", function () {
      return CloseScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NoopScrollStrategy", function () {
      return NoopScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BlockScrollStrategy", function () {
      return BlockScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OverlayModule", function () {
      return OverlayModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OVERLAY_PROVIDERS", function () {
      return OVERLAY_PROVIDERS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵg", function () {
      return OVERLAY_KEYBOARD_DISPATCHER_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵf", function () {
      return OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵb", function () {
      return OVERLAY_CONTAINER_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return OVERLAY_CONTAINER_PROVIDER_FACTORY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵe", function () {
      return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY;
    });
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/scrolling */
    "./node_modules/@angular/cdk/esm2015/scrolling.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ViewportRuler", function () {
      return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "VIEWPORT_RULER_PROVIDER", function () {
      return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["VIEWPORT_RULER_PROVIDER"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "CdkScrollable", function () {
      return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["CdkScrollable"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ScrollDispatcher", function () {
      return _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"];
    });
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/platform */
    "./node_modules/@angular/cdk/esm2015/platform.js");
    /* harmony import */


    var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/cdk/bidi */
    "./node_modules/@angular/cdk/esm2015/bidi.js");
    /* harmony import */


    var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! @angular/cdk/portal */
    "./node_modules/@angular/cdk/esm2015/portal.js");
    /* harmony import */


    var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @angular/cdk/keycodes */
    "./node_modules/@angular/cdk/esm2015/keycodes.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Strategy that will prevent the user from scrolling while the overlay is visible.
     */


    var BlockScrollStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewportRuler
       * @param {?} document
       */
      function BlockScrollStrategy(_viewportRuler, document) {
        _classCallCheck(this, BlockScrollStrategy);

        this._viewportRuler = _viewportRuler;
        this._previousHTMLStyles = {
          top: '',
          left: ''
        };
        this._isEnabled = false;
        this._document = document;
      }
      /**
       * Attaches this scroll strategy to an overlay.
       * @return {?}
       */


      _createClass(BlockScrollStrategy, [{
        key: "attach",
        value: function attach() {}
        /**
         * Blocks page-level scroll while the attached overlay is open.
         * @return {?}
         */

      }, {
        key: "enable",
        value: function enable() {
          if (this._canBeEnabled()) {
            /** @type {?} */
            var root =
            /** @type {?} */
            this._document.documentElement;
            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(); // Cache the previous inline styles in case the user had set them.

            this._previousHTMLStyles.left = root.style.left || '';
            this._previousHTMLStyles.top = root.style.top || ''; // Note: we're using the `html` node, instead of the `body`, because the `body` may
            // have the user agent margin, whereas the `html` is guaranteed not to have one.

            root.style.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(-this._previousScrollPosition.left);
            root.style.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(-this._previousScrollPosition.top);
            root.classList.add('cdk-global-scrollblock');
            this._isEnabled = true;
          }
        }
        /**
         * Unblocks page-level scroll while the attached overlay is open.
         * @return {?}
         */

      }, {
        key: "disable",
        value: function disable() {
          if (this._isEnabled) {
            /** @type {?} */
            var html =
            /** @type {?} */
            this._document.documentElement;
            /** @type {?} */

            var body =
            /** @type {?} */
            this._document.body;
            /** @type {?} */

            var htmlStyle =
            /** @type {?} */
            html.style;
            /** @type {?} */

            var bodyStyle =
            /** @type {?} */
            body.style;
            /** @type {?} */

            var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';
            /** @type {?} */

            var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';
            this._isEnabled = false;
            htmlStyle.left = this._previousHTMLStyles.left;
            htmlStyle.top = this._previousHTMLStyles.top;
            html.classList.remove('cdk-global-scrollblock'); // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior

            htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';
            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
            htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
            bodyStyle.scrollBehavior = previousBodyScrollBehavior;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_canBeEnabled",
        value: function _canBeEnabled() {
          // Since the scroll strategies can't be singletons, we have to use a global CSS class
          // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
          // scrolling multiple times.

          /** @type {?} */
          var html =
          /** @type {?} */
          this._document.documentElement;

          if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
            return false;
          }
          /** @type {?} */


          var body = this._document.body;
          /** @type {?} */

          var viewport = this._viewportRuler.getViewportSize();

          return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
        }
      }]);

      return BlockScrollStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
     * @return {?}
     */


    function getMatScrollStrategyAlreadyAttachedError() {
      return Error("Scroll strategy has already been attached.");
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Strategy that will close the overlay as soon as the user starts scrolling.
     */


    var CloseScrollStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _scrollDispatcher
       * @param {?} _ngZone
       * @param {?} _viewportRuler
       * @param {?=} _config
       */
      function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
        var _this108 = this;

        _classCallCheck(this, CloseScrollStrategy);

        this._scrollDispatcher = _scrollDispatcher;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        this._config = _config;
        this._scrollSubscription = null;
        /**
         * Detaches the overlay ref and disables the scroll strategy.
         */

        this._detach =
        /**
        * @return {?}
        */
        function () {
          _this108.disable();

          if (_this108._overlayRef.hasAttached()) {
            _this108._ngZone.run(
            /**
            * @return {?}
            */
            function () {
              return _this108._overlayRef.detach();
            });
          }
        };
      }
      /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */


      _createClass(CloseScrollStrategy, [{
        key: "attach",
        value: function attach(overlayRef) {
          if (this._overlayRef) {
            throw getMatScrollStrategyAlreadyAttachedError();
          }

          this._overlayRef = overlayRef;
        }
        /**
         * Enables the closing of the attached overlay on scroll.
         * @return {?}
         */

      }, {
        key: "enable",
        value: function enable() {
          var _this109 = this;

          if (this._scrollSubscription) {
            return;
          }
          /** @type {?} */


          var stream = this._scrollDispatcher.scrolled(0);

          if (this._config && this._config.threshold && this._config.threshold > 1) {
            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
            this._scrollSubscription = stream.subscribe(
            /**
            * @return {?}
            */
            function () {
              /** @type {?} */
              var scrollPosition = _this109._viewportRuler.getViewportScrollPosition().top;

              if (Math.abs(scrollPosition - _this109._initialScrollPosition) >
              /** @type {?} */

              /** @type {?} */
              _this109._config.threshold) {
                _this109._detach();
              } else {
                _this109._overlayRef.updatePosition();
              }
            });
          } else {
            this._scrollSubscription = stream.subscribe(this._detach);
          }
        }
        /**
         * Disables the closing the attached overlay on scroll.
         * @return {?}
         */

      }, {
        key: "disable",
        value: function disable() {
          if (this._scrollSubscription) {
            this._scrollSubscription.unsubscribe();

            this._scrollSubscription = null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this.disable();
          this._overlayRef =
          /** @type {?} */
          null;
        }
      }]);

      return CloseScrollStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Scroll strategy that doesn't do anything.
     */


    var NoopScrollStrategy =
    /*#__PURE__*/
    function () {
      function NoopScrollStrategy() {
        _classCallCheck(this, NoopScrollStrategy);
      }

      _createClass(NoopScrollStrategy, [{
        key: "enable",

        /**
         * Does nothing, as this scroll strategy is a no-op.
         * @return {?}
         */
        value: function enable() {}
        /**
         * Does nothing, as this scroll strategy is a no-op.
         * @return {?}
         */

      }, {
        key: "disable",
        value: function disable() {}
        /**
         * Does nothing, as this scroll strategy is a no-op.
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach() {}
      }]);

      return NoopScrollStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO(jelbourn): move this to live with the rest of the scrolling code
    // TODO(jelbourn): someday replace this with IntersectionObservers

    /**
     * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.
     * \@docs-private
     * @param {?} element Dimensions of the element (from getBoundingClientRect)
     * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
     * @return {?} Whether the element is scrolled out of view
     */


    function isElementScrolledOutsideView(element, scrollContainers) {
      return scrollContainers.some(
      /**
      * @param {?} containerBounds
      * @return {?}
      */
      function (containerBounds) {
        /** @type {?} */
        var outsideAbove = element.bottom < containerBounds.top;
        /** @type {?} */

        var outsideBelow = element.top > containerBounds.bottom;
        /** @type {?} */

        var outsideLeft = element.right < containerBounds.left;
        /** @type {?} */

        var outsideRight = element.left > containerBounds.right;
        return outsideAbove || outsideBelow || outsideLeft || outsideRight;
      });
    }
    /**
     * Gets whether an element is clipped by any of its scrolling containers.
     * \@docs-private
     * @param {?} element Dimensions of the element (from getBoundingClientRect)
     * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
     * @return {?} Whether the element is clipped
     */


    function isElementClippedByScrolling(element, scrollContainers) {
      return scrollContainers.some(
      /**
      * @param {?} scrollContainerRect
      * @return {?}
      */
      function (scrollContainerRect) {
        /** @type {?} */
        var clippedAbove = element.top < scrollContainerRect.top;
        /** @type {?} */

        var clippedBelow = element.bottom > scrollContainerRect.bottom;
        /** @type {?} */

        var clippedLeft = element.left < scrollContainerRect.left;
        /** @type {?} */

        var clippedRight = element.right > scrollContainerRect.right;
        return clippedAbove || clippedBelow || clippedLeft || clippedRight;
      });
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Strategy that will update the element position as the user is scrolling.
     */


    var RepositionScrollStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _scrollDispatcher
       * @param {?} _viewportRuler
       * @param {?} _ngZone
       * @param {?=} _config
       */
      function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
        _classCallCheck(this, RepositionScrollStrategy);

        this._scrollDispatcher = _scrollDispatcher;
        this._viewportRuler = _viewportRuler;
        this._ngZone = _ngZone;
        this._config = _config;
        this._scrollSubscription = null;
      }
      /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */


      _createClass(RepositionScrollStrategy, [{
        key: "attach",
        value: function attach(overlayRef) {
          if (this._overlayRef) {
            throw getMatScrollStrategyAlreadyAttachedError();
          }

          this._overlayRef = overlayRef;
        }
        /**
         * Enables repositioning of the attached overlay on scroll.
         * @return {?}
         */

      }, {
        key: "enable",
        value: function enable() {
          var _this110 = this;

          if (!this._scrollSubscription) {
            /** @type {?} */
            var throttle = this._config ? this._config.scrollThrottle : 0;
            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(
            /**
            * @return {?}
            */
            function () {
              _this110._overlayRef.updatePosition(); // TODO(crisbeto): make `close` on by default once all components can handle it.


              if (_this110._config && _this110._config.autoClose) {
                /** @type {?} */
                var overlayRect = _this110._overlayRef.overlayElement.getBoundingClientRect();

                var _this110$_viewportRul = _this110._viewportRuler.getViewportSize(),
                    width = _this110$_viewportRul.width,
                    height = _this110$_viewportRul.height; // TODO(crisbeto): include all ancestor scroll containers here once
                // we have a way of exposing the trigger element to the scroll strategy.

                /** @type {?} */


                var parentRects = [{
                  width: width,
                  height: height,
                  bottom: height,
                  right: width,
                  top: 0,
                  left: 0
                }];

                if (isElementScrolledOutsideView(overlayRect, parentRects)) {
                  _this110.disable();

                  _this110._ngZone.run(
                  /**
                  * @return {?}
                  */
                  function () {
                    return _this110._overlayRef.detach();
                  });
                }
              }
            });
          }
        }
        /**
         * Disables repositioning of the attached overlay on scroll.
         * @return {?}
         */

      }, {
        key: "disable",
        value: function disable() {
          if (this._scrollSubscription) {
            this._scrollSubscription.unsubscribe();

            this._scrollSubscription = null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this.disable();
          this._overlayRef =
          /** @type {?} */
          null;
        }
      }]);

      return RepositionScrollStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Options for how an overlay will handle scrolling.
     *
     * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
     * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
     */


    var ScrollStrategyOptions =
    /**
     * @param {?} _scrollDispatcher
     * @param {?} _viewportRuler
     * @param {?} _ngZone
     * @param {?} document
     */
    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {
      var _this111 = this;

      _classCallCheck(this, ScrollStrategyOptions);

      this._scrollDispatcher = _scrollDispatcher;
      this._viewportRuler = _viewportRuler;
      this._ngZone = _ngZone;
      /**
       * Do nothing on scroll.
       */

      this.noop =
      /**
      * @return {?}
      */
      function () {
        return new NoopScrollStrategy();
      };
      /**
       * Close the overlay as soon as the user scrolls.
       * @param config Configuration to be used inside the scroll strategy.
       */


      this.close =
      /**
      * @param {?=} config
      * @return {?}
      */
      function (config) {
        return new CloseScrollStrategy(_this111._scrollDispatcher, _this111._ngZone, _this111._viewportRuler, config);
      };
      /**
       * Block scrolling.
       */


      this.block =
      /**
      * @return {?}
      */
      function () {
        return new BlockScrollStrategy(_this111._viewportRuler, _this111._document);
      };
      /**
       * Update the overlay's position on scroll.
       * @param config Configuration to be used inside the scroll strategy.
       * Allows debouncing the reposition calls.
       */


      this.reposition =
      /**
      * @param {?=} config
      * @return {?}
      */
      function (config) {
        return new RepositionScrollStrategy(_this111._scrollDispatcher, _this111._viewportRuler, _this111._ngZone, config);
      };

      this._document = document;
    };

    ScrollStrategyOptions.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    ScrollStrategyOptions.ctorParameters = function () {
      return [{
        type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"]
      }, {
        type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }];
    };
    /** @nocollapse */


    ScrollStrategyOptions.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({
      factory: function ScrollStrategyOptions_Factory() {
        return new ScrollStrategyOptions(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollDispatcher"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]));
      },
      token: ScrollStrategyOptions,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Initial configuration used when creating an overlay.
     */

    var OverlayConfig =
    /**
     * @param {?=} config
     */
    function OverlayConfig(config) {
      _classCallCheck(this, OverlayConfig);

      /**
       * Strategy to be used when handling scroll events while the overlay is open.
       */
      this.scrollStrategy = new NoopScrollStrategy();
      /**
       * Custom class to add to the overlay pane.
       */

      this.panelClass = '';
      /**
       * Whether the overlay has a backdrop.
       */

      this.hasBackdrop = false;
      /**
       * Custom class to add to the backdrop
       */

      this.backdropClass = 'cdk-overlay-dark-backdrop';
      /**
       * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
       * Note that this usually doesn't include clicking on links (unless the user is using
       * the `HashLocationStrategy`).
       */

      this.disposeOnNavigation = false;

      if (config) {
        /** @type {?} */
        var configKeys =
        /** @type {?} */
        Object.keys(config);

        for (var _i2 = 0, _configKeys = configKeys; _i2 < _configKeys.length; _i2++) {
          var key = _configKeys[_i2];

          if (config[key] !== undefined) {
            // TypeScript, as of version 3.5, sees the left-hand-side of this expression
            // as "I don't know *which* key this is, so the only valid value is the intersection
            // of all the posible values." In this case, that happens to be `undefined`. TypeScript
            // is not smart enough to see that the right-hand-side is actually an access of the same
            // exact type with the same exact key, meaning that the value type must be identical.
            // So we use `any` to work around this.
            this[key] =
            /** @type {?} */
            config[key];
          }
        }
      }
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The points of the origin element and the overlay element to connect.
     */


    var ConnectionPositionPair =
    /**
     * @param {?} origin
     * @param {?} overlay
     * @param {?=} offsetX
     * @param {?=} offsetY
     * @param {?=} panelClass
     */
    function ConnectionPositionPair(origin, overlay, offsetX, offsetY, panelClass) {
      _classCallCheck(this, ConnectionPositionPair);

      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.panelClass = panelClass;
      this.originX = origin.originX;
      this.originY = origin.originY;
      this.overlayX = overlay.overlayX;
      this.overlayY = overlay.overlayY;
    };
    /**
     * Set of properties regarding the position of the origin and overlay relative to the viewport
     * with respect to the containing Scrollable elements.
     *
     * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
     * bounds of any one of the strategy's Scrollable's bounding client rectangle.
     *
     * The overlay and origin are outside view if there is no overlap between their bounding client
     * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
     *
     *       -----------                    -----------
     *       | outside |                    | clipped |
     *       |  view   |              --------------------------
     *       |         |              |     |         |        |
     *       ----------               |     -----------        |
     *  --------------------------    |                        |
     *  |                        |    |      Scrollable        |
     *  |                        |    |                        |
     *  |                        |     --------------------------
     *  |      Scrollable        |
     *  |                        |
     *  --------------------------
     *
     * \@docs-private
     */


    var ScrollingVisibility = function ScrollingVisibility() {
      _classCallCheck(this, ScrollingVisibility);
    };
    /**
     * The change event emitted by the strategy when a fallback position is used.
     */


    var ConnectedOverlayPositionChange =
    /**
     * @param {?} connectionPair
     * @param {?} scrollableViewProperties
     */
    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
      _classCallCheck(this, ConnectedOverlayPositionChange);

      this.connectionPair = connectionPair;
      this.scrollableViewProperties = scrollableViewProperties;
    };
    /** @nocollapse */


    ConnectedOverlayPositionChange.ctorParameters = function () {
      return [{
        type: ConnectionPositionPair
      }, {
        type: ScrollingVisibility,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"]
        }]
      }];
    };
    /**
     * Validates whether a vertical position property matches the expected values.
     * \@docs-private
     * @param {?} property Name of the property being validated.
     * @param {?} value Value of the property being validated.
     * @return {?}
     */


    function validateVerticalPosition(property, value) {
      if (value !== 'top' && value !== 'bottom' && value !== 'center') {
        throw Error("ConnectedPosition: Invalid ".concat(property, " \"").concat(value, "\". ") + "Expected \"top\", \"bottom\" or \"center\".");
      }
    }
    /**
     * Validates whether a horizontal position property matches the expected values.
     * \@docs-private
     * @param {?} property Name of the property being validated.
     * @param {?} value Value of the property being validated.
     * @return {?}
     */


    function validateHorizontalPosition(property, value) {
      if (value !== 'start' && value !== 'end' && value !== 'center') {
        throw Error("ConnectedPosition: Invalid ".concat(property, " \"").concat(value, "\". ") + "Expected \"start\", \"end\" or \"center\".");
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
     * if any. It maintains a list of attached overlays to determine best suited overlay based
     * on event target and order of overlay opens.
     */


    var OverlayKeyboardDispatcher =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} document
       */
      function OverlayKeyboardDispatcher(document) {
        var _this112 = this;

        _classCallCheck(this, OverlayKeyboardDispatcher);

        /**
         * Currently attached overlays in the order they were attached.
         */
        this._attachedOverlays = [];
        /**
         * Keyboard event listener that will be attached to the body.
         */

        this._keydownListener =
        /**
        * @param {?} event
        * @return {?}
        */
        function (event) {
          /** @type {?} */
          var overlays = _this112._attachedOverlays;

          for (var i = overlays.length - 1; i > -1; i--) {
            // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
            // We want to target the most recent overlay, rather than trying to match where the event came
            // from, because some components might open an overlay, but keep focus on a trigger element
            // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
            // because we don't want overlays that don't handle keyboard events to block the ones below
            // them that do.
            if (overlays[i]._keydownEventSubscriptions > 0) {
              overlays[i]._keydownEvents.next(event);

              break;
            }
          }
        };

        this._document = document;
      }
      /**
       * @return {?}
       */


      _createClass(OverlayKeyboardDispatcher, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._detach();
        }
        /**
         * Add a new overlay to the list of attached overlay refs.
         * @param {?} overlayRef
         * @return {?}
         */

      }, {
        key: "add",
        value: function add(overlayRef) {
          // Ensure that we don't get the same overlay multiple times.
          this.remove(overlayRef); // Lazily start dispatcher once first overlay is added

          if (!this._isAttached) {
            this._document.body.addEventListener('keydown', this._keydownListener);

            this._isAttached = true;
          }

          this._attachedOverlays.push(overlayRef);
        }
        /**
         * Remove an overlay from the list of attached overlay refs.
         * @param {?} overlayRef
         * @return {?}
         */

      }, {
        key: "remove",
        value: function remove(overlayRef) {
          /** @type {?} */
          var index = this._attachedOverlays.indexOf(overlayRef);

          if (index > -1) {
            this._attachedOverlays.splice(index, 1);
          } // Remove the global listener once there are no more overlays.


          if (this._attachedOverlays.length === 0) {
            this._detach();
          }
        }
        /**
         * Detaches the global keyboard event listener.
         * @private
         * @return {?}
         */

      }, {
        key: "_detach",
        value: function _detach() {
          if (this._isAttached) {
            this._document.body.removeEventListener('keydown', this._keydownListener);

            this._isAttached = false;
          }
        }
      }]);

      return OverlayKeyboardDispatcher;
    }();

    OverlayKeyboardDispatcher.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    OverlayKeyboardDispatcher.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }];
    };
    /** @nocollapse */


    OverlayKeyboardDispatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({
      factory: function OverlayKeyboardDispatcher_Factory() {
        return new OverlayKeyboardDispatcher(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]));
      },
      token: OverlayKeyboardDispatcher,
      providedIn: "root"
    });
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @param {?} dispatcher
     * @param {?} _document
     * @return {?}
     */

    function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {
      return dispatcher || new OverlayKeyboardDispatcher(_document);
    }
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @type {?}
     */


    var OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {
      // If there is already an OverlayKeyboardDispatcher available, use that.
      // Otherwise, provide a new one.
      provide: OverlayKeyboardDispatcher,
      deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_3__["SkipSelf"](), OverlayKeyboardDispatcher],
      /** @type {?} */
      // Coerce to `InjectionToken` so that the `deps` match the "shape"
      // of the type expected by Angular
      _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]],
      useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Container inside which all overlays will render.
     */

    var OverlayContainer =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} document
       */
      function OverlayContainer(document) {
        _classCallCheck(this, OverlayContainer);

        this._document = document;
      }
      /**
       * @return {?}
       */


      _createClass(OverlayContainer, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._containerElement && this._containerElement.parentNode) {
            this._containerElement.parentNode.removeChild(this._containerElement);
          }
        }
        /**
         * This method returns the overlay container element. It will lazily
         * create the element the first time  it is called to facilitate using
         * the container in non-browser environments.
         * @return {?} the container element
         */

      }, {
        key: "getContainerElement",
        value: function getContainerElement() {
          if (!this._containerElement) {
            this._createContainer();
          }

          return this._containerElement;
        }
        /**
         * Create the overlay container element, which is simply a div
         * with the 'cdk-overlay-container' class on the document body.
         * @protected
         * @return {?}
         */

      }, {
        key: "_createContainer",
        value: function _createContainer() {
          /** @type {?} */
          var containerClass = 'cdk-overlay-container';
          /** @type {?} */

          var previousContainers = this._document.getElementsByClassName(containerClass); // Remove any old containers. This can happen when transitioning from the server to the client.


          for (var i = 0; i < previousContainers.length; i++) {
            /** @type {?} */
            previousContainers[i].parentNode.removeChild(previousContainers[i]);
          }
          /** @type {?} */


          var container = this._document.createElement('div');

          container.classList.add(containerClass);

          this._document.body.appendChild(container);

          this._containerElement = container;
        }
      }]);

      return OverlayContainer;
    }();

    OverlayContainer.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    OverlayContainer.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }];
    };
    /** @nocollapse */


    OverlayContainer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({
      factory: function OverlayContainer_Factory() {
        return new OverlayContainer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]));
      },
      token: OverlayContainer,
      providedIn: "root"
    });
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @param {?} parentContainer
     * @param {?} _document
     * @return {?}
     */

    function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {
      return parentContainer || new OverlayContainer(_document);
    }
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @type {?}
     */


    var OVERLAY_CONTAINER_PROVIDER = {
      // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
      provide: OverlayContainer,
      deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_3__["SkipSelf"](), OverlayContainer],
      /** @type {?} */
      _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]],
      useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Reference to an overlay that has been created with the Overlay service.
     * Used to manipulate or dispose of said overlay.
     */

    var OverlayRef =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _portalOutlet
       * @param {?} _host
       * @param {?} _pane
       * @param {?} _config
       * @param {?} _ngZone
       * @param {?} _keyboardDispatcher
       * @param {?} _document
       * @param {?=} _location
       */
      function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location) {
        var _this113 = this;

        _classCallCheck(this, OverlayRef);

        this._portalOutlet = _portalOutlet;
        this._host = _host;
        this._pane = _pane;
        this._config = _config;
        this._ngZone = _ngZone;
        this._keyboardDispatcher = _keyboardDispatcher;
        this._document = _document;
        this._location = _location;
        this._backdropElement = null;
        this._backdropClick = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._attachments = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._detachments = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._locationChanges = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;

        this._backdropClickHandler =
        /**
        * @param {?} event
        * @return {?}
        */
        function (event) {
          return _this113._backdropClick.next(event);
        };

        this._keydownEventsObservable = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Observable"](
        /**
        * @param {?} observer
        * @return {?}
        */
        function (observer) {
          /** @type {?} */
          var subscription = _this113._keydownEvents.subscribe(observer);

          _this113._keydownEventSubscriptions++;
          return (
            /**
            * @return {?}
            */
            function () {
              subscription.unsubscribe();
              _this113._keydownEventSubscriptions--;
            }
          );
        });
        /**
         * Stream of keydown events dispatched to this overlay.
         */

        this._keydownEvents = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Amount of subscriptions to the keydown events.
         */

        this._keydownEventSubscriptions = 0;

        if (_config.scrollStrategy) {
          this._scrollStrategy = _config.scrollStrategy;

          this._scrollStrategy.attach(this);
        }

        this._positionStrategy = _config.positionStrategy;
      }
      /**
       * The overlay's HTML element
       * @return {?}
       */


      _createClass(OverlayRef, [{
        key: "attach",

        /**
         * Attaches content, given via a Portal, to the overlay.
         * If the overlay is configured to have a backdrop, it will be created.
         *
         * @param {?} portal Portal instance to which to attach the overlay.
         * @return {?} The portal attachment result.
         */
        value: function attach(portal) {
          var _this114 = this;

          /** @type {?} */
          var attachResult = this._portalOutlet.attach(portal);

          if (this._positionStrategy) {
            this._positionStrategy.attach(this);
          } // Update the pane element with the given configuration.


          if (!this._host.parentElement && this._previousHostParent) {
            this._previousHostParent.appendChild(this._host);
          }

          this._updateStackingOrder();

          this._updateElementSize();

          this._updateElementDirection();

          if (this._scrollStrategy) {
            this._scrollStrategy.enable();
          } // Update the position once the zone is stable so that the overlay will be fully rendered
          // before attempting to position it, as the position may depend on the size of the rendered
          // content.


          this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1)).subscribe(
          /**
          * @return {?}
          */
          function () {
            // The overlay could've been detached before the zone has stabilized.
            if (_this114.hasAttached()) {
              _this114.updatePosition();
            }
          }); // Enable pointer events for the overlay pane element.


          this._togglePointerEvents(true);

          if (this._config.hasBackdrop) {
            this._attachBackdrop();
          }

          if (this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, true);
          } // Only emit the `attachments` event once all other setup is done.


          this._attachments.next(); // Track this overlay by the keyboard dispatcher


          this._keyboardDispatcher.add(this); // @breaking-change 8.0.0 remove the null check for `_location`
          // once the constructor parameter is made required.


          if (this._config.disposeOnNavigation && this._location) {
            this._locationChanges = this._location.subscribe(
            /**
            * @return {?}
            */
            function () {
              return _this114.dispose();
            });
          }

          return attachResult;
        }
        /**
         * Detaches an overlay from a portal.
         * @return {?} The portal detachment result.
         */

      }, {
        key: "detach",
        value: function detach() {
          if (!this.hasAttached()) {
            return;
          }

          this.detachBackdrop(); // When the overlay is detached, the pane element should disable pointer events.
          // This is necessary because otherwise the pane element will cover the page and disable
          // pointer events therefore. Depends on the position strategy and the applied pane boundaries.

          this._togglePointerEvents(false);

          if (this._positionStrategy && this._positionStrategy.detach) {
            this._positionStrategy.detach();
          }

          if (this._scrollStrategy) {
            this._scrollStrategy.disable();
          }
          /** @type {?} */


          var detachmentResult = this._portalOutlet.detach(); // Only emit after everything is detached.


          this._detachments.next(); // Remove this overlay from keyboard dispatcher tracking.


          this._keyboardDispatcher.remove(this); // Keeping the host element in DOM the can cause scroll jank, because it still gets
          // rendered, even though it's transparent and unclickable which is why we remove it.


          this._detachContentWhenStable(); // Stop listening for location changes.


          this._locationChanges.unsubscribe();

          return detachmentResult;
        }
        /**
         * Cleans up the overlay from the DOM.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          /** @type {?} */
          var isAttached = this.hasAttached();

          if (this._positionStrategy) {
            this._positionStrategy.dispose();
          }

          this._disposeScrollStrategy();

          this.detachBackdrop();

          this._locationChanges.unsubscribe();

          this._keyboardDispatcher.remove(this);

          this._portalOutlet.dispose();

          this._attachments.complete();

          this._backdropClick.complete();

          this._keydownEvents.complete();

          if (this._host && this._host.parentNode) {
            this._host.parentNode.removeChild(this._host);

            this._host =
            /** @type {?} */
            null;
          }

          this._previousHostParent = this._pane =
          /** @type {?} */
          null;

          if (isAttached) {
            this._detachments.next();
          }

          this._detachments.complete();
        }
        /**
         * Whether the overlay has attached content.
         * @return {?}
         */

      }, {
        key: "hasAttached",
        value: function hasAttached() {
          return this._portalOutlet.hasAttached();
        }
        /**
         * Gets an observable that emits when the backdrop has been clicked.
         * @return {?}
         */

      }, {
        key: "backdropClick",
        value: function backdropClick() {
          return this._backdropClick.asObservable();
        }
        /**
         * Gets an observable that emits when the overlay has been attached.
         * @return {?}
         */

      }, {
        key: "attachments",
        value: function attachments() {
          return this._attachments.asObservable();
        }
        /**
         * Gets an observable that emits when the overlay has been detached.
         * @return {?}
         */

      }, {
        key: "detachments",
        value: function detachments() {
          return this._detachments.asObservable();
        }
        /**
         * Gets an observable of keydown events targeted to this overlay.
         * @return {?}
         */

      }, {
        key: "keydownEvents",
        value: function keydownEvents() {
          return this._keydownEventsObservable;
        }
        /**
         * Gets the current overlay configuration, which is immutable.
         * @return {?}
         */

      }, {
        key: "getConfig",
        value: function getConfig() {
          return this._config;
        }
        /**
         * Updates the position of the overlay based on the position strategy.
         * @return {?}
         */

      }, {
        key: "updatePosition",
        value: function updatePosition() {
          if (this._positionStrategy) {
            this._positionStrategy.apply();
          }
        }
        /**
         * Switches to a new position strategy and updates the overlay position.
         * @param {?} strategy
         * @return {?}
         */

      }, {
        key: "updatePositionStrategy",
        value: function updatePositionStrategy(strategy) {
          if (strategy === this._positionStrategy) {
            return;
          }

          if (this._positionStrategy) {
            this._positionStrategy.dispose();
          }

          this._positionStrategy = strategy;

          if (this.hasAttached()) {
            strategy.attach(this);
            this.updatePosition();
          }
        }
        /**
         * Update the size properties of the overlay.
         * @param {?} sizeConfig
         * @return {?}
         */

      }, {
        key: "updateSize",
        value: function updateSize(sizeConfig) {
          this._config = Object.assign({}, this._config, sizeConfig);

          this._updateElementSize();
        }
        /**
         * Sets the LTR/RTL direction for the overlay.
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "setDirection",
        value: function setDirection(dir) {
          this._config = Object.assign({}, this._config, {
            direction: dir
          });

          this._updateElementDirection();
        }
        /**
         * Add a CSS class or an array of classes to the overlay pane.
         * @param {?} classes
         * @return {?}
         */

      }, {
        key: "addPanelClass",
        value: function addPanelClass(classes) {
          if (this._pane) {
            this._toggleClasses(this._pane, classes, true);
          }
        }
        /**
         * Remove a CSS class or an array of classes from the overlay pane.
         * @param {?} classes
         * @return {?}
         */

      }, {
        key: "removePanelClass",
        value: function removePanelClass(classes) {
          if (this._pane) {
            this._toggleClasses(this._pane, classes, false);
          }
        }
        /**
         * Returns the layout direction of the overlay panel.
         * @return {?}
         */

      }, {
        key: "getDirection",
        value: function getDirection() {
          /** @type {?} */
          var direction = this._config.direction;

          if (!direction) {
            return 'ltr';
          }

          return typeof direction === 'string' ? direction : direction.value;
        }
        /**
         * Switches to a new scroll strategy.
         * @param {?} strategy
         * @return {?}
         */

      }, {
        key: "updateScrollStrategy",
        value: function updateScrollStrategy(strategy) {
          if (strategy === this._scrollStrategy) {
            return;
          }

          this._disposeScrollStrategy();

          this._scrollStrategy = strategy;

          if (this.hasAttached()) {
            strategy.attach(this);
            strategy.enable();
          }
        }
        /**
         * Updates the text direction of the overlay panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateElementDirection",
        value: function _updateElementDirection() {
          this._host.setAttribute('dir', this.getDirection());
        }
        /**
         * Updates the size of the overlay element based on the overlay config.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateElementSize",
        value: function _updateElementSize() {
          if (!this._pane) {
            return;
          }
          /** @type {?} */


          var style = this._pane.style;
          style.width = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.width);
          style.height = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.height);
          style.minWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.minWidth);
          style.minHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.minHeight);
          style.maxWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.maxWidth);
          style.maxHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(this._config.maxHeight);
        }
        /**
         * Toggles the pointer events for the overlay pane element.
         * @private
         * @param {?} enablePointer
         * @return {?}
         */

      }, {
        key: "_togglePointerEvents",
        value: function _togglePointerEvents(enablePointer) {
          this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
        }
        /**
         * Attaches a backdrop for this overlay.
         * @private
         * @return {?}
         */

      }, {
        key: "_attachBackdrop",
        value: function _attachBackdrop() {
          var _this115 = this;

          /** @type {?} */
          var showingClass = 'cdk-overlay-backdrop-showing';
          this._backdropElement = this._document.createElement('div');

          this._backdropElement.classList.add('cdk-overlay-backdrop');

          if (this._config.backdropClass) {
            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
          } // Insert the backdrop before the pane in the DOM order,
          // in order to handle stacked overlays properly.


          /** @type {?} */
          this._host.parentElement.insertBefore(this._backdropElement, this._host); // Forward backdrop clicks such that the consumer of the overlay can perform whatever
          // action desired when such a click occurs (usually closing the overlay).


          this._backdropElement.addEventListener('click', this._backdropClickHandler); // Add class to fade-in the backdrop after one frame.


          if (typeof requestAnimationFrame !== 'undefined') {
            this._ngZone.runOutsideAngular(
            /**
            * @return {?}
            */
            function () {
              requestAnimationFrame(
              /**
              * @return {?}
              */
              function () {
                if (_this115._backdropElement) {
                  _this115._backdropElement.classList.add(showingClass);
                }
              });
            });
          } else {
            this._backdropElement.classList.add(showingClass);
          }
        }
        /**
         * Updates the stacking order of the element, moving it to the top if necessary.
         * This is required in cases where one overlay was detached, while another one,
         * that should be behind it, was destroyed. The next time both of them are opened,
         * the stacking will be wrong, because the detached element's pane will still be
         * in its original DOM position.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateStackingOrder",
        value: function _updateStackingOrder() {
          if (this._host.nextSibling) {
            /** @type {?} */
            this._host.parentNode.appendChild(this._host);
          }
        }
        /**
         * Detaches the backdrop (if any) associated with the overlay.
         * @return {?}
         */

      }, {
        key: "detachBackdrop",
        value: function detachBackdrop() {
          var _this116 = this;

          /** @type {?} */
          var backdropToDetach = this._backdropElement;

          if (!backdropToDetach) {
            return;
          }
          /** @type {?} */


          var timeoutId;
          /** @type {?} */

          var finishDetach =
          /**
          * @return {?}
          */
          function finishDetach() {
            // It may not be attached to anything in certain cases (e.g. unit tests).
            if (backdropToDetach) {
              backdropToDetach.removeEventListener('click', _this116._backdropClickHandler);
              backdropToDetach.removeEventListener('transitionend', finishDetach);

              if (backdropToDetach.parentNode) {
                backdropToDetach.parentNode.removeChild(backdropToDetach);
              }
            } // It is possible that a new portal has been attached to this overlay since we started
            // removing the backdrop. If that is the case, only clear the backdrop reference if it
            // is still the same instance that we started to remove.


            if (_this116._backdropElement == backdropToDetach) {
              _this116._backdropElement = null;
            }

            if (_this116._config.backdropClass) {
              _this116._toggleClasses(
              /** @type {?} */
              backdropToDetach, _this116._config.backdropClass, false);
            }

            clearTimeout(timeoutId);
          };

          backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');

          this._ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            backdropToDetach.addEventListener('transitionend', finishDetach);
          }); // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
          // In this case we make it unclickable and we try to remove it after a delay.


          backdropToDetach.style.pointerEvents = 'none'; // Run this outside the Angular zone because there's nothing that Angular cares about.
          // If it were to run inside the Angular zone, every test that used Overlay would have to be
          // either async or fakeAsync.

          timeoutId = this._ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            return setTimeout(finishDetach, 500);
          });
        }
        /**
         * Toggles a single CSS class or an array of classes on an element.
         * @private
         * @param {?} element
         * @param {?} cssClasses
         * @param {?} isAdd
         * @return {?}
         */

      }, {
        key: "_toggleClasses",
        value: function _toggleClasses(element, cssClasses, isAdd) {
          /** @type {?} */
          var classList = element.classList;
          Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceArray"])(cssClasses).forEach(
          /**
          * @param {?} cssClass
          * @return {?}
          */
          function (cssClass) {
            // We can't do a spread here, because IE doesn't support setting multiple classes.
            // Also trying to add an empty string to a DOMTokenList will throw.
            if (cssClass) {
              isAdd ? classList.add(cssClass) : classList.remove(cssClass);
            }
          });
        }
        /**
         * Detaches the overlay content next time the zone stabilizes.
         * @private
         * @return {?}
         */

      }, {
        key: "_detachContentWhenStable",
        value: function _detachContentWhenStable() {
          var _this117 = this;

          // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
          // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will
          // be patched to run inside the zone, which will throw us into an infinite loop.
          this._ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            // We can't remove the host here immediately, because the overlay pane's content
            // might still be animating. This stream helps us avoid interrupting the animation
            // by waiting for the pane to become empty.

            /** @type {?} */
            var subscription = _this117._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(_this117._attachments, _this117._detachments))).subscribe(
            /**
            * @return {?}
            */
            function () {
              // Needs a couple of checks for the pane and host, because
              // they may have been removed by the time the zone stabilizes.
              if (!_this117._pane || !_this117._host || _this117._pane.children.length === 0) {
                if (_this117._pane && _this117._config.panelClass) {
                  _this117._toggleClasses(_this117._pane, _this117._config.panelClass, false);
                }

                if (_this117._host && _this117._host.parentElement) {
                  _this117._previousHostParent = _this117._host.parentElement;

                  _this117._previousHostParent.removeChild(_this117._host);
                }

                subscription.unsubscribe();
              }
            });
          });
        }
        /**
         * Disposes of a scroll strategy.
         * @private
         * @return {?}
         */

      }, {
        key: "_disposeScrollStrategy",
        value: function _disposeScrollStrategy() {
          /** @type {?} */
          var scrollStrategy = this._scrollStrategy;

          if (scrollStrategy) {
            scrollStrategy.disable();

            if (scrollStrategy.detach) {
              scrollStrategy.detach();
            }
          }
        }
      }, {
        key: "overlayElement",
        get: function get() {
          return this._pane;
        }
        /**
         * The overlay's backdrop HTML element.
         * @return {?}
         */

      }, {
        key: "backdropElement",
        get: function get() {
          return this._backdropElement;
        }
        /**
         * Wrapper around the panel element. Can be used for advanced
         * positioning where a wrapper with specific styling is
         * required around the overlay pane.
         * @return {?}
         */

      }, {
        key: "hostElement",
        get: function get() {
          return this._host;
        }
      }]);

      return OverlayRef;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: refactor clipping detection into a separate thing (part of scrolling module)
    // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.

    /**
     * Class to be added to the overlay bounding box.
     * @type {?}
     */


    var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';
    /**
     * A strategy for positioning overlays. Using this strategy, an overlay is given an
     * implicit position relative some origin element. The relative position is defined in terms of
     * a point on the origin element that is connected to a point on the overlay element. For example,
     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
     * of the overlay.
     */

    var FlexibleConnectedPositionStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} connectedTo
       * @param {?} _viewportRuler
       * @param {?} _document
       * @param {?} _platform
       * @param {?} _overlayContainer
       */
      function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
        _classCallCheck(this, FlexibleConnectedPositionStrategy);

        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        /**
         * Last size used for the bounding box. Used to avoid resizing the overlay after open.
         */

        this._lastBoundingBoxSize = {
          width: 0,
          height: 0
        };
        /**
         * Whether the overlay was pushed in a previous positioning.
         */

        this._isPushed = false;
        /**
         * Whether the overlay can be pushed on-screen on the initial open.
         */

        this._canPush = true;
        /**
         * Whether the overlay can grow via flexible width/height after the initial open.
         */

        this._growAfterOpen = false;
        /**
         * Whether the overlay's width and height can be constrained to fit within the viewport.
         */

        this._hasFlexibleDimensions = true;
        /**
         * Whether the overlay position is locked.
         */

        this._positionLocked = false;
        /**
         * Amount of space that must be maintained between the overlay and the edge of the viewport.
         */

        this._viewportMargin = 0;
        /**
         * The Scrollable containers used to check scrollable view properties on position change.
         */

        this._scrollables = [];
        /**
         * Ordered list of preferred positions, from most to least desirable.
         */

        this._preferredPositions = [];
        /**
         * Subject that emits whenever the position changes.
         */

        this._positionChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Subscription to viewport size changes.
         */

        this._resizeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
        /**
         * Default offset for the overlay along the x axis.
         */

        this._offsetX = 0;
        /**
         * Default offset for the overlay along the y axis.
         */

        this._offsetY = 0;
        /**
         * Keeps track of the CSS classes that the position strategy has applied on the overlay panel.
         */

        this._appliedPanelClasses = [];
        /**
         * Observable sequence of position changes.
         */

        this.positionChanges = this._positionChanges.asObservable();
        this.setOrigin(connectedTo);
      }
      /**
       * Ordered list of preferred positions, from most to least desirable.
       * @return {?}
       */


      _createClass(FlexibleConnectedPositionStrategy, [{
        key: "attach",

        /**
         * Attaches this position strategy to an overlay.
         * @param {?} overlayRef
         * @return {?}
         */
        value: function attach(overlayRef) {
          var _this118 = this;

          if (this._overlayRef && overlayRef !== this._overlayRef) {
            throw Error('This position strategy is already attached to an overlay');
          }

          this._validatePositions();

          overlayRef.hostElement.classList.add(boundingBoxClass);
          this._overlayRef = overlayRef;
          this._boundingBox = overlayRef.hostElement;
          this._pane = overlayRef.overlayElement;
          this._isDisposed = false;
          this._isInitialRender = true;
          this._lastPosition = null;

          this._resizeSubscription.unsubscribe();

          this._resizeSubscription = this._viewportRuler.change().subscribe(
          /**
          * @return {?}
          */
          function () {
            // When the window is resized, we want to trigger the next reposition as if it
            // was an initial render, in order for the strategy to pick a new optimal position,
            // otherwise position locking will cause it to stay at the old one.
            _this118._isInitialRender = true;

            _this118.apply();
          });
        }
        /**
         * Updates the position of the overlay element, using whichever preferred position relative
         * to the origin best fits on-screen.
         *
         * The selection of a position goes as follows:
         *  - If any positions fit completely within the viewport as-is,
         *      choose the first position that does so.
         *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
         *      choose the position with the greatest available size modified by the positions' weight.
         *  - If pushing is enabled, take the position that went off-screen the least and push it
         *      on-screen.
         *  - If none of the previous criteria were met, use the position that goes off-screen the least.
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "apply",
        value: function apply() {
          // We shouldn't do anything if the strategy was disposed or we're on the server.
          if (this._isDisposed || !this._platform.isBrowser) {
            return;
          } // If the position has been applied already (e.g. when the overlay was opened) and the
          // consumer opted into locking in the position, re-use the old position, in order to
          // prevent the overlay from jumping around.


          if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
            this.reapplyLastPosition();
            return;
          }

          this._clearPanelClasses();

          this._resetOverlayElementStyles();

          this._resetBoundingBoxStyles(); // We need the bounding rects for the origin and the overlay to determine how to position
          // the overlay relative to the origin.
          // We use the viewport rect to determine whether a position would go off-screen.


          this._viewportRect = this._getNarrowedViewportRect();
          this._originRect = this._getOriginRect();
          this._overlayRect = this._pane.getBoundingClientRect();
          /** @type {?} */

          var originRect = this._originRect;
          /** @type {?} */

          var overlayRect = this._overlayRect;
          /** @type {?} */

          var viewportRect = this._viewportRect; // Positions where the overlay will fit with flexible dimensions.

          /** @type {?} */

          var flexibleFits = []; // Fallback if none of the preferred positions fit within the viewport.

          /** @type {?} */

          var fallback; // Go through each of the preferred positions looking for a good fit.
          // If a good fit is found, it will be applied immediately.

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this._preferredPositions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var pos = _step2.value;

              // Get the exact (x, y) coordinate for the point-of-origin on the origin element.

              /** @type {?} */
              var originPoint = this._getOriginPoint(originRect, pos); // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the
              // overlay in this position. We use the top-left corner for calculations and later translate
              // this into an appropriate (top, left, bottom, right) style.

              /** @type {?} */


              var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos); // Calculate how well the overlay would fit into the viewport with this point.

              /** @type {?} */


              var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos); // If the overlay, without any further work, fits into the viewport, use this position.


              if (overlayFit.isCompletelyWithinViewport) {
                this._isPushed = false;

                this._applyPosition(pos, originPoint);

                return;
              } // If the overlay has flexible dimensions, we can use this position
              // so long as there's enough space for the minimum dimensions.


              if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
                // Save positions where the overlay will fit with flexible dimensions. We will use these
                // if none of the positions fit *without* flexible dimensions.
                flexibleFits.push({
                  position: pos,
                  origin: originPoint,
                  overlayRect: overlayRect,
                  boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                });
                continue;
              } // If the current preferred position does not fit on the screen, remember the position
              // if it has more visible area on-screen than we've seen and move onto the next preferred
              // position.


              if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
                fallback = {
                  overlayFit: overlayFit,
                  overlayPoint: overlayPoint,
                  originPoint: originPoint,
                  position: pos,
                  overlayRect: overlayRect
                };
              }
            } // If there are any positions where the overlay would fit with flexible dimensions, choose the
            // one that has the greatest area available modified by the position's weight

          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (flexibleFits.length) {
            /** @type {?} */
            var bestFit = null;
            /** @type {?} */

            var bestScore = -1;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = flexibleFits[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var fit = _step3.value;

                /** @type {?} */
                var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);

                if (score > bestScore) {
                  bestScore = score;
                  bestFit = fit;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            this._isPushed = false;

            this._applyPosition(
            /** @type {?} */
            bestFit.position,
            /** @type {?} */
            bestFit.origin);

            return;
          } // When none of the preferred positions fit within the viewport, take the position
          // that went off-screen the least and attempt to push it on-screen.


          if (this._canPush) {
            // TODO(jelbourn): after pushing, the opening "direction" of the overlay might not make sense.
            this._isPushed = true;

            this._applyPosition(
            /** @type {?} */
            fallback.position,
            /** @type {?} */
            fallback.originPoint);

            return;
          } // All options for getting the overlay within the viewport have been exhausted, so go with the
          // position that went off-screen the least.


          this._applyPosition(
          /** @type {?} */
          fallback.position,
          /** @type {?} */
          fallback.originPoint);
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this._clearPanelClasses();

          this._lastPosition = null;
          this._previousPushAmount = null;

          this._resizeSubscription.unsubscribe();
        }
        /**
         * Cleanup after the element gets destroyed.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          if (this._isDisposed) {
            return;
          } // We can't use `_resetBoundingBoxStyles` here, because it resets
          // some properties to zero, rather than removing them.


          if (this._boundingBox) {
            extendStyles(this._boundingBox.style,
            /** @type {?} */
            {
              top: '',
              left: '',
              right: '',
              bottom: '',
              height: '',
              width: '',
              alignItems: '',
              justifyContent: ''
            });
          }

          if (this._pane) {
            this._resetOverlayElementStyles();
          }

          if (this._overlayRef) {
            this._overlayRef.hostElement.classList.remove(boundingBoxClass);
          }

          this.detach();

          this._positionChanges.complete();

          this._overlayRef = this._boundingBox =
          /** @type {?} */
          null;
          this._isDisposed = true;
        }
        /**
         * This re-aligns the overlay element with the trigger in its last calculated position,
         * even if a position higher in the "preferred positions" list would now fit. This
         * allows one to re-align the panel without changing the orientation of the panel.
         * @return {?}
         */

      }, {
        key: "reapplyLastPosition",
        value: function reapplyLastPosition() {
          if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
            this._originRect = this._getOriginRect();
            this._overlayRect = this._pane.getBoundingClientRect();
            this._viewportRect = this._getNarrowedViewportRect();
            /** @type {?} */

            var lastPosition = this._lastPosition || this._preferredPositions[0];
            /** @type {?} */

            var originPoint = this._getOriginPoint(this._originRect, lastPosition);

            this._applyPosition(lastPosition, originPoint);
          }
        }
        /**
         * Sets the list of Scrollable containers that host the origin element so that
         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
         * Scrollable must be an ancestor element of the strategy's origin element.
         * @template THIS
         * @this {THIS}
         * @param {?} scrollables
         * @return {THIS}
         */

      }, {
        key: "withScrollableContainers",
        value: function withScrollableContainers(scrollables) {
          /** @type {?} */
          this._scrollables = scrollables;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Adds new preferred positions.
         * @template THIS
         * @this {THIS}
         * @param {?} positions List of positions options for this overlay.
         * @return {THIS}
         */

      }, {
        key: "withPositions",
        value: function withPositions(positions) {
          /** @type {?} */
          this._preferredPositions = positions; // If the last calculated position object isn't part of the positions anymore, clear
          // it in order to avoid it being picked up if the consumer tries to re-apply.

          if (positions.indexOf(
          /** @type {?} */

          /** @type {?} */
          this._lastPosition) === -1) {
            /** @type {?} */
            this._lastPosition = null;
          }

          /** @type {?} */
          this._validatePositions();

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
         * @template THIS
         * @this {THIS}
         * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
         * @return {THIS}
         */

      }, {
        key: "withViewportMargin",
        value: function withViewportMargin(margin) {
          /** @type {?} */
          this._viewportMargin = margin;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets whether the overlay's width and height can be constrained to fit within the viewport.
         * @template THIS
         * @this {THIS}
         * @param {?=} flexibleDimensions
         * @return {THIS}
         */

      }, {
        key: "withFlexibleDimensions",
        value: function withFlexibleDimensions() {
          var flexibleDimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          this._hasFlexibleDimensions = flexibleDimensions;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets whether the overlay can grow after the initial open via flexible width/height.
         * @template THIS
         * @this {THIS}
         * @param {?=} growAfterOpen
         * @return {THIS}
         */

      }, {
        key: "withGrowAfterOpen",
        value: function withGrowAfterOpen() {
          var growAfterOpen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          this._growAfterOpen = growAfterOpen;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
         * @template THIS
         * @this {THIS}
         * @param {?=} canPush
         * @return {THIS}
         */

      }, {
        key: "withPush",
        value: function withPush() {
          var canPush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          this._canPush = canPush;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets whether the overlay's position should be locked in after it is positioned
         * initially. When an overlay is locked in, it won't attempt to reposition itself
         * when the position is re-applied (e.g. when the user scrolls away).
         * @template THIS
         * @this {THIS}
         * @param {?=} isLocked Whether the overlay should locked in.
         * @return {THIS}
         */

      }, {
        key: "withLockedPosition",
        value: function withLockedPosition() {
          var isLocked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          this._positionLocked = isLocked;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the origin, relative to which to position the overlay.
         * Using an element origin is useful for building components that need to be positioned
         * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
         * used for cases like contextual menus which open relative to the user's pointer.
         * @template THIS
         * @this {THIS}
         * @param {?} origin Reference to the new origin.
         * @return {THIS}
         */

      }, {
        key: "setOrigin",
        value: function setOrigin(origin) {
          /** @type {?} */
          this._origin = origin;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the default offset for the overlay's connection point on the x-axis.
         * @template THIS
         * @this {THIS}
         * @param {?} offset New offset in the X axis.
         * @return {THIS}
         */

      }, {
        key: "withDefaultOffsetX",
        value: function withDefaultOffsetX(offset) {
          /** @type {?} */
          this._offsetX = offset;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the default offset for the overlay's connection point on the y-axis.
         * @template THIS
         * @this {THIS}
         * @param {?} offset New offset in the Y axis.
         * @return {THIS}
         */

      }, {
        key: "withDefaultOffsetY",
        value: function withDefaultOffsetY(offset) {
          /** @type {?} */
          this._offsetY = offset;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Configures that the position strategy should set a `transform-origin` on some elements
         * inside the overlay, depending on the current position that is being applied. This is
         * useful for the cases where the origin of an animation can change depending on the
         * alignment of the overlay.
         * @template THIS
         * @this {THIS}
         * @param {?} selector CSS selector that will be used to find the target
         *    elements onto which to set the transform origin.
         * @return {THIS}
         */

      }, {
        key: "withTransformOriginOn",
        value: function withTransformOriginOn(selector) {
          /** @type {?} */
          this._transformOriginSelector = selector;
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
         * @private
         * @param {?} originRect
         * @param {?} pos
         * @return {?}
         */

      }, {
        key: "_getOriginPoint",
        value: function _getOriginPoint(originRect, pos) {
          /** @type {?} */
          var x;

          if (pos.originX == 'center') {
            // Note: when centering we should always use the `left`
            // offset, otherwise the position will be wrong in RTL.
            x = originRect.left + originRect.width / 2;
          } else {
            /** @type {?} */
            var startX = this._isRtl() ? originRect.right : originRect.left;
            /** @type {?} */

            var endX = this._isRtl() ? originRect.left : originRect.right;
            x = pos.originX == 'start' ? startX : endX;
          }
          /** @type {?} */


          var y;

          if (pos.originY == 'center') {
            y = originRect.top + originRect.height / 2;
          } else {
            y = pos.originY == 'top' ? originRect.top : originRect.bottom;
          }

          return {
            x: x,
            y: y
          };
        }
        /**
         * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
         * origin point to which the overlay should be connected.
         * @private
         * @param {?} originPoint
         * @param {?} overlayRect
         * @param {?} pos
         * @return {?}
         */

      }, {
        key: "_getOverlayPoint",
        value: function _getOverlayPoint(originPoint, overlayRect, pos) {
          // Calculate the (overlayStartX, overlayStartY), the start of the
          // potential overlay position relative to the origin point.

          /** @type {?} */
          var overlayStartX;

          if (pos.overlayX == 'center') {
            overlayStartX = -overlayRect.width / 2;
          } else if (pos.overlayX === 'start') {
            overlayStartX = this._isRtl() ? -overlayRect.width : 0;
          } else {
            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
          }
          /** @type {?} */


          var overlayStartY;

          if (pos.overlayY == 'center') {
            overlayStartY = -overlayRect.height / 2;
          } else {
            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
          } // The (x, y) coordinates of the overlay.


          return {
            x: originPoint.x + overlayStartX,
            y: originPoint.y + overlayStartY
          };
        }
        /**
         * Gets how well an overlay at the given point will fit within the viewport.
         * @private
         * @param {?} point
         * @param {?} overlay
         * @param {?} viewport
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_getOverlayFit",
        value: function _getOverlayFit(point, overlay, viewport, position) {
          var x = point.x,
              y = point.y;
          /** @type {?} */

          var offsetX = this._getOffset(position, 'x');
          /** @type {?} */


          var offsetY = this._getOffset(position, 'y'); // Account for the offsets since they could push the overlay out of the viewport.


          if (offsetX) {
            x += offsetX;
          }

          if (offsetY) {
            y += offsetY;
          } // How much the overlay would overflow at this position, on each side.

          /** @type {?} */


          var leftOverflow = 0 - x;
          /** @type {?} */

          var rightOverflow = x + overlay.width - viewport.width;
          /** @type {?} */

          var topOverflow = 0 - y;
          /** @type {?} */

          var bottomOverflow = y + overlay.height - viewport.height; // Visible parts of the element on each axis.

          /** @type {?} */

          var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
          /** @type {?} */


          var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
          /** @type {?} */


          var visibleArea = visibleWidth * visibleHeight;
          return {
            visibleArea: visibleArea,
            isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
            fitsInViewportVertically: visibleHeight === overlay.height,
            fitsInViewportHorizontally: visibleWidth == overlay.width
          };
        }
        /**
         * Whether the overlay can fit within the viewport when it may resize either its width or height.
         * @private
         * @param {?} fit How well the overlay fits in the viewport at some position.
         * @param {?} point The (x, y) coordinates of the overlat at some position.
         * @param {?} viewport The geometry of the viewport.
         * @return {?}
         */

      }, {
        key: "_canFitWithFlexibleDimensions",
        value: function _canFitWithFlexibleDimensions(fit, point, viewport) {
          if (this._hasFlexibleDimensions) {
            /** @type {?} */
            var availableHeight = viewport.bottom - point.y;
            /** @type {?} */

            var availableWidth = viewport.right - point.x;
            /** @type {?} */

            var minHeight = this._overlayRef.getConfig().minHeight;
            /** @type {?} */


            var minWidth = this._overlayRef.getConfig().minWidth;
            /** @type {?} */


            var verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
            /** @type {?} */

            var horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
            return verticalFit && horizontalFit;
          }

          return false;
        }
        /**
         * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
         * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
         * right and bottom).
         *
         * @private
         * @param {?} start Starting point from which the overlay is pushed.
         * @param {?} overlay Dimensions of the overlay.
         * @param {?} scrollPosition Current viewport scroll position.
         * @return {?} The point at which to position the overlay after pushing. This is effectively a new
         *     originPoint.
         */

      }, {
        key: "_pushOverlayOnScreen",
        value: function _pushOverlayOnScreen(start, overlay, scrollPosition) {
          // If the position is locked and we've pushed the overlay already, reuse the previous push
          // amount, rather than pushing it again. If we were to continue pushing, the element would
          // remain in the viewport, which goes against the expectations when position locking is enabled.
          if (this._previousPushAmount && this._positionLocked) {
            return {
              x: start.x + this._previousPushAmount.x,
              y: start.y + this._previousPushAmount.y
            };
          }
          /** @type {?} */


          var viewport = this._viewportRect; // Determine how much the overlay goes outside the viewport on each
          // side, which we'll use to decide which direction to push it.

          /** @type {?} */

          var overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);
          /** @type {?} */

          var overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);
          /** @type {?} */

          var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
          /** @type {?} */

          var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0); // Amount by which to push the overlay in each axis such that it remains on-screen.

          /** @type {?} */

          var pushX = 0;
          /** @type {?} */

          var pushY = 0; // If the overlay fits completely within the bounds of the viewport, push it from whichever
          // direction is goes off-screen. Otherwise, push the top-left corner such that its in the
          // viewport and allow for the trailing end of the overlay to go out of bounds.

          if (overlay.width <= viewport.width) {
            pushX = overflowLeft || -overflowRight;
          } else {
            pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
          }

          if (overlay.height <= viewport.height) {
            pushY = overflowTop || -overflowBottom;
          } else {
            pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
          }

          this._previousPushAmount = {
            x: pushX,
            y: pushY
          };
          return {
            x: start.x + pushX,
            y: start.y + pushY
          };
        }
        /**
         * Applies a computed position to the overlay and emits a position change.
         * @private
         * @param {?} position The position preference
         * @param {?} originPoint The point on the origin element where the overlay is connected.
         * @return {?}
         */

      }, {
        key: "_applyPosition",
        value: function _applyPosition(position, originPoint) {
          this._setTransformOrigin(position);

          this._setOverlayElementStyles(originPoint, position);

          this._setBoundingBoxStyles(originPoint, position);

          if (position.panelClass) {
            this._addPanelClasses(position.panelClass);
          } // Save the last connected position in case the position needs to be re-calculated.


          this._lastPosition = position; // Notify that the position has been changed along with its change properties.
          // We only emit if we've got any subscriptions, because the scroll visibility
          // calculcations can be somewhat expensive.

          if (this._positionChanges.observers.length) {
            /** @type {?} */
            var scrollableViewProperties = this._getScrollVisibility();
            /** @type {?} */


            var changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);

            this._positionChanges.next(changeEvent);
          }

          this._isInitialRender = false;
        }
        /**
         * Sets the transform origin based on the configured selector and the passed-in position.
         * @private
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_setTransformOrigin",
        value: function _setTransformOrigin(position) {
          if (!this._transformOriginSelector) {
            return;
          }
          /** @type {?} */


          var elements =
          /** @type {?} */
          this._boundingBox.querySelectorAll(this._transformOriginSelector);
          /** @type {?} */


          var xOrigin;
          /** @type {?} */

          var yOrigin = position.overlayY;

          if (position.overlayX === 'center') {
            xOrigin = 'center';
          } else if (this._isRtl()) {
            xOrigin = position.overlayX === 'start' ? 'right' : 'left';
          } else {
            xOrigin = position.overlayX === 'start' ? 'left' : 'right';
          }

          for (var i = 0; i < elements.length; i++) {
            elements[i].style.transformOrigin = "".concat(xOrigin, " ").concat(yOrigin);
          }
        }
        /**
         * Gets the position and size of the overlay's sizing container.
         *
         * This method does no measuring and applies no styles so that we can cheaply compute the
         * bounds for all positions and choose the best fit based on these results.
         * @private
         * @param {?} origin
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_calculateBoundingBoxRect",
        value: function _calculateBoundingBoxRect(origin, position) {
          /** @type {?} */
          var viewport = this._viewportRect;
          /** @type {?} */

          var isRtl = this._isRtl();
          /** @type {?} */


          var height;
          /** @type {?} */

          var top;
          /** @type {?} */

          var bottom;

          if (position.overlayY === 'top') {
            // Overlay is opening "downward" and thus is bound by the bottom viewport edge.
            top = origin.y;
            height = viewport.height - top + this._viewportMargin;
          } else if (position.overlayY === 'bottom') {
            // Overlay is opening "upward" and thus is bound by the top viewport edge. We need to add
            // the viewport margin back in, because the viewport rect is narrowed down to remove the
            // margin, whereas the `origin` position is calculated based on its `ClientRect`.
            bottom = viewport.height - origin.y + this._viewportMargin * 2;
            height = viewport.height - bottom + this._viewportMargin;
          } else {
            // If neither top nor bottom, it means that the overlay is vertically centered on the
            // origin point. Note that we want the position relative to the viewport, rather than
            // the page, which is why we don't use something like `viewport.bottom - origin.y` and
            // `origin.y - viewport.top`.

            /** @type {?} */
            var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
            /** @type {?} */

            var previousHeight = this._lastBoundingBoxSize.height;
            height = smallestDistanceToViewportEdge * 2;
            top = origin.y - smallestDistanceToViewportEdge;

            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
              top = origin.y - previousHeight / 2;
            }
          } // The overlay is opening 'right-ward' (the content flows to the right).

          /** @type {?} */


          var isBoundedByRightViewportEdge = position.overlayX === 'start' && !isRtl || position.overlayX === 'end' && isRtl; // The overlay is opening 'left-ward' (the content flows to the left).

          /** @type {?} */

          var isBoundedByLeftViewportEdge = position.overlayX === 'end' && !isRtl || position.overlayX === 'start' && isRtl;
          /** @type {?} */

          var width;
          /** @type {?} */

          var left;
          /** @type {?} */

          var right;

          if (isBoundedByLeftViewportEdge) {
            right = viewport.width - origin.x + this._viewportMargin;
            width = origin.x - this._viewportMargin;
          } else if (isBoundedByRightViewportEdge) {
            left = origin.x;
            width = viewport.right - origin.x;
          } else {
            // If neither start nor end, it means that the overlay is horizontally centered on the
            // origin point. Note that we want the position relative to the viewport, rather than
            // the page, which is why we don't use something like `viewport.right - origin.x` and
            // `origin.x - viewport.left`.

            /** @type {?} */
            var _smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
            /** @type {?} */


            var previousWidth = this._lastBoundingBoxSize.width;
            width = _smallestDistanceToViewportEdge * 2;
            left = origin.x - _smallestDistanceToViewportEdge;

            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
              left = origin.x - previousWidth / 2;
            }
          }

          return {
            top:
            /** @type {?} */
            top,
            left:
            /** @type {?} */
            left,
            bottom:
            /** @type {?} */
            bottom,
            right:
            /** @type {?} */
            right,
            width: width,
            height: height
          };
        }
        /**
         * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
         * origin's connection point and stetches to the bounds of the viewport.
         *
         * @private
         * @param {?} origin The point on the origin element where the overlay is connected.
         * @param {?} position The position preference
         * @return {?}
         */

      }, {
        key: "_setBoundingBoxStyles",
        value: function _setBoundingBoxStyles(origin, position) {
          /** @type {?} */
          var boundingBoxRect = this._calculateBoundingBoxRect(origin, position); // It's weird if the overlay *grows* while scrolling, so we take the last size into account
          // when applying a new size.


          if (!this._isInitialRender && !this._growAfterOpen) {
            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
          }
          /** @type {?} */


          var styles =
          /** @type {?} */
          {};

          if (this._hasExactPosition()) {
            styles.top = styles.left = '0';
            styles.bottom = styles.right = '';
            styles.width = styles.height = '100%';
          } else {
            /** @type {?} */
            var maxHeight = this._overlayRef.getConfig().maxHeight;
            /** @type {?} */


            var maxWidth = this._overlayRef.getConfig().maxWidth;

            styles.height = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.height);
            styles.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.top);
            styles.bottom = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.bottom);
            styles.width = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.width);
            styles.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.left);
            styles.right = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(boundingBoxRect.right); // Push the pane content towards the proper direction.

            if (position.overlayX === 'center') {
              styles.alignItems = 'center';
            } else {
              styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';
            }

            if (position.overlayY === 'center') {
              styles.justifyContent = 'center';
            } else {
              styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';
            }

            if (maxHeight) {
              styles.maxHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(maxHeight);
            }

            if (maxWidth) {
              styles.maxWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(maxWidth);
            }
          }

          this._lastBoundingBoxSize = boundingBoxRect;
          extendStyles(
          /** @type {?} */
          this._boundingBox.style, styles);
        }
        /**
         * Resets the styles for the bounding box so that a new positioning can be computed.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetBoundingBoxStyles",
        value: function _resetBoundingBoxStyles() {
          extendStyles(
          /** @type {?} */
          this._boundingBox.style,
          /** @type {?} */
          {
            top: '0',
            left: '0',
            right: '0',
            bottom: '0',
            height: '',
            width: '',
            alignItems: '',
            justifyContent: ''
          });
        }
        /**
         * Resets the styles for the overlay pane so that a new positioning can be computed.
         * @private
         * @return {?}
         */

      }, {
        key: "_resetOverlayElementStyles",
        value: function _resetOverlayElementStyles() {
          extendStyles(this._pane.style,
          /** @type {?} */
          {
            top: '',
            left: '',
            bottom: '',
            right: '',
            position: '',
            transform: ''
          });
        }
        /**
         * Sets positioning styles to the overlay element.
         * @private
         * @param {?} originPoint
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_setOverlayElementStyles",
        value: function _setOverlayElementStyles(originPoint, position) {
          /** @type {?} */
          var styles =
          /** @type {?} */
          {};

          if (this._hasExactPosition()) {
            /** @type {?} */
            var scrollPosition = this._viewportRuler.getViewportScrollPosition();

            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
          } else {
            styles.position = 'static';
          } // Use a transform to apply the offsets. We do this because the `center` positions rely on
          // being in the normal flex flow and setting a `top` / `left` at all will completely throw
          // off the position. We also can't use margins, because they won't have an effect in some
          // cases where the element doesn't have anything to "push off of". Finally, this works
          // better both with flexible and non-flexible positioning.

          /** @type {?} */


          var transformString = '';
          /** @type {?} */

          var offsetX = this._getOffset(position, 'x');
          /** @type {?} */


          var offsetY = this._getOffset(position, 'y');

          if (offsetX) {
            transformString += "translateX(".concat(offsetX, "px) ");
          }

          if (offsetY) {
            transformString += "translateY(".concat(offsetY, "px)");
          }

          styles.transform = transformString.trim(); // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because
          // we need these values to both be set to "100%" for the automatic flexible sizing to work.
          // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.

          if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {
            styles.maxHeight = '';
          }

          if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {
            styles.maxWidth = '';
          }

          extendStyles(this._pane.style, styles);
        }
        /**
         * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
         * @private
         * @param {?} position
         * @param {?} originPoint
         * @param {?} scrollPosition
         * @return {?}
         */

      }, {
        key: "_getExactOverlayY",
        value: function _getExactOverlayY(position, originPoint, scrollPosition) {
          // Reset any existing styles. This is necessary in case the
          // preferred position has changed since the last `apply`.

          /** @type {?} */
          var styles =
          /** @type {?} */
          {
            top: null,
            bottom: null
          };
          /** @type {?} */

          var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);

          if (this._isPushed) {
            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
          }
          /** @type {?} */


          var virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top; // Normally this would be zero, however when the overlay is attached to an input (e.g. in an
          // autocomplete), mobile browsers will shift everything in order to put the input in the middle
          // of the screen and to make space for the virtual keyboard. We need to account for this offset,
          // otherwise our positioning will be thrown off.


          overlayPoint.y -= virtualKeyboardOffset; // We want to set either `top` or `bottom` based on whether the overlay wants to appear
          // above or below the origin and the direction in which the element will expand.

          if (position.overlayY === 'bottom') {
            // When using `bottom`, we adjust the y position such that it is the distance
            // from the bottom of the viewport rather than the top.

            /** @type {?} */
            var documentHeight =
            /** @type {?} */
            this._document.documentElement.clientHeight;
            styles.bottom = "".concat(documentHeight - (overlayPoint.y + this._overlayRect.height), "px");
          } else {
            styles.top = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(overlayPoint.y);
          }

          return styles;
        }
        /**
         * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
         * @private
         * @param {?} position
         * @param {?} originPoint
         * @param {?} scrollPosition
         * @return {?}
         */

      }, {
        key: "_getExactOverlayX",
        value: function _getExactOverlayX(position, originPoint, scrollPosition) {
          // Reset any existing styles. This is necessary in case the preferred position has
          // changed since the last `apply`.

          /** @type {?} */
          var styles =
          /** @type {?} */
          {
            left: null,
            right: null
          };
          /** @type {?} */

          var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);

          if (this._isPushed) {
            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
          } // We want to set either `left` or `right` based on whether the overlay wants to appear "before"
          // or "after" the origin, which determines the direction in which the element will expand.
          // For the horizontal axis, the meaning of "before" and "after" change based on whether the
          // page is in RTL or LTR.

          /** @type {?} */


          var horizontalStyleProperty;

          if (this._isRtl()) {
            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';
          } else {
            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';
          } // When we're setting `right`, we adjust the x position such that it is the distance
          // from the right edge of the viewport rather than the left edge.


          if (horizontalStyleProperty === 'right') {
            /** @type {?} */
            var documentWidth =
            /** @type {?} */
            this._document.documentElement.clientWidth;
            styles.right = "".concat(documentWidth - (overlayPoint.x + this._overlayRect.width), "px");
          } else {
            styles.left = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceCssPixelValue"])(overlayPoint.x);
          }

          return styles;
        }
        /**
         * Gets the view properties of the trigger and overlay, including whether they are clipped
         * or completely outside the view of any of the strategy's scrollables.
         * @private
         * @return {?}
         */

      }, {
        key: "_getScrollVisibility",
        value: function _getScrollVisibility() {
          // Note: needs fresh rects since the position could've changed.

          /** @type {?} */
          var originBounds = this._getOriginRect();
          /** @type {?} */


          var overlayBounds = this._pane.getBoundingClientRect(); // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers
          // every time, we should be able to use the scrollTop of the containers if the size of those
          // containers hasn't changed.

          /** @type {?} */


          var scrollContainerBounds = this._scrollables.map(
          /**
          * @param {?} scrollable
          * @return {?}
          */
          function (scrollable) {
            return scrollable.getElementRef().nativeElement.getBoundingClientRect();
          });

          return {
            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
          };
        }
        /**
         * Subtracts the amount that an element is overflowing on an axis from its length.
         * @private
         * @param {?} length
         * @param {...?} overflows
         * @return {?}
         */

      }, {
        key: "_subtractOverflows",
        value: function _subtractOverflows(length) {
          for (var _len4 = arguments.length, overflows = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            overflows[_key4 - 1] = arguments[_key4];
          }

          return overflows.reduce(
          /**
          * @param {?} currentValue
          * @param {?} currentOverflow
          * @return {?}
          */
          function (currentValue, currentOverflow) {
            return currentValue - Math.max(currentOverflow, 0);
          }, length);
        }
        /**
         * Narrows the given viewport rect by the current _viewportMargin.
         * @private
         * @return {?}
         */

      }, {
        key: "_getNarrowedViewportRect",
        value: function _getNarrowedViewportRect() {
          // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,
          // because we want to use the `clientWidth` and `clientHeight` as the base. The difference
          // being that the client properties don't include the scrollbar, as opposed to `innerWidth`
          // and `innerHeight` that do. This is necessary, because the overlay container uses
          // 100% `width` and `height` which don't include the scrollbar either.

          /** @type {?} */
          var width =
          /** @type {?} */
          this._document.documentElement.clientWidth;
          /** @type {?} */

          var height =
          /** @type {?} */
          this._document.documentElement.clientHeight;
          /** @type {?} */

          var scrollPosition = this._viewportRuler.getViewportScrollPosition();

          return {
            top: scrollPosition.top + this._viewportMargin,
            left: scrollPosition.left + this._viewportMargin,
            right: scrollPosition.left + width - this._viewportMargin,
            bottom: scrollPosition.top + height - this._viewportMargin,
            width: width - 2 * this._viewportMargin,
            height: height - 2 * this._viewportMargin
          };
        }
        /**
         * Whether the we're dealing with an RTL context
         * @private
         * @return {?}
         */

      }, {
        key: "_isRtl",
        value: function _isRtl() {
          return this._overlayRef.getDirection() === 'rtl';
        }
        /**
         * Determines whether the overlay uses exact or flexible positioning.
         * @private
         * @return {?}
         */

      }, {
        key: "_hasExactPosition",
        value: function _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed;
        }
        /**
         * Retrieves the offset of a position along the x or y axis.
         * @private
         * @param {?} position
         * @param {?} axis
         * @return {?}
         */

      }, {
        key: "_getOffset",
        value: function _getOffset(position, axis) {
          if (axis === 'x') {
            // We don't do something like `position['offset' + axis]` in
            // order to avoid breking minifiers that rename properties.
            return position.offsetX == null ? this._offsetX : position.offsetX;
          }

          return position.offsetY == null ? this._offsetY : position.offsetY;
        }
        /**
         * Validates that the current position match the expected values.
         * @private
         * @return {?}
         */

      }, {
        key: "_validatePositions",
        value: function _validatePositions() {
          if (!this._preferredPositions.length) {
            throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');
          } // TODO(crisbeto): remove these once Angular's template type
          // checking is advanced enough to catch these cases.


          this._preferredPositions.forEach(
          /**
          * @param {?} pair
          * @return {?}
          */
          function (pair) {
            validateHorizontalPosition('originX', pair.originX);
            validateVerticalPosition('originY', pair.originY);
            validateHorizontalPosition('overlayX', pair.overlayX);
            validateVerticalPosition('overlayY', pair.overlayY);
          });
        }
        /**
         * Adds a single CSS class or an array of classes on the overlay panel.
         * @private
         * @param {?} cssClasses
         * @return {?}
         */

      }, {
        key: "_addPanelClasses",
        value: function _addPanelClasses(cssClasses) {
          var _this119 = this;

          if (this._pane) {
            Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceArray"])(cssClasses).forEach(
            /**
            * @param {?} cssClass
            * @return {?}
            */
            function (cssClass) {
              if (cssClass !== '' && _this119._appliedPanelClasses.indexOf(cssClass) === -1) {
                _this119._appliedPanelClasses.push(cssClass);

                _this119._pane.classList.add(cssClass);
              }
            });
          }
        }
        /**
         * Clears the classes that the position strategy has applied from the overlay panel.
         * @private
         * @return {?}
         */

      }, {
        key: "_clearPanelClasses",
        value: function _clearPanelClasses() {
          var _this120 = this;

          if (this._pane) {
            this._appliedPanelClasses.forEach(
            /**
            * @param {?} cssClass
            * @return {?}
            */
            function (cssClass) {
              _this120._pane.classList.remove(cssClass);
            });

            this._appliedPanelClasses = [];
          }
        }
        /**
         * Returns the ClientRect of the current origin.
         * @private
         * @return {?}
         */

      }, {
        key: "_getOriginRect",
        value: function _getOriginRect() {
          /** @type {?} */
          var origin = this._origin;

          if (origin instanceof _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"]) {
            return origin.nativeElement.getBoundingClientRect();
          }

          if (origin instanceof HTMLElement) {
            return origin.getBoundingClientRect();
          }
          /** @type {?} */


          var width = origin.width || 0;
          /** @type {?} */

          var height = origin.height || 0; // If the origin is a point, return a client rect as if it was a 0x0 element at the point.

          return {
            top: origin.y,
            bottom: origin.y + height,
            left: origin.x,
            right: origin.x + width,
            height: height,
            width: width
          };
        }
      }, {
        key: "positions",
        get: function get() {
          return this._preferredPositions;
        }
      }]);

      return FlexibleConnectedPositionStrategy;
    }();
    /**
     * Shallow-extends a stylesheet object with another stylesheet object.
     * @param {?} dest
     * @param {?} source
     * @return {?}
     */


    function extendStyles(dest, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          dest[key] = source[key];
        }
      }

      return dest;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A strategy for positioning overlays. Using this strategy, an overlay is given an
     * implicit position relative to some origin element. The relative position is defined in terms of
     * a point on the origin element that is connected to a point on the overlay element. For example,
     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
     * of the overlay.
     * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
     * \@breaking-change 8.0.0
     */


    var ConnectedPositionStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} originPos
       * @param {?} overlayPos
       * @param {?} connectedTo
       * @param {?} viewportRuler
       * @param {?} document
       * @param {?} platform
       * @param {?} overlayContainer
       */
      function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {
        _classCallCheck(this, ConnectedPositionStrategy);

        /**
         * Ordered list of preferred positions, from most to least desirable.
         */
        this._preferredPositions = []; // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain
        // the extra logic, we create an instance of the positioning strategy that has some
        // defaults that make it behave as the old position strategy and to which we'll
        // proxy all of the API calls.

        this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer).withFlexibleDimensions(false).withPush(false).withViewportMargin(0);
        this.withFallbackPosition(originPos, overlayPos);
      }
      /**
       * Whether the we're dealing with an RTL context
       * @return {?}
       */


      _createClass(ConnectedPositionStrategy, [{
        key: "attach",

        /**
         * Attach this position strategy to an overlay.
         * @param {?} overlayRef
         * @return {?}
         */
        value: function attach(overlayRef) {
          this._overlayRef = overlayRef;

          this._positionStrategy.attach(overlayRef);

          if (this._direction) {
            overlayRef.setDirection(this._direction);
            this._direction = null;
          }
        }
        /**
         * Disposes all resources used by the position strategy.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          this._positionStrategy.dispose();
        }
        /**
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this._positionStrategy.detach();
        }
        /**
         * Updates the position of the overlay element, using whichever preferred position relative
         * to the origin fits on-screen.
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "apply",
        value: function apply() {
          this._positionStrategy.apply();
        }
        /**
         * Re-positions the overlay element with the trigger in its last calculated position,
         * even if a position higher in the "preferred positions" list would now fit. This
         * allows one to re-align the panel without changing the orientation of the panel.
         * @return {?}
         */

      }, {
        key: "recalculateLastPosition",
        value: function recalculateLastPosition() {
          this._positionStrategy.reapplyLastPosition();
        }
        /**
         * Sets the list of Scrollable containers that host the origin element so that
         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
         * Scrollable must be an ancestor element of the strategy's origin element.
         * @param {?} scrollables
         * @return {?}
         */

      }, {
        key: "withScrollableContainers",
        value: function withScrollableContainers(scrollables) {
          this._positionStrategy.withScrollableContainers(scrollables);
        }
        /**
         * Adds a new preferred fallback position.
         * @template THIS
         * @this {THIS}
         * @param {?} originPos
         * @param {?} overlayPos
         * @param {?=} offsetX
         * @param {?=} offsetY
         * @return {THIS}
         */

      }, {
        key: "withFallbackPosition",
        value: function withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {
          /** @type {?} */
          var position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);

          /** @type {?} */
          this._preferredPositions.push(position);

          /** @type {?} */
          this._positionStrategy.withPositions(
          /** @type {?} */
          this._preferredPositions);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the layout direction so the overlay's position can be adjusted to match.
         * @template THIS
         * @this {THIS}
         * @param {?} dir New layout direction.
         * @return {THIS}
         */

      }, {
        key: "withDirection",
        value: function withDirection(dir) {
          // Since the direction might be declared before the strategy is attached,
          // we save the value in a temporary property and we'll transfer it to the
          // overlay ref on attachment.
          if (
          /** @type {?} */
          this._overlayRef) {
            /** @type {?} */
            this._overlayRef.setDirection(dir);
          } else {
            /** @type {?} */
            this._direction = dir;
          }

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets an offset for the overlay's connection point on the x-axis
         * @template THIS
         * @this {THIS}
         * @param {?} offset New offset in the X axis.
         * @return {THIS}
         */

      }, {
        key: "withOffsetX",
        value: function withOffsetX(offset) {
          /** @type {?} */
          this._positionStrategy.withDefaultOffsetX(offset);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets an offset for the overlay's connection point on the y-axis
         * @template THIS
         * @this {THIS}
         * @param {?} offset New offset in the Y axis.
         * @return {THIS}
         */

      }, {
        key: "withOffsetY",
        value: function withOffsetY(offset) {
          /** @type {?} */
          this._positionStrategy.withDefaultOffsetY(offset);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets whether the overlay's position should be locked in after it is positioned
         * initially. When an overlay is locked in, it won't attempt to reposition itself
         * when the position is re-applied (e.g. when the user scrolls away).
         * @template THIS
         * @this {THIS}
         * @param {?} isLocked Whether the overlay should locked in.
         * @return {THIS}
         */

      }, {
        key: "withLockedPosition",
        value: function withLockedPosition(isLocked) {
          /** @type {?} */
          this._positionStrategy.withLockedPosition(isLocked);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Overwrites the current set of positions with an array of new ones.
         * @template THIS
         * @this {THIS}
         * @param {?} positions Position pairs to be set on the strategy.
         * @return {THIS}
         */

      }, {
        key: "withPositions",
        value: function withPositions(positions) {
          /** @type {?} */
          this._preferredPositions = positions.slice();

          /** @type {?} */
          this._positionStrategy.withPositions(
          /** @type {?} */
          this._preferredPositions);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the origin element, relative to which to position the overlay.
         * @template THIS
         * @this {THIS}
         * @param {?} origin Reference to the new origin element.
         * @return {THIS}
         */

      }, {
        key: "setOrigin",
        value: function setOrigin(origin) {
          /** @type {?} */
          this._positionStrategy.setOrigin(origin);

          return (
            /** @type {?} */
            this
          );
        }
      }, {
        key: "_isRtl",
        get: function get() {
          return this._overlayRef.getDirection() === 'rtl';
        }
        /**
         * Emits an event when the connection point changes.
         * @return {?}
         */

      }, {
        key: "onPositionChange",
        get: function get() {
          return this._positionStrategy.positionChanges;
        }
        /**
         * Ordered list of preferred positions, from most to least desirable.
         * @return {?}
         */

      }, {
        key: "positions",
        get: function get() {
          return this._preferredPositions;
        }
      }]);

      return ConnectedPositionStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Class to be added to the overlay pane wrapper.
     * @type {?}
     */


    var wrapperClass = 'cdk-global-overlay-wrapper';
    /**
     * A strategy for positioning overlays. Using this strategy, an overlay is given an
     * explicit position relative to the browser's viewport. We use flexbox, instead of
     * transforms, in order to avoid issues with subpixel rendering which can cause the
     * element to become blurry.
     */

    var GlobalPositionStrategy =
    /*#__PURE__*/
    function () {
      function GlobalPositionStrategy() {
        _classCallCheck(this, GlobalPositionStrategy);

        this._cssPosition = 'static';
        this._topOffset = '';
        this._bottomOffset = '';
        this._leftOffset = '';
        this._rightOffset = '';
        this._alignItems = '';
        this._justifyContent = '';
        this._width = '';
        this._height = '';
      }
      /**
       * @param {?} overlayRef
       * @return {?}
       */


      _createClass(GlobalPositionStrategy, [{
        key: "attach",
        value: function attach(overlayRef) {
          /** @type {?} */
          var config = overlayRef.getConfig();
          this._overlayRef = overlayRef;

          if (this._width && !config.width) {
            overlayRef.updateSize({
              width: this._width
            });
          }

          if (this._height && !config.height) {
            overlayRef.updateSize({
              height: this._height
            });
          }

          overlayRef.hostElement.classList.add(wrapperClass);
          this._isDisposed = false;
        }
        /**
         * Sets the top position of the overlay. Clears any previously set vertical position.
         * @template THIS
         * @this {THIS}
         * @param {?=} value New top offset.
         * @return {THIS}
         */

      }, {
        key: "top",
        value: function top() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this._bottomOffset = '';

          /** @type {?} */
          this._topOffset = value;

          /** @type {?} */
          this._alignItems = 'flex-start';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the left position of the overlay. Clears any previously set horizontal position.
         * @template THIS
         * @this {THIS}
         * @param {?=} value New left offset.
         * @return {THIS}
         */

      }, {
        key: "left",
        value: function left() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this._rightOffset = '';

          /** @type {?} */
          this._leftOffset = value;

          /** @type {?} */
          this._justifyContent = 'flex-start';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the bottom position of the overlay. Clears any previously set vertical position.
         * @template THIS
         * @this {THIS}
         * @param {?=} value New bottom offset.
         * @return {THIS}
         */

      }, {
        key: "bottom",
        value: function bottom() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this._topOffset = '';

          /** @type {?} */
          this._bottomOffset = value;

          /** @type {?} */
          this._alignItems = 'flex-end';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the right position of the overlay. Clears any previously set horizontal position.
         * @template THIS
         * @this {THIS}
         * @param {?=} value New right offset.
         * @return {THIS}
         */

      }, {
        key: "right",
        value: function right() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this._leftOffset = '';

          /** @type {?} */
          this._rightOffset = value;

          /** @type {?} */
          this._justifyContent = 'flex-end';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the overlay width and clears any previously set width.
         * @deprecated Pass the `width` through the `OverlayConfig`.
         * \@breaking-change 8.0.0
         * @template THIS
         * @this {THIS}
         * @param {?=} value New width for the overlay
         * @return {THIS}
         */

      }, {
        key: "width",
        value: function width() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          if (
          /** @type {?} */
          this._overlayRef) {
            /** @type {?} */
            this._overlayRef.updateSize({
              width: value
            });
          } else {
            /** @type {?} */
            this._width = value;
          }

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Sets the overlay height and clears any previously set height.
         * @deprecated Pass the `height` through the `OverlayConfig`.
         * \@breaking-change 8.0.0
         * @template THIS
         * @this {THIS}
         * @param {?=} value New height for the overlay
         * @return {THIS}
         */

      }, {
        key: "height",
        value: function height() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          if (
          /** @type {?} */
          this._overlayRef) {
            /** @type {?} */
            this._overlayRef.updateSize({
              height: value
            });
          } else {
            /** @type {?} */
            this._height = value;
          }

          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Centers the overlay horizontally with an optional offset.
         * Clears any previously set horizontal position.
         *
         * @template THIS
         * @this {THIS}
         * @param {?=} offset Overlay offset from the horizontal center.
         * @return {THIS}
         */

      }, {
        key: "centerHorizontally",
        value: function centerHorizontally() {
          var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this.left(offset);

          /** @type {?} */
          this._justifyContent = 'center';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Centers the overlay vertically with an optional offset.
         * Clears any previously set vertical position.
         *
         * @template THIS
         * @this {THIS}
         * @param {?=} offset Overlay offset from the vertical center.
         * @return {THIS}
         */

      }, {
        key: "centerVertically",
        value: function centerVertically() {
          var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          /** @type {?} */
          this.top(offset);

          /** @type {?} */
          this._alignItems = 'center';
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * Apply the position to the element.
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "apply",
        value: function apply() {
          // Since the overlay ref applies the strategy asynchronously, it could
          // have been disposed before it ends up being applied. If that is the
          // case, we shouldn't do anything.
          if (!this._overlayRef || !this._overlayRef.hasAttached()) {
            return;
          }
          /** @type {?} */


          var styles = this._overlayRef.overlayElement.style;
          /** @type {?} */

          var parentStyles = this._overlayRef.hostElement.style;
          /** @type {?} */

          var config = this._overlayRef.getConfig();

          styles.position = this._cssPosition;
          styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;
          styles.marginTop = config.height === '100%' ? '0' : this._topOffset;
          styles.marginBottom = this._bottomOffset;
          styles.marginRight = this._rightOffset;

          if (config.width === '100%') {
            parentStyles.justifyContent = 'flex-start';
          } else if (this._justifyContent === 'center') {
            parentStyles.justifyContent = 'center';
          } else if (this._overlayRef.getConfig().direction === 'rtl') {
            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we
            // don't want that because our positioning is explicitly `left` and `right`, hence
            // why we do another inversion to ensure that the overlay stays in the same position.
            // TODO: reconsider this if we add `start` and `end` methods.
            if (this._justifyContent === 'flex-start') {
              parentStyles.justifyContent = 'flex-end';
            } else if (this._justifyContent === 'flex-end') {
              parentStyles.justifyContent = 'flex-start';
            }
          } else {
            parentStyles.justifyContent = this._justifyContent;
          }

          parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;
        }
        /**
         * Cleans up the DOM changes from the position strategy.
         * \@docs-private
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          if (this._isDisposed || !this._overlayRef) {
            return;
          }
          /** @type {?} */


          var styles = this._overlayRef.overlayElement.style;
          /** @type {?} */

          var parent = this._overlayRef.hostElement;
          /** @type {?} */

          var parentStyles = parent.style;
          parent.classList.remove(wrapperClass);
          parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';
          this._overlayRef =
          /** @type {?} */
          null;
          this._isDisposed = true;
        }
      }]);

      return GlobalPositionStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Builder for overlay position strategy.
     */


    var OverlayPositionBuilder =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewportRuler
       * @param {?} _document
       * @param {?} _platform
       * @param {?} _overlayContainer
       */
      function OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {
        _classCallCheck(this, OverlayPositionBuilder);

        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
      }
      /**
       * Creates a global position strategy.
       * @return {?}
       */


      _createClass(OverlayPositionBuilder, [{
        key: "global",
        value: function global() {
          return new GlobalPositionStrategy();
        }
        /**
         * Creates a relative position strategy.
         * @deprecated Use `flexibleConnectedTo` instead.
         * \@breaking-change 8.0.0
         * @param {?} elementRef
         * @param {?} originPos
         * @param {?} overlayPos
         * @return {?}
         */

      }, {
        key: "connectedTo",
        value: function connectedTo(elementRef, originPos, overlayPos) {
          return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        }
        /**
         * Creates a flexible position strategy.
         * @param {?} origin Origin relative to which to position the overlay.
         * @return {?}
         */

      }, {
        key: "flexibleConnectedTo",
        value: function flexibleConnectedTo(origin) {
          return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
        }
      }]);

      return OverlayPositionBuilder;
    }();

    OverlayPositionBuilder.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    OverlayPositionBuilder.ctorParameters = function () {
      return [{
        type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }, {
        type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"]
      }, {
        type: OverlayContainer
      }];
    };
    /** @nocollapse */


    OverlayPositionBuilder.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({
      factory: function OverlayPositionBuilder_Factory() {
        return new OverlayPositionBuilder(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(OverlayContainer));
      },
      token: OverlayPositionBuilder,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Next overlay unique ID.
     * @type {?}
     */

    var nextUniqueId = 0; // Note that Overlay is *not* scoped to the app root because the ComponentFactoryResolver
    // it needs is different based on where OverlayModule is imported.

    /**
     * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
     * used as a low-level building block for other components. Dialogs, tooltips, menus,
     * selects, etc. can all be built using overlays. The service should primarily be used by authors
     * of re-usable components rather than developers building end-user applications.
     *
     * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
     */

    var Overlay =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} scrollStrategies
       * @param {?} _overlayContainer
       * @param {?} _componentFactoryResolver
       * @param {?} _positionBuilder
       * @param {?} _keyboardDispatcher
       * @param {?} _injector
       * @param {?} _ngZone
       * @param {?} _document
       * @param {?} _directionality
       * @param {?=} _location
       */
      function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location) {
        _classCallCheck(this, Overlay);

        this.scrollStrategies = scrollStrategies;
        this._overlayContainer = _overlayContainer;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._positionBuilder = _positionBuilder;
        this._keyboardDispatcher = _keyboardDispatcher;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._document = _document;
        this._directionality = _directionality;
        this._location = _location;
      }
      /**
       * Creates an overlay.
       * @param {?=} config Configuration applied to the overlay.
       * @return {?} Reference to the created overlay.
       */


      _createClass(Overlay, [{
        key: "create",
        value: function create(config) {
          /** @type {?} */
          var host = this._createHostElement();
          /** @type {?} */


          var pane = this._createPaneElement(host);
          /** @type {?} */


          var portalOutlet = this._createPortalOutlet(pane);
          /** @type {?} */


          var overlayConfig = new OverlayConfig(config);
          overlayConfig.direction = overlayConfig.direction || this._directionality.value;
          return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);
        }
        /**
         * Gets a position builder that can be used, via fluent API,
         * to construct and configure a position strategy.
         * @return {?} An overlay position builder.
         */

      }, {
        key: "position",
        value: function position() {
          return this._positionBuilder;
        }
        /**
         * Creates the DOM element for an overlay and appends it to the overlay container.
         * @private
         * @param {?} host
         * @return {?} Newly-created pane element
         */

      }, {
        key: "_createPaneElement",
        value: function _createPaneElement(host) {
          /** @type {?} */
          var pane = this._document.createElement('div');

          pane.id = "cdk-overlay-".concat(nextUniqueId++);
          pane.classList.add('cdk-overlay-pane');
          host.appendChild(pane);
          return pane;
        }
        /**
         * Creates the host element that wraps around an overlay
         * and can be used for advanced positioning.
         * @private
         * @return {?} Newly-create host element.
         */

      }, {
        key: "_createHostElement",
        value: function _createHostElement() {
          /** @type {?} */
          var host = this._document.createElement('div');

          this._overlayContainer.getContainerElement().appendChild(host);

          return host;
        }
        /**
         * Create a DomPortalOutlet into which the overlay content can be loaded.
         * @private
         * @param {?} pane The DOM element to turn into a portal outlet.
         * @return {?} A portal outlet for the given DOM element.
         */

      }, {
        key: "_createPortalOutlet",
        value: function _createPortalOutlet(pane) {
          // We have to resolve the ApplicationRef later in order to allow people
          // to use overlay-based providers during app initialization.
          if (!this._appRef) {
            this._appRef = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ApplicationRef"]);
          }

          return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["DomPortalOutlet"](pane, this._componentFactoryResolver, this._appRef, this._injector);
        }
      }]);

      return Overlay;
    }();

    Overlay.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"]
    }];
    /** @nocollapse */

    Overlay.ctorParameters = function () {
      return [{
        type: ScrollStrategyOptions
      }, {
        type: OverlayContainer
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ComponentFactoryResolver"]
      }, {
        type: OverlayPositionBuilder
      }, {
        type: OverlayKeyboardDispatcher
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injector"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["Directionality"]
      }, {
        type: _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"]
        }]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Default set of positions for the overlay. Follows the behavior of a dropdown.
     * @type {?}
     */


    var defaultPositionList = [{
      originX: 'start',
      originY: 'bottom',
      overlayX: 'start',
      overlayY: 'top'
    }, {
      originX: 'start',
      originY: 'top',
      overlayX: 'start',
      overlayY: 'bottom'
    }, {
      originX: 'end',
      originY: 'top',
      overlayX: 'end',
      overlayY: 'bottom'
    }, {
      originX: 'end',
      originY: 'bottom',
      overlayX: 'end',
      overlayY: 'top'
    }];
    /**
     * Injection token that determines the scroll handling while the connected overlay is open.
     * @type {?}
     */

    var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('cdk-connected-overlay-scroll-strategy');
    /**
     * Directive applied to an element to make it usable as an origin for an Overlay using a
     * ConnectedPositionStrategy.
     */

    var CdkOverlayOrigin =
    /**
     * @param {?} elementRef
     */
    function CdkOverlayOrigin(elementRef) {
      _classCallCheck(this, CdkOverlayOrigin);

      this.elementRef = elementRef;
    };

    CdkOverlayOrigin.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
        exportAs: 'cdkOverlayOrigin'
      }]
    }];
    /** @nocollapse */

    CdkOverlayOrigin.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"]
      }];
    };
    /**
     * Directive to facilitate declarative creation of an
     * Overlay using a FlexibleConnectedPositionStrategy.
     */


    var CdkConnectedOverlay =
    /*#__PURE__*/
    function () {
      // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.

      /**
       * @param {?} _overlay
       * @param {?} templateRef
       * @param {?} viewContainerRef
       * @param {?} scrollStrategyFactory
       * @param {?} _dir
       */
      function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
        _classCallCheck(this, CdkConnectedOverlay);

        this._overlay = _overlay;
        this._dir = _dir;
        this._hasBackdrop = false;
        this._lockPosition = false;
        this._growAfterOpen = false;
        this._flexibleDimensions = false;
        this._push = false;
        this._backdropSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
        /**
         * Margin between the overlay and the viewport edges.
         */

        this.viewportMargin = 0;
        /**
         * Whether the overlay is open.
         */

        this.open = false;
        /**
         * Event emitted when the backdrop is clicked.
         */

        this.backdropClick = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
        /**
         * Event emitted when the position has changed.
         */

        this.positionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
        /**
         * Event emitted when the overlay has been attached.
         */

        this.attach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
        /**
         * Event emitted when the overlay has been detached.
         */

        this.detach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
        /**
         * Emits when there are keyboard events that are targeted at the overlay.
         */

        this.overlayKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
        this._templatePortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["TemplatePortal"](templateRef, viewContainerRef);
        this._scrollStrategyFactory = scrollStrategyFactory;
        this.scrollStrategy = this._scrollStrategyFactory();
      }
      /**
       * The offset in pixels for the overlay connection point on the x-axis
       * @return {?}
       */


      _createClass(CdkConnectedOverlay, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          if (this._overlayRef) {
            this._overlayRef.dispose();
          }

          this._backdropSubscription.unsubscribe();
        }
        /**
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (this._position) {
            this._updatePositionStrategy(this._position);

            this._overlayRef.updateSize({
              width: this.width,
              minWidth: this.minWidth,
              height: this.height,
              minHeight: this.minHeight
            });

            if (changes['origin'] && this.open) {
              this._position.apply();
            }
          }

          if (changes['open']) {
            this.open ? this._attachOverlay() : this._detachOverlay();
          }
        }
        /**
         * Creates an overlay
         * @private
         * @return {?}
         */

      }, {
        key: "_createOverlay",
        value: function _createOverlay() {
          var _this121 = this;

          if (!this.positions || !this.positions.length) {
            this.positions = defaultPositionList;
          }

          this._overlayRef = this._overlay.create(this._buildConfig());

          this._overlayRef.keydownEvents().subscribe(
          /**
          * @param {?} event
          * @return {?}
          */
          function (event) {
            _this121.overlayKeydown.next(event);

            if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__["ESCAPE"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__["hasModifierKey"])(event)) {
              event.preventDefault();

              _this121._detachOverlay();
            }
          });
        }
        /**
         * Builds the overlay config based on the directive's inputs
         * @private
         * @return {?}
         */

      }, {
        key: "_buildConfig",
        value: function _buildConfig() {
          /** @type {?} */
          var positionStrategy = this._position = this._createPositionStrategy();
          /** @type {?} */


          var overlayConfig = new OverlayConfig({
            direction: this._dir,
            positionStrategy: positionStrategy,
            scrollStrategy: this.scrollStrategy,
            hasBackdrop: this.hasBackdrop
          });

          if (this.width || this.width === 0) {
            overlayConfig.width = this.width;
          }

          if (this.height || this.height === 0) {
            overlayConfig.height = this.height;
          }

          if (this.minWidth || this.minWidth === 0) {
            overlayConfig.minWidth = this.minWidth;
          }

          if (this.minHeight || this.minHeight === 0) {
            overlayConfig.minHeight = this.minHeight;
          }

          if (this.backdropClass) {
            overlayConfig.backdropClass = this.backdropClass;
          }

          if (this.panelClass) {
            overlayConfig.panelClass = this.panelClass;
          }

          return overlayConfig;
        }
        /**
         * Updates the state of a position strategy, based on the values of the directive inputs.
         * @private
         * @param {?} positionStrategy
         * @return {?}
         */

      }, {
        key: "_updatePositionStrategy",
        value: function _updatePositionStrategy(positionStrategy) {
          var _this122 = this;

          /** @type {?} */
          var positions = this.positions.map(
          /**
          * @param {?} currentPosition
          * @return {?}
          */
          function (currentPosition) {
            return {
              originX: currentPosition.originX,
              originY: currentPosition.originY,
              overlayX: currentPosition.overlayX,
              overlayY: currentPosition.overlayY,
              offsetX: currentPosition.offsetX || _this122.offsetX,
              offsetY: currentPosition.offsetY || _this122.offsetY,
              panelClass: currentPosition.panelClass || undefined
            };
          });
          return positionStrategy.setOrigin(this.origin.elementRef).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition);
        }
        /**
         * Returns the position strategy of the overlay to be set on the overlay config
         * @private
         * @return {?}
         */

      }, {
        key: "_createPositionStrategy",
        value: function _createPositionStrategy() {
          var _this123 = this;

          /** @type {?} */
          var strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);

          this._updatePositionStrategy(strategy);

          strategy.positionChanges.subscribe(
          /**
          * @param {?} p
          * @return {?}
          */
          function (p) {
            return _this123.positionChange.emit(p);
          });
          return strategy;
        }
        /**
         * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
         * @private
         * @return {?}
         */

      }, {
        key: "_attachOverlay",
        value: function _attachOverlay() {
          var _this124 = this;

          if (!this._overlayRef) {
            this._createOverlay();
          } else {
            // Update the overlay size, in case the directive's inputs have changed
            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
          }

          if (!this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._templatePortal);

            this.attach.emit();
          }

          if (this.hasBackdrop) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(
            /**
            * @param {?} event
            * @return {?}
            */
            function (event) {
              _this124.backdropClick.emit(event);
            });
          } else {
            this._backdropSubscription.unsubscribe();
          }
        }
        /**
         * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
         * @private
         * @return {?}
         */

      }, {
        key: "_detachOverlay",
        value: function _detachOverlay() {
          if (this._overlayRef) {
            this._overlayRef.detach();

            this.detach.emit();
          }

          this._backdropSubscription.unsubscribe();
        }
      }, {
        key: "offsetX",
        get: function get() {
          return this._offsetX;
        }
        /**
         * @param {?} offsetX
         * @return {?}
         */
        ,
        set: function set(offsetX) {
          this._offsetX = offsetX;

          if (this._position) {
            this._updatePositionStrategy(this._position);
          }
        }
        /**
         * The offset in pixels for the overlay connection point on the y-axis
         * @return {?}
         */

      }, {
        key: "offsetY",
        get: function get() {
          return this._offsetY;
        }
        /**
         * @param {?} offsetY
         * @return {?}
         */
        ,
        set: function set(offsetY) {
          this._offsetY = offsetY;

          if (this._position) {
            this._updatePositionStrategy(this._position);
          }
        }
        /**
         * Whether or not the overlay should attach a backdrop.
         * @return {?}
         */

      }, {
        key: "hasBackdrop",
        get: function get() {
          return this._hasBackdrop;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hasBackdrop = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
        }
        /**
         * Whether or not the overlay should be locked when scrolling.
         * @return {?}
         */

      }, {
        key: "lockPosition",
        get: function get() {
          return this._lockPosition;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._lockPosition = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
        }
        /**
         * Whether the overlay's width and height can be constrained to fit within the viewport.
         * @return {?}
         */

      }, {
        key: "flexibleDimensions",
        get: function get() {
          return this._flexibleDimensions;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._flexibleDimensions = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
        }
        /**
         * Whether the overlay can grow after the initial open when flexible positioning is turned on.
         * @return {?}
         */

      }, {
        key: "growAfterOpen",
        get: function get() {
          return this._growAfterOpen;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._growAfterOpen = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
        }
        /**
         * Whether the overlay can be pushed on-screen if none of the provided positions fit.
         * @return {?}
         */

      }, {
        key: "push",
        get: function get() {
          return this._push;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._push = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
        }
        /**
         * The associated overlay reference.
         * @return {?}
         */

      }, {
        key: "overlayRef",
        get: function get() {
          return this._overlayRef;
        }
        /**
         * The element's layout direction.
         * @return {?}
         */

      }, {
        key: "dir",
        get: function get() {
          return this._dir ? this._dir.value : 'ltr';
        }
      }]);

      return CdkConnectedOverlay;
    }();

    CdkConnectedOverlay.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"],
      args: [{
        selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
        exportAs: 'cdkConnectedOverlay'
      }]
    }];
    /** @nocollapse */

    CdkConnectedOverlay.ctorParameters = function () {
      return [{
        type: Overlay
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]
        }]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"]
        }]
      }];
    };

    CdkConnectedOverlay.propDecorators = {
      origin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayOrigin']
      }],
      positions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayPositions']
      }],
      offsetX: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayOffsetX']
      }],
      offsetY: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayOffsetY']
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayWidth']
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayHeight']
      }],
      minWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayMinWidth']
      }],
      minHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayMinHeight']
      }],
      backdropClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayBackdropClass']
      }],
      panelClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayPanelClass']
      }],
      viewportMargin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayViewportMargin']
      }],
      scrollStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayScrollStrategy']
      }],
      open: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayOpen']
      }],
      hasBackdrop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayHasBackdrop']
      }],
      lockPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayLockPosition']
      }],
      flexibleDimensions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayFlexibleDimensions']
      }],
      growAfterOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayGrowAfterOpen']
      }],
      push: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"],
        args: ['cdkConnectedOverlayPush']
      }],
      backdropClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"]
      }],
      positionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"]
      }],
      attach: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"]
      }],
      detach: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"]
      }],
      overlayKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"]
      }]
    };
    /**
     * \@docs-private
     * @param {?} overlay
     * @return {?}
     */

    function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
      return (
        /**
        * @return {?}
        */
        function () {
          return overlay.scrollStrategies.reposition();
        }
      );
    }
    /**
     * \@docs-private
     * @type {?}
     */


    var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
      provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
      deps: [Overlay],
      useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var OverlayModule = function OverlayModule() {
      _classCallCheck(this, OverlayModule);
    };

    OverlayModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"],
      args: [{
        imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__["BidiModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["PortalModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollingModule"]],
        exports: [CdkConnectedOverlay, CdkOverlayOrigin, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ScrollingModule"]],
        declarations: [CdkConnectedOverlay, CdkOverlayOrigin],
        providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
      }]
    }];
    /**
     * @deprecated Use `OverlayModule` instead.
     * \@breaking-change 8.0.0
     * \@docs-private
     * @type {?}
     */

    var OVERLAY_PROVIDERS = [Overlay, OverlayPositionBuilder, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["VIEWPORT_RULER_PROVIDER"], OVERLAY_CONTAINER_PROVIDER, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Alternative to OverlayContainer that supports correct displaying of overlay elements in
     * Fullscreen mode
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
     *
     * Should be provided in the root component.
     */

    var FullscreenOverlayContainer =
    /*#__PURE__*/
    function (_OverlayContainer) {
      _inherits(FullscreenOverlayContainer, _OverlayContainer);

      /**
       * @param {?} _document
       */
      function FullscreenOverlayContainer(_document) {
        _classCallCheck(this, FullscreenOverlayContainer);

        return _possibleConstructorReturn(this, _getPrototypeOf(FullscreenOverlayContainer).call(this, _document));
      }
      /**
       * @return {?}
       */


      _createClass(FullscreenOverlayContainer, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          _get(_getPrototypeOf(FullscreenOverlayContainer.prototype), "ngOnDestroy", this).call(this);

          if (this._fullScreenEventName && this._fullScreenListener) {
            this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_createContainer",
        value: function _createContainer() {
          var _this125 = this;

          _get(_getPrototypeOf(FullscreenOverlayContainer.prototype), "_createContainer", this).call(this);

          this._adjustParentForFullscreenChange();

          this._addFullscreenChangeListener(
          /**
          * @return {?}
          */
          function () {
            return _this125._adjustParentForFullscreenChange();
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_adjustParentForFullscreenChange",
        value: function _adjustParentForFullscreenChange() {
          if (!this._containerElement) {
            return;
          }
          /** @type {?} */


          var fullscreenElement = this.getFullscreenElement();
          /** @type {?} */

          var parent = fullscreenElement || this._document.body;
          parent.appendChild(this._containerElement);
        }
        /**
         * @private
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "_addFullscreenChangeListener",
        value: function _addFullscreenChangeListener(fn) {
          /** @type {?} */
          var eventName = this._getEventName();

          if (eventName) {
            if (this._fullScreenListener) {
              this._document.removeEventListener(eventName, this._fullScreenListener);
            }

            this._document.addEventListener(eventName, fn);

            this._fullScreenListener = fn;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getEventName",
        value: function _getEventName() {
          if (!this._fullScreenEventName) {
            /** @type {?} */
            var _document =
            /** @type {?} */
            this._document;

            if (_document.fullscreenEnabled) {
              this._fullScreenEventName = 'fullscreenchange';
            } else if (_document.webkitFullscreenEnabled) {
              this._fullScreenEventName = 'webkitfullscreenchange';
            } else if (_document.mozFullScreenEnabled) {
              this._fullScreenEventName = 'mozfullscreenchange';
            } else if (_document.msFullscreenEnabled) {
              this._fullScreenEventName = 'MSFullscreenChange';
            }
          }

          return this._fullScreenEventName;
        }
        /**
         * When the page is put into fullscreen mode, a specific element is specified.
         * Only that element and its children are visible when in fullscreen mode.
         * @return {?}
         */

      }, {
        key: "getFullscreenElement",
        value: function getFullscreenElement() {
          /** @type {?} */
          var _document =
          /** @type {?} */
          this._document;
          return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
        }
      }]);

      return FullscreenOverlayContainer;
    }(OverlayContainer);

    FullscreenOverlayContainer.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    FullscreenOverlayContainer.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]]
        }]
      }];
    };
    /** @nocollapse */


    FullscreenOverlayContainer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"])({
      factory: function FullscreenOverlayContainer_Factory() {
        return new FullscreenOverlayContainer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]));
      },
      token: FullscreenOverlayContainer,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/portal.js":
  /*!*****************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/portal.js ***!
    \*****************************************************/

  /*! exports provided: Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, BasePortalHost, DomPortalOutlet, DomPortalHost, CdkPortal, TemplatePortalDirective, CdkPortalOutlet, PortalHostDirective, PortalModule, PortalInjector */

  /***/
  function node_modulesAngularCdkEsm2015PortalJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Portal", function () {
      return Portal;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentPortal", function () {
      return ComponentPortal;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplatePortal", function () {
      return TemplatePortal;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BasePortalOutlet", function () {
      return BasePortalOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BasePortalHost", function () {
      return BasePortalHost;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DomPortalOutlet", function () {
      return DomPortalOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DomPortalHost", function () {
      return DomPortalHost;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkPortal", function () {
      return CdkPortal;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplatePortalDirective", function () {
      return TemplatePortalDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkPortalOutlet", function () {
      return CdkPortalOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PortalHostDirective", function () {
      return PortalHostDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PortalModule", function () {
      return PortalModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PortalInjector", function () {
      return PortalInjector;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Throws an exception when attempting to attach a null portal to a host.
     * \@docs-private
     * @return {?}
     */


    function throwNullPortalError() {
      throw Error('Must provide a portal to attach');
    }
    /**
     * Throws an exception when attempting to attach a portal to a host that is already attached.
     * \@docs-private
     * @return {?}
     */


    function throwPortalAlreadyAttachedError() {
      throw Error('Host already has a portal attached');
    }
    /**
     * Throws an exception when attempting to attach a portal to an already-disposed host.
     * \@docs-private
     * @return {?}
     */


    function throwPortalOutletAlreadyDisposedError() {
      throw Error('This PortalOutlet has already been disposed');
    }
    /**
     * Throws an exception when attempting to attach an unknown portal type.
     * \@docs-private
     * @return {?}
     */


    function throwUnknownPortalTypeError() {
      throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');
    }
    /**
     * Throws an exception when attempting to attach a portal to a null host.
     * \@docs-private
     * @return {?}
     */


    function throwNullPortalOutletError() {
      throw Error('Attempting to attach a portal to a null PortalOutlet');
    }
    /**
     * Throws an exception when attempting to detach a portal that is not attached.
     * \@docs-private
     * @return {?}
     */


    function throwNoPortalAttachedError() {
      throw Error('Attempting to detach a portal that is not attached to a host');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     * @abstract
     * @template T
     */


    var Portal =
    /*#__PURE__*/
    function () {
      function Portal() {
        _classCallCheck(this, Portal);
      }

      _createClass(Portal, [{
        key: "attach",

        /**
         * Attach this portal to a host.
         * @param {?} host
         * @return {?}
         */
        value: function attach(host) {
          if (host == null) {
            throwNullPortalOutletError();
          }

          if (host.hasAttached()) {
            throwPortalAlreadyAttachedError();
          }

          this._attachedHost = host;
          return (
            /** @type {?} */
            host.attach(this)
          );
        }
        /**
         * Detach this portal from its host
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          /** @type {?} */
          var host = this._attachedHost;

          if (host == null) {
            throwNoPortalAttachedError();
          } else {
            this._attachedHost = null;
            host.detach();
          }
        }
        /**
         * Whether this portal is attached to a host.
         * @return {?}
         */

      }, {
        key: "setAttachedHost",

        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         * @param {?} host
         * @return {?}
         */
        value: function setAttachedHost(host) {
          this._attachedHost = host;
        }
      }, {
        key: "isAttached",
        get: function get() {
          return this._attachedHost != null;
        }
      }]);

      return Portal;
    }();
    /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     * @template T
     */


    var ComponentPortal =
    /*#__PURE__*/
    function (_Portal) {
      _inherits(ComponentPortal, _Portal);

      /**
       * @param {?} component
       * @param {?=} viewContainerRef
       * @param {?=} injector
       * @param {?=} componentFactoryResolver
       */
      function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
        var _this126;

        _classCallCheck(this, ComponentPortal);

        _this126 = _possibleConstructorReturn(this, _getPrototypeOf(ComponentPortal).call(this));
        _this126.component = component;
        _this126.viewContainerRef = viewContainerRef;
        _this126.injector = injector;
        _this126.componentFactoryResolver = componentFactoryResolver;
        return _this126;
      }

      return ComponentPortal;
    }(Portal);
    /**
     * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
     * @template C
     */


    var TemplatePortal =
    /*#__PURE__*/
    function (_Portal2) {
      _inherits(TemplatePortal, _Portal2);

      /**
       * @param {?} template
       * @param {?} viewContainerRef
       * @param {?=} context
       */
      function TemplatePortal(template, viewContainerRef, context) {
        var _this127;

        _classCallCheck(this, TemplatePortal);

        _this127 = _possibleConstructorReturn(this, _getPrototypeOf(TemplatePortal).call(this));
        _this127.templateRef = template;
        _this127.viewContainerRef = viewContainerRef;
        _this127.context = context;
        return _this127;
      }
      /**
       * @return {?}
       */


      _createClass(TemplatePortal, [{
        key: "attach",

        /**
         * Attach the portal to the provided `PortalOutlet`.
         * When a context is provided it will override the `context` property of the `TemplatePortal`
         * instance.
         * @param {?} host
         * @param {?=} context
         * @return {?}
         */
        value: function attach(host) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;
          this.context = context;
          return _get(_getPrototypeOf(TemplatePortal.prototype), "attach", this).call(this, host);
        }
        /**
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this.context = undefined;
          return _get(_getPrototypeOf(TemplatePortal.prototype), "detach", this).call(this);
        }
      }, {
        key: "origin",
        get: function get() {
          return this.templateRef.elementRef;
        }
      }]);

      return TemplatePortal;
    }(Portal);
    /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     * @abstract
     */


    var BasePortalOutlet =
    /*#__PURE__*/
    function () {
      function BasePortalOutlet() {
        _classCallCheck(this, BasePortalOutlet);

        /**
         * Whether this host has already been permanently disposed.
         */
        this._isDisposed = false;
      }
      /**
       * Whether this host has an attached portal.
       * @return {?}
       */


      _createClass(BasePortalOutlet, [{
        key: "hasAttached",
        value: function hasAttached() {
          return !!this._attachedPortal;
        }
        /**
         * Attaches a portal.
         * @param {?} portal
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach(portal) {
          if (!portal) {
            throwNullPortalError();
          }

          if (this.hasAttached()) {
            throwPortalAlreadyAttachedError();
          }

          if (this._isDisposed) {
            throwPortalOutletAlreadyDisposedError();
          }

          if (portal instanceof ComponentPortal) {
            this._attachedPortal = portal;
            return this.attachComponentPortal(portal);
          } else if (portal instanceof TemplatePortal) {
            this._attachedPortal = portal;
            return this.attachTemplatePortal(portal);
          }

          throwUnknownPortalTypeError();
        }
        /**
         * Detaches a previously attached portal.
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          if (this._attachedPortal) {
            this._attachedPortal.setAttachedHost(null);

            this._attachedPortal = null;
          }

          this._invokeDisposeFn();
        }
        /**
         * Permanently dispose of this portal host.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          if (this.hasAttached()) {
            this.detach();
          }

          this._invokeDisposeFn();

          this._isDisposed = true;
        }
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "setDisposeFn",
        value: function setDisposeFn(fn) {
          this._disposeFn = fn;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_invokeDisposeFn",
        value: function _invokeDisposeFn() {
          if (this._disposeFn) {
            this._disposeFn();

            this._disposeFn = null;
          }
        }
      }]);

      return BasePortalOutlet;
    }();
    /**
     * @deprecated Use `BasePortalOutlet` instead.
     * \@breaking-change 9.0.0
     * @abstract
     */


    var BasePortalHost =
    /*#__PURE__*/
    function (_BasePortalOutlet) {
      _inherits(BasePortalHost, _BasePortalOutlet);

      function BasePortalHost() {
        _classCallCheck(this, BasePortalHost);

        return _possibleConstructorReturn(this, _getPrototypeOf(BasePortalHost).apply(this, arguments));
      }

      return BasePortalHost;
    }(BasePortalOutlet);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */


    var DomPortalOutlet =
    /*#__PURE__*/
    function (_BasePortalOutlet2) {
      _inherits(DomPortalOutlet, _BasePortalOutlet2);

      /**
       * @param {?} outletElement
       * @param {?} _componentFactoryResolver
       * @param {?} _appRef
       * @param {?} _defaultInjector
       */
      function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
        var _this128;

        _classCallCheck(this, DomPortalOutlet);

        _this128 = _possibleConstructorReturn(this, _getPrototypeOf(DomPortalOutlet).call(this));
        _this128.outletElement = outletElement;
        _this128._componentFactoryResolver = _componentFactoryResolver;
        _this128._appRef = _appRef;
        _this128._defaultInjector = _defaultInjector;
        return _this128;
      }
      /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @template T
       * @param {?} portal Portal to be attached
       * @return {?} Reference to the created component.
       */


      _createClass(DomPortalOutlet, [{
        key: "attachComponentPortal",
        value: function attachComponentPortal(portal) {
          var _this129 = this;

          /** @type {?} */
          var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
          /** @type {?} */

          var componentFactory = resolver.resolveComponentFactory(portal.component);
          /** @type {?} */

          var componentRef; // If the portal specifies a ViewContainerRef, we will use that as the attachment point
          // for the component (in terms of Angular's component tree, not rendering).
          // When the ViewContainerRef is missing, we use the factory to create the component directly
          // and then manually attach the view to the application.

          if (portal.viewContainerRef) {
            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
            this.setDisposeFn(
            /**
            * @return {?}
            */
            function () {
              return componentRef.destroy();
            });
          } else {
            componentRef = componentFactory.create(portal.injector || this._defaultInjector);

            this._appRef.attachView(componentRef.hostView);

            this.setDisposeFn(
            /**
            * @return {?}
            */
            function () {
              _this129._appRef.detachView(componentRef.hostView);

              componentRef.destroy();
            });
          } // At this point the component has been instantiated, so we move it to the location in the DOM
          // where we want it to be rendered.


          this.outletElement.appendChild(this._getComponentRootNode(componentRef));
          return componentRef;
        }
        /**
         * Attaches a template portal to the DOM as an embedded view.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */

      }, {
        key: "attachTemplatePortal",
        value: function attachTemplatePortal(portal) {
          var _this130 = this;

          /** @type {?} */
          var viewContainer = portal.viewContainerRef;
          /** @type {?} */

          var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
          viewRef.detectChanges(); // The method `createEmbeddedView` will add the view as a child of the viewContainer.
          // But for the DomPortalOutlet the view can be added everywhere in the DOM
          // (e.g Overlay Container) To move the view to the specified host element. We just
          // re-append the existing root nodes.

          viewRef.rootNodes.forEach(
          /**
          * @param {?} rootNode
          * @return {?}
          */
          function (rootNode) {
            return _this130.outletElement.appendChild(rootNode);
          });
          this.setDisposeFn(
          /**
          * @return {?}
          */
          function () {
            /** @type {?} */
            var index = viewContainer.indexOf(viewRef);

            if (index !== -1) {
              viewContainer.remove(index);
            }
          }); // TODO(jelbourn): Return locals from view.

          return viewRef;
        }
        /**
         * Clears out a portal from the DOM.
         * @return {?}
         */

      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(DomPortalOutlet.prototype), "dispose", this).call(this);

          if (this.outletElement.parentNode != null) {
            this.outletElement.parentNode.removeChild(this.outletElement);
          }
        }
        /**
         * Gets the root HTMLElement for an instantiated component.
         * @private
         * @param {?} componentRef
         * @return {?}
         */

      }, {
        key: "_getComponentRootNode",
        value: function _getComponentRootNode(componentRef) {
          return (
            /** @type {?} */

            /** @type {?} */
            componentRef.hostView.rootNodes[0]
          );
        }
      }]);

      return DomPortalOutlet;
    }(BasePortalOutlet);
    /**
     * @deprecated Use `DomPortalOutlet` instead.
     * \@breaking-change 9.0.0
     */


    var DomPortalHost =
    /*#__PURE__*/
    function (_DomPortalOutlet) {
      _inherits(DomPortalHost, _DomPortalOutlet);

      function DomPortalHost() {
        _classCallCheck(this, DomPortalHost);

        return _possibleConstructorReturn(this, _getPrototypeOf(DomPortalHost).apply(this, arguments));
      }

      return DomPortalHost;
    }(DomPortalOutlet);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
     * the directive instance itself can be attached to a host, enabling declarative use of portals.
     */


    var CdkPortal =
    /*#__PURE__*/
    function (_TemplatePortal) {
      _inherits(CdkPortal, _TemplatePortal);

      /**
       * @param {?} templateRef
       * @param {?} viewContainerRef
       */
      function CdkPortal(templateRef, viewContainerRef) {
        _classCallCheck(this, CdkPortal);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkPortal).call(this, templateRef, viewContainerRef));
      }

      return CdkPortal;
    }(TemplatePortal);

    CdkPortal.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdkPortal]',
        exportAs: 'cdkPortal'
      }]
    }];
    /** @nocollapse */

    CdkPortal.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]
      }];
    };
    /**
     * @deprecated Use `CdkPortal` instead.
     * \@breaking-change 9.0.0
     */


    var TemplatePortalDirective =
    /*#__PURE__*/
    function (_CdkPortal) {
      _inherits(TemplatePortalDirective, _CdkPortal);

      function TemplatePortalDirective() {
        _classCallCheck(this, TemplatePortalDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(TemplatePortalDirective).apply(this, arguments));
      }

      return TemplatePortalDirective;
    }(CdkPortal);

    TemplatePortalDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdk-portal], [portal]',
        exportAs: 'cdkPortal',
        providers: [{
          provide: CdkPortal,
          useExisting: TemplatePortalDirective
        }]
      }]
    }];
    /**
     * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
     * directly attached to it, enabling declarative use.
     *
     * Usage:
     * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
     */

    var CdkPortalOutlet =
    /*#__PURE__*/
    function (_BasePortalOutlet3) {
      _inherits(CdkPortalOutlet, _BasePortalOutlet3);

      /**
       * @param {?} _componentFactoryResolver
       * @param {?} _viewContainerRef
       */
      function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
        var _this131;

        _classCallCheck(this, CdkPortalOutlet);

        _this131 = _possibleConstructorReturn(this, _getPrototypeOf(CdkPortalOutlet).call(this));
        _this131._componentFactoryResolver = _componentFactoryResolver;
        _this131._viewContainerRef = _viewContainerRef;
        /**
         * Whether the portal component is initialized.
         */

        _this131._isInitialized = false;
        /**
         * Emits when a portal is attached to the outlet.
         */

        _this131.attached = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        return _this131;
      }
      /**
       * Portal associated with the Portal outlet.
       * @return {?}
       */


      _createClass(CdkPortalOutlet, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this._isInitialized = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          _get(_getPrototypeOf(CdkPortalOutlet.prototype), "dispose", this).call(this);

          this._attachedPortal = null;
          this._attachedRef = null;
        }
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @template T
         * @param {?} portal Portal to be attached to the portal outlet.
         * @return {?} Reference to the created component.
         */

      }, {
        key: "attachComponentPortal",
        value: function attachComponentPortal(portal) {
          portal.setAttachedHost(this); // If the portal specifies an origin, use that as the logical location of the component
          // in the application tree. Otherwise use the location of this PortalOutlet.

          /** @type {?} */

          var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
          /** @type {?} */

          var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
          /** @type {?} */

          var componentFactory = resolver.resolveComponentFactory(portal.component);
          /** @type {?} */

          var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);

          _get(_getPrototypeOf(CdkPortalOutlet.prototype), "setDisposeFn", this).call(this,
          /**
          * @return {?}
          */
          function () {
            return ref.destroy();
          });

          this._attachedPortal = portal;
          this._attachedRef = ref;
          this.attached.emit(ref);
          return ref;
        }
        /**
         * Attach the given TemplatePortal to this PortlHost as an embedded View.
         * @template C
         * @param {?} portal Portal to be attached.
         * @return {?} Reference to the created embedded view.
         */

      }, {
        key: "attachTemplatePortal",
        value: function attachTemplatePortal(portal) {
          var _this132 = this;

          portal.setAttachedHost(this);
          /** @type {?} */

          var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);

          _get(_getPrototypeOf(CdkPortalOutlet.prototype), "setDisposeFn", this).call(this,
          /**
          * @return {?}
          */
          function () {
            return _this132._viewContainerRef.clear();
          });

          this._attachedPortal = portal;
          this._attachedRef = viewRef;
          this.attached.emit(viewRef);
          return viewRef;
        }
      }, {
        key: "portal",
        get: function get() {
          return this._attachedPortal;
        }
        /**
         * @param {?} portal
         * @return {?}
         */
        ,
        set: function set(portal) {
          // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
          // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
          // and attach a portal programmatically in the parent component. When Angular does the first CD
          // round, it will fire the setter with empty string, causing the user's content to be cleared.
          if (this.hasAttached() && !portal && !this._isInitialized) {
            return;
          }

          if (this.hasAttached()) {
            _get(_getPrototypeOf(CdkPortalOutlet.prototype), "detach", this).call(this);
          }

          if (portal) {
            _get(_getPrototypeOf(CdkPortalOutlet.prototype), "attach", this).call(this, portal);
          }

          this._attachedPortal = portal;
        }
        /**
         * Component or view reference that is attached to the portal.
         * @return {?}
         */

      }, {
        key: "attachedRef",
        get: function get() {
          return this._attachedRef;
        }
      }]);

      return CdkPortalOutlet;
    }(BasePortalOutlet);

    CdkPortalOutlet.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdkPortalOutlet]',
        exportAs: 'cdkPortalOutlet',
        inputs: ['portal: cdkPortalOutlet']
      }]
    }];
    /** @nocollapse */

    CdkPortalOutlet.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]
      }];
    };

    CdkPortalOutlet.propDecorators = {
      attached: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }]
    };
    /**
     * @deprecated Use `CdkPortalOutlet` instead.
     * \@breaking-change 9.0.0
     */

    var PortalHostDirective =
    /*#__PURE__*/
    function (_CdkPortalOutlet) {
      _inherits(PortalHostDirective, _CdkPortalOutlet);

      function PortalHostDirective() {
        _classCallCheck(this, PortalHostDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(PortalHostDirective).apply(this, arguments));
      }

      return PortalHostDirective;
    }(CdkPortalOutlet);

    PortalHostDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdkPortalHost], [portalHost]',
        exportAs: 'cdkPortalHost',
        inputs: ['portal: cdkPortalHost'],
        providers: [{
          provide: CdkPortalOutlet,
          useExisting: PortalHostDirective
        }]
      }]
    }];

    var PortalModule = function PortalModule() {
      _classCallCheck(this, PortalModule);
    };

    PortalModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
      args: [{
        exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
        declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Custom injector to be used when providing custom
     * injection tokens to components inside a portal.
     * \@docs-private
     */

    var PortalInjector =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _parentInjector
       * @param {?} _customTokens
       */
      function PortalInjector(_parentInjector, _customTokens) {
        _classCallCheck(this, PortalInjector);

        this._parentInjector = _parentInjector;
        this._customTokens = _customTokens;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */


      _createClass(PortalInjector, [{
        key: "get",
        value: function get(token, notFoundValue) {
          /** @type {?} */
          var value = this._customTokens.get(token);

          if (typeof value !== 'undefined') {
            return value;
          }

          return this._parentInjector.get(token, notFoundValue);
        }
      }]);

      return PortalInjector;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/

  },

  /***/
  "./node_modules/@angular/cdk/esm2015/scrolling.js":
  /*!********************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/scrolling.js ***!
    \********************************************************/

  /*! exports provided: _fixedSizeVirtualScrollStrategyFactory, FixedSizeVirtualScrollStrategy, CdkFixedSizeVirtualScroll, SCROLL_DISPATCHER_PROVIDER_FACTORY, DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, ScrollingModule, ScrollDispatchModule, VIEWPORT_RULER_PROVIDER_FACTORY, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER, CdkVirtualForOf, VIRTUAL_SCROLL_STRATEGY, CdkVirtualScrollViewport */

  /***/
  function node_modulesAngularCdkEsm2015ScrollingJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "_fixedSizeVirtualScrollStrategyFactory", function () {
      return _fixedSizeVirtualScrollStrategyFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FixedSizeVirtualScrollStrategy", function () {
      return FixedSizeVirtualScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkFixedSizeVirtualScroll", function () {
      return CdkFixedSizeVirtualScroll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SCROLL_DISPATCHER_PROVIDER_FACTORY", function () {
      return SCROLL_DISPATCHER_PROVIDER_FACTORY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DEFAULT_SCROLL_TIME", function () {
      return DEFAULT_SCROLL_TIME;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollDispatcher", function () {
      return ScrollDispatcher;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SCROLL_DISPATCHER_PROVIDER", function () {
      return SCROLL_DISPATCHER_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkScrollable", function () {
      return CdkScrollable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollingModule", function () {
      return ScrollingModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollDispatchModule", function () {
      return ScrollDispatchModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VIEWPORT_RULER_PROVIDER_FACTORY", function () {
      return VIEWPORT_RULER_PROVIDER_FACTORY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DEFAULT_RESIZE_TIME", function () {
      return DEFAULT_RESIZE_TIME;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewportRuler", function () {
      return ViewportRuler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VIEWPORT_RULER_PROVIDER", function () {
      return VIEWPORT_RULER_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkVirtualForOf", function () {
      return CdkVirtualForOf;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VIRTUAL_SCROLL_STRATEGY", function () {
      return VIRTUAL_SCROLL_STRATEGY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkVirtualScrollViewport", function () {
      return CdkVirtualScrollViewport;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/platform */
    "./node_modules/@angular/cdk/esm2015/platform.js");
    /* harmony import */


    var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/cdk/bidi */
    "./node_modules/@angular/cdk/esm2015/bidi.js");
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The injection token used to specify the virtual scrolling strategy.
     * @type {?}
     */


    var VIRTUAL_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('VIRTUAL_SCROLL_STRATEGY');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Virtual scrolling strategy for lists with items of known fixed size.
     */

    var FixedSizeVirtualScrollStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} itemSize The size of the items in the virtually scrolling list.
       * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      function FixedSizeVirtualScrollStrategy(itemSize, minBufferPx, maxBufferPx) {
        _classCallCheck(this, FixedSizeVirtualScrollStrategy);

        this._scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * \@docs-private Implemented as part of VirtualScrollStrategy.
         */

        this.scrolledIndexChange = this._scrolledIndexChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["distinctUntilChanged"])());
        /**
         * The attached viewport.
         */

        this._viewport = null;
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
      }
      /**
       * Attaches this scroll strategy to a viewport.
       * @param {?} viewport The viewport to attach this strategy to.
       * @return {?}
       */


      _createClass(FixedSizeVirtualScrollStrategy, [{
        key: "attach",
        value: function attach(viewport) {
          this._viewport = viewport;

          this._updateTotalContentSize();

          this._updateRenderedRange();
        }
        /**
         * Detaches this scroll strategy from the currently attached viewport.
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this._scrolledIndexChange.complete();

          this._viewport = null;
        }
        /**
         * Update the item size and buffer size.
         * @param {?} itemSize The size of the items in the virtually scrolling list.
         * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more
         * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.
         * @return {?}
         */

      }, {
        key: "updateItemAndBufferSize",
        value: function updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
          if (maxBufferPx < minBufferPx) {
            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');
          }

          this._itemSize = itemSize;
          this._minBufferPx = minBufferPx;
          this._maxBufferPx = maxBufferPx;

          this._updateTotalContentSize();

          this._updateRenderedRange();
        }
        /**
         * \@docs-private Implemented as part of VirtualScrollStrategy.
         * @return {?}
         */

      }, {
        key: "onContentScrolled",
        value: function onContentScrolled() {
          this._updateRenderedRange();
        }
        /**
         * \@docs-private Implemented as part of VirtualScrollStrategy.
         * @return {?}
         */

      }, {
        key: "onDataLengthChanged",
        value: function onDataLengthChanged() {
          this._updateTotalContentSize();

          this._updateRenderedRange();
        }
        /**
         * \@docs-private Implemented as part of VirtualScrollStrategy.
         * @return {?}
         */

      }, {
        key: "onContentRendered",
        value: function onContentRendered() {}
        /**
         * \@docs-private Implemented as part of VirtualScrollStrategy.
         * @return {?}
         */

      }, {
        key: "onRenderedOffsetChanged",
        value: function onRenderedOffsetChanged() {}
        /**
         * Scroll to the offset for the given index.
         * @param {?} index The index of the element to scroll to.
         * @param {?} behavior The ScrollBehavior to use when scrolling.
         * @return {?}
         */

      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index, behavior) {
          if (this._viewport) {
            this._viewport.scrollToOffset(index * this._itemSize, behavior);
          }
        }
        /**
         * Update the viewport's total content size.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateTotalContentSize",
        value: function _updateTotalContentSize() {
          if (!this._viewport) {
            return;
          }

          this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
        }
        /**
         * Update the viewport's rendered range.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateRenderedRange",
        value: function _updateRenderedRange() {
          if (!this._viewport) {
            return;
          }
          /** @type {?} */


          var scrollOffset = this._viewport.measureScrollOffset();
          /** @type {?} */


          var firstVisibleIndex = scrollOffset / this._itemSize;
          /** @type {?} */

          var renderedRange = this._viewport.getRenderedRange();
          /** @type {?} */


          var newRange = {
            start: renderedRange.start,
            end: renderedRange.end
          };
          /** @type {?} */

          var viewportSize = this._viewport.getViewportSize();
          /** @type {?} */


          var dataLength = this._viewport.getDataLength();
          /** @type {?} */


          var startBuffer = scrollOffset - newRange.start * this._itemSize;

          if (startBuffer < this._minBufferPx && newRange.start != 0) {
            /** @type {?} */
            var expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
            newRange.start = Math.max(0, newRange.start - expandStart);
            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
          } else {
            /** @type {?} */
            var endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);

            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
              /** @type {?} */
              var expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);

              if (expandEnd > 0) {
                newRange.end = Math.min(dataLength, newRange.end + expandEnd);
                newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
              }
            }
          }

          this._viewport.setRenderedRange(newRange);

          this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);

          this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
        }
      }]);

      return FixedSizeVirtualScrollStrategy;
    }();
    /**
     * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created
     * `FixedSizeVirtualScrollStrategy` from the given directive.
     * @param {?} fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the
     *     `FixedSizeVirtualScrollStrategy` from.
     * @return {?}
     */


    function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
      return fixedSizeDir._scrollStrategy;
    }
    /**
     * A virtual scroll strategy that supports fixed-size items.
     */


    var CdkFixedSizeVirtualScroll =
    /*#__PURE__*/
    function () {
      function CdkFixedSizeVirtualScroll() {
        _classCallCheck(this, CdkFixedSizeVirtualScroll);

        this._itemSize = 20;
        this._minBufferPx = 100;
        this._maxBufferPx = 200;
        /**
         * The scroll strategy used by this directive.
         */

        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
      }
      /**
       * The size of the items in the list (in pixels).
       * @return {?}
       */


      _createClass(CdkFixedSizeVirtualScroll, [{
        key: "ngOnChanges",

        /**
         * @return {?}
         */
        value: function ngOnChanges() {
          this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
        }
      }, {
        key: "itemSize",
        get: function get() {
          return this._itemSize;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._itemSize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceNumberProperty"])(value);
        }
        /**
         * The minimum amount of buffer rendered beyond the viewport (in pixels).
         * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
         * @return {?}
         */

      }, {
        key: "minBufferPx",
        get: function get() {
          return this._minBufferPx;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._minBufferPx = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceNumberProperty"])(value);
        }
        /**
         * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
         * @return {?}
         */

      }, {
        key: "maxBufferPx",
        get: function get() {
          return this._maxBufferPx;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._maxBufferPx = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceNumberProperty"])(value);
        }
      }]);

      return CdkFixedSizeVirtualScroll;
    }();

    CdkFixedSizeVirtualScroll.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: 'cdk-virtual-scroll-viewport[itemSize]',
        providers: [{
          provide: VIRTUAL_SCROLL_STRATEGY,
          useFactory: _fixedSizeVirtualScrollStrategyFactory,
          deps: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(
          /**
          * @return {?}
          */
          function () {
            return CdkFixedSizeVirtualScroll;
          })]
        }]
      }]
    }];
    CdkFixedSizeVirtualScroll.propDecorators = {
      itemSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      minBufferPx: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      maxBufferPx: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Time in ms to throttle the scrolling events by default.
     * @type {?}
     */

    var DEFAULT_SCROLL_TIME = 20;
    /**
     * Service contained all registered Scrollable references and emits an event when any one of the
     * Scrollable references emit a scrolled event.
     */

    var ScrollDispatcher =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _ngZone
       * @param {?} _platform
       */
      function ScrollDispatcher(_ngZone, _platform) {
        _classCallCheck(this, ScrollDispatcher);

        this._ngZone = _ngZone;
        this._platform = _platform;
        /**
         * Subject for notifying that a registered scrollable reference element has been scrolled.
         */

        this._scrolled = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * Keeps track of the global `scroll` and `resize` subscriptions.
         */

        this._globalSubscription = null;
        /**
         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.
         */

        this._scrolledCount = 0;
        /**
         * Map of all the scrollable references that are registered with the service and their
         * scroll event subscriptions.
         */

        this.scrollContainers = new Map();
      }
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param {?} scrollable Scrollable instance to be registered.
       * @return {?}
       */


      _createClass(ScrollDispatcher, [{
        key: "register",
        value: function register(scrollable) {
          var _this133 = this;

          if (!this.scrollContainers.has(scrollable)) {
            this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(
            /**
            * @return {?}
            */
            function () {
              return _this133._scrolled.next(scrollable);
            }));
          }
        }
        /**
         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
         * @param {?} scrollable Scrollable instance to be deregistered.
         * @return {?}
         */

      }, {
        key: "deregister",
        value: function deregister(scrollable) {
          /** @type {?} */
          var scrollableReference = this.scrollContainers.get(scrollable);

          if (scrollableReference) {
            scrollableReference.unsubscribe();
            this.scrollContainers.delete(scrollable);
          }
        }
        /**
         * Returns an observable that emits an event whenever any of the registered Scrollable
         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
         * to override the default "throttle" time.
         *
         * **Note:** in order to avoid hitting change detection for every scroll event,
         * all of the events emitted from this stream will be run outside the Angular zone.
         * If you need to update any data bindings as a result of a scroll event, you have
         * to run the callback using `NgZone.run`.
         * @param {?=} auditTimeInMs
         * @return {?}
         */

      }, {
        key: "scrolled",
        value: function scrolled() {
          var _this134 = this;

          var auditTimeInMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SCROLL_TIME;

          if (!this._platform.isBrowser) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])();
          }

          return new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
          /**
          * @param {?} observer
          * @return {?}
          */
          function (observer) {
            if (!_this134._globalSubscription) {
              _this134._addGlobalListener();
            } // In the case of a 0ms delay, use an observable without auditTime
            // since it does add a perceptible delay in processing overhead.

            /** @type {?} */


            var subscription = auditTimeInMs > 0 ? _this134._scrolled.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["auditTime"])(auditTimeInMs)).subscribe(observer) : _this134._scrolled.subscribe(observer);
            _this134._scrolledCount++;
            return (
              /**
              * @return {?}
              */
              function () {
                subscription.unsubscribe();
                _this134._scrolledCount--;

                if (!_this134._scrolledCount) {
                  _this134._removeGlobalListener();
                }
              }
            );
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this135 = this;

          this._removeGlobalListener();

          this.scrollContainers.forEach(
          /**
          * @param {?} _
          * @param {?} container
          * @return {?}
          */
          function (_, container) {
            return _this135.deregister(container);
          });

          this._scrolled.complete();
        }
        /**
         * Returns an observable that emits whenever any of the
         * scrollable ancestors of an element are scrolled.
         * @param {?} elementRef Element whose ancestors to listen for.
         * @param {?=} auditTimeInMs Time to throttle the scroll events.
         * @return {?}
         */

      }, {
        key: "ancestorScrolled",
        value: function ancestorScrolled(elementRef, auditTimeInMs) {
          /** @type {?} */
          var ancestors = this.getAncestorScrollContainers(elementRef);
          return this.scrolled(auditTimeInMs).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["filter"])(
          /**
          * @param {?} target
          * @return {?}
          */
          function (target) {
            return !target || ancestors.indexOf(target) > -1;
          }));
        }
        /**
         * Returns all registered Scrollables that contain the provided element.
         * @param {?} elementRef
         * @return {?}
         */

      }, {
        key: "getAncestorScrollContainers",
        value: function getAncestorScrollContainers(elementRef) {
          var _this136 = this;

          /** @type {?} */
          var scrollingContainers = [];
          this.scrollContainers.forEach(
          /**
          * @param {?} _subscription
          * @param {?} scrollable
          * @return {?}
          */
          function (_subscription, scrollable) {
            if (_this136._scrollableContainsElement(scrollable, elementRef)) {
              scrollingContainers.push(scrollable);
            }
          });
          return scrollingContainers;
        }
        /**
         * Returns true if the element is contained within the provided Scrollable.
         * @private
         * @param {?} scrollable
         * @param {?} elementRef
         * @return {?}
         */

      }, {
        key: "_scrollableContainsElement",
        value: function _scrollableContainsElement(scrollable, elementRef) {
          /** @type {?} */
          var element = elementRef.nativeElement;
          /** @type {?} */

          var scrollableElement = scrollable.getElementRef().nativeElement; // Traverse through the element parents until we reach null, checking if any of the elements
          // are the scrollable's element.

          do {
            if (element == scrollableElement) {
              return true;
            }
          } while (element =
          /** @type {?} */
          element.parentElement);

          return false;
        }
        /**
         * Sets up the global scroll listeners.
         * @private
         * @return {?}
         */

      }, {
        key: "_addGlobalListener",
        value: function _addGlobalListener() {
          var _this137 = this;

          this._globalSubscription = this._ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(window.document, 'scroll').subscribe(
            /**
            * @return {?}
            */
            function () {
              return _this137._scrolled.next();
            });
          });
        }
        /**
         * Cleans up the global scroll listener.
         * @private
         * @return {?}
         */

      }, {
        key: "_removeGlobalListener",
        value: function _removeGlobalListener() {
          if (this._globalSubscription) {
            this._globalSubscription.unsubscribe();

            this._globalSubscription = null;
          }
        }
      }]);

      return ScrollDispatcher;
    }();

    ScrollDispatcher.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    ScrollDispatcher.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }, {
        type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]
      }];
    };
    /** @nocollapse */


    ScrollDispatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      factory: function ScrollDispatcher_Factory() {
        return new ScrollDispatcher(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]));
      },
      token: ScrollDispatcher,
      providedIn: "root"
    });
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @param {?} parentDispatcher
     * @param {?} ngZone
     * @param {?} platform
     * @return {?}
     */

    function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
      return parentDispatcher || new ScrollDispatcher(ngZone, platform);
    }
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @type {?}
     */


    var SCROLL_DISPATCHER_PROVIDER = {
      // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
      provide: ScrollDispatcher,
      deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), ScrollDispatcher], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]],
      useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Sends an event when the directive's element is scrolled. Registers itself with the
     * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
     * can be listened to through the service.
     */

    var CdkScrollable =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} scrollDispatcher
       * @param {?} ngZone
       * @param {?=} dir
       */
      function CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {
        var _this138 = this;

        _classCallCheck(this, CdkScrollable);

        this.elementRef = elementRef;
        this.scrollDispatcher = scrollDispatcher;
        this.ngZone = ngZone;
        this.dir = dir;
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        this._elementScrolled = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
        /**
        * @param {?} observer
        * @return {?}
        */
        function (observer) {
          return _this138.ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(_this138.elementRef.nativeElement, 'scroll').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(_this138._destroyed)).subscribe(observer);
          });
        });
      }
      /**
       * @return {?}
       */


      _createClass(CdkScrollable, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.scrollDispatcher.register(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.scrollDispatcher.deregister(this);

          this._destroyed.next();

          this._destroyed.complete();
        }
        /**
         * Returns observable that emits when a scroll event is fired on the host element.
         * @return {?}
         */

      }, {
        key: "elementScrolled",
        value: function elementScrolled() {
          return this._elementScrolled;
        }
        /**
         * Gets the ElementRef for the viewport.
         * @return {?}
         */

      }, {
        key: "getElementRef",
        value: function getElementRef() {
          return this.elementRef;
        }
        /**
         * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
         * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
         * left and right always refer to the left and right side of the scrolling container irrespective
         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
         * in an RTL context.
         * @param {?} options specified the offsets to scroll to.
         * @return {?}
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(options) {
          /** @type {?} */
          var el = this.elementRef.nativeElement;
          /** @type {?} */

          var isRtl = this.dir && this.dir.value == 'rtl'; // Rewrite start & end offsets as right or left offsets.

          options.left = options.left == null ? isRtl ? options.end : options.start : options.left;
          options.right = options.right == null ? isRtl ? options.start : options.end : options.right; // Rewrite the bottom offset as a top offset.

          if (options.bottom != null) {
            /** @type {?} */
            options.top = el.scrollHeight - el.clientHeight - options.bottom;
          } // Rewrite the right offset as a left offset.


          if (isRtl && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["getRtlScrollAxisType"])() != _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["RtlScrollAxisType"].NORMAL) {
            if (options.left != null) {
              /** @type {?} */
              options.right = el.scrollWidth - el.clientWidth - options.left;
            }

            if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["getRtlScrollAxisType"])() == _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["RtlScrollAxisType"].INVERTED) {
              options.left = options.right;
            } else if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["getRtlScrollAxisType"])() == _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["RtlScrollAxisType"].NEGATED) {
              options.left = options.right ? -options.right : options.right;
            }
          } else {
            if (options.right != null) {
              /** @type {?} */
              options.left = el.scrollWidth - el.clientWidth - options.right;
            }
          }

          this._applyScrollToOptions(options);
        }
        /**
         * @private
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "_applyScrollToOptions",
        value: function _applyScrollToOptions(options) {
          /** @type {?} */
          var el = this.elementRef.nativeElement;

          if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["supportsScrollBehavior"])()) {
            el.scrollTo(options);
          } else {
            if (options.top != null) {
              el.scrollTop = options.top;
            }

            if (options.left != null) {
              el.scrollLeft = options.left;
            }
          }
        }
        /**
         * Measures the scroll offset relative to the specified edge of the viewport. This method can be
         * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
         * about what scrollLeft means in RTL. The values returned by this method are normalized such that
         * left and right always refer to the left and right side of the scrolling container irrespective
         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
         * in an RTL context.
         * @param {?} from The edge to measure from.
         * @return {?}
         */

      }, {
        key: "measureScrollOffset",
        value: function measureScrollOffset(from) {
          /** @type {?} */
          var LEFT = 'left';
          /** @type {?} */

          var RIGHT = 'right';
          /** @type {?} */

          var el = this.elementRef.nativeElement;

          if (from == 'top') {
            return el.scrollTop;
          }

          if (from == 'bottom') {
            return el.scrollHeight - el.clientHeight - el.scrollTop;
          } // Rewrite start & end as left or right offsets.

          /** @type {?} */


          var isRtl = this.dir && this.dir.value == 'rtl';

          if (from == 'start') {
            from = isRtl ? RIGHT : LEFT;
          } else if (from == 'end') {
            from = isRtl ? LEFT : RIGHT;
          }

          if (isRtl && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["getRtlScrollAxisType"])() == _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["RtlScrollAxisType"].INVERTED) {
            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and
            // 0 when scrolled all the way right.
            if (from == LEFT) {
              return el.scrollWidth - el.clientWidth - el.scrollLeft;
            } else {
              return el.scrollLeft;
            }
          } else if (isRtl && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["getRtlScrollAxisType"])() == _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["RtlScrollAxisType"].NEGATED) {
            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and
            // 0 when scrolled all the way right.
            if (from == LEFT) {
              return el.scrollLeft + el.scrollWidth - el.clientWidth;
            } else {
              return -el.scrollLeft;
            }
          } else {
            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and
            // (scrollWidth - clientWidth) when scrolled all the way right.
            if (from == LEFT) {
              return el.scrollLeft;
            } else {
              return el.scrollWidth - el.clientWidth - el.scrollLeft;
            }
          }
        }
      }]);

      return CdkScrollable;
    }();

    CdkScrollable.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdk-scrollable], [cdkScrollable]'
      }]
    }];
    /** @nocollapse */

    CdkScrollable.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }, {
        type: ScrollDispatcher
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"]
        }]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Checks if the given ranges are equal.
     * @param {?} r1
     * @param {?} r2
     * @return {?}
     */


    function rangesEqual(r1, r2) {
      return r1.start == r2.start && r1.end == r2.end;
    }
    /**
     * Scheduler to be used for scroll events. Needs to fall back to
     * something that doesn't rely on requestAnimationFrame on environments
     * that don't support it (e.g. server-side rendering).
     * @type {?}
     */


    var SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? rxjs__WEBPACK_IMPORTED_MODULE_2__["animationFrameScheduler"] : rxjs__WEBPACK_IMPORTED_MODULE_2__["asapScheduler"];
    /**
     * A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`.
     */

    var CdkVirtualScrollViewport =
    /*#__PURE__*/
    function (_CdkScrollable) {
      _inherits(CdkVirtualScrollViewport, _CdkScrollable);

      /**
       * @param {?} elementRef
       * @param {?} _changeDetectorRef
       * @param {?} ngZone
       * @param {?} _scrollStrategy
       * @param {?} dir
       * @param {?} scrollDispatcher
       */
      function CdkVirtualScrollViewport(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher) {
        var _this139;

        _classCallCheck(this, CdkVirtualScrollViewport);

        _this139 = _possibleConstructorReturn(this, _getPrototypeOf(CdkVirtualScrollViewport).call(this, elementRef, scrollDispatcher, ngZone, dir));
        _this139.elementRef = elementRef;
        _this139._changeDetectorRef = _changeDetectorRef;
        _this139._scrollStrategy = _scrollStrategy;
        /**
         * Emits when the viewport is detached from a CdkVirtualForOf.
         */

        _this139._detachedSubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * Emits when the rendered range changes.
         */

        _this139._renderedRangeSubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        _this139._orientation = 'vertical'; // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
        // depending on how the strategy calculates the scrolled index, it may come at a cost to
        // performance.

        /**
         * Emits when the index of the first element visible in the viewport changes.
         */

        _this139.scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](
        /**
        * @param {?} observer
        * @return {?}
        */
        function (observer) {
          return _this139._scrollStrategy.scrolledIndexChange.subscribe(
          /**
          * @param {?} index
          * @return {?}
          */
          function (index) {
            return Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              return _this139.ngZone.run(
              /**
              * @return {?}
              */
              function () {
                return observer.next(index);
              });
            });
          });
        });
        /**
         * A stream that emits whenever the rendered range changes.
         */

        _this139.renderedRangeStream = _this139._renderedRangeSubject.asObservable();
        /**
         * The total size of all content (in pixels), including content that is not currently rendered.
         */

        _this139._totalContentSize = 0;
        /**
         * A string representing the `style.width` property value to be used for the spacer element.
         */

        _this139._totalContentWidth = '';
        /**
         * A string representing the `style.height` property value to be used for the spacer element.
         */

        _this139._totalContentHeight = '';
        /**
         * The currently rendered range of indices.
         */

        _this139._renderedRange = {
          start: 0,
          end: 0
        };
        /**
         * The length of the data bound to this viewport (in number of items).
         */

        _this139._dataLength = 0;
        /**
         * The size of the viewport (in pixels).
         */

        _this139._viewportSize = 0;
        /**
         * The last rendered content offset that was set.
         */

        _this139._renderedContentOffset = 0;
        /**
         * Whether the last rendered content offset was to the end of the content (and therefore needs to
         * be rewritten as an offset to the start of the content).
         */

        _this139._renderedContentOffsetNeedsRewrite = false;
        /**
         * Whether there is a pending change detection cycle.
         */

        _this139._isChangeDetectionPending = false;
        /**
         * A list of functions to run after the next change detection cycle.
         */

        _this139._runAfterChangeDetection = [];

        if (!_scrollStrategy) {
          throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
        }

        return _this139;
      }
      /**
       * The direction the viewport scrolls.
       * @return {?}
       */


      _createClass(CdkVirtualScrollViewport, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          var _this140 = this;

          _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "ngOnInit", this).call(this); // It's still too early to measure the viewport at this point. Deferring with a promise allows
          // the Viewport to be rendered with the correct size before we measure. We run this outside the
          // zone to avoid causing more change detection cycles. We handle the change detection loop
          // ourselves instead.


          this.ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            return Promise.resolve().then(
            /**
            * @return {?}
            */
            function () {
              _this140._measureViewportSize();

              _this140._scrollStrategy.attach(_this140);

              _this140.elementScrolled().pipe( // Start off with a fake scroll event so we properly detect our initial position.
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])(
              /** @type {?} */
              null), // Collect multiple events into one until the next animation frame. This way if
              // there are multiple scroll events in the same frame we only need to recheck
              // our layout once.
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["auditTime"])(0, SCROLL_SCHEDULER)).subscribe(
              /**
              * @return {?}
              */
              function () {
                return _this140._scrollStrategy.onContentScrolled();
              });

              _this140._markChangeDetectionNeeded();
            });
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.detach();

          this._scrollStrategy.detach(); // Complete all subjects


          this._renderedRangeSubject.complete();

          this._detachedSubject.complete();

          _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "ngOnDestroy", this).call(this);
        }
        /**
         * Attaches a `CdkVirtualForOf` to this viewport.
         * @param {?} forOf
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach(forOf) {
          var _this141 = this;

          if (this._forOf) {
            throw Error('CdkVirtualScrollViewport is already attached.');
          } // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length
          // changes. Run outside the zone to avoid triggering change detection, since we're managing the
          // change detection loop ourselves.


          this.ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          function () {
            _this141._forOf = forOf;

            _this141._forOf.dataStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(_this141._detachedSubject)).subscribe(
            /**
            * @param {?} data
            * @return {?}
            */
            function (data) {
              /** @type {?} */
              var newLength = data.length;

              if (newLength !== _this141._dataLength) {
                _this141._dataLength = newLength;

                _this141._scrollStrategy.onDataLengthChanged();
              }

              _this141._doChangeDetection();
            });
          });
        }
        /**
         * Detaches the current `CdkVirtualForOf`.
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this._forOf = null;

          this._detachedSubject.next();
        }
        /**
         * Gets the length of the data bound to this viewport (in number of items).
         * @return {?}
         */

      }, {
        key: "getDataLength",
        value: function getDataLength() {
          return this._dataLength;
        }
        /**
         * Gets the size of the viewport (in pixels).
         * @return {?}
         */

      }, {
        key: "getViewportSize",
        value: function getViewportSize() {
          return this._viewportSize;
        } // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
        // cycle happens. I'm being careful to only call it after the render cycle is complete and before
        // setting it to something else, but its error prone and should probably be split into
        // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.

        /**
         * Get the current rendered range of items.
         * @return {?}
         */

      }, {
        key: "getRenderedRange",
        value: function getRenderedRange() {
          return this._renderedRange;
        }
        /**
         * Sets the total size of all content (in pixels), including content that is not currently
         * rendered.
         * @param {?} size
         * @return {?}
         */

      }, {
        key: "setTotalContentSize",
        value: function setTotalContentSize(size) {
          if (this._totalContentSize !== size) {
            this._totalContentSize = size;

            this._calculateSpacerSize();

            this._markChangeDetectionNeeded();
          }
        }
        /**
         * Sets the currently rendered range of indices.
         * @param {?} range
         * @return {?}
         */

      }, {
        key: "setRenderedRange",
        value: function setRenderedRange(range) {
          var _this142 = this;

          if (!rangesEqual(this._renderedRange, range)) {
            this._renderedRangeSubject.next(this._renderedRange = range);

            this._markChangeDetectionNeeded(
            /**
            * @return {?}
            */
            function () {
              return _this142._scrollStrategy.onContentRendered();
            });
          }
        }
        /**
         * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
         * @return {?}
         */

      }, {
        key: "getOffsetToRenderedContentStart",
        value: function getOffsetToRenderedContentStart() {
          return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
        }
        /**
         * Sets the offset from the start of the viewport to either the start or end of the rendered data
         * (in pixels).
         * @param {?} offset
         * @param {?=} to
         * @return {?}
         */

      }, {
        key: "setRenderedContentOffset",
        value: function setRenderedContentOffset(offset) {
          var _this143 = this;

          var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'to-start';
          // For a horizontal viewport in a right-to-left language we need to translate along the x-axis
          // in the negative direction.

          /** @type {?} */
          var isRtl = this.dir && this.dir.value == 'rtl';
          /** @type {?} */

          var isHorizontal = this.orientation == 'horizontal';
          /** @type {?} */

          var axis = isHorizontal ? 'X' : 'Y';
          /** @type {?} */

          var axisDirection = isHorizontal && isRtl ? -1 : 1;
          /** @type {?} */

          var transform = "translate".concat(axis, "(").concat(Number(axisDirection * offset), "px)");
          this._renderedContentOffset = offset;

          if (to === 'to-end') {
            transform += " translate".concat(axis, "(-100%)"); // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise
            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would
            // expand upward).

            this._renderedContentOffsetNeedsRewrite = true;
          }

          if (this._renderedContentTransform != transform) {
            // We know this value is safe because we parse `offset` with `Number()` before passing it
            // into the string.
            this._renderedContentTransform = transform;

            this._markChangeDetectionNeeded(
            /**
            * @return {?}
            */
            function () {
              if (_this143._renderedContentOffsetNeedsRewrite) {
                _this143._renderedContentOffset -= _this143.measureRenderedContentSize();
                _this143._renderedContentOffsetNeedsRewrite = false;

                _this143.setRenderedContentOffset(_this143._renderedContentOffset);
              } else {
                _this143._scrollStrategy.onRenderedOffsetChanged();
              }
            });
          }
        }
        /**
         * Scrolls to the given offset from the start of the viewport. Please note that this is not always
         * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
         * direction, this would be the equivalent of setting a fictional `scrollRight` property.
         * @param {?} offset The offset to scroll to.
         * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
         * @return {?}
         */

      }, {
        key: "scrollToOffset",
        value: function scrollToOffset(offset) {
          var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';

          /** @type {?} */
          var options = {
            behavior: behavior
          };

          if (this.orientation === 'horizontal') {
            options.start = offset;
          } else {
            options.top = offset;
          }

          this.scrollTo(options);
        }
        /**
         * Scrolls to the offset for the given index.
         * @param {?} index The index of the element to scroll to.
         * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
         * @return {?}
         */

      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index) {
          var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';

          this._scrollStrategy.scrollToIndex(index, behavior);
        }
        /**
         * Gets the current scroll offset from the start of the viewport (in pixels).
         * @param {?=} from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
         *     in horizontal mode.
         * @return {?}
         */

      }, {
        key: "measureScrollOffset",
        value: function measureScrollOffset(from) {
          return _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), "measureScrollOffset", this).call(this, from ? from : this.orientation === 'horizontal' ? 'start' : 'top');
        }
        /**
         * Measure the combined size of all of the rendered items.
         * @return {?}
         */

      }, {
        key: "measureRenderedContentSize",
        value: function measureRenderedContentSize() {
          /** @type {?} */
          var contentEl = this._contentWrapper.nativeElement;
          return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;
        }
        /**
         * Measure the total combined size of the given range. Throws if the range includes items that are
         * not rendered.
         * @param {?} range
         * @return {?}
         */

      }, {
        key: "measureRangeSize",
        value: function measureRangeSize(range) {
          if (!this._forOf) {
            return 0;
          }

          return this._forOf.measureRangeSize(range, this.orientation);
        }
        /**
         * Update the viewport dimensions and re-render.
         * @return {?}
         */

      }, {
        key: "checkViewportSize",
        value: function checkViewportSize() {
          // TODO: Cleanup later when add logic for handling content resize
          this._measureViewportSize();

          this._scrollStrategy.onDataLengthChanged();
        }
        /**
         * Measure the viewport size.
         * @private
         * @return {?}
         */

      }, {
        key: "_measureViewportSize",
        value: function _measureViewportSize() {
          /** @type {?} */
          var viewportEl = this.elementRef.nativeElement;
          this._viewportSize = this.orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;
        }
        /**
         * Queue up change detection to run.
         * @private
         * @param {?=} runAfter
         * @return {?}
         */

      }, {
        key: "_markChangeDetectionNeeded",
        value: function _markChangeDetectionNeeded(runAfter) {
          var _this144 = this;

          if (runAfter) {
            this._runAfterChangeDetection.push(runAfter);
          } // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of
          // properties sequentially we only have to run `_doChangeDetection` once at the end.


          if (!this._isChangeDetectionPending) {
            this._isChangeDetectionPending = true;
            this.ngZone.runOutsideAngular(
            /**
            * @return {?}
            */
            function () {
              return Promise.resolve().then(
              /**
              * @return {?}
              */
              function () {
                _this144._doChangeDetection();
              });
            });
          }
        }
        /**
         * Run change detection.
         * @private
         * @return {?}
         */

      }, {
        key: "_doChangeDetection",
        value: function _doChangeDetection() {
          var _this145 = this;

          this._isChangeDetectionPending = false; // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection
          // from the root, since the repeated items are content projected in. Calling `detectChanges`
          // instead does not properly check the projected content.

          this.ngZone.run(
          /**
          * @return {?}
          */
          function () {
            return _this145._changeDetectorRef.markForCheck();
          }); // Apply the content transform. The transform can't be set via an Angular binding because
          // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of
          // string literals, a variable that can only be 'X' or 'Y', and user input that is run through
          // the `Number` function first to coerce it to a numeric value.

          this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
          /** @type {?} */

          var runAfterChangeDetection = this._runAfterChangeDetection;
          this._runAfterChangeDetection = [];
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = runAfterChangeDetection[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var fn = _step4.value;
              fn();
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
        /**
         * Calculates the `style.width` and `style.height` for the spacer element.
         * @private
         * @return {?}
         */

      }, {
        key: "_calculateSpacerSize",
        value: function _calculateSpacerSize() {
          this._totalContentHeight = this.orientation === 'horizontal' ? '' : "".concat(this._totalContentSize, "px");
          this._totalContentWidth = this.orientation === 'horizontal' ? "".concat(this._totalContentSize, "px") : '';
        }
      }, {
        key: "orientation",
        get: function get() {
          return this._orientation;
        }
        /**
         * @param {?} orientation
         * @return {?}
         */
        ,
        set: function set(orientation) {
          if (this._orientation !== orientation) {
            this._orientation = orientation;

            this._calculateSpacerSize();
          }
        }
      }]);

      return CdkVirtualScrollViewport;
    }(CdkScrollable);

    CdkVirtualScrollViewport.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
      args: [{
        selector: 'cdk-virtual-scroll-viewport',
        template: "<div #contentWrapper class=\"cdk-virtual-scroll-content-wrapper\"><ng-content></ng-content></div><div class=\"cdk-virtual-scroll-spacer\" [style.width]=\"_totalContentWidth\" [style.height]=\"_totalContentHeight\"></div>",
        styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:0}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:0}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}"],
        host: {
          'class': 'cdk-virtual-scroll-viewport',
          '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === "horizontal"',
          '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== "horizontal"'
        },
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: CdkScrollable,
          useExisting: CdkVirtualScrollViewport
        }]
      }]
    }];
    /** @nocollapse */

    CdkVirtualScrollViewport.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
          args: [VIRTUAL_SCROLL_STRATEGY]
        }]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"]
        }]
      }, {
        type: ScrollDispatcher
      }];
    };

    CdkVirtualScrollViewport.propDecorators = {
      orientation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      scrolledIndexChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
      }],
      _contentWrapper: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
        args: ['contentWrapper', {
          static: true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Helper to extract size from a DOM Node.
     * @param {?} orientation
     * @param {?} node
     * @return {?}
     */

    function getSize(orientation, node) {
      /** @type {?} */
      var el =
      /** @type {?} */
      node;

      if (!el.getBoundingClientRect) {
        return 0;
      }
      /** @type {?} */


      var rect = el.getBoundingClientRect();
      return orientation == 'horizontal' ? rect.width : rect.height;
    }
    /**
     * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling
     * container.
     * @template T
     */


    var CdkVirtualForOf =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewContainerRef
       * @param {?} _template
       * @param {?} _differs
       * @param {?} _viewport
       * @param {?} ngZone
       */
      function CdkVirtualForOf(_viewContainerRef, _template, _differs, _viewport, ngZone) {
        var _this146 = this;

        _classCallCheck(this, CdkVirtualForOf);

        this._viewContainerRef = _viewContainerRef;
        this._template = _template;
        this._differs = _differs;
        this._viewport = _viewport;
        /**
         * Emits when the rendered view of the data changes.
         */

        this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * Subject that emits when a new DataSource instance is given.
         */

        this._dataSourceChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        /**
         * The size of the cache used to store templates that are not being used for re-use later.
         * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
         */

        this.cdkVirtualForTemplateCacheSize = 20;
        /**
         * Emits whenever the data in the current DataSource changes.
         */

        this.dataStream = this._dataSourceChanges.pipe( // Start off with null `DataSource`.
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])(
        /** @type {?} */
        null), // Bundle up the previous and current data sources so we can work with both.
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["pairwise"])(), // Use `_changeDataSource` to disconnect from the previous data source and connect to the
        // new one, passing back a stream of data changes which we run through `switchMap` to give
        // us a data stream that emits the latest data from whatever the current `DataSource` is.
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["switchMap"])(
        /**
        * @param {?} __0
        * @return {?}
        */
        function (_ref25) {
          var _ref26 = _slicedToArray(_ref25, 2),
              prev = _ref26[0],
              cur = _ref26[1];

          return _this146._changeDataSource(prev, cur);
        }), // Replay the last emitted data when someone subscribes.
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["shareReplay"])(1));
        /**
         * The differ used to calculate changes to the data.
         */

        this._differ = null;
        /**
         * The template cache used to hold on ot template instancess that have been stamped out, but don't
         * currently need to be rendered. These instances will be reused in the future rather than
         * stamping out brand new ones.
         */

        this._templateCache = [];
        /**
         * Whether the rendered data should be updated during the next ngDoCheck cycle.
         */

        this._needsUpdate = false;
        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
        this.dataStream.subscribe(
        /**
        * @param {?} data
        * @return {?}
        */
        function (data) {
          _this146._data = data;

          _this146._onRenderedDataChange();
        });

        this._viewport.renderedRangeStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(
        /**
        * @param {?} range
        * @return {?}
        */
        function (range) {
          _this146._renderedRange = range;
          ngZone.run(
          /**
          * @return {?}
          */
          function () {
            return _this146.viewChange.next(_this146._renderedRange);
          });

          _this146._onRenderedDataChange();
        });

        this._viewport.attach(this);
      }
      /**
       * The DataSource to display.
       * @return {?}
       */


      _createClass(CdkVirtualForOf, [{
        key: "measureRangeSize",

        /**
         * Measures the combined size (width for horizontal orientation, height for vertical) of all items
         * in the specified range. Throws an error if the range includes items that are not currently
         * rendered.
         * @param {?} range
         * @param {?} orientation
         * @return {?}
         */
        value: function measureRangeSize(range, orientation) {
          if (range.start >= range.end) {
            return 0;
          }

          if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {
            throw Error("Error: attempted to measure an item that isn't rendered.");
          } // The index into the list of rendered views for the first item in the range.

          /** @type {?} */


          var renderedStartIndex = range.start - this._renderedRange.start; // The length of the range we're measuring.

          /** @type {?} */

          var rangeLen = range.end - range.start; // Loop over all root nodes for all items in the range and sum up their size.

          /** @type {?} */

          var totalSize = 0;
          /** @type {?} */

          var i = rangeLen;

          while (i--) {
            /** @type {?} */
            var view =
            /** @type {?} */
            this._viewContainerRef.get(i + renderedStartIndex);
            /** @type {?} */


            var j = view ? view.rootNodes.length : 0;

            while (j--) {
              totalSize += getSize(orientation,
              /** @type {?} */
              view.rootNodes[j]);
            }
          }

          return totalSize;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this._differ && this._needsUpdate) {
            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of
            // this list being rendered (can use simpler algorithm) vs needs update due to data actually
            // changing (need to do this diff).

            /** @type {?} */
            var changes = this._differ.diff(this._renderedItems);

            if (!changes) {
              this._updateContext();
            } else {
              this._applyChanges(changes);
            }

            this._needsUpdate = false;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._viewport.detach();

          this._dataSourceChanges.next();

          this._dataSourceChanges.complete();

          this.viewChange.complete();

          this._destroyed.next();

          this._destroyed.complete();

          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this._templateCache[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var view = _step5.value;
              view.destroy();
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
        /**
         * React to scroll state changes in the viewport.
         * @private
         * @return {?}
         */

      }, {
        key: "_onRenderedDataChange",
        value: function _onRenderedDataChange() {
          if (!this._renderedRange) {
            return;
          }

          this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);

          if (!this._differ) {
            this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);
          }

          this._needsUpdate = true;
        }
        /**
         * Swap out one `DataSource` for another.
         * @private
         * @param {?} oldDs
         * @param {?} newDs
         * @return {?}
         */

      }, {
        key: "_changeDataSource",
        value: function _changeDataSource(oldDs, newDs) {
          if (oldDs) {
            oldDs.disconnect(this);
          }

          this._needsUpdate = true;
          return newDs ? newDs.connect(this) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])();
        }
        /**
         * Update the `CdkVirtualForOfContext` for all views.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateContext",
        value: function _updateContext() {
          /** @type {?} */
          var count = this._data.length;
          /** @type {?} */

          var i = this._viewContainerRef.length;

          while (i--) {
            /** @type {?} */
            var view =
            /** @type {?} */
            this._viewContainerRef.get(i);

            view.context.index = this._renderedRange.start + i;
            view.context.count = count;

            this._updateComputedContextProperties(view.context);

            view.detectChanges();
          }
        }
        /**
         * Apply changes to the DOM.
         * @private
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "_applyChanges",
        value: function _applyChanges(changes) {
          var _this147 = this;

          // Rearrange the views to put them in the right location.
          changes.forEachOperation(
          /**
          * @param {?} record
          * @param {?} adjustedPreviousIndex
          * @param {?} currentIndex
          * @return {?}
          */
          function (record, adjustedPreviousIndex, currentIndex) {
            if (record.previousIndex == null) {
              // Item added.
              // Item added.

              /** @type {?} */
              var view = _this147._insertViewForNewItem(
              /** @type {?} */
              currentIndex);

              view.context.$implicit = record.item;
            } else if (currentIndex == null) {
              // Item removed.
              _this147._cacheView(_this147._detachView(
              /** @type {?} */
              adjustedPreviousIndex));
            } else {
              // Item moved.
              // Item moved.

              /** @type {?} */
              var _view =
              /** @type {?} */
              _this147._viewContainerRef.get(
              /** @type {?} */
              adjustedPreviousIndex);

              _this147._viewContainerRef.move(_view, currentIndex);

              _view.context.$implicit = record.item;
            }
          }); // Update $implicit for any items that had an identity change.

          changes.forEachIdentityChange(
          /**
          * @param {?} record
          * @return {?}
          */
          function (record) {
            /** @type {?} */
            var view =
            /** @type {?} */
            _this147._viewContainerRef.get(
            /** @type {?} */
            record.currentIndex);

            view.context.$implicit = record.item;
          }); // Update the context variables on all items.

          /** @type {?} */

          var count = this._data.length;
          /** @type {?} */

          var i = this._viewContainerRef.length;

          while (i--) {
            /** @type {?} */
            var view =
            /** @type {?} */
            this._viewContainerRef.get(i);

            view.context.index = this._renderedRange.start + i;
            view.context.count = count;

            this._updateComputedContextProperties(view.context);
          }
        }
        /**
         * Cache the given detached view.
         * @private
         * @param {?} view
         * @return {?}
         */

      }, {
        key: "_cacheView",
        value: function _cacheView(view) {
          if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {
            this._templateCache.push(view);
          } else {
            /** @type {?} */
            var index = this._viewContainerRef.indexOf(view); // It's very unlikely that the index will ever be -1, but just in case,
            // destroy the view on its own, otherwise destroy it through the
            // container to ensure that all the references are removed.


            if (index === -1) {
              view.destroy();
            } else {
              this._viewContainerRef.remove(index);
            }
          }
        }
        /**
         * Inserts a view for a new item, either from the cache or by creating a new one.
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_insertViewForNewItem",
        value: function _insertViewForNewItem(index) {
          return this._insertViewFromCache(index) || this._createEmbeddedViewAt(index);
        }
        /**
         * Update the computed properties on the `CdkVirtualForOfContext`.
         * @private
         * @param {?} context
         * @return {?}
         */

      }, {
        key: "_updateComputedContextProperties",
        value: function _updateComputedContextProperties(context) {
          context.first = context.index === 0;
          context.last = context.index === context.count - 1;
          context.even = context.index % 2 === 0;
          context.odd = !context.even;
        }
        /**
         * Creates a new embedded view and moves it to the given index
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_createEmbeddedViewAt",
        value: function _createEmbeddedViewAt(index) {
          // Note that it's important that we insert the item directly at the proper index,
          // rather than inserting it and the moving it in place, because if there's a directive
          // on the same node that injects the `ViewContainerRef`, Angular will insert another
          // comment node which can throw off the move when it's being repeated for all items.
          return this._viewContainerRef.createEmbeddedView(this._template, {
            $implicit:
            /** @type {?} */
            null,
            cdkVirtualForOf: this._cdkVirtualForOf,
            index: -1,
            count: -1,
            first: false,
            last: false,
            odd: false,
            even: false
          }, index);
        }
        /**
         * Inserts a recycled view from the cache at the given index.
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_insertViewFromCache",
        value: function _insertViewFromCache(index) {
          /** @type {?} */
          var cachedView = this._templateCache.pop();

          if (cachedView) {
            this._viewContainerRef.insert(cachedView, index);
          }

          return cachedView || null;
        }
        /**
         * Detaches the embedded view at the given index.
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "_detachView",
        value: function _detachView(index) {
          return (
            /** @type {?} */
            this._viewContainerRef.detach(index)
          );
        }
      }, {
        key: "cdkVirtualForOf",
        get: function get() {
          return this._cdkVirtualForOf;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._cdkVirtualForOf = value;
          /** @type {?} */

          var ds = Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_6__["isDataSource"])(value) ? value : // Slice the value if its an NgIterable to ensure we're working with an array.
          new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_6__["ArrayDataSource"](value instanceof rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"] ? value : Array.prototype.slice.call(value || []));

          this._dataSourceChanges.next(ds);
        }
        /**
         * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
         * the item and produces a value to be used as the item's identity when tracking changes.
         * @return {?}
         */

      }, {
        key: "cdkVirtualForTrackBy",
        get: function get() {
          return this._cdkVirtualForTrackBy;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          var _this148 = this;

          this._needsUpdate = true;
          this._cdkVirtualForTrackBy = fn ?
          /**
          * @param {?} index
          * @param {?} item
          * @return {?}
          */
          function (index, item) {
            return fn(index + (_this148._renderedRange ? _this148._renderedRange.start : 0), item);
          } : undefined;
        }
        /**
         * The template used to stamp out new elements.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "cdkVirtualForTemplate",
        set: function set(value) {
          if (value) {
            this._needsUpdate = true;
            this._template = value;
          }
        }
      }]);

      return CdkVirtualForOf;
    }();

    CdkVirtualForOf.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
      args: [{
        selector: '[cdkVirtualFor][cdkVirtualForOf]'
      }]
    }];
    /** @nocollapse */

    CdkVirtualForOf.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"]
      }, {
        type: CdkVirtualScrollViewport,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }];
    };

    CdkVirtualForOf.propDecorators = {
      cdkVirtualForOf: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      cdkVirtualForTrackBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      cdkVirtualForTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }],
      cdkVirtualForTemplateCacheSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var ScrollingModule = function ScrollingModule() {
      _classCallCheck(this, ScrollingModule);
    };

    ScrollingModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
      args: [{
        imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["PlatformModule"]],
        exports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], CdkFixedSizeVirtualScroll, CdkScrollable, CdkVirtualForOf, CdkVirtualScrollViewport],
        declarations: [CdkFixedSizeVirtualScroll, CdkScrollable, CdkVirtualForOf, CdkVirtualScrollViewport]
      }]
    }];
    /**
     * @deprecated ScrollDispatchModule has been renamed to ScrollingModule.
     * \@breaking-change 8.0.0 delete this alias
     */

    var ScrollDispatchModule = function ScrollDispatchModule() {
      _classCallCheck(this, ScrollDispatchModule);
    };

    ScrollDispatchModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
      args: [{
        imports: [ScrollingModule],
        exports: [ScrollingModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Time in ms to throttle the resize events by default.
     * @type {?}
     */

    var DEFAULT_RESIZE_TIME = 20;
    /**
     * Simple utility for getting the bounds of the browser viewport.
     * \@docs-private
     */

    var ViewportRuler =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _platform
       * @param {?} ngZone
       */
      function ViewportRuler(_platform, ngZone) {
        var _this149 = this;

        _classCallCheck(this, ViewportRuler);

        this._platform = _platform;
        ngZone.runOutsideAngular(
        /**
        * @return {?}
        */
        function () {
          _this149._change = _platform.isBrowser ? Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["merge"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(window, 'resize'), Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(window, 'orientationchange')) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(); // Note that we need to do the subscription inside `runOutsideAngular`
          // since subscribing is what causes the event listener to be added.

          _this149._invalidateCache = _this149.change().subscribe(
          /**
          * @return {?}
          */
          function () {
            return _this149._updateViewportSize();
          });
        });
      }
      /**
       * @return {?}
       */


      _createClass(ViewportRuler, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._invalidateCache.unsubscribe();
        }
        /**
         * Returns the viewport's width and height.
         * @return {?}
         */

      }, {
        key: "getViewportSize",
        value: function getViewportSize() {
          if (!this._viewportSize) {
            this._updateViewportSize();
          }
          /** @type {?} */


          var output = {
            width: this._viewportSize.width,
            height: this._viewportSize.height
          }; // If we're not on a browser, don't cache the size since it'll be mocked out anyway.

          if (!this._platform.isBrowser) {
            this._viewportSize =
            /** @type {?} */
            null;
          }

          return output;
        }
        /**
         * Gets a ClientRect for the viewport's bounds.
         * @return {?}
         */

      }, {
        key: "getViewportRect",
        value: function getViewportRect() {
          // Use the document element's bounding rect rather than the window scroll properties
          // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
          // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
          // conceptual viewports. Under most circumstances these viewports are equivalent, but they
          // can disagree when the page is pinch-zoomed (on devices that support touch).
          // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
          // We use the documentElement instead of the body because, by default (without a css reset)
          // browsers typically give the document body an 8px margin, which is not included in
          // getBoundingClientRect().

          /** @type {?} */
          var scrollPosition = this.getViewportScrollPosition();

          var _this$getViewportSize = this.getViewportSize(),
              width = _this$getViewportSize.width,
              height = _this$getViewportSize.height;

          return {
            top: scrollPosition.top,
            left: scrollPosition.left,
            bottom: scrollPosition.top + height,
            right: scrollPosition.left + width,
            height: height,
            width: width
          };
        }
        /**
         * Gets the (top, left) scroll position of the viewport.
         * @return {?}
         */

      }, {
        key: "getViewportScrollPosition",
        value: function getViewportScrollPosition() {
          // While we can get a reference to the fake document
          // during SSR, it doesn't have getBoundingClientRect.
          if (!this._platform.isBrowser) {
            return {
              top: 0,
              left: 0
            };
          } // The top-left-corner of the viewport is determined by the scroll position of the document
          // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
          // whether `document.body` or `document.documentElement` is the scrolled element, so reading
          // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
          // `document.documentElement` works consistently, where the `top` and `left` values will
          // equal negative the scroll position.

          /** @type {?} */


          var documentElement =
          /** @type {?} */
          document.documentElement;
          /** @type {?} */

          var documentRect = documentElement.getBoundingClientRect();
          /** @type {?} */

          var top = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
          /** @type {?} */

          var left = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
          return {
            top: top,
            left: left
          };
        }
        /**
         * Returns a stream that emits whenever the size of the viewport changes.
         * @param {?=} throttleTime Time in milliseconds to throttle the stream.
         * @return {?}
         */

      }, {
        key: "change",
        value: function change() {
          var throttleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_RESIZE_TIME;
          return throttleTime > 0 ? this._change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["auditTime"])(throttleTime)) : this._change;
        }
        /**
         * Updates the cached viewport size.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateViewportSize",
        value: function _updateViewportSize() {
          this._viewportSize = this._platform.isBrowser ? {
            width: window.innerWidth,
            height: window.innerHeight
          } : {
            width: 0,
            height: 0
          };
        }
      }]);

      return ViewportRuler;
    }();

    ViewportRuler.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    ViewportRuler.ctorParameters = function () {
      return [{
        type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]
      }];
    };
    /** @nocollapse */


    ViewportRuler.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      factory: function ViewportRuler_Factory() {
        return new ViewportRuler(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]));
      },
      token: ViewportRuler,
      providedIn: "root"
    });
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @param {?} parentRuler
     * @param {?} platform
     * @param {?} ngZone
     * @return {?}
     */

    function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {
      return parentRuler || new ViewportRuler(platform, ngZone);
    }
    /**
     * \@docs-private \@deprecated \@breaking-change 8.0.0
     * @type {?}
     */


    var VIEWPORT_RULER_PROVIDER = {
      // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
      provide: ViewportRuler,
      deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), ViewportRuler], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]],
      useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/@angular/cdk/esm2015/table.js":
  /*!****************************************************!*\
    !*** ./node_modules/@angular/cdk/esm2015/table.js ***!
    \****************************************************/

  /*! exports provided: DataSource, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CDK_TABLE_TEMPLATE, CdkTable, CdkCellDef, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, BaseCdkCell, CdkHeaderCell, CdkFooterCell, CdkCell, CDK_ROW_TEMPLATE, BaseRowDef, CdkHeaderRowDef, CdkFooterRowDef, CdkRowDef, CdkCellOutlet, CdkHeaderRow, CdkFooterRow, CdkRow, CdkTableModule, STICKY_DIRECTIONS, StickyStyler, mixinHasStickyInput, TEXT_COLUMN_OPTIONS, CdkTextColumn */

  /***/
  function node_modulesAngularCdkEsm2015TableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DataRowOutlet", function () {
      return DataRowOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HeaderRowOutlet", function () {
      return HeaderRowOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FooterRowOutlet", function () {
      return FooterRowOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CDK_TABLE_TEMPLATE", function () {
      return CDK_TABLE_TEMPLATE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkTable", function () {
      return CdkTable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkCellDef", function () {
      return CdkCellDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkHeaderCellDef", function () {
      return CdkHeaderCellDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkFooterCellDef", function () {
      return CdkFooterCellDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkColumnDef", function () {
      return CdkColumnDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BaseCdkCell", function () {
      return BaseCdkCell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkHeaderCell", function () {
      return CdkHeaderCell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkFooterCell", function () {
      return CdkFooterCell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkCell", function () {
      return CdkCell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CDK_ROW_TEMPLATE", function () {
      return CDK_ROW_TEMPLATE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BaseRowDef", function () {
      return BaseRowDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkHeaderRowDef", function () {
      return CdkHeaderRowDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkFooterRowDef", function () {
      return CdkFooterRowDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkRowDef", function () {
      return CdkRowDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkCellOutlet", function () {
      return CdkCellOutlet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkHeaderRow", function () {
      return CdkHeaderRow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkFooterRow", function () {
      return CdkFooterRow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkRow", function () {
      return CdkRow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkTableModule", function () {
      return CdkTableModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "STICKY_DIRECTIONS", function () {
      return STICKY_DIRECTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "StickyStyler", function () {
      return StickyStyler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mixinHasStickyInput", function () {
      return mixinHasStickyInput;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TEXT_COLUMN_OPTIONS", function () {
      return TEXT_COLUMN_OPTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CdkTextColumn", function () {
      return CdkTextColumn;
    });
    /* harmony import */


    var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/cdk/coercion */
    "./node_modules/@angular/cdk/esm2015/coercion.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/cdk/bidi */
    "./node_modules/@angular/cdk/esm2015/bidi.js");
    /* harmony import */


    var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/cdk/collections */
    "./node_modules/@angular/cdk/esm2015/collections.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "DataSource", function () {
      return _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["DataSource"];
    });
    /* harmony import */


    var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/cdk/platform */
    "./node_modules/@angular/cdk/esm2015/platform.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Mixin to provide a directive with a function that checks if the sticky input has been
     * changed since the last time the function was called. Essentially adds a dirty-check to the
     * sticky value.
     * \@docs-private
     * @template T
     * @param {?} base
     * @return {?}
     */


    function mixinHasStickyInput(base) {
      return (
        /*#__PURE__*/
        function (_base) {
          _inherits(_class, _base);

          /**
           * @param {...?} args
           */
          function _class() {
            var _getPrototypeOf2;

            var _this150;

            _classCallCheck(this, _class);

            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            _this150 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(_class)).call.apply(_getPrototypeOf2, [this].concat(args)));
            _this150._sticky = false;
            /**
             * Whether the sticky input has changed since it was last checked.
             */

            _this150._hasStickyChanged = false;
            return _this150;
          }
          /**
           * Whether sticky positioning should be applied.
           * @return {?}
           */


          _createClass(_class, [{
            key: "hasStickyChanged",

            /**
             * Whether the sticky value has changed since this was last called.
             * @return {?}
             */
            value: function hasStickyChanged() {
              /** @type {?} */
              var hasStickyChanged = this._hasStickyChanged;
              this._hasStickyChanged = false;
              return hasStickyChanged;
            }
            /**
             * Resets the dirty check for cases where the sticky state has been used without checking.
             * @return {?}
             */

          }, {
            key: "resetStickyChanged",
            value: function resetStickyChanged() {
              this._hasStickyChanged = false;
            }
          }, {
            key: "sticky",
            get: function get() {
              return this._sticky;
            }
            /**
             * @param {?} v
             * @return {?}
             */
            ,
            set: function set(v) {
              /** @type {?} */
              var prevValue = this._sticky;
              this._sticky = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
              this._hasStickyChanged = prevValue !== this._sticky;
            }
          }]);

          return _class;
        }(base)
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Cell definition for a CDK table.
     * Captures the template of a column's data row cell as well as cell-specific properties.
     */


    var CdkCellDef =
    /**
     * @param {?} template
     */
    function CdkCellDef(
    /** @docs-private */
    template) {
      _classCallCheck(this, CdkCellDef);

      this.template = template;
    };

    CdkCellDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkCellDef]'
      }]
    }];
    /** @nocollapse */

    CdkCellDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * Header cell definition for a CDK table.
     * Captures the template of a column's header cell and as well as cell-specific properties.
     */


    var CdkHeaderCellDef =
    /**
     * @param {?} template
     */
    function CdkHeaderCellDef(
    /** @docs-private */
    template) {
      _classCallCheck(this, CdkHeaderCellDef);

      this.template = template;
    };

    CdkHeaderCellDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkHeaderCellDef]'
      }]
    }];
    /** @nocollapse */

    CdkHeaderCellDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * Footer cell definition for a CDK table.
     * Captures the template of a column's footer cell and as well as cell-specific properties.
     */


    var CdkFooterCellDef =
    /**
     * @param {?} template
     */
    function CdkFooterCellDef(
    /** @docs-private */
    template) {
      _classCallCheck(this, CdkFooterCellDef);

      this.template = template;
    };

    CdkFooterCellDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkFooterCellDef]'
      }]
    }];
    /** @nocollapse */

    CdkFooterCellDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    }; // Boilerplate for applying mixins to CdkColumnDef.

    /**
     * \@docs-private
     */


    var CdkColumnDefBase = function CdkColumnDefBase() {
      _classCallCheck(this, CdkColumnDefBase);
    };
    /** @type {?} */


    var _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
    /**
     * Column definition for the CDK table.
     * Defines a set of cells available for a table column.
     */


    var CdkColumnDef =
    /*#__PURE__*/
    function (_CdkColumnDefBase2) {
      _inherits(CdkColumnDef, _CdkColumnDefBase2);

      function CdkColumnDef() {
        var _this151;

        _classCallCheck(this, CdkColumnDef);

        _this151 = _possibleConstructorReturn(this, _getPrototypeOf(CdkColumnDef).apply(this, arguments));
        _this151._stickyEnd = false;
        return _this151;
      }
      /**
       * Unique name for this column.
       * @return {?}
       */


      _createClass(CdkColumnDef, [{
        key: "name",
        get: function get() {
          return this._name;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        ,
        set: function set(name) {
          // If the directive is set without a name (updated programatically), then this setter will
          // trigger with an empty string and should not overwrite the programatically set value.
          if (!name) {
            return;
          }

          this._name = name;
          this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
        }
        /**
         * Whether this column should be sticky positioned on the end of the row. Should make sure
         * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
         * has been changed.
         * @return {?}
         */

      }, {
        key: "stickyEnd",
        get: function get() {
          return this._stickyEnd;
        }
        /**
         * @param {?} v
         * @return {?}
         */
        ,
        set: function set(v) {
          /** @type {?} */
          var prevValue = this._stickyEnd;
          this._stickyEnd = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
          this._hasStickyChanged = prevValue !== this._stickyEnd;
        }
      }]);

      return CdkColumnDef;
    }(_CdkColumnDefBase);

    CdkColumnDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkColumnDef]',
        inputs: ['sticky'],
        providers: [{
          provide: 'MAT_SORT_HEADER_COLUMN_DEF',
          useExisting: CdkColumnDef
        }]
      }]
    }];
    CdkColumnDef.propDecorators = {
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['cdkColumnDef']
      }],
      stickyEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['stickyEnd']
      }],
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [CdkCellDef, {
          static: false
        }]
      }],
      headerCell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [CdkHeaderCellDef, {
          static: false
        }]
      }],
      footerCell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [CdkFooterCellDef, {
          static: false
        }]
      }]
    };
    /**
     * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
     */

    var BaseCdkCell =
    /**
     * @param {?} columnDef
     * @param {?} elementRef
     */
    function BaseCdkCell(columnDef, elementRef) {
      _classCallCheck(this, BaseCdkCell);

      /** @type {?} */
      var columnClassName = "cdk-column-".concat(columnDef.cssClassFriendlyName);
      elementRef.nativeElement.classList.add(columnClassName);
    };
    /**
     * Header cell template container that adds the right classes and role.
     */


    var CdkHeaderCell =
    /*#__PURE__*/
    function (_BaseCdkCell) {
      _inherits(CdkHeaderCell, _BaseCdkCell);

      /**
       * @param {?} columnDef
       * @param {?} elementRef
       */
      function CdkHeaderCell(columnDef, elementRef) {
        _classCallCheck(this, CdkHeaderCell);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkHeaderCell).call(this, columnDef, elementRef));
      }

      return CdkHeaderCell;
    }(BaseCdkCell);

    CdkHeaderCell.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'cdk-header-cell, th[cdk-header-cell]',
        host: {
          'class': 'cdk-header-cell',
          'role': 'columnheader'
        }
      }]
    }];
    /** @nocollapse */

    CdkHeaderCell.ctorParameters = function () {
      return [{
        type: CdkColumnDef
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * Footer cell template container that adds the right classes and role.
     */


    var CdkFooterCell =
    /*#__PURE__*/
    function (_BaseCdkCell2) {
      _inherits(CdkFooterCell, _BaseCdkCell2);

      /**
       * @param {?} columnDef
       * @param {?} elementRef
       */
      function CdkFooterCell(columnDef, elementRef) {
        _classCallCheck(this, CdkFooterCell);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkFooterCell).call(this, columnDef, elementRef));
      }

      return CdkFooterCell;
    }(BaseCdkCell);

    CdkFooterCell.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'cdk-footer-cell, td[cdk-footer-cell]',
        host: {
          'class': 'cdk-footer-cell',
          'role': 'gridcell'
        }
      }]
    }];
    /** @nocollapse */

    CdkFooterCell.ctorParameters = function () {
      return [{
        type: CdkColumnDef
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * Cell template container that adds the right classes and role.
     */


    var CdkCell =
    /*#__PURE__*/
    function (_BaseCdkCell3) {
      _inherits(CdkCell, _BaseCdkCell3);

      /**
       * @param {?} columnDef
       * @param {?} elementRef
       */
      function CdkCell(columnDef, elementRef) {
        _classCallCheck(this, CdkCell);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkCell).call(this, columnDef, elementRef));
      }

      return CdkCell;
    }(BaseCdkCell);

    CdkCell.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'cdk-cell, td[cdk-cell]',
        host: {
          'class': 'cdk-cell',
          'role': 'gridcell'
        }
      }]
    }];
    /** @nocollapse */

    CdkCell.ctorParameters = function () {
      return [{
        type: CdkColumnDef
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The row template that can be used by the mat-table. Should not be used outside of the
     * material library.
     * @type {?}
     */


    var CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
    /**
     * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
     * for changes and notifying the table.
     * @abstract
     */

    var BaseRowDef =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} template
       * @param {?} _differs
       */
      function BaseRowDef(template, _differs) {
        _classCallCheck(this, BaseRowDef);

        this.template = template;
        this._differs = _differs;
      }
      /**
       * @param {?} changes
       * @return {?}
       */


      _createClass(BaseRowDef, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          // Create a new columns differ if one does not yet exist. Initialize it based on initial value
          // of the columns property or an empty array if none is provided.
          if (!this._columnsDiffer) {
            /** @type {?} */
            var columns = changes['columns'] && changes['columns'].currentValue || [];
            this._columnsDiffer = this._differs.find(columns).create();

            this._columnsDiffer.diff(columns);
          }
        }
        /**
         * Returns the difference between the current columns and the columns from the last diff, or null
         * if there is no difference.
         * @return {?}
         */

      }, {
        key: "getColumnsDiff",
        value: function getColumnsDiff() {
          return this._columnsDiffer.diff(this.columns);
        }
        /**
         * Gets this row def's relevant cell template from the provided column def.
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "extractCellTemplate",
        value: function extractCellTemplate(column) {
          if (this instanceof CdkHeaderRowDef) {
            return column.headerCell.template;
          }

          if (this instanceof CdkFooterRowDef) {
            return column.footerCell.template;
          } else {
            return column.cell.template;
          }
        }
      }]);

      return BaseRowDef;
    }(); // Boilerplate for applying mixins to CdkHeaderRowDef.

    /**
     * \@docs-private
     */


    var CdkHeaderRowDefBase =
    /*#__PURE__*/
    function (_BaseRowDef) {
      _inherits(CdkHeaderRowDefBase, _BaseRowDef);

      function CdkHeaderRowDefBase() {
        _classCallCheck(this, CdkHeaderRowDefBase);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkHeaderRowDefBase).apply(this, arguments));
      }

      return CdkHeaderRowDefBase;
    }(BaseRowDef);
    /** @type {?} */


    var _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);
    /**
     * Header row definition for the CDK table.
     * Captures the header row's template and other header properties such as the columns to display.
     */


    var CdkHeaderRowDef =
    /*#__PURE__*/
    function (_CdkHeaderRowDefBase2) {
      _inherits(CdkHeaderRowDef, _CdkHeaderRowDefBase2);

      /**
       * @param {?} template
       * @param {?} _differs
       */
      function CdkHeaderRowDef(template, _differs) {
        _classCallCheck(this, CdkHeaderRowDef);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkHeaderRowDef).call(this, template, _differs));
      } // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.

      /**
       * @param {?} changes
       * @return {?}
       */


      _createClass(CdkHeaderRowDef, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          _get(_getPrototypeOf(CdkHeaderRowDef.prototype), "ngOnChanges", this).call(this, changes);
        }
      }]);

      return CdkHeaderRowDef;
    }(_CdkHeaderRowDefBase);

    CdkHeaderRowDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkHeaderRowDef]',
        inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky']
      }]
    }];
    /** @nocollapse */

    CdkHeaderRowDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }];
    }; // Boilerplate for applying mixins to CdkFooterRowDef.

    /**
     * \@docs-private
     */


    var CdkFooterRowDefBase =
    /*#__PURE__*/
    function (_BaseRowDef2) {
      _inherits(CdkFooterRowDefBase, _BaseRowDef2);

      function CdkFooterRowDefBase() {
        _classCallCheck(this, CdkFooterRowDefBase);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkFooterRowDefBase).apply(this, arguments));
      }

      return CdkFooterRowDefBase;
    }(BaseRowDef);
    /** @type {?} */


    var _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);
    /**
     * Footer row definition for the CDK table.
     * Captures the footer row's template and other footer properties such as the columns to display.
     */


    var CdkFooterRowDef =
    /*#__PURE__*/
    function (_CdkFooterRowDefBase2) {
      _inherits(CdkFooterRowDef, _CdkFooterRowDefBase2);

      /**
       * @param {?} template
       * @param {?} _differs
       */
      function CdkFooterRowDef(template, _differs) {
        _classCallCheck(this, CdkFooterRowDef);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkFooterRowDef).call(this, template, _differs));
      } // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.

      /**
       * @param {?} changes
       * @return {?}
       */


      _createClass(CdkFooterRowDef, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          _get(_getPrototypeOf(CdkFooterRowDef.prototype), "ngOnChanges", this).call(this, changes);
        }
      }]);

      return CdkFooterRowDef;
    }(_CdkFooterRowDefBase);

    CdkFooterRowDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkFooterRowDef]',
        inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky']
      }]
    }];
    /** @nocollapse */

    CdkFooterRowDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }];
    };
    /**
     * Data row definition for the CDK table.
     * Captures the header row's template and other row properties such as the columns to display and
     * a when predicate that describes when this row should be used.
     * @template T
     */


    var CdkRowDef =
    /*#__PURE__*/
    function (_BaseRowDef3) {
      _inherits(CdkRowDef, _BaseRowDef3);

      // TODO(andrewseguin): Add an input for providing a switch function to determine
      //   if this template should be used.

      /**
       * @param {?} template
       * @param {?} _differs
       */
      function CdkRowDef(template, _differs) {
        _classCallCheck(this, CdkRowDef);

        return _possibleConstructorReturn(this, _getPrototypeOf(CdkRowDef).call(this, template, _differs));
      }

      return CdkRowDef;
    }(BaseRowDef);

    CdkRowDef.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkRowDef]',
        inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen']
      }]
    }];
    /** @nocollapse */

    CdkRowDef.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }];
    };
    /**
     * Outlet for rendering cells inside of a row or header row.
     * \@docs-private
     */


    var CdkCellOutlet =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewContainer
       */
      function CdkCellOutlet(_viewContainer) {
        _classCallCheck(this, CdkCellOutlet);

        this._viewContainer = _viewContainer;
        CdkCellOutlet.mostRecentCellOutlet = this;
      }
      /**
       * @return {?}
       */


      _createClass(CdkCellOutlet, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          // If this was the last outlet being rendered in the view, remove the reference
          // from the static property after it has been destroyed to avoid leaking memory.
          if (CdkCellOutlet.mostRecentCellOutlet === this) {
            CdkCellOutlet.mostRecentCellOutlet = null;
          }
        }
      }]);

      return CdkCellOutlet;
    }();
    /**
     * Static property containing the latest constructed instance of this class.
     * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
     * createEmbeddedView. After one of these components are created, this property will provide
     * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
     * construct the cells with the provided context.
     */


    CdkCellOutlet.mostRecentCellOutlet = null;
    CdkCellOutlet.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[cdkCellOutlet]'
      }]
    }];
    /** @nocollapse */

    CdkCellOutlet.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }];
    };
    /**
     * Header template container that contains the cell outlet. Adds the right class and role.
     */


    var CdkHeaderRow = function CdkHeaderRow() {
      _classCallCheck(this, CdkHeaderRow);
    };

    CdkHeaderRow.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'cdk-header-row, tr[cdk-header-row]',
        template: CDK_ROW_TEMPLATE,
        host: {
          'class': 'cdk-header-row',
          'role': 'row'
        },
        // See note on CdkTable for explanation on why this uses the default change detection strategy.
        // tslint:disable-next-line:validate-decorators
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None
      }]
    }];
    /**
     * Footer template container that contains the cell outlet. Adds the right class and role.
     */

    var CdkFooterRow = function CdkFooterRow() {
      _classCallCheck(this, CdkFooterRow);
    };

    CdkFooterRow.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'cdk-footer-row, tr[cdk-footer-row]',
        template: CDK_ROW_TEMPLATE,
        host: {
          'class': 'cdk-footer-row',
          'role': 'row'
        },
        // See note on CdkTable for explanation on why this uses the default change detection strategy.
        // tslint:disable-next-line:validate-decorators
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None
      }]
    }];
    /**
     * Data row template container that contains the cell outlet. Adds the right class and role.
     */

    var CdkRow = function CdkRow() {
      _classCallCheck(this, CdkRow);
    };

    CdkRow.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'cdk-row, tr[cdk-row]',
        template: CDK_ROW_TEMPLATE,
        host: {
          'class': 'cdk-row',
          'role': 'row'
        },
        // See note on CdkTable for explanation on why this uses the default change detection strategy.
        // tslint:disable-next-line:validate-decorators
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * List of all possible directions that can be used for sticky positioning.
     * \@docs-private
     * @type {?}
     */

    var STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
    /**
     * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
     * \@docs-private
     */

    var StickyStyler =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _isNativeHtmlTable Whether the sticky logic should be based on a table
       *     that uses the native `<table>` element.
       * @param {?} _stickCellCss The CSS class that will be applied to every row/cell that has
       *     sticky positioning applied.
       * @param {?} direction The directionality context of the table (ltr/rtl); affects column positioning
       *     by reversing left/right positions.
       * @param {?=} _isBrowser Whether the table is currently being rendered on the server or the client.
       */
      function StickyStyler(_isNativeHtmlTable, _stickCellCss, direction) {
        var _isBrowser = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        _classCallCheck(this, StickyStyler);

        this._isNativeHtmlTable = _isNativeHtmlTable;
        this._stickCellCss = _stickCellCss;
        this.direction = direction;
        this._isBrowser = _isBrowser;
      }
      /**
       * Clears the sticky positioning styles from the row and its cells by resetting the `position`
       * style, setting the zIndex to 0, and unsetting each provided sticky direction.
       * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
       * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
       * @return {?}
       */


      _createClass(StickyStyler, [{
        key: "clearStickyPositioning",
        value: function clearStickyPositioning(rows, stickyDirections) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = rows[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var row = _step6.value;

              // If the row isn't an element (e.g. if it's an `ng-container`),
              // it won't have inline styles or `children` so we skip it.
              if (row.nodeType !== row.ELEMENT_NODE) {
                continue;
              }

              this._removeStickyStyle(row, stickyDirections);

              for (var i = 0; i < row.children.length; i++) {
                /** @type {?} */
                var cell =
                /** @type {?} */
                row.children[i];

                this._removeStickyStyle(cell, stickyDirections);
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
        /**
         * Applies sticky left and right positions to the cells of each row according to the sticky
         * states of the rendered column definitions.
         * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
         * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
         *     in this index position should be stuck to the start of the row.
         * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
         *     in this index position should be stuck to the end of the row.
         * @return {?}
         */

      }, {
        key: "updateStickyColumns",
        value: function updateStickyColumns(rows, stickyStartStates, stickyEndStates) {
          /** @type {?} */
          var hasStickyColumns = stickyStartStates.some(
          /**
          * @param {?} state
          * @return {?}
          */
          function (state) {
            return state;
          }) || stickyEndStates.some(
          /**
          * @param {?} state
          * @return {?}
          */
          function (state) {
            return state;
          });

          if (!rows.length || !hasStickyColumns || !this._isBrowser) {
            return;
          }
          /** @type {?} */


          var firstRow = rows[0];
          /** @type {?} */

          var numCells = firstRow.children.length;
          /** @type {?} */

          var cellWidths = this._getCellWidths(firstRow);
          /** @type {?} */


          var startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
          /** @type {?} */


          var endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
          /** @type {?} */


          var isRtl = this.direction === 'rtl';
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = rows[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var row = _step7.value;

              for (var i = 0; i < numCells; i++) {
                /** @type {?} */
                var cell =
                /** @type {?} */
                row.children[i];

                if (stickyStartStates[i]) {
                  this._addStickyStyle(cell, isRtl ? 'right' : 'left', startPositions[i]);
                }

                if (stickyEndStates[i]) {
                  this._addStickyStyle(cell, isRtl ? 'left' : 'right', endPositions[i]);
                }
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
        /**
         * Applies sticky positioning to the row's cells if using the native table layout, and to the
         * row itself otherwise.
         * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
         *     sticky state and to the provided top or bottom position.
         * @param {?} stickyStates A list of boolean states where each state represents whether the row
         *     should be stuck in the particular top or bottom position.
         * @param {?} position The position direction in which the row should be stuck if that row should be
         *     sticky.
         *
         * @return {?}
         */

      }, {
        key: "stickRows",
        value: function stickRows(rowsToStick, stickyStates, position) {
          // Since we can't measure the rows on the server, we can't stick the rows properly.
          if (!this._isBrowser) {
            return;
          } // If positioning the rows to the bottom, reverse their order when evaluating the sticky
          // position such that the last row stuck will be "bottom: 0px" and so on.

          /** @type {?} */


          var rows = position === 'bottom' ? rowsToStick.reverse() : rowsToStick;
          /** @type {?} */

          var stickyHeight = 0;

          for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            if (!stickyStates[rowIndex]) {
              continue;
            }
            /** @type {?} */


            var row = rows[rowIndex];

            if (this._isNativeHtmlTable) {
              for (var j = 0; j < row.children.length; j++) {
                /** @type {?} */
                var cell =
                /** @type {?} */
                row.children[j];

                this._addStickyStyle(cell, position, stickyHeight);
              }
            } else {
              // Flex does not respect the stick positioning on the cells, needs to be applied to the row.
              // If this is applied on a native table, Safari causes the header to fly in wrong direction.
              this._addStickyStyle(row, position, stickyHeight);
            }

            if (rowIndex === rows.length - 1) {
              // prevent unnecessary reflow from getBoundingClientRect()
              return;
            }

            stickyHeight += row.getBoundingClientRect().height;
          }
        }
        /**
         * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
         * footer rows is to apply sticky styling to the tfoot container. This should only be done if
         * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
         * the tfoot element.
         * @param {?} tableElement
         * @param {?} stickyStates
         * @return {?}
         */

      }, {
        key: "updateStickyFooterContainer",
        value: function updateStickyFooterContainer(tableElement, stickyStates) {
          if (!this._isNativeHtmlTable) {
            return;
          }
          /** @type {?} */


          var tfoot =
          /** @type {?} */
          tableElement.querySelector('tfoot');

          if (stickyStates.some(
          /**
          * @param {?} state
          * @return {?}
          */
          function (state) {
            return !state;
          })) {
            this._removeStickyStyle(tfoot, ['bottom']);
          } else {
            this._addStickyStyle(tfoot, 'bottom', 0);
          }
        }
        /**
         * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
         * the zIndex, removing each of the provided sticky directions, and removing the
         * sticky position if there are no more directions.
         * @param {?} element
         * @param {?} stickyDirections
         * @return {?}
         */

      }, {
        key: "_removeStickyStyle",
        value: function _removeStickyStyle(element, stickyDirections) {
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = stickyDirections[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var dir = _step8.value;
              element.style[dir] = '';
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }

          element.style.zIndex = this._getCalculatedZIndex(element); // If the element no longer has any more sticky directions, remove sticky positioning and
          // the sticky CSS class.

          /** @type {?} */

          var hasDirection = STICKY_DIRECTIONS.some(
          /**
          * @param {?} dir
          * @return {?}
          */
          function (dir) {
            return !!element.style[dir];
          });

          if (!hasDirection) {
            element.style.position = '';
            element.classList.remove(this._stickCellCss);
          }
        }
        /**
         * Adds the sticky styling to the element by adding the sticky style class, changing position
         * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
         * direction and value.
         * @param {?} element
         * @param {?} dir
         * @param {?} dirValue
         * @return {?}
         */

      }, {
        key: "_addStickyStyle",
        value: function _addStickyStyle(element, dir, dirValue) {
          element.classList.add(this._stickCellCss);
          element.style[dir] = "".concat(dirValue, "px");
          element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
          element.style.zIndex = this._getCalculatedZIndex(element);
        }
        /**
         * Calculate what the z-index should be for the element, depending on what directions (top,
         * bottom, left, right) have been set. It should be true that elements with a top direction
         * should have the highest index since these are elements like a table header. If any of those
         * elements are also sticky in another direction, then they should appear above other elements
         * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
         * (e.g. footer rows) should then be next in the ordering such that they are below the header
         * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
         * should minimally increment so that they are above non-sticky elements but below top and bottom
         * elements.
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "_getCalculatedZIndex",
        value: function _getCalculatedZIndex(element) {
          /** @type {?} */
          var zIndexIncrements = {
            top: 100,
            bottom: 10,
            left: 1,
            right: 1
          };
          /** @type {?} */

          var zIndex = 0;
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = STICKY_DIRECTIONS[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var dir = _step9.value;

              if (element.style[dir]) {
                zIndex += zIndexIncrements[dir];
              }
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                _iterator9.return();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }

          return zIndex ? "".concat(zIndex) : '';
        }
        /**
         * Gets the widths for each cell in the provided row.
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "_getCellWidths",
        value: function _getCellWidths(row) {
          /** @type {?} */
          var cellWidths = [];
          /** @type {?} */

          var firstRowCells = row.children;

          for (var i = 0; i < firstRowCells.length; i++) {
            /** @type {?} */
            var cell =
            /** @type {?} */
            firstRowCells[i];
            cellWidths.push(cell.getBoundingClientRect().width);
          }

          return cellWidths;
        }
        /**
         * Determines the left and right positions of each sticky column cell, which will be the
         * accumulation of all sticky column cell widths to the left and right, respectively.
         * Non-sticky cells do not need to have a value set since their positions will not be applied.
         * @param {?} widths
         * @param {?} stickyStates
         * @return {?}
         */

      }, {
        key: "_getStickyStartColumnPositions",
        value: function _getStickyStartColumnPositions(widths, stickyStates) {
          /** @type {?} */
          var positions = [];
          /** @type {?} */

          var nextPosition = 0;

          for (var i = 0; i < widths.length; i++) {
            if (stickyStates[i]) {
              positions[i] = nextPosition;
              nextPosition += widths[i];
            }
          }

          return positions;
        }
        /**
         * Determines the left and right positions of each sticky column cell, which will be the
         * accumulation of all sticky column cell widths to the left and right, respectively.
         * Non-sticky cells do not need to have a value set since their positions will not be applied.
         * @param {?} widths
         * @param {?} stickyStates
         * @return {?}
         */

      }, {
        key: "_getStickyEndColumnPositions",
        value: function _getStickyEndColumnPositions(widths, stickyStates) {
          /** @type {?} */
          var positions = [];
          /** @type {?} */

          var nextPosition = 0;

          for (var i = widths.length; i > 0; i--) {
            if (stickyStates[i]) {
              positions[i] = nextPosition;
              nextPosition += widths[i];
            }
          }

          return positions;
        }
      }]);

      return StickyStyler;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns an error to be thrown when attempting to find an unexisting column.
     * \@docs-private
     * @param {?} id Id whose lookup failed.
     * @return {?}
     */


    function getTableUnknownColumnError(id) {
      return Error("Could not find column with id \"".concat(id, "\"."));
    }
    /**
     * Returns an error to be thrown when two column definitions have the same name.
     * \@docs-private
     * @param {?} name
     * @return {?}
     */


    function getTableDuplicateColumnNameError(name) {
      return Error("Duplicate column definition name provided: \"".concat(name, "\"."));
    }
    /**
     * Returns an error to be thrown when there are multiple rows that are missing a when function.
     * \@docs-private
     * @return {?}
     */


    function getTableMultipleDefaultRowDefsError() {
      return Error("There can only be one default row without a when predicate function.");
    }
    /**
     * Returns an error to be thrown when there are no matching row defs for a particular set of data.
     * \@docs-private
     * @param {?} data
     * @return {?}
     */


    function getTableMissingMatchingRowDefError(data) {
      return Error("Could not find a matching row definition for the" + "provided row data: ".concat(JSON.stringify(data)));
    }
    /**
     * Returns an error to be thrown when there is no row definitions present in the content.
     * \@docs-private
     * @return {?}
     */


    function getTableMissingRowDefsError() {
      return Error('Missing definitions for header, footer, and row; ' + 'cannot determine which columns should be rendered.');
    }
    /**
     * Returns an error to be thrown when the data source does not match the compatible types.
     * \@docs-private
     * @return {?}
     */


    function getTableUnknownDataSourceError() {
      return Error("Provided data source did not match an array, Observable, or DataSource");
    }
    /**
     * Returns an error to be thrown when the text column cannot find a parent table to inject.
     * \@docs-private
     * @return {?}
     */


    function getTableTextColumnMissingParentTableError() {
      return Error("Text column could not find a parent table for registration.");
    }
    /**
     * Returns an error to be thrown when a table text column doesn't have a name.
     * \@docs-private
     * @return {?}
     */


    function getTableTextColumnMissingNameError() {
      return Error("Table text column must have a name.");
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provides a handle for the table to grab the view container's ng-container to insert data rows.
     * \@docs-private
     */


    var DataRowOutlet =
    /**
     * @param {?} viewContainer
     * @param {?} elementRef
     */
    function DataRowOutlet(viewContainer, elementRef) {
      _classCallCheck(this, DataRowOutlet);

      this.viewContainer = viewContainer;
      this.elementRef = elementRef;
    };

    DataRowOutlet.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[rowOutlet]'
      }]
    }];
    /** @nocollapse */

    DataRowOutlet.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * Provides a handle for the table to grab the view container's ng-container to insert the header.
     * \@docs-private
     */


    var HeaderRowOutlet =
    /**
     * @param {?} viewContainer
     * @param {?} elementRef
     */
    function HeaderRowOutlet(viewContainer, elementRef) {
      _classCallCheck(this, HeaderRowOutlet);

      this.viewContainer = viewContainer;
      this.elementRef = elementRef;
    };

    HeaderRowOutlet.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[headerRowOutlet]'
      }]
    }];
    /** @nocollapse */

    HeaderRowOutlet.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * Provides a handle for the table to grab the view container's ng-container to insert the footer.
     * \@docs-private
     */


    var FooterRowOutlet =
    /**
     * @param {?} viewContainer
     * @param {?} elementRef
     */
    function FooterRowOutlet(viewContainer, elementRef) {
      _classCallCheck(this, FooterRowOutlet);

      this.viewContainer = viewContainer;
      this.elementRef = elementRef;
    };

    FooterRowOutlet.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[footerRowOutlet]'
      }]
    }];
    /** @nocollapse */

    FooterRowOutlet.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * The table template that can be used by the mat-table. Should not be used outside of the
     * material library.
     * \@docs-private
     * @type {?}
     */


    var CDK_TABLE_TEMPLATE = // Note that according to MDN, the `caption` element has to be projected as the **first**
    // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
    "\n  <ng-content select=\"caption\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n";
    /**
     * A data table that can render a header row, data rows, and a footer row.
     * Uses the dataSource input to determine the data to be rendered. The data can be provided either
     * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
     * connect function that will return an Observable stream that emits the data array to render.
     * @template T
     */

    var CdkTable =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _differs
       * @param {?} _changeDetectorRef
       * @param {?} _elementRef
       * @param {?} role
       * @param {?} _dir
       * @param {?} _document
       * @param {?} _platform
       */
      function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform) {
        _classCallCheck(this, CdkTable);

        this._differs = _differs;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._dir = _dir;
        this._platform = _platform;
        /**
         * Subject that emits when the component has been destroyed.
         */

        this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
        /**
         * Map of all the user's defined columns (header, data, and footer cell template) identified by
         * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
         * any custom column definitions added to `_customColumnDefs`.
         */

        this._columnDefsByName = new Map();
        /**
         * Column definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * column definitions as *its* content child.
         */

        this._customColumnDefs = new Set();
        /**
         * Data row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * built-in data rows as *its* content child.
         */

        this._customRowDefs = new Set();
        /**
         * Header row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * built-in header rows as *its* content child.
         */

        this._customHeaderRowDefs = new Set();
        /**
         * Footer row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
         * built-in footer row as *its* content child.
         */

        this._customFooterRowDefs = new Set();
        /**
         * Whether the header row definition has been changed. Triggers an update to the header row after
         * content is checked. Initialized as true so that the table renders the initial set of rows.
         */

        this._headerRowDefChanged = true;
        /**
         * Whether the footer row definition has been changed. Triggers an update to the footer row after
         * content is checked. Initialized as true so that the table renders the initial set of rows.
         */

        this._footerRowDefChanged = true;
        /**
         * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
         * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
         * the cached `RenderRow` objects when possible, the row identity is preserved when the data
         * and row template matches, which allows the `IterableDiffer` to check rows by reference
         * and understand which rows are added/moved/removed.
         *
         * Implemented as a map of maps where the first key is the `data: T` object and the second is the
         * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
         * contains an array of created pairs. The array is necessary to handle cases where the data
         * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
         * stored.
         */

        this._cachedRenderRowsMap = new Map();
        /**
         * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
         * table subclasses.
         */

        this.stickyCssClass = 'cdk-table-sticky';
        this._multiTemplateDataRows = false; // TODO(andrewseguin): Remove max value as the end index
        //   and instead calculate the view on init and scroll.

        /**
         * Stream containing the latest information on what rows are being displayed on screen.
         * Can be used by the data source to as a heuristic of what data should be provided.
         *
         * \@docs-private
         */

        this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]({
          start: 0,
          end: Number.MAX_VALUE
        });

        if (!role) {
          this._elementRef.nativeElement.setAttribute('role', 'grid');
        }

        this._document = _document;
        this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
      }
      /**
       * Tracking function that will be used to check the differences in data changes. Used similarly
       * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
       * relative to the function to know if a row should be added/removed/moved.
       * Accepts a function that takes two parameters, `index` and `item`.
       * @return {?}
       */


      _createClass(CdkTable, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          var _this152 = this;

          this._setupStickyStyler();

          if (this._isNativeHtmlTable) {
            this._applyNativeTableSections();
          } // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
          // the user has provided a custom trackBy, return the result of that function as evaluated
          // with the values of the `RenderRow`'s data and index.


          this._dataDiffer = this._differs.find([]).create(
          /**
          * @param {?} _i
          * @param {?} dataRow
          * @return {?}
          */
          function (_i, dataRow) {
            return _this152.trackBy ? _this152.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentChecked",
        value: function ngAfterContentChecked() {
          // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
          this._cacheRowDefs();

          this._cacheColumnDefs(); // Make sure that the user has at least added header, footer, or data row def.


          if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) {
            throw getTableMissingRowDefsError();
          } // Render updates if the list of columns have been changed for the header, row, or footer defs.


          this._renderUpdatedColumns(); // If the header row definition has been changed, trigger a render to the header row.


          if (this._headerRowDefChanged) {
            this._forceRenderHeaderRows();

            this._headerRowDefChanged = false;
          } // If the footer row definition has been changed, trigger a render to the footer row.


          if (this._footerRowDefChanged) {
            this._forceRenderFooterRows();

            this._footerRowDefChanged = false;
          } // If there is a data source and row definitions, connect to the data source unless a
          // connection has already been made.


          if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
            this._observeRenderChanges();
          }

          this._checkStickyStates();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._rowOutlet.viewContainer.clear();

          this._headerRowOutlet.viewContainer.clear();

          this._footerRowOutlet.viewContainer.clear();

          this._cachedRenderRowsMap.clear();

          this._onDestroy.next();

          this._onDestroy.complete();

          if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
            this.dataSource.disconnect(this);
          }
        }
        /**
         * Renders rows based on the table's latest set of data, which was either provided directly as an
         * input or retrieved through an Observable stream (directly or from a DataSource).
         * Checks for differences in the data since the last diff to perform only the necessary
         * changes (add/remove/move rows).
         *
         * If the table's data source is a DataSource or Observable, this will be invoked automatically
         * each time the provided Observable stream emits a new data array. Otherwise if your data is
         * an array, this function will need to be called to render any changes.
         * @return {?}
         */

      }, {
        key: "renderRows",
        value: function renderRows() {
          var _this153 = this;

          this._renderRows = this._getAllRenderRows();
          /** @type {?} */

          var changes = this._dataDiffer.diff(this._renderRows);

          if (!changes) {
            return;
          }
          /** @type {?} */


          var viewContainer = this._rowOutlet.viewContainer;
          changes.forEachOperation(
          /**
          * @param {?} record
          * @param {?} prevIndex
          * @param {?} currentIndex
          * @return {?}
          */
          function (record, prevIndex, currentIndex) {
            if (record.previousIndex == null) {
              _this153._insertRow(record.item,
              /** @type {?} */
              currentIndex);
            } else if (currentIndex == null) {
              viewContainer.remove(
              /** @type {?} */
              prevIndex);
            } else {
              /** @type {?} */
              var view =
              /** @type {?} */
              viewContainer.get(
              /** @type {?} */
              prevIndex);
              viewContainer.move(
              /** @type {?} */
              view, currentIndex);
            }
          }); // Update the meta context of a row's context data (index, count, first, last, ...)

          this._updateRowIndexContext(); // Update rows that did not get added/removed/moved but may have had their identity changed,
          // e.g. if trackBy matched data on some property but the actual data reference changed.


          changes.forEachIdentityChange(
          /**
          * @param {?} record
          * @return {?}
          */
          function (record) {
            /** @type {?} */
            var rowView =
            /** @type {?} */
            viewContainer.get(
            /** @type {?} */
            record.currentIndex);
            rowView.context.$implicit = record.item.data;
          });
          this.updateStickyColumnStyles();
        }
        /**
         * Sets the header row definition to be used. Overrides the header row definition gathered by
         * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
         * table's content is checked.
         * \@docs-private
         * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
         * \@breaking-change 8.0.0
         * @param {?} headerRowDef
         * @return {?}
         */

      }, {
        key: "setHeaderRowDef",
        value: function setHeaderRowDef(headerRowDef) {
          this._customHeaderRowDefs = new Set([headerRowDef]);
          this._headerRowDefChanged = true;
        }
        /**
         * Sets the footer row definition to be used. Overrides the footer row definition gathered by
         * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
         * table's content is checked.
         * \@docs-private
         * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
         * \@breaking-change 8.0.0
         * @param {?} footerRowDef
         * @return {?}
         */

      }, {
        key: "setFooterRowDef",
        value: function setFooterRowDef(footerRowDef) {
          this._customFooterRowDefs = new Set([footerRowDef]);
          this._footerRowDefChanged = true;
        }
        /**
         * Adds a column definition that was not included as part of the content children.
         * @param {?} columnDef
         * @return {?}
         */

      }, {
        key: "addColumnDef",
        value: function addColumnDef(columnDef) {
          this._customColumnDefs.add(columnDef);
        }
        /**
         * Removes a column definition that was not included as part of the content children.
         * @param {?} columnDef
         * @return {?}
         */

      }, {
        key: "removeColumnDef",
        value: function removeColumnDef(columnDef) {
          this._customColumnDefs.delete(columnDef);
        }
        /**
         * Adds a row definition that was not included as part of the content children.
         * @param {?} rowDef
         * @return {?}
         */

      }, {
        key: "addRowDef",
        value: function addRowDef(rowDef) {
          this._customRowDefs.add(rowDef);
        }
        /**
         * Removes a row definition that was not included as part of the content children.
         * @param {?} rowDef
         * @return {?}
         */

      }, {
        key: "removeRowDef",
        value: function removeRowDef(rowDef) {
          this._customRowDefs.delete(rowDef);
        }
        /**
         * Adds a header row definition that was not included as part of the content children.
         * @param {?} headerRowDef
         * @return {?}
         */

      }, {
        key: "addHeaderRowDef",
        value: function addHeaderRowDef(headerRowDef) {
          this._customHeaderRowDefs.add(headerRowDef);

          this._headerRowDefChanged = true;
        }
        /**
         * Removes a header row definition that was not included as part of the content children.
         * @param {?} headerRowDef
         * @return {?}
         */

      }, {
        key: "removeHeaderRowDef",
        value: function removeHeaderRowDef(headerRowDef) {
          this._customHeaderRowDefs.delete(headerRowDef);

          this._headerRowDefChanged = true;
        }
        /**
         * Adds a footer row definition that was not included as part of the content children.
         * @param {?} footerRowDef
         * @return {?}
         */

      }, {
        key: "addFooterRowDef",
        value: function addFooterRowDef(footerRowDef) {
          this._customFooterRowDefs.add(footerRowDef);

          this._footerRowDefChanged = true;
        }
        /**
         * Removes a footer row definition that was not included as part of the content children.
         * @param {?} footerRowDef
         * @return {?}
         */

      }, {
        key: "removeFooterRowDef",
        value: function removeFooterRowDef(footerRowDef) {
          this._customFooterRowDefs.delete(footerRowDef);

          this._footerRowDefChanged = true;
        }
        /**
         * Updates the header sticky styles. First resets all applied styles with respect to the cells
         * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
         * automatically called when the header row changes its displayed set of columns, or if its
         * sticky input changes. May be called manually for cases where the cell content changes outside
         * of these events.
         * @return {?}
         */

      }, {
        key: "updateStickyHeaderRowStyles",
        value: function updateStickyHeaderRowStyles() {
          /** @type {?} */
          var headerRows = this._getRenderedRows(this._headerRowOutlet);
          /** @type {?} */


          var tableElement =
          /** @type {?} */
          this._elementRef.nativeElement; // Hide the thead element if there are no header rows. This is necessary to satisfy
          // overzealous a11y checkers that fail because the `rowgroup` element does not contain
          // required child `row`.

          /** @type {?} */

          var thead = tableElement.querySelector('thead');

          if (thead) {
            thead.style.display = headerRows.length ? '' : 'none';
          }
          /** @type {?} */


          var stickyStates = this._headerRowDefs.map(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return def.sticky;
          });

          this._stickyStyler.clearStickyPositioning(headerRows, ['top']);

          this._stickyStyler.stickRows(headerRows, stickyStates, 'top'); // Reset the dirty state of the sticky input change since it has been used.


          this._headerRowDefs.forEach(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return def.resetStickyChanged();
          });
        }
        /**
         * Updates the footer sticky styles. First resets all applied styles with respect to the cells
         * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
         * automatically called when the footer row changes its displayed set of columns, or if its
         * sticky input changes. May be called manually for cases where the cell content changes outside
         * of these events.
         * @return {?}
         */

      }, {
        key: "updateStickyFooterRowStyles",
        value: function updateStickyFooterRowStyles() {
          /** @type {?} */
          var footerRows = this._getRenderedRows(this._footerRowOutlet);
          /** @type {?} */


          var tableElement =
          /** @type {?} */
          this._elementRef.nativeElement; // Hide the tfoot element if there are no footer rows. This is necessary to satisfy
          // overzealous a11y checkers that fail because the `rowgroup` element does not contain
          // required child `row`.

          /** @type {?} */

          var tfoot = tableElement.querySelector('tfoot');

          if (tfoot) {
            tfoot.style.display = footerRows.length ? '' : 'none';
          }
          /** @type {?} */


          var stickyStates = this._footerRowDefs.map(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return def.sticky;
          });

          this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);

          this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');

          this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates); // Reset the dirty state of the sticky input change since it has been used.


          this._footerRowDefs.forEach(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return def.resetStickyChanged();
          });
        }
        /**
         * Updates the column sticky styles. First resets all applied styles with respect to the cells
         * sticking to the left and right. Then sticky styles are added for the left and right according
         * to the column definitions for each cell in each row. This is automatically called when
         * the data source provides a new set of data or when a column definition changes its sticky
         * input. May be called manually for cases where the cell content changes outside of these events.
         * @return {?}
         */

      }, {
        key: "updateStickyColumnStyles",
        value: function updateStickyColumnStyles() {
          var _this154 = this;

          /** @type {?} */
          var headerRows = this._getRenderedRows(this._headerRowOutlet);
          /** @type {?} */


          var dataRows = this._getRenderedRows(this._rowOutlet);
          /** @type {?} */


          var footerRows = this._getRenderedRows(this._footerRowOutlet); // Clear the left and right positioning from all columns in the table across all rows since
          // sticky columns span across all table sections (header, data, footer)


          this._stickyStyler.clearStickyPositioning([].concat(_toConsumableArray(headerRows), _toConsumableArray(dataRows), _toConsumableArray(footerRows)), ['left', 'right']); // Update the sticky styles for each header row depending on the def's sticky state


          headerRows.forEach(
          /**
          * @param {?} headerRow
          * @param {?} i
          * @return {?}
          */
          function (headerRow, i) {
            _this154._addStickyColumnStyles([headerRow], _this154._headerRowDefs[i]);
          }); // Update the sticky styles for each data row depending on its def's sticky state

          this._rowDefs.forEach(
          /**
          * @param {?} rowDef
          * @return {?}
          */
          function (rowDef) {
            // Collect all the rows rendered with this row definition.

            /** @type {?} */
            var rows = [];

            for (var i = 0; i < dataRows.length; i++) {
              if (_this154._renderRows[i].rowDef === rowDef) {
                rows.push(dataRows[i]);
              }
            }

            _this154._addStickyColumnStyles(rows, rowDef);
          }); // Update the sticky styles for each footer row depending on the def's sticky state


          footerRows.forEach(
          /**
          * @param {?} footerRow
          * @param {?} i
          * @return {?}
          */
          function (footerRow, i) {
            _this154._addStickyColumnStyles([footerRow], _this154._footerRowDefs[i]);
          }); // Reset the dirty state of the sticky input change since it has been used.

          Array.from(this._columnDefsByName.values()).forEach(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return def.resetStickyChanged();
          });
        }
        /**
         * Get the list of RenderRow objects to render according to the current list of data and defined
         * row definitions. If the previous list already contained a particular pair, it should be reused
         * so that the differ equates their references.
         * @private
         * @return {?}
         */

      }, {
        key: "_getAllRenderRows",
        value: function _getAllRenderRows() {
          /** @type {?} */
          var renderRows = []; // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
          // new cache while unused ones can be picked up by garbage collection.

          /** @type {?} */

          var prevCachedRenderRows = this._cachedRenderRowsMap;
          this._cachedRenderRowsMap = new Map(); // For each data object, get the list of rows that should be rendered, represented by the
          // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.

          for (var i = 0; i < this._data.length; i++) {
            /** @type {?} */
            var data = this._data[i];
            /** @type {?} */

            var renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));

            if (!this._cachedRenderRowsMap.has(data)) {
              this._cachedRenderRowsMap.set(data, new WeakMap());
            }

            for (var j = 0; j < renderRowsForData.length; j++) {
              /** @type {?} */
              var renderRow = renderRowsForData[j];
              /** @type {?} */

              var cache =
              /** @type {?} */
              this._cachedRenderRowsMap.get(renderRow.data);

              if (cache.has(renderRow.rowDef)) {
                /** @type {?} */
                cache.get(renderRow.rowDef).push(renderRow);
              } else {
                cache.set(renderRow.rowDef, [renderRow]);
              }

              renderRows.push(renderRow);
            }
          }

          return renderRows;
        }
        /**
         * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
         * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
         * `(T, CdkRowDef)` pair.
         * @private
         * @param {?} data
         * @param {?} dataIndex
         * @param {?=} cache
         * @return {?}
         */

      }, {
        key: "_getRenderRowsForData",
        value: function _getRenderRowsForData(data, dataIndex, cache) {
          /** @type {?} */
          var rowDefs = this._getRowDefs(data, dataIndex);

          return rowDefs.map(
          /**
          * @param {?} rowDef
          * @return {?}
          */
          function (rowDef) {
            /** @type {?} */
            var cachedRenderRows = cache && cache.has(rowDef) ?
            /** @type {?} */
            cache.get(rowDef) : [];

            if (cachedRenderRows.length) {
              /** @type {?} */
              var dataRow =
              /** @type {?} */
              cachedRenderRows.shift();
              dataRow.dataIndex = dataIndex;
              return dataRow;
            } else {
              return {
                data: data,
                rowDef: rowDef,
                dataIndex: dataIndex
              };
            }
          });
        }
        /**
         * Update the map containing the content's column definitions.
         * @private
         * @return {?}
         */

      }, {
        key: "_cacheColumnDefs",
        value: function _cacheColumnDefs() {
          var _this155 = this;

          this._columnDefsByName.clear();
          /** @type {?} */


          var columnDefs = mergeQueryListAndSet(this._contentColumnDefs, this._customColumnDefs);
          columnDefs.forEach(
          /**
          * @param {?} columnDef
          * @return {?}
          */
          function (columnDef) {
            if (_this155._columnDefsByName.has(columnDef.name)) {
              throw getTableDuplicateColumnNameError(columnDef.name);
            }

            _this155._columnDefsByName.set(columnDef.name, columnDef);
          });
        }
        /**
         * Update the list of all available row definitions that can be used.
         * @private
         * @return {?}
         */

      }, {
        key: "_cacheRowDefs",
        value: function _cacheRowDefs() {
          this._headerRowDefs = mergeQueryListAndSet(this._contentHeaderRowDefs, this._customHeaderRowDefs);
          this._footerRowDefs = mergeQueryListAndSet(this._contentFooterRowDefs, this._customFooterRowDefs);
          this._rowDefs = mergeQueryListAndSet(this._contentRowDefs, this._customRowDefs); // After all row definitions are determined, find the row definition to be considered default.

          /** @type {?} */

          var defaultRowDefs = this._rowDefs.filter(
          /**
          * @param {?} def
          * @return {?}
          */
          function (def) {
            return !def.when;
          });

          if (!this.multiTemplateDataRows && defaultRowDefs.length > 1) {
            throw getTableMultipleDefaultRowDefsError();
          }

          this._defaultRowDef = defaultRowDefs[0];
        }
        /**
         * Check if the header, data, or footer rows have changed what columns they want to display or
         * whether the sticky states have changed for the header or footer. If there is a diff, then
         * re-render that section.
         * @private
         * @return {?}
         */

      }, {
        key: "_renderUpdatedColumns",
        value: function _renderUpdatedColumns() {
          /** @type {?} */
          var columnsDiffReducer =
          /**
          * @param {?} acc
          * @param {?} def
          * @return {?}
          */
          function columnsDiffReducer(acc, def) {
            return acc || !!def.getColumnsDiff();
          }; // Force re-render data rows if the list of column definitions have changed.


          if (this._rowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderDataRows();
          } // Force re-render header/footer rows if the list of column definitions have changed..


          if (this._headerRowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderHeaderRows();
          }

          if (this._footerRowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderFooterRows();
          }
        }
        /**
         * Switch to the provided data source by resetting the data and unsubscribing from the current
         * render change subscription if one exists. If the data source is null, interpret this by
         * clearing the row outlet. Otherwise start listening for new data.
         * @private
         * @param {?} dataSource
         * @return {?}
         */

      }, {
        key: "_switchDataSource",
        value: function _switchDataSource(dataSource) {
          this._data = [];

          if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
            this.dataSource.disconnect(this);
          } // Stop listening for data from the previous data source.


          if (this._renderChangeSubscription) {
            this._renderChangeSubscription.unsubscribe();

            this._renderChangeSubscription = null;
          }

          if (!dataSource) {
            if (this._dataDiffer) {
              this._dataDiffer.diff([]);
            }

            this._rowOutlet.viewContainer.clear();
          }

          this._dataSource = dataSource;
        }
        /**
         * Set up a subscription for the data provided by the data source.
         * @private
         * @return {?}
         */

      }, {
        key: "_observeRenderChanges",
        value: function _observeRenderChanges() {
          var _this156 = this;

          // If no data source has been set, there is nothing to observe for changes.
          if (!this.dataSource) {
            return;
          }
          /** @type {?} */


          var dataStream;

          if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
            dataStream = this.dataSource.connect(this);
          } else if (this.dataSource instanceof rxjs__WEBPACK_IMPORTED_MODULE_6__["Observable"]) {
            dataStream = this.dataSource;
          } else if (Array.isArray(this.dataSource)) {
            dataStream = Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])(this.dataSource);
          }

          if (dataStream === undefined) {
            throw getTableUnknownDataSourceError();
          }

          this._renderChangeSubscription = dataStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy)).subscribe(
          /**
          * @param {?} data
          * @return {?}
          */
          function (data) {
            _this156._data = data || [];

            _this156.renderRows();
          });
        }
        /**
         * Clears any existing content in the header row outlet and creates a new embedded view
         * in the outlet using the header row definition.
         * @private
         * @return {?}
         */

      }, {
        key: "_forceRenderHeaderRows",
        value: function _forceRenderHeaderRows() {
          var _this157 = this;

          // Clear the header row outlet if any content exists.
          if (this._headerRowOutlet.viewContainer.length > 0) {
            this._headerRowOutlet.viewContainer.clear();
          }

          this._headerRowDefs.forEach(
          /**
          * @param {?} def
          * @param {?} i
          * @return {?}
          */
          function (def, i) {
            return _this157._renderRow(_this157._headerRowOutlet, def, i);
          });

          this.updateStickyHeaderRowStyles();
          this.updateStickyColumnStyles();
        }
        /**
         * Clears any existing content in the footer row outlet and creates a new embedded view
         * in the outlet using the footer row definition.
         * @private
         * @return {?}
         */

      }, {
        key: "_forceRenderFooterRows",
        value: function _forceRenderFooterRows() {
          var _this158 = this;

          // Clear the footer row outlet if any content exists.
          if (this._footerRowOutlet.viewContainer.length > 0) {
            this._footerRowOutlet.viewContainer.clear();
          }

          this._footerRowDefs.forEach(
          /**
          * @param {?} def
          * @param {?} i
          * @return {?}
          */
          function (def, i) {
            return _this158._renderRow(_this158._footerRowOutlet, def, i);
          });

          this.updateStickyFooterRowStyles();
          this.updateStickyColumnStyles();
        }
        /**
         * Adds the sticky column styles for the rows according to the columns' stick states.
         * @private
         * @param {?} rows
         * @param {?} rowDef
         * @return {?}
         */

      }, {
        key: "_addStickyColumnStyles",
        value: function _addStickyColumnStyles(rows, rowDef) {
          var _this159 = this;

          /** @type {?} */
          var columnDefs = Array.from(rowDef.columns || []).map(
          /**
          * @param {?} columnName
          * @return {?}
          */
          function (columnName) {
            /** @type {?} */
            var columnDef = _this159._columnDefsByName.get(columnName);

            if (!columnDef) {
              throw getTableUnknownColumnError(columnName);
            }

            return (
              /** @type {?} */
              columnDef
            );
          });
          /** @type {?} */

          var stickyStartStates = columnDefs.map(
          /**
          * @param {?} columnDef
          * @return {?}
          */
          function (columnDef) {
            return columnDef.sticky;
          });
          /** @type {?} */

          var stickyEndStates = columnDefs.map(
          /**
          * @param {?} columnDef
          * @return {?}
          */
          function (columnDef) {
            return columnDef.stickyEnd;
          });

          this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates);
        }
        /**
         * Gets the list of rows that have been rendered in the row outlet.
         * @param {?} rowOutlet
         * @return {?}
         */

      }, {
        key: "_getRenderedRows",
        value: function _getRenderedRows(rowOutlet) {
          /** @type {?} */
          var renderedRows = [];

          for (var i = 0; i < rowOutlet.viewContainer.length; i++) {
            /** @type {?} */
            var viewRef =
            /** @type {?} */

            /** @type {?} */
            rowOutlet.viewContainer.get(i);
            renderedRows.push(viewRef.rootNodes[0]);
          }

          return renderedRows;
        }
        /**
         * Get the matching row definitions that should be used for this row data. If there is only
         * one row definition, it is returned. Otherwise, find the row definitions that has a when
         * predicate that returns true with the data. If none return true, return the default row
         * definition.
         * @param {?} data
         * @param {?} dataIndex
         * @return {?}
         */

      }, {
        key: "_getRowDefs",
        value: function _getRowDefs(data, dataIndex) {
          if (this._rowDefs.length == 1) {
            return [this._rowDefs[0]];
          }
          /** @type {?} */


          var rowDefs = [];

          if (this.multiTemplateDataRows) {
            rowDefs = this._rowDefs.filter(
            /**
            * @param {?} def
            * @return {?}
            */
            function (def) {
              return !def.when || def.when(dataIndex, data);
            });
          } else {
            /** @type {?} */
            var rowDef = this._rowDefs.find(
            /**
            * @param {?} def
            * @return {?}
            */
            function (def) {
              return def.when && def.when(dataIndex, data);
            }) || this._defaultRowDef;

            if (rowDef) {
              rowDefs.push(rowDef);
            }
          }

          if (!rowDefs.length) {
            throw getTableMissingMatchingRowDefError(data);
          }

          return rowDefs;
        }
        /**
         * Create the embedded view for the data row template and place it in the correct index location
         * within the data row view container.
         * @private
         * @param {?} renderRow
         * @param {?} renderIndex
         * @return {?}
         */

      }, {
        key: "_insertRow",
        value: function _insertRow(renderRow, renderIndex) {
          /** @type {?} */
          var rowDef = renderRow.rowDef;
          /** @type {?} */

          var context = {
            $implicit: renderRow.data
          };

          this._renderRow(this._rowOutlet, rowDef, renderIndex, context);
        }
        /**
         * Creates a new row template in the outlet and fills it with the set of cell templates.
         * Optionally takes a context to provide to the row and cells, as well as an optional index
         * of where to place the new row template in the outlet.
         * @private
         * @param {?} outlet
         * @param {?} rowDef
         * @param {?} index
         * @param {?=} context
         * @return {?}
         */

      }, {
        key: "_renderRow",
        value: function _renderRow(outlet, rowDef, index) {
          var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
          outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = this._getCellTemplates(rowDef)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var cellTemplate = _step10.value;

              if (CdkCellOutlet.mostRecentCellOutlet) {
                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
              }
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }

          this._changeDetectorRef.markForCheck();
        }
        /**
         * Updates the index-related context for each row to reflect any changes in the index of the rows,
         * e.g. first/last/even/odd.
         * @private
         * @return {?}
         */

      }, {
        key: "_updateRowIndexContext",
        value: function _updateRowIndexContext() {
          /** @type {?} */
          var viewContainer = this._rowOutlet.viewContainer;

          for (var renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
            /** @type {?} */
            var viewRef =
            /** @type {?} */
            viewContainer.get(renderIndex);
            /** @type {?} */

            var context =
            /** @type {?} */
            viewRef.context;
            context.count = count;
            context.first = renderIndex === 0;
            context.last = renderIndex === count - 1;
            context.even = renderIndex % 2 === 0;
            context.odd = !context.even;

            if (this.multiTemplateDataRows) {
              context.dataIndex = this._renderRows[renderIndex].dataIndex;
              context.renderIndex = renderIndex;
            } else {
              context.index = this._renderRows[renderIndex].dataIndex;
            }
          }
        }
        /**
         * Gets the column definitions for the provided row def.
         * @private
         * @param {?} rowDef
         * @return {?}
         */

      }, {
        key: "_getCellTemplates",
        value: function _getCellTemplates(rowDef) {
          var _this160 = this;

          if (!rowDef || !rowDef.columns) {
            return [];
          }

          return Array.from(rowDef.columns,
          /**
          * @param {?} columnId
          * @return {?}
          */
          function (columnId) {
            /** @type {?} */
            var column = _this160._columnDefsByName.get(columnId);

            if (!column) {
              throw getTableUnknownColumnError(columnId);
            }

            return rowDef.extractCellTemplate(column);
          });
        }
        /**
         * Adds native table sections (e.g. tbody) and moves the row outlets into them.
         * @private
         * @return {?}
         */

      }, {
        key: "_applyNativeTableSections",
        value: function _applyNativeTableSections() {
          /** @type {?} */
          var documentFragment = this._document.createDocumentFragment();
          /** @type {?} */


          var sections = [{
            tag: 'thead',
            outlet: this._headerRowOutlet
          }, {
            tag: 'tbody',
            outlet: this._rowOutlet
          }, {
            tag: 'tfoot',
            outlet: this._footerRowOutlet
          }];

          for (var _i3 = 0, _sections = sections; _i3 < _sections.length; _i3++) {
            var section = _sections[_i3];

            /** @type {?} */
            var element = this._document.createElement(section.tag);

            element.setAttribute('role', 'rowgroup');
            element.appendChild(section.outlet.elementRef.nativeElement);
            documentFragment.appendChild(element);
          } // Use a DocumentFragment so we don't hit the DOM on each iteration.


          this._elementRef.nativeElement.appendChild(documentFragment);
        }
        /**
         * Forces a re-render of the data rows. Should be called in cases where there has been an input
         * change that affects the evaluation of which rows should be rendered, e.g. toggling
         * `multiTemplateDataRows` or adding/removing row definitions.
         * @private
         * @return {?}
         */

      }, {
        key: "_forceRenderDataRows",
        value: function _forceRenderDataRows() {
          this._dataDiffer.diff([]);

          this._rowOutlet.viewContainer.clear();

          this.renderRows();
          this.updateStickyColumnStyles();
        }
        /**
         * Checks if there has been a change in sticky states since last check and applies the correct
         * sticky styles. Since checking resets the "dirty" state, this should only be performed once
         * during a change detection and after the inputs are settled (after content check).
         * @private
         * @return {?}
         */

      }, {
        key: "_checkStickyStates",
        value: function _checkStickyStates() {
          /** @type {?} */
          var stickyCheckReducer =
          /**
          * @param {?} acc
          * @param {?} d
          * @return {?}
          */
          function stickyCheckReducer(acc, d) {
            return acc || d.hasStickyChanged();
          }; // Note that the check needs to occur for every definition since it notifies the definition
          // that it can reset its dirty state. Using another operator like `some` may short-circuit
          // remaining definitions and leave them in an unchecked state.


          if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
            this.updateStickyHeaderRowStyles();
          }

          if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
            this.updateStickyFooterRowStyles();
          }

          if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
            this.updateStickyColumnStyles();
          }
        }
        /**
         * Creates the sticky styler that will be used for sticky rows and columns. Listens
         * for directionality changes and provides the latest direction to the styler. Re-applies column
         * stickiness when directionality changes.
         * @private
         * @return {?}
         */

      }, {
        key: "_setupStickyStyler",
        value: function _setupStickyStyler() {
          var _this161 = this;

          /** @type {?} */
          var direction = this._dir ? this._dir.value : 'ltr';
          this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._platform.isBrowser);
          (this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy)).subscribe(
          /**
          * @param {?} value
          * @return {?}
          */
          function (value) {
            _this161._stickyStyler.direction = value;

            _this161.updateStickyColumnStyles();
          });
        }
      }, {
        key: "trackBy",
        get: function get() {
          return this._trackByFn;
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && fn != null && typeof fn !== 'function' &&
          /** @type {?} */
          console &&
          /** @type {?} */
          console.warn) {
            console.warn("trackBy must be a function, but received ".concat(JSON.stringify(fn), "."));
          }

          this._trackByFn = fn;
        }
        /**
         * The table's source of data, which can be provided in three ways (in order of complexity):
         *   - Simple data array (each object represents one table row)
         *   - Stream that emits a data array each time the array changes
         *   - `DataSource` object that implements the connect/disconnect interface.
         *
         * If a data array is provided, the table must be notified when the array's objects are
         * added, removed, or moved. This can be done by calling the `renderRows()` function which will
         * render the diff since the last table render. If the data array reference is changed, the table
         * will automatically trigger an update to the rows.
         *
         * When providing an Observable stream, the table will trigger an update automatically when the
         * stream emits a new array of data.
         *
         * Finally, when providing a `DataSource` object, the table will use the Observable stream
         * provided by the connect function and trigger updates when that stream emits new data array
         * values. During the table's ngOnDestroy or when the data source is removed from the table, the
         * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
         * subscriptions registered during the connect process).
         * @return {?}
         */

      }, {
        key: "dataSource",
        get: function get() {
          return this._dataSource;
        }
        /**
         * @param {?} dataSource
         * @return {?}
         */
        ,
        set: function set(dataSource) {
          if (this._dataSource !== dataSource) {
            this._switchDataSource(dataSource);
          }
        }
        /**
         * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
         * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
         * dataobject will render the first row that evaluates its when predicate to true, in the order
         * defined in the table, or otherwise the default row which does not have a when predicate.
         * @return {?}
         */

      }, {
        key: "multiTemplateDataRows",
        get: function get() {
          return this._multiTemplateDataRows;
        }
        /**
         * @param {?} v
         * @return {?}
         */
        ,
        set: function set(v) {
          this._multiTemplateDataRows = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v); // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),
          // this setter will be invoked before the row outlet has been defined hence the null check.

          if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
            this._forceRenderDataRows();
          }
        }
      }]);

      return CdkTable;
    }();

    CdkTable.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'cdk-table, table[cdk-table]',
        exportAs: 'cdkTable',
        template: CDK_TABLE_TEMPLATE,
        host: {
          'class': 'cdk-table'
        },
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
        // The "OnPush" status for the `MatTable` component is effectively a noop, so we are removing it.
        // The view for `MatTable` consists entirely of templates declared in other views. As they are
        // declared elsewhere, they are checked when their declaration points are checked.
        // tslint:disable-next-line:validate-decorators
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default
      }]
    }];
    /** @nocollapse */

    CdkTable.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"],
          args: ['role']
        }]
      }, {
        type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"]]
        }]
      }, {
        type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"]
      }];
    };

    CdkTable.propDecorators = {
      trackBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dataSource: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      multiTemplateDataRows: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      _rowOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [DataRowOutlet, {
          static: true
        }]
      }],
      _headerRowOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [HeaderRowOutlet, {
          static: true
        }]
      }],
      _footerRowOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [FooterRowOutlet, {
          static: true
        }]
      }],
      _contentColumnDefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [CdkColumnDef]
      }],
      _contentRowDefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [CdkRowDef]
      }],
      _contentHeaderRowDefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [CdkHeaderRowDef]
      }],
      _contentFooterRowDefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [CdkFooterRowDef]
      }]
    };
    /**
     * Utility function that gets a merged list of the entries in a QueryList and values of a Set.
     * @template T
     * @param {?} queryList
     * @param {?} set
     * @return {?}
     */

    function mergeQueryListAndSet(queryList, set) {
      return queryList.toArray().concat(Array.from(set));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Injection token that can be used to specify the text column options.
     * @type {?}
     */


    var TEXT_COLUMN_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('text-column-options');
    /**
     * Column that simply shows text content for the header and row cells. Assumes that the table
     * is using the native table implementation (`<table>`).
     *
     * By default, the name of this column will be the header text and data property accessor.
     * The header text can be overridden with the `headerText` input. Cell values can be overridden with
     * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
     * input.
     * @template T
     */

    var CdkTextColumn =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _table
       * @param {?} _options
       */
      function CdkTextColumn(_table, _options) {
        _classCallCheck(this, CdkTextColumn);

        this._table = _table;
        this._options = _options;
        /**
         * Alignment of the cell values.
         */

        this.justify = 'start';
        this._options = _options || {};
      }
      /**
       * Column name that should be used to reference this column.
       * @return {?}
       */


      _createClass(CdkTextColumn, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this._syncColumnDefName();

          if (this.headerText === undefined) {
            this.headerText = this._createDefaultHeaderText();
          }

          if (!this.dataAccessor) {
            this.dataAccessor = this._options.defaultDataAccessor ||
            /**
            * @param {?} data
            * @param {?} name
            * @return {?}
            */
            function (data, name) {
              return (
                /** @type {?} */
                data[name]
              );
            };
          }

          if (this._table) {
            // Provide the cell and headerCell directly to the table with the static `ViewChild` query,
            // since the columnDef will not pick up its content by the time the table finishes checking
            // its content and initializing the rows.
            this.columnDef.cell = this.cell;
            this.columnDef.headerCell = this.headerCell;

            this._table.addColumnDef(this.columnDef);
          } else {
            throw getTableTextColumnMissingParentTableError();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._table) {
            this._table.removeColumnDef(this.columnDef);
          }
        }
        /**
         * Creates a default header text. Use the options' header text transformation function if one
         * has been provided. Otherwise simply capitalize the column name.
         * @return {?}
         */

      }, {
        key: "_createDefaultHeaderText",
        value: function _createDefaultHeaderText() {
          /** @type {?} */
          var name = this.name;

          if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && !name) {
            throw getTableTextColumnMissingNameError();
          }

          if (this._options && this._options.defaultHeaderTextTransform) {
            return this._options.defaultHeaderTextTransform(name);
          }

          return name[0].toUpperCase() + name.slice(1);
        }
        /**
         * Synchronizes the column definition name with the text column name.
         * @private
         * @return {?}
         */

      }, {
        key: "_syncColumnDefName",
        value: function _syncColumnDefName() {
          if (this.columnDef) {
            this.columnDef.name = this.name;
          }
        }
      }, {
        key: "name",
        get: function get() {
          return this._name;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        ,
        set: function set(name) {
          this._name = name; // With Ivy, inputs can be initialized before static query results are
          // available. In that case, we defer the synchronization until "ngOnInit" fires.

          this._syncColumnDefName();
        }
      }]);

      return CdkTextColumn;
    }();

    CdkTextColumn.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'cdk-text-column',
        template: "\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
        encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
        // Change detection is intentionally not set to OnPush. This component's template will be provided
        // to the table to be inserted into its view. This is problematic when change detection runs since
        // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
        // mean's the template in the table's view will not have the updated value (and in fact will cause
        // an ExpressionChangedAfterItHasBeenCheckedError).
        // tslint:disable-next-line:validate-decorators
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default
      }]
    }];
    /** @nocollapse */

    CdkTextColumn.ctorParameters = function () {
      return [{
        type: CdkTable,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [TEXT_COLUMN_OPTIONS]
        }]
      }];
    };

    CdkTextColumn.propDecorators = {
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      headerText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dataAccessor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      justify: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnDef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [CdkColumnDef, {
          static: true
        }]
      }],
      cell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [CdkCellDef, {
          static: true
        }]
      }],
      headerCell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [CdkHeaderCellDef, {
          static: true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn];

    var CdkTableModule = function CdkTableModule() {
      _classCallCheck(this, CdkTableModule);
    };

    CdkTableModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
        exports: EXPORTED_DECLARATIONS,
        declarations: EXPORTED_DECLARATIONS
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /***/
  },

  /***/
  "./node_modules/decimal.js/decimal.js":
  /*!********************************************!*\
    !*** ./node_modules/decimal.js/decimal.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesDecimalJsDecimalJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;

    ;

    (function (globalScope) {
      'use strict';
      /*
       *  decimal.js v10.2.0
       *  An arbitrary-precision Decimal type for JavaScript.
       *  https://github.com/MikeMcl/decimal.js
       *  Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
       *  MIT Licence
       */
      // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //
      // The maximum exponent magnitude.
      // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.

      var EXP_LIMIT = 9e15,
          // 0 to 9e15
      // The limit on the value of `precision`, and on the value of the first argument to
      // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
      MAX_DIGITS = 1e9,
          // 0 to 1e9
      // Base conversion alphabet.
      NUMERALS = '0123456789abcdef',
          // The natural logarithm of 10 (1025 digits).
      LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',
          // Pi (1025 digits).
      PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',
          // The initial configuration properties of the Decimal constructor.
      DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false // true/false

      },
          // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //
      Decimal,
          inexact,
          noConflict,
          quadrant,
          external = true,
          decimalError = '[DecimalError] ',
          invalidArgument = decimalError + 'Invalid argument: ',
          precisionLimitExceeded = decimalError + 'Precision limit exceeded',
          cryptoUnavailable = decimalError + 'crypto unavailable',
          mathfloor = Math.floor,
          mathpow = Math.pow,
          isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
          isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
          isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
          isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
          BASE = 1e7,
          LOG_BASE = 7,
          MAX_SAFE_INTEGER = 9007199254740991,
          LN10_PRECISION = LN10.length - 1,
          PI_PRECISION = PI.length - 1,
          // Decimal.prototype object
      P = {
        name: '[object Decimal]'
      }; // Decimal prototype methods

      /*
       *  absoluteValue             abs
       *  ceil
       *  comparedTo                cmp
       *  cosine                    cos
       *  cubeRoot                  cbrt
       *  decimalPlaces             dp
       *  dividedBy                 div
       *  dividedToIntegerBy        divToInt
       *  equals                    eq
       *  floor
       *  greaterThan               gt
       *  greaterThanOrEqualTo      gte
       *  hyperbolicCosine          cosh
       *  hyperbolicSine            sinh
       *  hyperbolicTangent         tanh
       *  inverseCosine             acos
       *  inverseHyperbolicCosine   acosh
       *  inverseHyperbolicSine     asinh
       *  inverseHyperbolicTangent  atanh
       *  inverseSine               asin
       *  inverseTangent            atan
       *  isFinite
       *  isInteger                 isInt
       *  isNaN
       *  isNegative                isNeg
       *  isPositive                isPos
       *  isZero
       *  lessThan                  lt
       *  lessThanOrEqualTo         lte
       *  logarithm                 log
       *  [maximum]                 [max]
       *  [minimum]                 [min]
       *  minus                     sub
       *  modulo                    mod
       *  naturalExponential        exp
       *  naturalLogarithm          ln
       *  negated                   neg
       *  plus                      add
       *  precision                 sd
       *  round
       *  sine                      sin
       *  squareRoot                sqrt
       *  tangent                   tan
       *  times                     mul
       *  toBinary
       *  toDecimalPlaces           toDP
       *  toExponential
       *  toFixed
       *  toFraction
       *  toHexadecimal             toHex
       *  toNearest
       *  toNumber
       *  toOctal
       *  toPower                   pow
       *  toPrecision
       *  toSignificantDigits       toSD
       *  toString
       *  truncated                 trunc
       *  valueOf                   toJSON
       */

      /*
       * Return a new Decimal whose value is the absolute value of this Decimal.
       *
       */

      P.absoluteValue = P.abs = function () {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
       * direction of positive Infinity.
       *
       */


      P.ceil = function () {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      /*
       * Return
       *   1    if the value of this Decimal is greater than the value of `y`,
       *  -1    if the value of this Decimal is less than the value of `y`,
       *   0    if they have the same value,
       *   NaN  if the value of either Decimal is NaN.
       *
       */


      P.comparedTo = P.cmp = function (y) {
        var i,
            j,
            xdL,
            ydL,
            x = this,
            xd = x.d,
            yd = (y = new x.constructor(y)).d,
            xs = x.s,
            ys = y.s; // Either NaN or ±Infinity?

        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        } // Either zero?


        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0; // Signs differ?

        if (xs !== ys) return xs; // Compare exponents.

        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length; // Compare digit by digit.

        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        } // Compare lengths.


        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      /*
       * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * cos(0)         = 1
       * cos(-0)        = 1
       * cos(Infinity)  = NaN
       * cos(-Infinity) = NaN
       * cos(NaN)       = NaN
       *
       */


      P.cosine = P.cos = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (!x.d) return new Ctor(NaN); // cos(0) = cos(-0) = 1

        if (!x.d[0]) return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      /*
       *
       * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       *  cbrt(0)  =  0
       *  cbrt(-0) = -0
       *  cbrt(1)  =  1
       *  cbrt(-1) = -1
       *  cbrt(N)  =  N
       *  cbrt(-I) = -I
       *  cbrt(I)  =  I
       *
       * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
       *
       */


      P.cubeRoot = P.cbrt = function () {
        var e,
            m,
            n,
            r,
            rep,
            s,
            sd,
            t,
            t3,
            t3plusx,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false; // Initial estimate.

        s = x.s * mathpow(x.s * x, 1 / 3); // Math.cbrt underflow/overflow?
        // Pass x to Math.pow as integer, then adjust the exponent of the result.

        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e; // Adjust n exponent so it is a multiple of 3 away from x exponent.

          if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? '0' : '00';
          s = mathpow(n, 1 / 3); // Rarely, e may be one less than the result exponent value.

          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

          if (s == 1 / 0) {
            n = '5e' + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf('e') + 1) + e;
          }

          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }

        sd = (e = Ctor.precision) + 3; // Halley's method.
        // TODO? Compare Newton's method.

        for (;;) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1); // TODO? Replace with for-loop and checkRoundingDigits.

          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
            // , i.e. approaching a rounding boundary, continue the iteration.

            if (n == '9999' || !rep && n == '4999') {
              // On the first iteration only, check to see if rounding up gives the exact result as the
              // nines may infinitely repeat.
              if (!rep) {
                finalise(t, e + 1, 0);

                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              sd += 4;
              rep = 1;
            } else {
              // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
              // If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                // Truncate to the first rounding digit.
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }

              break;
            }
          }
        }

        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      /*
       * Return the number of decimal places of the value of this Decimal.
       *
       */


      P.decimalPlaces = P.dp = function () {
        var w,
            d = this.d,
            n = NaN;

        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last word.

          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) {
            n--;
          }
          if (n < 0) n = 0;
        }

        return n;
      };
      /*
       *  n / 0 = I
       *  n / N = N
       *  n / I = 0
       *  0 / n = 0
       *  0 / 0 = N
       *  0 / N = N
       *  0 / I = 0
       *  N / n = N
       *  N / 0 = N
       *  N / N = N
       *  N / I = N
       *  I / n = I
       *  I / 0 = I
       *  I / N = N
       *  I / I = N
       *
       * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       */


      P.dividedBy = P.div = function (y) {
        return divide(this, new this.constructor(y));
      };
      /*
       * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
       * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
       *
       */


      P.dividedToIntegerBy = P.divToInt = function (y) {
        var x = this,
            Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      /*
       * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
       *
       */


      P.equals = P.eq = function (y) {
        return this.cmp(y) === 0;
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
       * direction of negative Infinity.
       *
       */


      P.floor = function () {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      /*
       * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
       * false.
       *
       */


      P.greaterThan = P.gt = function (y) {
        return this.cmp(y) > 0;
      };
      /*
       * Return true if the value of this Decimal is greater than or equal to the value of `y`,
       * otherwise return false.
       *
       */


      P.greaterThanOrEqualTo = P.gte = function (y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      /*
       * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [1, Infinity]
       *
       * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
       *
       * cosh(0)         = 1
       * cosh(-0)        = 1
       * cosh(Infinity)  = Infinity
       * cosh(-Infinity) = Infinity
       * cosh(NaN)       = NaN
       *
       *  x        time taken (ms)   result
       * 1000      9                 9.8503555700852349694e+433
       * 10000     25                4.4034091128314607936e+4342
       * 100000    171               1.4033316802130615897e+43429
       * 1000000   3817              1.5166076984010437725e+434294
       * 10000000  abandoned after 2 minute wait
       *
       * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
       *
       */


      P.hyperbolicCosine = P.cosh = function () {
        var k,
            n,
            pr,
            rm,
            len,
            x = this,
            Ctor = x.constructor,
            one = new Ctor(1);
        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length; // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
        // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))
        // Estimate the optimum number of times to use the argument reduction.
        // TODO? Estimation reused from cosine() and may not be optimal here.

        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = '2.3283064365386962890625e-10';
        }

        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true); // Reverse argument reduction

        var cosh2_x,
            i = k,
            d8 = new Ctor(8);

        for (; i--;) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }

        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      /*
       * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
       *
       * sinh(0)         = 0
       * sinh(-0)        = -0
       * sinh(Infinity)  = Infinity
       * sinh(-Infinity) = -Infinity
       * sinh(NaN)       = NaN
       *
       * x        time taken (ms)
       * 10       2 ms
       * 100      5 ms
       * 1000     14 ms
       * 10000    82 ms
       * 100000   886 ms            1.4033316802130615897e+43429
       * 200000   2613 ms
       * 300000   5407 ms
       * 400000   8824 ms
       * 500000   13026 ms          8.7080643612718084129e+217146
       * 1000000  48543 ms
       *
       * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
       *
       */


      P.hyperbolicSine = P.sinh = function () {
        var k,
            pr,
            rm,
            len,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;

        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
          // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
          // 3 multiplications and 1 addition
          // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
          // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
          // 4 multiplications and 2 additions
          // Estimate the optimum number of times to use the argument reduction.
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true); // Reverse argument reduction

          var sinh2_x,
              d5 = new Ctor(5),
              d16 = new Ctor(16),
              d20 = new Ctor(20);

          for (; k--;) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }

        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      /*
       * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * tanh(x) = sinh(x) / cosh(x)
       *
       * tanh(0)         = 0
       * tanh(-0)        = -0
       * tanh(Infinity)  = 1
       * tanh(-Infinity) = -1
       * tanh(NaN)       = NaN
       *
       */


      P.hyperbolicTangent = P.tanh = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      /*
       * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
       * this Decimal.
       *
       * Domain: [-1, 1]
       * Range: [0, pi]
       *
       * acos(x) = pi/2 - asin(x)
       *
       * acos(0)       = pi/2
       * acos(-0)      = pi/2
       * acos(1)       = 0
       * acos(-1)      = pi
       * acos(1/2)     = pi/3
       * acos(-1/2)    = 2*pi/3
       * acos(|x| > 1) = NaN
       * acos(NaN)     = NaN
       *
       */


      P.inverseCosine = P.acos = function () {
        var halfPi,
            x = this,
            Ctor = x.constructor,
            k = x.abs().cmp(1),
            pr = Ctor.precision,
            rm = Ctor.rounding;

        if (k !== -1) {
          return k === 0 // |x| is 1
          ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) // |x| > 1 or x is NaN
          : new Ctor(NaN);
        }

        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5); // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
       * value of this Decimal.
       *
       * Domain: [1, Infinity]
       * Range: [0, Infinity]
       *
       * acosh(x) = ln(x + sqrt(x^2 - 1))
       *
       * acosh(x < 1)     = NaN
       * acosh(NaN)       = NaN
       * acosh(Infinity)  = Infinity
       * acosh(-Infinity) = NaN
       * acosh(0)         = NaN
       * acosh(-0)        = NaN
       * acosh(1)         = 0
       * acosh(-1)        = NaN
       *
       */


      P.inverseHyperbolicCosine = P.acosh = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
       * of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * asinh(x) = ln(x + sqrt(x^2 + 1))
       *
       * asinh(NaN)       = NaN
       * asinh(Infinity)  = Infinity
       * asinh(-Infinity) = -Infinity
       * asinh(0)         = 0
       * asinh(-0)        = -0
       *
       */


      P.inverseHyperbolicSine = P.asinh = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
       * value of this Decimal.
       *
       * Domain: [-1, 1]
       * Range: [-Infinity, Infinity]
       *
       * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
       *
       * atanh(|x| > 1)   = NaN
       * atanh(NaN)       = NaN
       * atanh(Infinity)  = NaN
       * atanh(-Infinity) = NaN
       * atanh(0)         = 0
       * atanh(-0)        = -0
       * atanh(1)         = Infinity
       * atanh(-1)        = -Infinity
       *
       */


      P.inverseHyperbolicTangent = P.atanh = function () {
        var pr,
            rm,
            wpr,
            xsd,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      /*
       * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
       * Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi/2, pi/2]
       *
       * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
       *
       * asin(0)       = 0
       * asin(-0)      = -0
       * asin(1/2)     = pi/6
       * asin(-1/2)    = -pi/6
       * asin(1)       = pi/2
       * asin(-1)      = -pi/2
       * asin(|x| > 1) = NaN
       * asin(NaN)     = NaN
       *
       * TODO? Compare performance of Taylor series.
       *
       */


      P.inverseSine = P.asin = function () {
        var halfPi,
            k,
            pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (x.isZero()) return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;

        if (k !== -1) {
          // |x| is 1
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          } // |x| > 1 or x is NaN


          return new Ctor(NaN);
        } // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6


        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      /*
       * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
       * of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi/2, pi/2]
       *
       * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
       *
       * atan(0)         = 0
       * atan(-0)        = -0
       * atan(1)         = pi/4
       * atan(-1)        = -pi/4
       * atan(Infinity)  = pi/2
       * atan(-Infinity) = -pi/2
       * atan(NaN)       = NaN
       *
       */


      P.inverseTangent = P.atan = function () {
        var i,
            j,
            k,
            n,
            px,
            t,
            r,
            wpr,
            x2,
            x = this,
            Ctor = x.constructor,
            pr = Ctor.precision,
            rm = Ctor.rounding;

        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);

          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }

        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1; // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
        // Argument reduction
        // Ensure |x| < 0.42
        // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

        k = Math.min(28, wpr / LOG_BASE + 2 | 0);

        for (i = k; i; --i) {
          x = x.div(x.times(x).plus(1).sqrt().plus(1));
        }

        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x; // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...

        for (; i !== -1;) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;) {
            ;
          }
        }

        if (k) r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      /*
       * Return true if the value of this Decimal is a finite number, otherwise return false.
       *
       */


      P.isFinite = function () {
        return !!this.d;
      };
      /*
       * Return true if the value of this Decimal is an integer, otherwise return false.
       *
       */


      P.isInteger = P.isInt = function () {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      /*
       * Return true if the value of this Decimal is NaN, otherwise return false.
       *
       */


      P.isNaN = function () {
        return !this.s;
      };
      /*
       * Return true if the value of this Decimal is negative, otherwise return false.
       *
       */


      P.isNegative = P.isNeg = function () {
        return this.s < 0;
      };
      /*
       * Return true if the value of this Decimal is positive, otherwise return false.
       *
       */


      P.isPositive = P.isPos = function () {
        return this.s > 0;
      };
      /*
       * Return true if the value of this Decimal is 0 or -0, otherwise return false.
       *
       */


      P.isZero = function () {
        return !!this.d && this.d[0] === 0;
      };
      /*
       * Return true if the value of this Decimal is less than `y`, otherwise return false.
       *
       */


      P.lessThan = P.lt = function (y) {
        return this.cmp(y) < 0;
      };
      /*
       * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
       *
       */


      P.lessThanOrEqualTo = P.lte = function (y) {
        return this.cmp(y) < 1;
      };
      /*
       * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * If no base is specified, return log[10](arg).
       *
       * log[base](arg) = ln(arg) / ln(base)
       *
       * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
       * otherwise:
       *
       * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
       * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
       * between the result and the correctly rounded result will be one ulp (unit in the last place).
       *
       * log[-b](a)       = NaN
       * log[0](a)        = NaN
       * log[1](a)        = NaN
       * log[NaN](a)      = NaN
       * log[Infinity](a) = NaN
       * log[b](0)        = -Infinity
       * log[b](-0)       = -Infinity
       * log[b](-a)       = NaN
       * log[b](1)        = 0
       * log[b](Infinity) = Infinity
       * log[b](NaN)      = NaN
       *
       * [base] {number|string|Decimal} The base of the logarithm.
       *
       */


      P.logarithm = P.log = function (base) {
        var isBase10,
            d,
            denominator,
            k,
            inf,
            num,
            sd,
            r,
            arg = this,
            Ctor = arg.constructor,
            pr = Ctor.precision,
            rm = Ctor.rounding,
            guard = 5; // Default base is 10.

        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d; // Return NaN if base is negative, or non-finite, or is 0 or 1.

          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
          isBase10 = base.eq(10);
        }

        d = arg.d; // Is arg negative, non-finite, 0 or 1?

        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        } // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
        // integer power of 10.


        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0;) {
              k /= 10;
            }

            inf = k !== 1;
          }
        }

        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd); // The result will have 5 rounding digits.

        r = divide(num, denominator, sd, 1); // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
        // calculate 10 further digits.
        //
        // If the result is known to have an infinite decimal expansion, repeat this until it is clear
        // that the result is above or below the boundary. Otherwise, if after calculating the 10
        // further digits, the last 14 are nines, round up and assume the result is exact.
        // Also assume the result is exact if the last 14 are zero.
        //
        // Example of a result that will be incorrectly rounded:
        // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
        // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
        // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
        // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
        // place is still 2.6.

        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);

            if (!inf) {
              // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }

              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }

        external = true;
        return finalise(r, pr, rm);
      };
      /*
       * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
       *
       * arguments {number|string|Decimal}
       *
      P.max = function () {
        Array.prototype.push.call(arguments, this);
        return maxOrMin(this.constructor, arguments, 'lt');
      };
       */

      /*
       * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
       *
       * arguments {number|string|Decimal}
       *
      P.min = function () {
        Array.prototype.push.call(arguments, this);
        return maxOrMin(this.constructor, arguments, 'gt');
      };
       */

      /*
       *  n - 0 = n
       *  n - N = N
       *  n - I = -I
       *  0 - n = -n
       *  0 - 0 = 0
       *  0 - N = N
       *  0 - I = -I
       *  N - n = N
       *  N - 0 = N
       *  N - N = N
       *  N - I = N
       *  I - n = I
       *  I - 0 = I
       *  I - N = N
       *  I - I = N
       *
       * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */


      P.minus = P.sub = function (y) {
        var d,
            e,
            i,
            j,
            k,
            len,
            pr,
            rm,
            xd,
            xe,
            xLTy,
            yd,
            x = this,
            Ctor = x.constructor;
        y = new Ctor(y); // If either is not finite...

        if (!x.d || !y.d) {
          // Return NaN if either is NaN.
          if (!x.s || !y.s) y = new Ctor(NaN); // Return y negated if x is finite and y is ±Infinity.
          else if (x.d) y.s = -y.s; // Return x if y is finite and x is ±Infinity.
            // Return x if both are ±Infinity with different signs.
            // Return NaN if both are ±Infinity with the same sign.
            else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        } // If signs differ...


        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }

        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding; // If either is zero...

        if (!xd[0] || !yd[0]) {
          // Return y negated if x is zero and y is non-zero.
          if (yd[0]) y.s = -y.s; // Return x if y is zero and x is non-zero.
          else if (xd[0]) y = new Ctor(x); // Return zero if both are zero.
            // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
            else return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        } // x and y are finite, non-zero numbers with the same sign.
        // Calculate base 1e7 exponents.


        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e; // If base 1e7 exponents differ...

        if (k) {
          xLTy = k < 0;

          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          } // Numbers with massively different exponents would result in a very high number of
          // zeros needing to be prepended, but this can be avoided while still ensuring correct
          // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.


          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

          if (k > i) {
            k = i;
            d.length = 1;
          } // Prepend zeros to equalise exponents.


          d.reverse();

          for (i = k; i--;) {
            d.push(0);
          }

          d.reverse(); // Base 1e7 exponents equal.
        } else {
          // Check digits to determine which is the bigger number.
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;

          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }

          k = 0;
        }

        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }

        len = xd.length; // Append zeros to `xd` if shorter.
        // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.

        for (i = yd.length - len; i > 0; --i) {
          xd[len++] = 0;
        } // Subtract yd from xd.


        for (i = yd.length; i > k;) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0;) {
              xd[j] = BASE - 1;
            }

            --xd[j];
            xd[i] += BASE;
          }

          xd[i] -= yd[i];
        } // Remove trailing zeros.


        for (; xd[--len] === 0;) {
          xd.pop();
        } // Remove leading zeros and adjust exponent accordingly.


        for (; xd[0] === 0; xd.shift()) {
          --e;
        } // Zero?


        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      /*
       *   n % 0 =  N
       *   n % N =  N
       *   n % I =  n
       *   0 % n =  0
       *  -0 % n = -0
       *   0 % 0 =  N
       *   0 % N =  N
       *   0 % I =  0
       *   N % n =  N
       *   N % 0 =  N
       *   N % N =  N
       *   N % I =  N
       *   I % n =  N
       *   I % 0 =  N
       *   I % N =  N
       *   I % I =  N
       *
       * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * The result depends on the modulo mode.
       *
       */


      P.modulo = P.mod = function (y) {
        var q,
            x = this,
            Ctor = x.constructor;
        y = new Ctor(y); // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.

        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN); // Return x if y is ±Infinity or x is ±0.

        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        } // Prevent rounding of intermediate calculations.


        external = false;

        if (Ctor.modulo == 9) {
          // Euclidian division: q = sign(y) * floor(x / abs(y))
          // result = x - q * y    where  0 <= result < abs(y)
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }

        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      /*
       * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
       * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */


      P.naturalExponential = P.exp = function () {
        return naturalExponential(this);
      };
      /*
       * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
       * rounded to `precision` significant digits using rounding mode `rounding`.
       *
       */


      P.naturalLogarithm = P.ln = function () {
        return naturalLogarithm(this);
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
       * -1.
       *
       */


      P.negated = P.neg = function () {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      /*
       *  n + 0 = n
       *  n + N = N
       *  n + I = I
       *  0 + n = n
       *  0 + 0 = 0
       *  0 + N = N
       *  0 + I = I
       *  N + n = N
       *  N + 0 = N
       *  N + N = N
       *  N + I = N
       *  I + n = I
       *  I + 0 = I
       *  I + N = N
       *  I + I = I
       *
       * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       */


      P.plus = P.add = function (y) {
        var carry,
            d,
            e,
            i,
            k,
            len,
            pr,
            rm,
            xd,
            yd,
            x = this,
            Ctor = x.constructor;
        y = new Ctor(y); // If either is not finite...

        if (!x.d || !y.d) {
          // Return NaN if either is NaN.
          if (!x.s || !y.s) y = new Ctor(NaN); // Return x if y is finite and x is ±Infinity.
          // Return x if both are ±Infinity with the same sign.
          // Return NaN if both are ±Infinity with different signs.
          // Return y if x is finite and y is ±Infinity.
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        } // If signs differ...


        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }

        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding; // If either is zero...

        if (!xd[0] || !yd[0]) {
          // Return x if y is zero.
          // Return y if y is non-zero.
          if (!yd[0]) y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        } // x and y are finite, non-zero numbers with the same sign.
        // Calculate base 1e7 exponents.


        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e; // If base 1e7 exponents differ...

        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          } // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.


          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;

          if (i > len) {
            i = len;
            d.length = 1;
          } // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.


          d.reverse();

          for (; i--;) {
            d.push(0);
          }

          d.reverse();
        }

        len = xd.length;
        i = yd.length; // If yd is longer than xd, swap xd and yd so xd points to the longer array.

        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        } // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.


        for (carry = 0; i;) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }

        if (carry) {
          xd.unshift(carry);
          ++e;
        } // Remove trailing zeros.
        // No need to check for zero, as +x + +y != 0 && -x + -y != 0


        for (len = xd.length; xd[--len] == 0;) {
          xd.pop();
        }

        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      /*
       * Return the number of significant digits of the value of this Decimal.
       *
       * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
       *
       */


      P.precision = P.sd = function (z) {
        var k,
            x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }

        return k;
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
       * rounding mode `rounding`.
       *
       */


      P.round = function () {
        var x = this,
            Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      /*
       * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-1, 1]
       *
       * sin(x) = x - x^3/3! + x^5/5! - ...
       *
       * sin(0)         = 0
       * sin(-0)        = -0
       * sin(Infinity)  = NaN
       * sin(-Infinity) = NaN
       * sin(NaN)       = NaN
       *
       */


      P.sine = P.sin = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      /*
       * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       *  sqrt(-n) =  N
       *  sqrt(N)  =  N
       *  sqrt(-I) =  N
       *  sqrt(I)  =  I
       *  sqrt(0)  =  0
       *  sqrt(-0) = -0
       *
       */


      P.squareRoot = P.sqrt = function () {
        var m,
            n,
            sd,
            r,
            rep,
            t,
            x = this,
            d = x.d,
            e = x.e,
            s = x.s,
            Ctor = x.constructor; // Negative/NaN/Infinity/zero?

        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }

        external = false; // Initial estimate.

        s = Math.sqrt(+x); // Math.sqrt underflow/overflow?
        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e) % 2 == 0) n += '0';
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

          if (s == 1 / 0) {
            n = '1e' + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf('e') + 1) + e;
          }

          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }

        sd = (e = Ctor.precision) + 3; // Newton-Raphson iteration.

        for (;;) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5); // TODO? Replace with for-loop and checkRoundingDigits.

          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
            // 4999, i.e. approaching a rounding boundary, continue the iteration.

            if (n == '9999' || !rep && n == '4999') {
              // On the first iteration only, check to see if rounding up gives the exact result as the
              // nines may infinitely repeat.
              if (!rep) {
                finalise(t, e + 1, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              sd += 4;
              rep = 1;
            } else {
              // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
              // If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                // Truncate to the first rounding digit.
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }

        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      /*
       * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-Infinity, Infinity]
       *
       * tan(0)         = 0
       * tan(-0)        = -0
       * tan(Infinity)  = NaN
       * tan(-Infinity) = NaN
       * tan(NaN)       = NaN
       *
       */


      P.tangent = P.tan = function () {
        var pr,
            rm,
            x = this,
            Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      /*
       *  n * 0 = 0
       *  n * N = N
       *  n * I = I
       *  0 * n = 0
       *  0 * 0 = 0
       *  0 * N = N
       *  0 * I = N
       *  N * n = N
       *  N * 0 = N
       *  N * N = N
       *  N * I = N
       *  I * n = I
       *  I * 0 = N
       *  I * N = N
       *  I * I = I
       *
       * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       */


      P.times = P.mul = function (y) {
        var carry,
            e,
            i,
            k,
            r,
            rL,
            t,
            xdL,
            ydL,
            x = this,
            Ctor = x.constructor,
            xd = x.d,
            yd = (y = new Ctor(y)).d;
        y.s *= x.s; // If either is NaN, ±Infinity or ±0...

        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd // Return NaN if either is NaN.
          // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
          ? NaN // Return ±Infinity if either is ±Infinity.
          // Return ±0 if either is ±0.
          : !xd || !yd ? y.s / 0 : y.s * 0);
        }

        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length; // Ensure xd points to the longer array.

        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        } // Initialise the result array with zeros.


        r = [];
        rL = xdL + ydL;

        for (i = rL; i--;) {
          r.push(0);
        } // Multiply!


        for (i = ydL; --i >= 0;) {
          carry = 0;

          for (k = xdL + i; k > i;) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }

          r[k] = (r[k] + carry) % BASE | 0;
        } // Remove trailing zeros.


        for (; !r[--rL];) {
          r.pop();
        }

        if (carry) ++e;else r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      /*
       * Return a string representing the value of this Decimal in base 2, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toBinary = function (sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
       * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
       *
       * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toDecimalPlaces = P.toDP = function (dp, rm) {
        var x = this,
            Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0) return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      /*
       * Return a string representing the value of this Decimal in exponential notation rounded to
       * `dp` fixed decimal places using rounding mode `rounding`.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toExponential = function (dp, rm) {
        var str,
            x = this,
            Ctor = x.constructor;

        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }

        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };
      /*
       * Return a string representing the value of this Decimal in normal (fixed-point) notation to
       * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
       * omitted.
       *
       * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
       *
       * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
       * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
       * (-0).toFixed(3) is '0.000'.
       * (-0.5).toFixed(0) is '-0'.
       *
       */


      P.toFixed = function (dp, rm) {
        var str,
            y,
            x = this,
            Ctor = x.constructor;

        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        } // To determine whether to add the minus sign look at the value before it was rounded,
        // i.e. look at `x` rather than `y`.


        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };
      /*
       * Return an array representing the value of this Decimal as a simple fraction with an integer
       * numerator and an integer denominator.
       *
       * The denominator will be a positive non-zero value less than or equal to the specified maximum
       * denominator. If a maximum denominator is not specified, the denominator will be the lowest
       * value necessary to represent the number exactly.
       *
       * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
       *
       */


      P.toFraction = function (maxD) {
        var d,
            d0,
            d1,
            d2,
            e,
            k,
            n,
            n0,
            n1,
            pr,
            q,
            r,
            x = this,
            xd = x.d,
            Ctor = x.constructor;
        if (!xd) return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

        if (maxD == null) {
          // d is 10**e, the minimum max-denominator needed.
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }

        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;

        for (;;) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }

        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s; // Determine which fraction is closer to x, n0/d0 or n1/d1?

        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      /*
       * Return a string representing the value of this Decimal in base 16, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toHexadecimal = P.toHex = function (sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      /*
       * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
       * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
       *
       * The return value will always have the same sign as this Decimal, unless either this Decimal
       * or `y` is NaN, in which case the return value will be also be NaN.
       *
       * The return value is not affected by the value of `precision`.
       *
       * y {number|string|Decimal} The magnitude to round to a multiple of.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * 'toNearest() rounding mode not an integer: {rm}'
       * 'toNearest() rounding mode out of range: {rm}'
       *
       */


      P.toNearest = function (y, rm) {
        var x = this,
            Ctor = x.constructor;
        x = new Ctor(x);

        if (y == null) {
          // If x is not finite, return x.
          if (!x.d) return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);

          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          } // If x is not finite, return x if y is not NaN, else NaN.


          if (!x.d) return y.s ? x : y; // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.

          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        } // If y is not zero, calculate the nearest multiple of y to x.


        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x); // If y is zero, return zero with the sign of x.
        } else {
          y.s = x.s;
          x = y;
        }

        return x;
      };
      /*
       * Return the value of this Decimal converted to a number primitive.
       * Zero keeps its sign.
       *
       */


      P.toNumber = function () {
        return +this;
      };
      /*
       * Return a string representing the value of this Decimal in base 8, round to `sd` significant
       * digits using rounding mode `rm`.
       *
       * If the optional `sd` argument is present then return binary exponential notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toOctal = function (sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
       * to `precision` significant digits using rounding mode `rounding`.
       *
       * ECMAScript compliant.
       *
       *   pow(x, NaN)                           = NaN
       *   pow(x, ±0)                            = 1
         *   pow(NaN, non-zero)                    = NaN
       *   pow(abs(x) > 1, +Infinity)            = +Infinity
       *   pow(abs(x) > 1, -Infinity)            = +0
       *   pow(abs(x) == 1, ±Infinity)           = NaN
       *   pow(abs(x) < 1, +Infinity)            = +0
       *   pow(abs(x) < 1, -Infinity)            = +Infinity
       *   pow(+Infinity, y > 0)                 = +Infinity
       *   pow(+Infinity, y < 0)                 = +0
       *   pow(-Infinity, odd integer > 0)       = -Infinity
       *   pow(-Infinity, even integer > 0)      = +Infinity
       *   pow(-Infinity, odd integer < 0)       = -0
       *   pow(-Infinity, even integer < 0)      = +0
       *   pow(+0, y > 0)                        = +0
       *   pow(+0, y < 0)                        = +Infinity
       *   pow(-0, odd integer > 0)              = -0
       *   pow(-0, even integer > 0)             = +0
       *   pow(-0, odd integer < 0)              = -Infinity
       *   pow(-0, even integer < 0)             = +Infinity
       *   pow(finite x < 0, finite non-integer) = NaN
       *
       * For non-integer or very large exponents pow(x, y) is calculated using
       *
       *   x^y = exp(y*ln(x))
       *
       * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
       * probability of an incorrectly rounded result
       * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
       * i.e. 1 in 250,000,000,000,000
       *
       * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
       *
       * y {number|string|Decimal} The power to which to raise this Decimal.
       *
       */


      P.toPower = P.pow = function (y) {
        var e,
            k,
            pr,
            r,
            rm,
            s,
            x = this,
            Ctor = x.constructor,
            yn = +(y = new Ctor(y)); // Either ±Infinity, NaN or ±0?

        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1)) return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1)) return finalise(x, pr, rm); // y exponent

        e = mathfloor(y.e / LOG_BASE); // If y is a small integer use the 'exponentiation by squaring' algorithm.

        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }

        s = x.s; // if x is negative

        if (s < 0) {
          // if y is not an integer
          if (e < y.d.length - 1) return new Ctor(NaN); // Result is positive if x is negative and the last digit of integer y is even.

          if ((y.d[e] & 1) == 0) s = 1; // if x.eq(-1)

          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        } // Estimate result exponent.
        // x^y = 10^e,  where e = y * log10(x)
        // log10(x) = log10(x_significand) + x_exponent
        // log10(x_significand) = ln(x_significand) / ln(10)


        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + '').e; // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.
        // Overflow/underflow?

        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1; // Estimate the extra guard digits needed to ensure five correct rounding digits from
        // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
        // new Decimal(2.32456).pow('2087987436534566.46411')
        // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815

        k = Math.min(12, (e + '').length); // r = x^y = exp(y*ln(x))

        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr); // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)

        if (r.d) {
          // Truncate to the required precision plus five rounding digits.
          r = finalise(r, pr + 5, 1); // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
          // the result.

          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10; // Truncate to the increased precision plus five rounding digits.

            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1); // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).

            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }

        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      /*
       * Return a string representing the value of this Decimal rounded to `sd` significant digits
       * using rounding mode `rounding`.
       *
       * Return exponential notation if `sd` is less than the number of digits necessary to represent
       * the integer part of the value in normal notation.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       */


      P.toPrecision = function (sd, rm) {
        var str,
            x = this,
            Ctor = x.constructor;

        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }

        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
       * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
       * omitted.
       *
       * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
       * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
       *
       * 'toSD() digits out of range: {sd}'
       * 'toSD() digits not an integer: {sd}'
       * 'toSD() rounding mode not an integer: {rm}'
       * 'toSD() rounding mode out of range: {rm}'
       *
       */


      P.toSignificantDigits = P.toSD = function (sd, rm) {
        var x = this,
            Ctor = x.constructor;

        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
        }

        return finalise(new Ctor(x), sd, rm);
      };
      /*
       * Return a string representing the value of this Decimal.
       *
       * Return exponential notation if this Decimal has a positive exponent equal to or greater than
       * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
       *
       */


      P.toString = function () {
        var x = this,
            Ctor = x.constructor,
            str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? '-' + str : str;
      };
      /*
       * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
       *
       */


      P.truncated = P.trunc = function () {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      /*
       * Return a string representing the value of this Decimal.
       * Unlike `toString`, negative zero will include the minus sign.
       *
       */


      P.valueOf = P.toJSON = function () {
        var x = this,
            Ctor = x.constructor,
            str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? '-' + str : str;
      };
      /*
      // Add aliases to match BigDecimal method names.
      // P.add = P.plus;
      P.subtract = P.minus;
      P.multiply = P.times;
      P.divide = P.div;
      P.remainder = P.mod;
      P.compareTo = P.cmp;
      P.negate = P.neg;
       */
      // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.

      /*
       *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
       *                           finiteToString, naturalExponential, naturalLogarithm
       *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
       *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
       *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
       *  convertBase              toStringBinary, parseOther
       *  cos                      P.cos
       *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
       *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
       *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
       *                           taylorSeries, atan2, parseOther
       *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
       *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
       *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
       *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
       *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
       *                           P.truncated, divide, getLn10, getPi, naturalExponential,
       *                           naturalLogarithm, ceil, floor, round, trunc
       *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
       *                           toStringBinary
       *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
       *  getLn10                  P.logarithm, naturalLogarithm
       *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
       *  getPrecision             P.precision, P.toFraction
       *  getZeroString            digitsToString, finiteToString
       *  intPow                   P.toPower, parseOther
       *  isOdd                    toLessThanHalfPi
       *  maxOrMin                 max, min
       *  naturalExponential       P.naturalExponential, P.toPower
       *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
       *                           P.toPower, naturalExponential
       *  nonFiniteToString        finiteToString, toStringBinary
       *  parseDecimal             Decimal
       *  parseOther               Decimal
       *  sin                      P.sin
       *  taylorSeries             P.cosh, P.sinh, cos, sin
       *  toLessThanHalfPi         P.cos, P.sin
       *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
       *  truncate                 intPow
       *
       *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
       *                           naturalLogarithm, config, parseOther, random, Decimal
       */


      function digitsToString(d) {
        var i,
            k,
            ws,
            indexOfLastWord = d.length - 1,
            str = '',
            w = d[0];

        if (indexOfLastWord > 0) {
          str += w;

          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + '';
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }

          w = d[i];
          ws = w + '';
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return '0';
        } // Remove trailing zeros of last w.


        for (; w % 10 === 0;) {
          w /= 10;
        }

        return str + w;
      }

      function checkInt32(i, min, max) {
        if (i !== ~~i || i < min || i > max) {
          throw Error(invalidArgument + i);
        }
      }
      /*
       * Check 5 rounding digits if `repeating` is null, 4 otherwise.
       * `repeating == null` if caller is `log` or `pow`,
       * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
       */


      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd; // Get the length of the first word of the array d.

        for (k = d[0]; k >= 10; k /= 10) {
          --i;
        } // Is the rounding digit in the first word of d?


        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        } // i is the index (0 - 6) of the rounding digit.
        // E.g. if within the word 3487563 the first rounding digit is 5,
        // then i = 4, k = 1000, rd = 3487563 % 1000 = 563


        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;

        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1000 | 0;else if (i == 1) rd = rd / 100 | 0;else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
          }
        }

        return r;
      } // Convert string of `baseIn` to an array of numbers of `baseOut`.
      // Eg. convertBase('255', 10, 16) returns [15, 15].
      // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].


      function convertBase(str, baseIn, baseOut) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            strL = str.length;

        for (; i < strL;) {
          for (arrL = arr.length; arrL--;) {
            arr[arrL] *= baseIn;
          }

          arr[0] += NUMERALS.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }
      /*
       * cos(x) = 1 - x^2/2! + x^4/4! - ...
       * |x| < pi/2
       *
       */


      function cosine(Ctor, x) {
        var k,
            y,
            len = x.d.length; // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
        // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1
        // Estimate the optimum number of times to use the argument reduction.

        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = '2.3283064365386962890625e-10';
        }

        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1)); // Reverse argument reduction

        for (var i = k; i--;) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }

        Ctor.precision -= k;
        return x;
      }
      /*
       * Perform division in the specified base.
       */


      var divide = function () {
        // Assumes non-zero x and k, and hence non-zero result.
        function multiplyInteger(x, k, base) {
          var temp,
              carry = 0,
              i = x.length;

          for (x = x.slice(); i--;) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }

          if (carry) x.unshift(carry);
          return x;
        }

        function compare(a, b, aL, bL) {
          var i, r;

          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }

          return r;
        }

        function subtract(a, b, aL, base) {
          var i = 0; // Subtract b from a.

          for (; aL--;) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          } // Remove leading zeros.


          for (; !a[0] && a.length > 1;) {
            a.shift();
          }
        }

        return function (x, y, pr, rm, dp, base) {
          var cmp,
              e,
              i,
              k,
              logBase,
              more,
              prod,
              prodL,
              q,
              qd,
              rem,
              remL,
              rem0,
              sd,
              t,
              xi,
              xL,
              yd0,
              yL,
              yz,
              Ctor = x.constructor,
              sign = x.s == y.s ? 1 : -1,
              xd = x.d,
              yd = y.d; // Either NaN, Infinity or 0?

          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor( // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
          }

          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }

          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign);
          qd = q.d = []; // Result exponent may be one less than e.
          // The digit array of a Decimal from toStringBinary may have trailing zeros.

          for (i = 0; yd[i] == (xd[i] || 0); i++) {
            ;
          }

          if (yd[i] > (xd[i] || 0)) e--;

          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }

          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            // Convert precision in number of base 10 digits to base 1e7 digits.
            sd = sd / logBase + 2 | 0;
            i = 0; // divisor < 1e7

            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++; // k is the carry.

              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }

              more = k || i < xL; // divisor >= 1e7
            } else {
              // Normalise xd and yd so highest order digit of yd is >= base/2
              k = base / (yd[0] + 1) | 0;

              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }

              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length; // Add zeros to make remainder as long as divisor.

              for (; remL < yL;) {
                rem[remL++] = 0;
              }

              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2) ++yd0;

              do {
                k = 0; // Compare divisor and remainder.

                cmp = compare(yd, rem, yL, remL); // If divisor < remainder.

                if (cmp < 0) {
                  // Calculate trial digit, k.
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // k will be how many times the divisor goes into the current remainder.

                  k = rem0 / yd0 | 0; //  Algorithm:
                  //  1. product = divisor * trial digit (k)
                  //  2. if product > remainder: product -= divisor, k--
                  //  3. remainder -= product
                  //  4. if product was < remainder at 2:
                  //    5. compare new remainder and divisor
                  //    6. If remainder > divisor: remainder -= divisor, k++

                  if (k > 1) {
                    if (k >= base) k = base - 1; // product = divisor * trial digit.

                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length; // Compare product and remainder.

                    cmp = compare(prod, rem, prodL, remL); // product > remainder.

                    if (cmp == 1) {
                      k--; // Subtract divisor from product.

                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    // cmp is -1.
                    // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                    // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }

                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0); // Subtract product from remainder.

                  subtract(rem, prod, remL, base); // If product was < previous remainder.

                  if (cmp == -1) {
                    remL = rem.length; // Compare divisor and new remainder.

                    cmp = compare(yd, rem, yL, remL); // If divisor < new remainder, subtract divisor from remainder.

                    if (cmp < 1) {
                      k++; // Subtract divisor from remainder.

                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }

                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                } // if cmp === 1, k will be 0
                // Add the next digit, k, to the result array.


                qd[i++] = k; // Update the remainder.

                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);

              more = rem[0] !== void 0;
            } // Leading zero?


            if (!qd[0]) qd.shift();
          } // logBase is 1 when divide is being used for base conversion.


          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {
            // To calculate q.e, first get the number of digits of qd[0].
            for (i = 1, k = qd[0]; k >= 10; k /= 10) {
              i++;
            }

            q.e = i + e * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }

          return q;
        };
      }();
      /*
       * Round `x` to `sd` significant digits using rounding mode `rm`.
       * Check for over/under-flow.
       */


      function finalise(x, sd, rm, isTruncated) {
        var digits,
            i,
            j,
            k,
            rd,
            roundUp,
            w,
            xd,
            xdi,
            Ctor = x.constructor; // Don't round if sd is null or undefined.

        out: if (sd != null) {
          xd = x.d; // Infinity/NaN.

          if (!xd) return x; // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
          // w: the word of xd containing rd, a base 1e7 number.
          // xdi: the index of w within xd.
          // digits: the number of digits of w.
          // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
          // they had leading zeros)
          // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).
          // Get the length of the first word of the digits array xd.

          for (digits = 1, k = xd[0]; k >= 10; k /= 10) {
            digits++;
          }

          i = sd - digits; // Is the rounding digit in the first word of xd?

          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0]; // Get the rounding digit at index j of w.

            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;

            if (xdi >= k) {
              if (isTruncated) {
                // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
                for (; k++ <= xdi;) {
                  xd.push(0);
                }

                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi]; // Get the number of digits of w.

              for (digits = 1; k >= 10; k /= 10) {
                digits++;
              } // Get the index of rd within w.


              i %= LOG_BASE; // Get the index of rd within w, adjusted for leading zeros.
              // The number of leading zeros of w is given by LOG_BASE - digits.

              j = i - LOG_BASE + digits; // Get the rounding digit at index j of w.

              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          } // Are there any non-zero digits after the rounding digit?


          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1)); // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
          // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
          // will give 714.

          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xd[0]) {
            xd.length = 0;

            if (roundUp) {
              // Convert sd to decimal places.
              sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              // Zero.
              xd[0] = x.e = 0;
            }

            return x;
          } // Remove excess digits.


          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i); // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of w.

            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }

          if (roundUp) {
            for (;;) {
              // Is the digit to be rounded up in the first word of xd?
              if (xdi == 0) {
                // i will be the length of xd[0] before k is added.
                for (i = 1, j = xd[0]; j >= 10; j /= 10) {
                  i++;
                }

                j = xd[0] += k;

                for (k = 1; j >= 10; j /= 10) {
                  k++;
                } // if i != k the length has increased.


                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }

                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          } // Remove trailing zeros.


          for (i = xd.length; xd[--i] === 0;) {
            xd.pop();
          }
        }

        if (external) {
          // Overflow?
          if (x.e > Ctor.maxE) {
            // Infinity.
            x.d = null;
            x.e = NaN; // Underflow?
          } else if (x.e < Ctor.minE) {
            // Zero.
            x.e = 0;
            x.d = [0]; // Ctor.underflow = true;
          } // else Ctor.underflow = false;

        }

        return x;
      }

      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k,
            e = x.e,
            str = digitsToString(x.d),
            len = str.length;

        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + '.' + str.slice(1);
          }

          str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
        } else if (e < 0) {
          str = '0.' + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);

          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += '.';
            str += getZeroString(k);
          }
        }

        return str;
      } // Calculate the base 10 exponent from the base 1e7 exponent.


      function getBase10Exponent(digits, e) {
        var w = digits[0]; // Add the number of digits of the first word of the digits array.

        for (e *= LOG_BASE; w >= 10; w /= 10) {
          e++;
        }

        return e;
      }

      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          // Reset global state in case the exception is caught.
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }

        return finalise(new Ctor(LN10), sd, 1, true);
      }

      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }

      function getPrecision(digits) {
        var w = digits.length - 1,
            len = w * LOG_BASE + 1;
        w = digits[w]; // If non-zero...

        if (w) {
          // Subtract the number of trailing zeros of the last word.
          for (; w % 10 == 0; w /= 10) {
            len--;
          } // Add the number of digits of the first word.


          for (w = digits[0]; w >= 10; w /= 10) {
            len++;
          }
        }

        return len;
      }

      function getZeroString(k) {
        var zs = '';

        for (; k--;) {
          zs += '0';
        }

        return zs;
      }
      /*
       * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
       * integer of type number.
       *
       * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
       *
       */


      function intPow(Ctor, x, n, pr) {
        var isTruncated,
            r = new Ctor(1),
            // Max n of 9007199254740991 takes 53 loop iterations.
        // Maximum digits array length; leaves [28, 34] guard digits.
        k = Math.ceil(pr / LOG_BASE + 4);
        external = false;

        for (;;) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }

          n = mathfloor(n / 2);

          if (n === 0) {
            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }

          x = x.times(x);
          truncate(x.d, k);
        }

        external = true;
        return r;
      }

      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      /*
       * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
       */


      function maxOrMin(Ctor, args, ltgt) {
        var y,
            x = new Ctor(args[0]),
            i = 0;

        for (; ++i < args.length;) {
          y = new Ctor(args[i]);

          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }

        return x;
      }
      /*
       * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
       * digits.
       *
       * Taylor/Maclaurin series.
       *
       * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
       *
       * Argument reduction:
       *   Repeat x = x / 32, k += 5, until |x| < 0.1
       *   exp(x) = exp(x / 2^k)^(2^k)
       *
       * Previously, the argument was initially reduced by
       * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
       * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
       * found to be slower than just dividing repeatedly by 32 as above.
       *
       * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
       * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
       * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
       *
       *  exp(Infinity)  = Infinity
       *  exp(-Infinity) = 0
       *  exp(NaN)       = NaN
       *  exp(±0)        = 1
       *
       *  exp(x) is non-terminating for any finite, non-zero x.
       *
       *  The result will always be correctly rounded.
       *
       */


      function naturalExponential(x, sd) {
        var denominator,
            guard,
            j,
            pow,
            sum,
            t,
            wpr,
            rep = 0,
            i = 0,
            k = 0,
            Ctor = x.constructor,
            rm = Ctor.rounding,
            pr = Ctor.precision; // 0/NaN/Infinity?

        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }

        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }

        t = new Ctor(0.03125); // while abs(x) >= 0.1

        while (x.e > -2) {
          // x = x / 2^5
          x = x.times(t);
          k += 5;
        } // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
        // necessary to ensure the first 4 rounding digits are correct.


        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow = sum = new Ctor(1);
        Ctor.precision = wpr;

        for (;;) {
          pow = finalise(pow.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum.plus(divide(pow, denominator, wpr, 1));

          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            j = k;

            while (j--) {
              sum = finalise(sum.times(sum), wpr, 1);
            } // Check to see if the first 4 rounding digits are [49]999.
            // If so, repeat the summation with a higher precision, otherwise
            // e.g. with precision: 18, rounding: 1
            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
            // `wpr - guard` is the index of first rounding digit.


            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }

          sum = t;
        }
      }
      /*
       * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
       * digits.
       *
       *  ln(-n)        = NaN
       *  ln(0)         = -Infinity
       *  ln(-0)        = -Infinity
       *  ln(1)         = 0
       *  ln(Infinity)  = Infinity
       *  ln(-Infinity) = NaN
       *  ln(NaN)       = NaN
       *
       *  ln(n) (n != 1) is non-terminating.
       *
       */


      function naturalLogarithm(y, sd) {
        var c,
            c0,
            denominator,
            e,
            numerator,
            rep,
            sum,
            t,
            wpr,
            x1,
            x2,
            n = 1,
            guard = 10,
            x = y,
            xd = x.d,
            Ctor = x.constructor,
            rm = Ctor.rounding,
            pr = Ctor.precision; // Is x negative or Infinity, NaN, 0 or 1?

        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }

        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }

        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);

        if (Math.abs(e = x.e) < 1.5e15) {
          // Argument reduction.
          // The series converges faster the closer the argument is to 1, so using
          // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
          // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
          // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
          // later be divided by this number, then separate out the power of 10 using
          // ln(a*10^b) = ln(a) + b*ln(10).
          // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
          //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
          // max n is 6 (gives 0.7 - 1.3)
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }

          e = x.e;

          if (c0 > 1) {
            x = new Ctor('0.' + c);
            e++;
          } else {
            x = new Ctor(c0 + '.' + c.slice(1));
          }
        } else {
          // The argument reduction method above may result in overflow if the argument y is a massive
          // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
          // function using ln(x*10^e) = ln(x) + e*ln(10).
          t = getLn10(Ctor, wpr + 2, pr).times(e + '');
          x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        } // x1 is x reduced to a value near 1.


        x1 = x; // Taylor series.
        // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
        // where x = (y - 1)/(y + 1)    (|x| < 1)

        sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;

        for (;;) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            sum = sum.times(2); // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.

            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
            sum = divide(sum, new Ctor(n), wpr, 1); // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
            // been repeated previously) and the first 4 rounding digits 9999?
            // If so, restart the summation with a higher precision, otherwise
            // e.g. with precision: 12, rounding: 1
            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
            // `wpr - guard` is the index of first rounding digit.

            if (sd == null) {
              if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum;
            }
          }

          sum = t;
          denominator += 2;
        }
      } // ±Infinity, NaN.


      function nonFiniteToString(x) {
        // Unsigned.
        return String(x.s * x.s / 0);
      }
      /*
       * Parse the value of a new Decimal `x` from string `str`.
       */


      function parseDecimal(x, str) {
        var e, i, len; // Decimal point?

        if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

        if ((i = str.search(/e/i)) > 0) {
          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          // Integer.
          e = str.length;
        } // Determine leading zeros.


        for (i = 0; str.charCodeAt(i) === 48; i++) {
          ;
        } // Determine trailing zeros.


        for (len = str.length; str.charCodeAt(len - 1) === 48; --len) {
          ;
        }

        str = str.slice(i, len);

        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = []; // Transform base
          // e is the base 10 exponent.
          // i is where to slice str to get the first word of the digits array.

          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;

          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.d.push(+str.slice(i, i += LOG_BASE));
            }

            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }

          for (; i--;) {
            str += '0';
          }

          x.d.push(+str);

          if (external) {
            // Overflow?
            if (x.e > x.constructor.maxE) {
              // Infinity.
              x.d = null;
              x.e = NaN; // Underflow?
            } else if (x.e < x.constructor.minE) {
              // Zero.
              x.e = 0;
              x.d = [0]; // x.constructor.underflow = true;
            } // else x.constructor.underflow = false;

          }
        } else {
          // Zero.
          x.e = 0;
          x.d = [0];
        }

        return x;
      }
      /*
       * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
       */


      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

        if (str === 'Infinity' || str === 'NaN') {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }

        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        } // Is there a binary exponent part?


        i = str.search(/p/i);

        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        } // Convert `str` as an integer then divide the result by `base` raised to a power such that the
        // fraction part will be restored.


        i = str.indexOf('.');
        isFloat = i >= 0;
        Ctor = x.constructor;

        if (isFloat) {
          str = str.replace('.', '');
          len = str.length;
          i = len - i; // log[10](16) = 1.2041... , log[10](88) = 1.9444....

          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }

        xd = convertBase(str, base, BASE);
        xe = xd.length - 1; // Remove trailing zeros.

        for (i = xe; xd[i] === 0; --i) {
          xd.pop();
        }

        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false; // At what precision to perform the division to ensure exact conversion?
        // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
        // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
        // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
        // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
        // Therefore using 4 * the number of digits of str will always be enough.

        if (isFloat) x = divide(x, divisor, len * 4); // Multiply by the binary exponent part if present.

        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;
        return x;
      }
      /*
       * sin(x) = x - x^3/3! + x^5/5! - ...
       * |x| < pi/2
       *
       */


      function sine(Ctor, x) {
        var k,
            len = x.d.length;
        if (len < 3) return taylorSeries(Ctor, 2, x, x); // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
        // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
        // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))
        // Estimate the optimum number of times to use the argument reduction.

        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x); // Reverse argument reduction

        var sin2_x,
            d5 = new Ctor(5),
            d16 = new Ctor(16),
            d20 = new Ctor(20);

        for (; k--;) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }

        return x;
      } // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.


      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j,
            t,
            u,
            x2,
            i = 1,
            pr = Ctor.precision,
            k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);

        for (;;) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);

          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--;) {
              ;
            }

            if (j == -1) break;
          }

          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }

        external = true;
        t.d.length = k + 1;
        return t;
      } // Exponent e must be positive and non-zero.


      function tinyPow(b, e) {
        var n = b;

        while (--e) {
          n *= b;
        }

        return n;
      } // Return the absolute value of `x` reduced to less than or equal to half pi.


      function toLessThanHalfPi(Ctor, x) {
        var t,
            isNeg = x.s < 0,
            pi = getPi(Ctor, Ctor.precision, 1),
            halfPi = pi.times(0.5);
        x = x.abs();

        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }

        t = x.divToInt(pi);

        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi)); // 0 <= x < pi

          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }

          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }

        return x.minus(pi).abs();
      }
      /*
       * Return the value of Decimal `x` as a string in base `baseOut`.
       *
       * If the optional `sd` argument is present include a binary exponent suffix.
       */


      function toStringBinary(x, baseOut, sd, rm) {
        var base,
            e,
            i,
            k,
            len,
            roundUp,
            str,
            xd,
            y,
            Ctor = x.constructor,
            isExp = sd !== void 0;

        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }

        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf('.'); // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
          // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
          // minBinaryExponent = floor(decimalExponent * log[2](10))
          // log[2](10) = 3.321928094887362347870319429489390175864

          if (isExp) {
            base = 2;

            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          } // Convert the number as an integer then divide the result by its base raised to a power such
          // that the fraction part will be restored.
          // Non-integer.


          if (i >= 0) {
            str = str.replace('.', '');
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }

          xd = convertBase(str, 10, base);
          e = len = xd.length; // Remove trailing zeros.

          for (; xd[--len] == 0;) {
            xd.pop();
          }

          if (!xd[0]) {
            str = isExp ? '0p+0' : '0';
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            } // The rounding digit, i.e. the digit after the digit that may be rounded up.


            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;

            if (roundUp) {
              // Rounding up may mean the previous digit has to be rounded up and so on.
              for (; ++xd[--sd] > base - 1;) {
                xd[sd] = 0;

                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            } // Determine trailing zeros.


            for (len = xd.length; !xd[len - 1]; --len) {
              ;
            } // E.g. [4, 11, 15] becomes 4bf.


            for (i = 0, str = ''; i < len; i++) {
              str += NUMERALS.charAt(xd[i]);
            } // Add binary exponent suffix?


            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;

                  for (--len; len % i; len++) {
                    str += '0';
                  }

                  xd = convertBase(str, base, baseOut);

                  for (len = xd.length; !xd[len - 1]; --len) {
                    ;
                  } // xd[0] will always be be 1


                  for (i = 1, str = '1.'; i < len; i++) {
                    str += NUMERALS.charAt(xd[i]);
                  }
                } else {
                  str = str.charAt(0) + '.' + str.slice(1);
                }
              }

              str = str + (e < 0 ? 'p' : 'p+') + e;
            } else if (e < 0) {
              for (; ++e;) {
                str = '0' + str;
              }

              str = '0.' + str;
            } else {
              if (++e > len) for (e -= len; e--;) {
                str += '0';
              } else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
            }
          }

          str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
        }

        return x.s < 0 ? '-' + str : str;
      } // Does not strip trailing zeros.


      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      } // Decimal methods

      /*
       *  abs
       *  acos
       *  acosh
       *  add
       *  asin
       *  asinh
       *  atan
       *  atanh
       *  atan2
       *  cbrt
       *  ceil
       *  clone
       *  config
       *  cos
       *  cosh
       *  div
       *  exp
       *  floor
       *  hypot
       *  ln
       *  log
       *  log2
       *  log10
       *  max
       *  min
       *  mod
       *  mul
       *  pow
       *  random
       *  round
       *  set
       *  sign
       *  sin
       *  sinh
       *  sqrt
       *  sub
       *  tan
       *  tanh
       *  trunc
       */

      /*
       * Return a new Decimal whose value is the absolute value of `x`.
       *
       * x {number|string|Decimal}
       *
       */


      function abs(x) {
        return new this(x).abs();
      }
      /*
       * Return a new Decimal whose value is the arccosine in radians of `x`.
       *
       * x {number|string|Decimal}
       *
       */


      function acos(x) {
        return new this(x).acos();
      }
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function acosh(x) {
        return new this(x).acosh();
      }
      /*
       * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */


      function add(x, y) {
        return new this(x).plus(y);
      }
      /*
       * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function asin(x) {
        return new this(x).asin();
      }
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function asinh(x) {
        return new this(x).asinh();
      }
      /*
       * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function atan(x) {
        return new this(x).atan();
      }
      /*
       * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
       * `precision` significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function atanh(x) {
        return new this(x).atanh();
      }
      /*
       * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
       * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * Domain: [-Infinity, Infinity]
       * Range: [-pi, pi]
       *
       * y {number|string|Decimal} The y-coordinate.
       * x {number|string|Decimal} The x-coordinate.
       *
       * atan2(±0, -0)               = ±pi
       * atan2(±0, +0)               = ±0
       * atan2(±0, -x)               = ±pi for x > 0
       * atan2(±0, x)                = ±0 for x > 0
       * atan2(-y, ±0)               = -pi/2 for y > 0
       * atan2(y, ±0)                = pi/2 for y > 0
       * atan2(±y, -Infinity)        = ±pi for finite y > 0
       * atan2(±y, +Infinity)        = ±0 for finite y > 0
       * atan2(±Infinity, x)         = ±pi/2 for finite x
       * atan2(±Infinity, -Infinity) = ±3*pi/4
       * atan2(±Infinity, +Infinity) = ±pi/4
       * atan2(NaN, x) = NaN
       * atan2(y, NaN) = NaN
       *
       */


      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r,
            pr = this.precision,
            rm = this.rounding,
            wpr = pr + 4; // Either NaN

        if (!y.s || !x.s) {
          r = new this(NaN); // Both ±Infinity
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s; // x is ±Infinity or y is ±0
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s; // y is ±Infinity or x is ±0
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s; // Both non-zero and finite
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }

        return r;
      }
      /*
       * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function cbrt(x) {
        return new this(x).cbrt();
      }
      /*
       * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
       *
       * x {number|string|Decimal}
       *
       */


      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      /*
       * Configure global settings for a Decimal constructor.
       *
       * `obj` is an object with one or more of the following properties,
       *
       *   precision  {number}
       *   rounding   {number}
       *   toExpNeg   {number}
       *   toExpPos   {number}
       *   maxE       {number}
       *   minE       {number}
       *   modulo     {number}
       *   crypto     {boolean|number}
       *   defaults   {true}
       *
       * E.g. Decimal.config({ precision: 20, rounding: 4 })
       *
       */


      function config(obj) {
        if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
        var i,
            p,
            v,
            useDefaults = obj.defaults === true,
            ps = ['precision', 1, MAX_DIGITS, 'rounding', 0, 8, 'toExpNeg', -EXP_LIMIT, 0, 'toExpPos', 0, EXP_LIMIT, 'maxE', 0, EXP_LIMIT, 'minE', -EXP_LIMIT, 0, 'modulo', 0, 9];

        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];

          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;else throw Error(invalidArgument + p + ': ' + v);
          }
        }

        if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];

        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ': ' + v);
          }
        }

        return this;
      }
      /*
       * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function cos(x) {
        return new this(x).cos();
      }
      /*
       * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function cosh(x) {
        return new this(x).cosh();
      }
      /*
       * Create and return a Decimal constructor with the same configuration properties as this Decimal
       * constructor.
       *
       */


      function clone(obj) {
        var i, p, ps;
        /*
         * The Decimal constructor and exported function.
         * Return a new Decimal instance.
         *
         * v {number|string|Decimal} A numeric value.
         *
         */

        function Decimal(v) {
          var e,
              i,
              t,
              x = this; // Decimal called without new.

          if (!(x instanceof Decimal)) return new Decimal(v); // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
          // which points to Object.

          x.constructor = Decimal; // Duplicate.

          if (v instanceof Decimal) {
            x.s = v.s;

            if (external) {
              if (!v.d || v.e > Decimal.maxE) {
                // Infinity.
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal.minE) {
                // Zero.
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }

            return;
          }

          t = typeof v;

          if (t === 'number') {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }

            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            } // Fast path for small integers.


            if (v === ~~v && v < 1e7) {
              for (e = 0, i = v; i >= 10; i /= 10) {
                e++;
              }

              if (external) {
                if (e > Decimal.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }

              return; // Infinity, NaN.
            } else if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }

            return parseDecimal(x, v.toString());
          } else if (t !== 'string') {
            throw Error(invalidArgument + v);
          } // Minus sign?


          if ((i = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            // Plus sign?
            if (i === 43) v = v.slice(1);
            x.s = 1;
          }

          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }

        Decimal.prototype = P;
        Decimal.ROUND_UP = 0;
        Decimal.ROUND_DOWN = 1;
        Decimal.ROUND_CEIL = 2;
        Decimal.ROUND_FLOOR = 3;
        Decimal.ROUND_HALF_UP = 4;
        Decimal.ROUND_HALF_DOWN = 5;
        Decimal.ROUND_HALF_EVEN = 6;
        Decimal.ROUND_HALF_CEIL = 7;
        Decimal.ROUND_HALF_FLOOR = 8;
        Decimal.EUCLID = 9;
        Decimal.config = Decimal.set = config;
        Decimal.clone = clone;
        Decimal.isDecimal = isDecimalInstance;
        Decimal.abs = abs;
        Decimal.acos = acos;
        Decimal.acosh = acosh; // ES6

        Decimal.add = add;
        Decimal.asin = asin;
        Decimal.asinh = asinh; // ES6

        Decimal.atan = atan;
        Decimal.atanh = atanh; // ES6

        Decimal.atan2 = atan2;
        Decimal.cbrt = cbrt; // ES6

        Decimal.ceil = ceil;
        Decimal.cos = cos;
        Decimal.cosh = cosh; // ES6

        Decimal.div = div;
        Decimal.exp = exp;
        Decimal.floor = floor;
        Decimal.hypot = hypot; // ES6

        Decimal.ln = ln;
        Decimal.log = log;
        Decimal.log10 = log10; // ES6

        Decimal.log2 = log2; // ES6

        Decimal.max = max;
        Decimal.min = min;
        Decimal.mod = mod;
        Decimal.mul = mul;
        Decimal.pow = pow;
        Decimal.random = random;
        Decimal.round = round;
        Decimal.sign = sign; // ES6

        Decimal.sin = sin;
        Decimal.sinh = sinh; // ES6

        Decimal.sqrt = sqrt;
        Decimal.sub = sub;
        Decimal.tan = tan;
        Decimal.tanh = tanh; // ES6

        Decimal.trunc = trunc; // ES6

        if (obj === void 0) obj = {};

        if (obj) {
          if (obj.defaults !== true) {
            ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];

            for (i = 0; i < ps.length;) {
              if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
            }
          }
        }

        Decimal.config(obj);
        return Decimal;
      }
      /*
       * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */


      function div(x, y) {
        return new this(x).div(y);
      }
      /*
       * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} The power to which to raise the base of the natural log.
       *
       */


      function exp(x) {
        return new this(x).exp();
      }
      /*
       * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
       *
       * x {number|string|Decimal}
       *
       */


      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      /*
       * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
       * rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
       *
       * arguments {number|string|Decimal}
       *
       */


      function hypot() {
        var i,
            n,
            t = new this(0);
        external = false;

        for (i = 0; i < arguments.length;) {
          n = new this(arguments[i++]);

          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }

            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }

        external = true;
        return t.sqrt();
      }
      /*
       * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
       * otherwise return false.
       *
       */


      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;
      }
      /*
       * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function ln(x) {
        return new this(x).ln();
      }
      /*
       * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
       * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
       *
       * log[y](x)
       *
       * x {number|string|Decimal} The argument of the logarithm.
       * y {number|string|Decimal} The base of the logarithm.
       *
       */


      function log(x, y) {
        return new this(x).log(y);
      }
      /*
       * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function log2(x) {
        return new this(x).log(2);
      }
      /*
       * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function log10(x) {
        return new this(x).log(10);
      }
      /*
       * Return a new Decimal whose value is the maximum of the arguments.
       *
       * arguments {number|string|Decimal}
       *
       */


      function max() {
        return maxOrMin(this, arguments, 'lt');
      }
      /*
       * Return a new Decimal whose value is the minimum of the arguments.
       *
       * arguments {number|string|Decimal}
       *
       */


      function min() {
        return maxOrMin(this, arguments, 'gt');
      }
      /*
       * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */


      function mod(x, y) {
        return new this(x).mod(y);
      }
      /*
       * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */


      function mul(x, y) {
        return new this(x).mul(y);
      }
      /*
       * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} The base.
       * y {number|string|Decimal} The exponent.
       *
       */


      function pow(x, y) {
        return new this(x).pow(y);
      }
      /*
       * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
       * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
       * are produced).
       *
       * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
       *
       */


      function random(sd) {
        var d,
            e,
            k,
            n,
            i = 0,
            r = new this(1),
            rd = [];
        if (sd === void 0) sd = this.precision;else checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);

        if (!this.crypto) {
          for (; i < k;) {
            rd[i++] = Math.random() * 1e7 | 0;
          } // Browsers supporting crypto.getRandomValues.

        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));

          for (; i < k;) {
            n = d[i]; // 0 <= n < 4294967296
            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).

            if (n >= 4.29e9) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              // 0 <= n <= 4289999999
              // 0 <= (n % 1e7) <= 9999999
              rd[i++] = n % 1e7;
            }
          } // Node.js supporting crypto.randomBytes.

        } else if (crypto.randomBytes) {
          // buffer
          d = crypto.randomBytes(k *= 4);

          for (; i < k;) {
            // 0 <= n < 2147483648
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24); // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).

            if (n >= 2.14e9) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              // 0 <= n <= 2139999999
              // 0 <= (n % 1e7) <= 9999999
              rd.push(n % 1e7);
              i += 4;
            }
          }

          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }

        k = rd[--i];
        sd %= LOG_BASE; // Convert trailing digits to zeros according to sd.

        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        } // Remove trailing words which are zero.


        for (; rd[i] === 0; i--) {
          rd.pop();
        } // Zero?


        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1; // Remove leading words which are zero and adjust exponent accordingly.

          for (; rd[0] === 0; e -= LOG_BASE) {
            rd.shift();
          } // Count the digits of the first word of rd to determine leading zeros.


          for (k = 1, n = rd[0]; n >= 10; n /= 10) {
            k++;
          } // Adjust the exponent for leading zeros of the first word of rd.


          if (k < LOG_BASE) e -= LOG_BASE - k;
        }

        r.e = e;
        r.d = rd;
        return r;
      }
      /*
       * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
       *
       * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
       *
       * x {number|string|Decimal}
       *
       */


      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      /*
       * Return
       *   1    if x > 0,
       *  -1    if x < 0,
       *   0    if x is 0,
       *  -0    if x is -0,
       *   NaN  otherwise
       *
       * x {number|string|Decimal}
       *
       */


      function sign(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      /*
       * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function sin(x) {
        return new this(x).sin();
      }
      /*
       * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function sinh(x) {
        return new this(x).sinh();
      }
      /*
       * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       *
       */


      function sqrt(x) {
        return new this(x).sqrt();
      }
      /*
       * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
       * using rounding mode `rounding`.
       *
       * x {number|string|Decimal}
       * y {number|string|Decimal}
       *
       */


      function sub(x, y) {
        return new this(x).sub(y);
      }
      /*
       * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
       * digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function tan(x) {
        return new this(x).tan();
      }
      /*
       * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
       * significant digits using rounding mode `rounding`.
       *
       * x {number|string|Decimal} A value in radians.
       *
       */


      function tanh(x) {
        return new this(x).tanh();
      }
      /*
       * Return a new Decimal whose value is `x` truncated to an integer.
       *
       * x {number|string|Decimal}
       *
       */


      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      } // Create and configure initial Decimal constructor.


      Decimal = clone(DEFAULTS);
      Decimal['default'] = Decimal.Decimal = Decimal; // Create the internal constants from their string values.

      LN10 = new Decimal(LN10);
      PI = new Decimal(PI); // Export.
      // AMD.

      if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return Decimal;
        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // Node and other environments that support module.exports.
      } else {}
    })(this);
    /***/

  },

  /***/
  "./src/app/shared/modal/modal.service.ts":
  /*!***********************************************!*\
    !*** ./src/app/shared/modal/modal.service.ts ***!
    \***********************************************/

  /*! exports provided: ModalService */

  /***/
  function srcAppSharedModalModalServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ModalService", function () {
      return ModalService;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @ng-bootstrap/ng-bootstrap */
    "./node_modules/@ng-bootstrap/ng-bootstrap/fesm2015/ng-bootstrap.js");
    /* harmony import */


    var _modal_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./modal.component */
    "./src/app/shared/modal/modal.component.ts");

    var ModalService =
    /*#__PURE__*/
    function () {
      // @Input() fromParent;
      function ModalService(ngbModalService) {
        _classCallCheck(this, ModalService);

        this.ngbModalService = ngbModalService;
      }

      _createClass(ModalService, [{
        key: "open",
        value: function open(modalOptions) {
          var modalRef = this.ngbModalService.open(_modal_component__WEBPACK_IMPORTED_MODULE_3__["ModalComponent"], {
            scrollable: true,
            centered: true // keyboard: false,
            // backdrop: 'static'

          });
          var data = modalOptions;
          modalRef.componentInstance.fromParent = data;
          console.log(modalRef.componentInstance.fromParent);
          modalRef.result.then(function (result) {
            console.log(result);
          }, function (reason) {
            console.log(reason);
          });
        }
      }]);

      return ModalService;
    }();

    ModalService.ctorParameters = function () {
      return [{
        type: _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_2__["NgbModal"]
      }];
    };

    ModalService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
      providedIn: 'root'
    })], ModalService);
    /***/
  }
}]);
//# sourceMappingURL=default~login-login-module~main-main-module-es5.js.map