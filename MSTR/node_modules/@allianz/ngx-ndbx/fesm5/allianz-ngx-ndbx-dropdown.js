import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { CommonModule } from '@angular/common';
import { NxCheckboxModule } from '@allianz/ngx-ndbx/checkbox';
import { ActiveDescendantKeyManager, A11yModule } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, SHIFT, TAB } from '@angular/cdk/keycodes';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { __extends, __spread } from 'tslib';
import { NxFormfieldControl, NxFormfieldComponent, NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { Subject, defer, merge } from 'rxjs';
import { takeUntil, filter, map, startWith, switchMap, take } from 'rxjs/operators';
import { Input, ChangeDetectionStrategy, Component, ChangeDetectorRef, ElementRef, EventEmitter, Inject, Optional, Output, ViewChild, Directive, TemplateRef, Attribute, ContentChildren, isDevMode, NgZone, Self, ContentChild, NgModule } from '@angular/core';
import { ObserversModule } from '@angular/cdk/observers';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 * @return {?}
 */
function getNxDropdownNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var NxDropdownControl = /** @class */ (function (_super) {
    __extends(NxDropdownControl, _super);
    function NxDropdownControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */
        _this.isMultiSelect = false;
        return _this;
    }
    NxDropdownControl.propDecorators = {
        isMultiSelect: [{ type: Input, args: ['nxIsMultiselect',] }]
    };
    return NxDropdownControl;
}(NxFormfieldControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownGroupComponent = /** @class */ (function () {
    function NxDropdownGroupComponent() {
    }
    NxDropdownGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown-group',
                    template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background-color:rgba(236,236,236,.5)}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-style:italic;padding:24px 32px 16px;font-weight:700;font-size:12px;line-height:16px}"]
                }] }
    ];
    NxDropdownGroupComponent.propDecorators = {
        label: [{ type: Input, args: ['nxLabel',] }]
    };
    return NxDropdownGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownItemChange = /** @class */ (function () {
    function NxDropdownItemChange(item, isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.item = item;
        this.isUserInput = isUserInput;
    }
    return NxDropdownItemChange;
}());
/**
 * the unique id counter
 * @type {?}
 */
var nextId = 0;
var NxDropdownItemComponent = /** @class */ (function () {
    function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
        var _this = this;
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = "nx-dropdown-item-" + nextId++;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._hidden = false;
        }));
    }
    Object.defineProperty(NxDropdownItemComponent.prototype, "id", {
        /** The unique ID of the option. */
        get: /**
         * The unique ID of the option.
         * @return {?}
         */
        function () { return this._id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "selected", {
        /** Whether the item is selected. */
        get: /**
         * Whether the item is selected.
         * @return {?}
         */
        function () {
            return this._selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "active", {
        /** Whether the item is active. */
        get: /**
         * Whether the item is active.
         * @return {?}
         */
        function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "multiselect", {
        /**
         * @docs-private
         * Whether the parent dropdown is in multiselect mode.
         */
        get: /**
         * \@docs-private
         * Whether the parent dropdown is in multiselect mode.
         * @return {?}
         */
        function () {
            return this._dropdown && this._dropdown.isMultiSelect;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            var viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    };
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxDropdownItemComponent.prototype._onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    };
    /**
    * `Selects the option while indicating the selection came from the user. Used to
    * determine if the select's view -> model callback should be invoked.`
    */
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    NxDropdownItemComponent.prototype._selectViaInteraction = /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    function () {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.show = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.hide = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    NxDropdownItemComponent.prototype._showOrHideByFilter = /**
     * @private
     * @param {?} search
     * @return {?}
     */
    function (search) {
        /** @type {?} */
        var constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    };
    Object.defineProperty(NxDropdownItemComponent.prototype, "_formattedValue", {
        get: /**
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownItemComponent.prototype, "viewValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this._elementRef.nativeElement.textContent || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.select = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.deselect = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.focus = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    NxDropdownItemComponent.prototype._emitSelectionChangeEvent = /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    function (isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.setActiveStyles = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.setInactiveStyles = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownItemComponent.prototype.getLabel = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.value;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NxDropdownItemComponent.prototype._isContentEmpty = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return element.children.length === 0 && !element.textContent.trim();
    };
    /**
     * @return {?}
     */
    NxDropdownItemComponent.prototype._onLabelChange = /**
     * @return {?}
     */
    function () {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    };
    NxDropdownItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown-item',
                    template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[id]': 'id',
                        'role': 'option',
                        '[attr.aria-selected]': 'selected.toString()',
                        '[class.nx-hidden]': '_hidden',
                        '[class.nx-dropdown-item--active]': 'active',
                        '[class.nx-selected]': 'selected',
                        '[class.nx-multiselect]': 'multiselect',
                        '(click)': '_onClick($event)'
                    },
                    styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-multiselect) ::ng-deep .nx-checkbox__label{height:28px;display:flex;align-items:center}:host(.nx-dropdown-item--active),:host:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active),:host:hover{color:highlightText}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}.nx-dropdown-results__option-checkicon{opacity:0;width:16px;height:16px;margin-right:8px}.nx-dropdown-results__option-checkicon nx-icon{font-size:16px}:host-context([data-whatinput=keyboard]).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
                }] }
    ];
    /** @nocollapse */
    NxDropdownItemComponent.ctorParameters = function () { return [
        { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
        { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    NxDropdownItemComponent.propDecorators = {
        value: [{ type: Input, args: ['nxValue',] }],
        onSelectionChange: [{ type: Output }],
        containerElement: [{ type: ViewChild, args: ['container',] }]
    };
    return NxDropdownItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This Directive solely purpose is to mark given ng-template and project it into the required destination.
var NxDropdownClosedLabelDirective = /** @class */ (function () {
    function NxDropdownClosedLabelDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NxDropdownClosedLabelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxClosedLabel]'
                },] }
    ];
    /** @nocollapse */
    NxDropdownClosedLabelDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NxDropdownClosedLabelDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
var  /**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
NxDropdownSelectChange = /** @class */ (function () {
    function NxDropdownSelectChange(source, value) {
        this.source = source;
        this.value = value;
    }
    return NxDropdownSelectChange;
}());
// used in calculation of scrolltop to correctly show some space to the top of the panel
/** @type {?} */
var itemPadding = 16;
// Max-height: 6 items x 44px + 16px padding before first item
/** @type {?} */
var SELECT_PANEL_MAX_HEIGHT = 280;
var NxDropdownComponent = /** @class */ (function (_super) {
    __extends(NxDropdownComponent, _super);
    function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        var _this = _super.call(this) || this;
        _this._changeDetectorRef = _changeDetectorRef;
        _this._elementRef = _elementRef;
        _this._ngZone = _ngZone;
        _this.formFieldComponent = formFieldComponent;
        _this.ngControl = ngControl;
        _this._parentForm = _parentForm;
        _this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        _this.readonly = false;
        _this._disabled = false;
        _this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        _this._panelOpen = false;
        /**
         * \@docs-private
         */
        _this.errorState = false;
        /**
         * The scroltop of the panelBody.
         */
        _this._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */
        _this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        _this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        _this._optionIds = '';
        _this._tabIndex = 0;
        /**
         * \@docs-private
         */
        _this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        _this._ariaLabel = '';
        _this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        _this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        _this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        _this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        _this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        _this._openedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the select has been closed.
         */
        _this._closedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return !o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        _this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        _this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        _this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        _this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        function () {
            if (_this.options) {
                return merge.apply(void 0, __spread(_this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.onSelectionChange; }))));
            }
            return _this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            function () { return _this.optionSelectionChanges; })));
        }));
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */
        _this._positions = [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
        /**
         * Emits whenever the component is destroyed.
         */
        _this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        _this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        _this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        function (o1, o2) { return o1 === o2; });
        _this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        function (search, itemValue) {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        _this._onChange = (/**
         * @return {?}
         */
        function () { });
        /**
         * `View -> model callback called when select has been touched`
         */
        _this._onTouched = (/**
         * @return {?}
         */
        function () { });
        if (_this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            _this.ngControl.valueAccessor = _this;
        }
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
        get: /**
         * @return {?}
         */
        function () { return this.disabled ? -1 : this._tabIndex; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // If the specified tabIndex value is null or undefined, fall back to the default value.
            this._tabIndex = value != null ? value : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "value", {
        /** Selected value */
        get: /**
         * Selected value
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (newValue !== this._value) {
                this.writeValue(newValue);
                this._value = newValue;
                this._onChange(newValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
        /** Whether the dropdown is disabled. */
        get: /**
         * Whether the dropdown is disabled.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "styles", {
        /** If set to 'negative', the component is displayed with the negative set of styles. */
        set: /**
         * If set to 'negative', the component is displayed with the negative set of styles.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._style === value) {
                return;
            }
            this._style = value;
            this._negative = !!this._style.match(/negative/);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._closedDropdownLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "selected", {
        /**
         * @docs-private
         * The currently selected option.
         */
        get: /**
         * \@docs-private
         * The currently selected option.
         * @return {?}
         */
        function () {
            return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._panelOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._panelOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "label", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.formFieldComponent ? this.formFieldComponent.label : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
        /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         */
        get: /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         * @return {?}
         */
        function () { return this._compareWith; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._compareWith = fn;
            if (this._selectionModel) {
                // A different comparator means the selection could change.
                this._initializeSelection();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
        /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         */
        get: /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         * @return {?}
         */
        function () { return this._filterFn; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._filterFn = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "focused", {
        /**
         * @docs-private
         * Whether the select is focused.
         */
        get: /**
         * \@docs-private
         * Whether the select is focused.
         * @return {?}
         */
        function () {
            return this._focused || this.panelOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            this.updateErrorState();
        }
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.onChange.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.select(); }));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.deselect(); }));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._resetOptions();
            _this._initializeSelection();
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next();
        this._destroy.complete();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    NxDropdownComponent.prototype.isErrorState = /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    };
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initKeyManager = /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item._hidden; }));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            _this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            if (_this._panelOpen && _this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                _this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                function () { return _this._scrollActiveOptionIntoView(); }));
            }
            else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                _this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._resetOptions = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                _this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge.apply(void 0, __spread(this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._stateChanges; })))).pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
                _this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    };
    /** Records option IDs to pass to the aria-owns property. */
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._setOptionIds = /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    function () {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option.id; })).join(' ');
    };
    /** Invoked when an option is clicked. */
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    NxDropdownComponent.prototype._onSelect = /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    function (option, isUserInput) {
        /** @type {?} */
        var wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
                if (isUserInput) {
                    // In case the user selected the option with their mouse, we
                    // want to restore focus back to the trigger, in order to
                    // prevent the select keyboard controls from clashing with
                    // the ones from `mat-option`.
                    this.focus();
                }
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initializeSelection = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
        }));
    };
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype._setSelectionByValue = /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            function (currentValue) { return _this._selectValue(currentValue); }));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            var correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Finds and selects and option based on its value.
     * @returns Option that has the corresponding value.
     */
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    NxDropdownComponent.prototype._selectValue = /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            try {
                // Treat null as a special reset value.
                return option.value != null && _this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    };
    /** Emits change event to set the model value. */
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    NxDropdownComponent.prototype._propagateChanges = /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    function (fallbackValue) {
        /** @type {?} */
        var valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.value; }));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    };
    /** Sorts the selected values in the selected based on their order in the panel. */
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._sortValues = /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    function () {
        if (this.isMultiSelect) {
            /** @type {?} */
            var options_1 = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
            this.stateChanges.next();
        }
    };
    /** Focuses the select element. */
    /**
     * Focuses the select element.
     * @return {?}
     */
    NxDropdownComponent.prototype.focus = /**
     * Focuses the select element.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /** Opens the panel of the dropdown. */
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.openPanel = /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    function () {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    };
    /** Closes the panel of the dropdown. */
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.closePanel = /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._panelOpen) {
            this._panelOpen = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.focus(); }));
        }
    };
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._calculateScrollTop = 
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    function () {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        this._scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            var offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            var panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */
            var activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                // to middle out the text a bit more add half of the height
                // (this is still a few pixels off because the container is a bit larger than the font)
                this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
                this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
        }
    };
    /** Scrolls the active option into view. */
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    function () {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        var activeOptionIndex = this._keyManager.activeItemIndex || 0;
        /** @type {?} */
        var itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);
        this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
    };
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    NxDropdownComponent.prototype._countGroupLabelsBeforeOption = /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    function (optionIndex, options, optionGroups) {
        if (optionGroups.length) {
            /** @type {?} */
            var optionsArray = options.toArray();
            /** @type {?} */
            var groups = optionGroups.toArray();
            /** @type {?} */
            var groupCounter = 0;
            for (var i = 0; i < optionIndex + 1; i++) {
                if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                    groupCounter++;
                }
            }
            return groupCounter;
        }
        return 0;
    };
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    NxDropdownComponent.prototype._getOptionScrollPosition = /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    function (optionIndex, optionHeight, currentScrollPosition, panelHeight) {
        /** @type {?} */
        var optionOffset = optionIndex * optionHeight + itemPadding;
        if (this.showFilter) {
            /** @type {?} */
            var filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
        }
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    NxDropdownComponent.prototype._getItemOffset = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top;
    };
    /**
     * @docs-private
     * Formfield Implementation
     */
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    NxDropdownComponent.prototype.setDescribedByIds = /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this.ariaDescribedby = ids.join(' ');
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.setAriaLabel = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._ariaLabel = value;
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaLabel = /**
     * @return {?}
     */
    function () {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    };
    Object.defineProperty(NxDropdownComponent.prototype, "empty", {
        /**
         * @docs-private
         * Whether the select has a value.
         */
        get: /**
         * \@docs-private
         * Whether the select has a value.
         * @return {?}
         */
        function () {
            return !this._selectionModel || this._selectionModel.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._selectionModel.hasValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.focused || !this.empty;
        },
        enumerable: true,
        configurable: true
    });
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param value New value to be written to the model.
     */
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    NxDropdownComponent.prototype.writeValue = /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    function (value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    NxDropdownComponent.prototype.setDisabledState = /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    };
    /** End ControlValueAccessor */
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleKeydown = /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleClosedKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        var isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleOpenKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        // all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)) {
            return;
        }
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        var manager = this._keyManager;
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            var previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.formatValue = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.valueFormatter(value);
    };
    /** Called when the user types in the filter input */
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._onFilter = /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
        /**
         * @docs-private
         * The value displayed in the trigger.
         */
        get: /**
         * \@docs-private
         * The value displayed in the trigger.
         * @return {?}
         */
        function () {
            if (this.empty) {
                return '';
            }
            if (this.isMultiSelect) {
                /** @type {?} */
                var selectedOptions = this._selectionModel.selected.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.viewValue; }));
                return selectedOptions.join(', ');
            }
            return this._selectionModel.selected[0].viewValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     */
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._highlightCorrectOption = /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    function () {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    };
    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    NxDropdownComponent.prototype._onAttached = /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    function () {
        var _this = this;
        this._changeDetectorRef.markForCheck();
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.panelBody.nativeElement.focus();
            if (_this._keyManager.activeItem) {
                _this._calculateScrollTop();
            }
            _this._changeDetectorRef.markForCheck();
            _this.openedChange.emit(true);
            if (_this.showFilter) {
                _this.filterInput.nativeElement.focus();
            }
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._onFocus = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    };
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     */
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    NxDropdownComponent.prototype._onBlur = /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    function () {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.currentFilter.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype._clearFilter = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    };
    /** @docs-private determines the `aria-activedescendant` to be set on the host. */
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaActiveDescendant = /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    function () {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    };
    NxDropdownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown',
                    template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                        { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                    ],
                    host: {
                        'role': 'button',
                        '[class.nx-dropdown]': 'true',
                        '[class.is-filled]': 'hasValue',
                        '[class.has-focus]': 'focused',
                        '[class.nx-dropdown--negative]': '_negative',
                        '[class.nx-dropdown--disabled]': 'disabled',
                        '[attr.aria-describedby]': 'ariaDescribedby || null',
                        '[attr.aria-required]': 'required',
                        '[attr.aria-label]': '_getAriaLabel()',
                        '[attr.aria-haspopup]': '"listbox"',
                        '[attr.aria-expanded]': 'panelOpen',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.tabindex]': 'tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': '_onFocus()',
                        '(blur)': '_onBlur()',
                        '(click)': 'openPanel()'
                    },
                    styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
                }] }
    ];
    /** @nocollapse */
    NxDropdownComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
        { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    NxDropdownComponent.propDecorators = {
        tabIndex: [{ type: Input }],
        _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
        value: [{ type: Input, args: ['nxValue',] }],
        disabled: [{ type: Input, args: ['nxDisabled',] }],
        required: [{ type: Input, args: ['nxRequired',] }],
        styles: [{ type: Input, args: ['nxStyle',] }],
        showFilter: [{ type: Input, args: ['nxShowFilter',] }],
        filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
        openedChange: [{ type: Output }],
        _openedStream: [{ type: Output, args: ['opened',] }],
        _closedStream: [{ type: Output, args: ['closed',] }],
        filterChanges: [{ type: Output, args: ['filterInput',] }],
        valueChange: [{ type: Output, args: ['nxValueChange',] }],
        selectionChange: [{ type: Output }],
        panel: [{ type: ViewChild, args: ['panel',] }],
        panelBody: [{ type: ViewChild, args: ['panelBody',] }],
        trigger: [{ type: ViewChild, args: ['trigger',] }],
        filterInput: [{ type: ViewChild, args: ['filterInput',] }],
        overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
        options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
        groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
        _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective,] }],
        _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel',] }],
        valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
        compareWith: [{ type: Input }],
        filterFn: [{ type: Input }]
    };
    return NxDropdownComponent;
}(NxDropdownControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxDropdownModule = /** @class */ (function () {
    function NxDropdownModule() {
    }
    NxDropdownModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        NxFormfieldModule,
                        NxCheckboxModule,
                        OverlayModule,
                        A11yModule,
                        NxIconModule,
                        ObserversModule
                    ],
                    declarations: [
                        NxDropdownComponent,
                        NxDropdownItemComponent,
                        NxDropdownGroupComponent,
                        NxDropdownClosedLabelDirective
                    ],
                    exports: [
                        NxDropdownComponent,
                        NxDropdownItemComponent,
                        NxDropdownGroupComponent,
                        NxDropdownClosedLabelDirective
                    ]
                },] }
    ];
    return NxDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxDropdownModule, NxDropdownSelectChange, SELECT_PANEL_MAX_HEIGHT, NxDropdownComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective as b, NxDropdownControl as a };

//# sourceMappingURL=allianz-ngx-ndbx-dropdown.js.map