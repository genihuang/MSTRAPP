import { CommonModule } from '@angular/common';
import { NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { Directive, Input, ElementRef, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE, ZERO, NINE, NUMPAD_ZERO, NUMPAD_NINE, A, Z } from '@angular/cdk/keycodes';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
/** @type {?} */
var NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
var NxMaskDirective = /** @class */ (function () {
    function NxMaskDirective(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._position = null;
        this._validateMask = true;
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        function () { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
    }
    Object.defineProperty(NxMaskDirective.prototype, "mask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mask;
        },
        /** Sets the mask.  */
        set: /**
         * Sets the mask.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            if (value !== this._mask) {
                this._mask = value;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "separators", {
        get: /**
         * @return {?}
         */
        function () {
            return this._separators;
        },
        /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         */
        set: /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         * @param {?} values
         * @return {?}
         */
        function (values) {
            this._separators = values;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "dropSpecialCharacters", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropSpecialCharacters;
        },
        /** Whether the separators should be dropped in the control value accessor. */
        set: /**
         * Whether the separators should be dropped in the control value accessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._dropSpecialCharacters) {
                this._dropSpecialCharacters = newValue;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "validateMask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._validateMask;
        },
        /** Whether the mask validation should be applied on the input. Default: true. */
        set: /**
         * Whether the mask validation should be applied on the input. Default: true.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._validateMask) {
                this._validateMask = newValue;
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** Returns the unmasked value. */
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    NxMaskDirective.prototype.getUnmaskedValue = /**
     * Returns the unmasked value.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    };
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     */
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onKeydown = /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var location = event.location;
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var currentValue = this._elementRef.nativeElement.value;
        // row of characters is selected: set cursor position to end of new entered character
        if (input.selectionStart !== input.selectionEnd) {
            /** @type {?} */
            var nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            /** @type {?} */
            var positionChange = this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this.mask[nextCharacterInMask])))
                ? this._calculateCursorShift(input.selectionStart)
                : 0;
            this._position = input.selectionStart + positionChange;
        }
        else if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            var backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            var lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            var selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            // if last character is deleted: only delete last character, do not trigger input event again
            // (here the separator would be added again)
            if (selectionAtLastCharacter) {
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                event.preventDefault();
                // do not delete a separator, only set cursor position
            }
            else if (this.isSeparator(lastCharacter)) {
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
                // for any other character: decrease cursor position by one.
                // the input is modified and will be validated in _onInputChange().
            }
            else {
                this._position = input.selectionStart - backspaceShift;
            }
        }
        else {
            this._position = input.selectionStart;
            /** @type {?} */
            var nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            if (this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this._mask[nextCharacterInMask])))) {
                // if mask is already filled up, do not allow any inputs
                if (currentValue.length === this.mask.length) {
                    input.setSelectionRange(nextCharacterInMask, nextCharacterInMask);
                    event.preventDefault();
                }
                else {
                    this._position = nextCharacterInMask + 1;
                }
            }
        }
    };
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     */
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    NxMaskDirective.prototype._calculateCursorShift = /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        var characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    NxMaskDirective.prototype._keyCodeIsNumber = /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    function (value, location) {
        return ((value >= ZERO && value <= NINE)
            || (location === 3 && value >= NUMPAD_ZERO && value <= NUMPAD_NINE));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype._keyCodeIsLetter = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (value >= A && value <= Z);
    };
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    NxMaskDirective.prototype._isKeyCodeAllowed = /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    function (value, location, maskedValue) {
        if ((maskedValue === '0' && this._keyCodeIsNumber(value, location))
            || (maskedValue === 'A' && (this._keyCodeIsNumber(value, location) || this._keyCodeIsLetter(value)))
            || (maskedValue === 'S' && this._keyCodeIsLetter(value))) {
            return true;
        }
        return false;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    NxMaskDirective.prototype._isStringAllowed = /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    function (value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onInputChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        this.updateValue(this.getMaskedString(input.value));
        if (this._position !== null) {
            input.setSelectionRange(this._position, this._position);
            this._position = null;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onPaste = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        var maskedString = this.getMaskedString(pastedData, input.selectionStart);
        this._position = input.selectionStart + maskedString.length;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._elementRef.nativeElement.value = value;
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    };
    /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    NxMaskDirective.prototype.getMaskedString = /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    function (inputValue, maskStartIndex) {
        if (maskStartIndex === void 0) { maskStartIndex = 0; }
        /** @type {?} */
        var formattedValue = '';
        /** @type {?} */
        var maskIndex = maskStartIndex;
        /** @type {?} */
        var inputIndex = 0;
        /** @type {?} */
        var carot = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                // shift for _position
                if (maskIndex === this._position + carot) {
                    carot++;
                }
                maskIndex++;
            }
        }
        if (carot > 0) {
            this._position = this._position + carot;
        }
        return formattedValue;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.isSeparator = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (this._separators.indexOf(value) !== -1);
    };
    // control value accessor
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.writeValue = 
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            value = '';
        }
        this.updateValue(this.getMaskedString(value));
    };
    /**
     * @param {?} onChange
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnChange = /**
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._onChangeCallback = onChange;
    };
    /**
     * @param {?} onTouched
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnTouched = /**
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._onTouchedCallback = onTouched;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnValidatorChange = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._validatorOnChange = fn;
    };
    /**
     * @return {?}
     */
    NxMaskDirective.prototype._validateFn = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        var maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxMaskDirective.prototype.validate = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.validateMask ? this._validateFn() : null;
    };
    NxMaskDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxMask]',
                    host: {
                        '(input)': '_onInputChange($event)',
                        '(keydown)': '_onKeydown($event)',
                        '(paste)': '_onPaste($event)',
                        '(blur)': '_onTouchedCallback()'
                    },
                    exportAs: 'nxMaskDirective',
                    providers: [
                        NX_MASK_VALUE_ACCESSOR,
                        { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                        NX_MASK_VALIDATORS
                    ]
                },] }
    ];
    /** @nocollapse */
    NxMaskDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NxMaskDirective.propDecorators = {
        mask: [{ type: Input, args: ['nxMask',] }],
        separators: [{ type: Input }],
        dropSpecialCharacters: [{ type: Input }],
        validateMask: [{ type: Input }]
    };
    return NxMaskDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxMaskModule = /** @class */ (function () {
    function NxMaskModule() {
    }
    NxMaskModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        NxFormfieldModule
                    ],
                    declarations: [
                        NxMaskDirective
                    ],
                    exports: [
                        NxFormfieldModule,
                        NxMaskDirective
                    ]
                },] }
    ];
    return NxMaskModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxMaskModule, NX_MASK_VALUE_ACCESSOR, NX_MASK_VALIDATORS, NxMaskDirective };

//# sourceMappingURL=allianz-ngx-ndbx-mask.js.map