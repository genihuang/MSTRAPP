import { CommonModule } from '@angular/common';
import { TemplatePortal, CdkPortalOutlet, PortalModule } from '@angular/cdk/portal';
import { __spread } from 'tslib';
import { Subject, merge, Subscription } from 'rxjs';
import { NxAccordionDirective, NxExpansionPanelComponent, NxAccordionModule } from '@allianz/ngx-ndbx/accordion';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';
import { ChangeDetectionStrategy, Component, Input, TemplateRef, ViewChild, ViewContainerRef, Optional, Inject, Host, Directive, ElementRef, ChangeDetectorRef, ContentChildren, EventEmitter, Output, HostListener, ViewChildren, SkipSelf, NgModule } from '@angular/core';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
var  /**
 * \@docs-private
 * @abstract
 */
NxTabGroupBase = /** @class */ (function () {
    function NxTabGroupBase() {
    }
    return NxTabGroupBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabComponent = /** @class */ (function () {
    function NxTabComponent(_viewContainerRef, _tabGroup) {
        this._viewContainerRef = _viewContainerRef;
        this._tabGroup = _tabGroup;
        /**
         * The portal that will be the hosted content of the tab
         */
        this._contentPortal = null;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error("The nx-tab element has to be wrapped in a nx-tab-group to work.\n      Please provide a nx-tab-group element and place your tabs inside it.");
        }
    }
    Object.defineProperty(NxTabComponent.prototype, "label", {
        /** Sets the label of the tab shown in the tablist. */
        get: /**
         * Sets the label of the tab shown in the tablist.
         * @return {?}
         */
        function () {
            return this._label;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._label !== value) {
                this._label = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabComponent.prototype, "content", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._contentPortal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NxTabComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.hasOwnProperty('label')) {
            this._stateChanges.next();
        }
    };
    /**
     * @return {?}
     */
    NxTabComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._contentPortal = new TemplatePortal(this._implicitContent, this._viewContainerRef);
    };
    /**
     * @return {?}
     */
    NxTabComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    NxTabComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab',
                    exportAs: 'nxTab',
                    template: "<ng-template><ng-content></ng-content></ng-template>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxTabComponent.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
    ]; };
    NxTabComponent.propDecorators = {
        label: [{ type: Input }],
        _implicitContent: [{ type: ViewChild, args: [TemplateRef,] }]
    };
    return NxTabComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabBodyComponent = /** @class */ (function () {
    function NxTabBodyComponent() {
        this._active = false;
    }
    Object.defineProperty(NxTabBodyComponent.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._active = coerceBooleanProperty(value);
            if (this._active) {
                this.attach();
            }
            else {
                this.detach();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.attach = /**
     * @return {?}
     */
    function () {
        if (!this.portalOutlet.hasAttached()) {
            this.portalOutlet.attach(this.content);
        }
    };
    /**
     * @return {?}
     */
    NxTabBodyComponent.prototype.detach = /**
     * @return {?}
     */
    function () {
        if (this.portalOutlet.hasAttached()) {
            this.portalOutlet.detach();
        }
    };
    NxTabBodyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-body',
                    template: "<ng-template cdkPortalOutlet></ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}"]
                }] }
    ];
    NxTabBodyComponent.propDecorators = {
        content: [{ type: Input }],
        active: [{ type: Input }],
        portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet,] }]
    };
    return NxTabBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabLabelDirective = /** @class */ (function () {
    function NxTabLabelDirective(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    NxTabLabelDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.focus();
    };
    NxTabLabelDirective.decorators = [
        { type: Directive, args: [{ selector: '[nxTabLabel]' },] }
    ];
    /** @nocollapse */
    NxTabLabelDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return NxTabLabelDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
var NxTabHeaderComponent = /** @class */ (function () {
    function NxTabHeaderComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    Object.defineProperty(NxTabHeaderComponent.prototype, "selectedIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selectedIndex = value;
            if (this._keyManager) {
                this._keyManager.updateActiveItemIndex(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabHeaderComponent.prototype, "focusIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._keyManager ? this._keyManager.activeItemIndex : 0;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                return;
            }
            this._keyManager.setActiveItem(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabHeaderComponent.prototype, "autoselect", {
        get: /**
         * @return {?}
         */
        function () {
            return this._autoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._autoselect = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    NxTabHeaderComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItemIndex(0);
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    NxTabHeaderComponent.prototype._isValidIndex = /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    function (idx) {
        if (!this.labels) {
            return true;
        }
        return !!this.labels.toArray()[idx];
    };
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     */
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    NxTabHeaderComponent.prototype.handleKeydown = /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    };
    NxTabHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-header',
                    template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
                }] }
    ];
    /** @nocollapse */
    NxTabHeaderComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabHeaderComponent.propDecorators = {
        selectedIndex: [{ type: Input }],
        autoselect: [{ type: Input }],
        selectFocusedIndex: [{ type: Output }],
        indexFocused: [{ type: Output }],
        labels: [{ type: ContentChildren, args: [NxTabLabelDirective,] }]
    };
    return NxTabHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabChangeEvent = /** @class */ (function () {
    function NxTabChangeEvent() {
    }
    return NxTabChangeEvent;
}());
/** @type {?} */
var nextId = 0;
/** @type {?} */
var MOBILE_BREAKPOINT = 480;
var NxTabGroupComponent = /** @class */ (function () {
    function NxTabGroupComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._groupId = nextId++;
    }
    Object.defineProperty(NxTabGroupComponent.prototype, "selectedIndex", {
        /** Sets the selected tab. */
        get: /**
         * Sets the selected tab.
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._indexToSelect = coerceNumberProperty(value, null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "negative", {
        /** Whether the negative set of styling should be used. */
        get: /**
         * Whether the negative set of styling should be used.
         * @return {?}
         */
        function () {
            return this._negative;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._negative) {
                this._negative = coerceBooleanProperty(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "autoselect", {
        /** Whether the tab should be immediately selected on focus. */
        get: /**
         * Whether the tab should be immediately selected on focus.
         * @return {?}
         */
        function () {
            return this._autoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._autoselect = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxTabGroupComponent.prototype, "mobileAccordion", {
        /** Whether the tabs should to accordion on mobile viewports. */
        get: /**
         * Whether the tabs should to accordion on mobile viewports.
         * @return {?}
         */
        function () {
            return this._mobileAccordion;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mobileAccordion = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._switchAppearance(window.innerWidth);
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === _this._selectedIndex) {
                /** @type {?} */
                var tabs = _this.tabs.toArray();
                for (var i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        _this._indexToSelect = _this._selectedIndex = i;
                        break;
                    }
                }
            }
            _this._changeDetectorRef.markForCheck();
        }));
    };
    /**
      * After the content is checked, this component knows what tabs have been defined
      * and what the selected index should be.
      */
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngAfterContentChecked = /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    function () {
        var _this = this;
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            var isFirstRun_1 = this._selectedIndex == null;
            if (!isFirstRun_1) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                _this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                function (tab, index) { return tab.isActive = index === indexToSelect; }));
                if (!isFirstRun_1) {
                    _this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
    };
    /**
     * @return {?}
     */
    NxTabGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    };
    /**
    * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
    * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
    * binding to be updated, we need to subscribe to changes in it and trigger change detection
    * manually.
    */
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._subscribeToTabLabels = /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge.apply(void 0, __spread(this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        function (tab) { return tab._stateChanges; })))).subscribe((/**
         * @return {?}
         */
        function () { return _this._changeDetectorRef.markForCheck(); }));
    };
    /** Clamps the given index to the bounds of 0 and the tabs length. */
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._clampTabIndex = /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.focusChanged = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.focusChange.emit(this._createChangeEvent(index));
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._createChangeEvent = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype.handleClick = /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.selectedIndex = this.tabHeader.focusIndex = index;
    };
    /**
     * @docs-private
     * Returns the tabindex for a tab label
     */
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    NxTabGroupComponent.prototype.getTabIndex = /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    function (tab, idx) {
        return this.selectedIndex === idx ? 0 : -1;
    };
    /** Returns a unique id for each tab label element */
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabLabelId = /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-label-" + this._groupId + "-" + i;
    };
    /** Returns a unique id for each tab content element */
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    NxTabGroupComponent.prototype._getTabContentId = /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return "nx-tab-content-" + this._groupId + "-" + i;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    NxTabGroupComponent.prototype.onResize = /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._switchAppearance(event.target.innerWidth);
    };
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    NxTabGroupComponent.prototype._switchAppearance = /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    function (viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._showDesktopVersion();
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showMobileVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    NxTabGroupComponent.prototype._showDesktopVersion = /**
     * @private
     * @return {?}
     */
    function () {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     */
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    NxTabGroupComponent.prototype._panelOpened = /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.selectedIndex = index;
    };
    NxTabGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-group',
                    template: "\n  <nx-tab-header *ngIf=\"!_showAccordion\"\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabel\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      {{tab.label}}\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(!_showAccordion && selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [content]=\"tab.content\"\n      [active]=\"!_showAccordion && selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n\n  <nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n    <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\">\n      <nx-expansion-panel-header>\n        <nx-expansion-panel-title>{{tab.label}}</nx-expansion-panel-title>\n      </nx-expansion-panel-header>\n      <ng-template [cdkPortalOutlet]=\"tab.content\"></ng-template>\n    </nx-expansion-panel>\n  </nx-accordion>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative'
                    },
                    providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                    styles: [":host{display:block}.nx-tab-header__item{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px;outline:0}.nx-tab-header__item::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}"]
                }] }
    ];
    /** @nocollapse */
    NxTabGroupComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabGroupComponent.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
        tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
        tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],
        panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
        accordion: [{ type: ViewChild, args: [NxAccordionDirective,] }],
        selectedIndex: [{ type: Input }],
        negative: [{ type: Input }],
        autoselect: [{ type: Input }],
        mobileAccordion: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        selectedTabChange: [{ type: Output }],
        focusChange: [{ type: Output }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return NxTabGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabNavBarComponent = /** @class */ (function () {
    function NxTabNavBarComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
    }
    Object.defineProperty(NxTabNavBarComponent.prototype, "negative", {
        get: /**
         * @return {?}
         */
        function () {
            return this._negative;
        },
        /** Whether the tab nav bar has negative styling. */
        set: /**
         * Whether the tab nav bar has negative styling.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this.negative) {
                this._negative = newValue;
                this._changeDetectorRef.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    NxTabNavBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-tab-nav-bar',
                    template: "<ng-content></ng-content>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.is-negative]': 'negative',
                        'role': 'navigation',
                    },
                    styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host-context([data-whatinput=keyboard]) nx-tab-link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
                }] }
    ];
    /** @nocollapse */
    NxTabNavBarComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NxTabNavBarComponent.propDecorators = {
        negative: [{ type: Input }]
    };
    return NxTabNavBarComponent;
}());
var NxTabLinkDirective = /** @class */ (function () {
    function NxTabLinkDirective(_tabNavBar) {
        this._tabNavBar = _tabNavBar;
        this._active = false;
        if (!this._tabNavBar) {
            throw Error("The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.");
        }
    }
    Object.defineProperty(NxTabLinkDirective.prototype, "active", {
        /** Whether the tab link is active and has the active styling. */
        get: /**
         * Whether the tab link is active and has the active styling.
         * @return {?}
         */
        function () {
            return this._active;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._active) {
                this._active = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    NxTabLinkDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxTabLink]',
                    host: {
                        '[class.nx-tab-link]': 'true',
                        '[class.is-active]': 'active',
                        '[attr.aria-current]': 'active',
                    }
                },] }
    ];
    /** @nocollapse */
    NxTabLinkDirective.ctorParameters = function () { return [
        { type: NxTabNavBarComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    NxTabLinkDirective.propDecorators = {
        active: [{ type: Input }]
    };
    return NxTabLinkDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxTabsModule = /** @class */ (function () {
    function NxTabsModule() {
    }
    NxTabsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        PortalModule,
                        NxAccordionModule
                    ],
                    exports: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective
                    ],
                    declarations: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective
                    ],
                    providers: [],
                },] }
    ];
    return NxTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxTabsModule, NxTabComponent, NxTabChangeEvent, NxTabGroupComponent, NxTabHeaderComponent, NxTabBodyComponent, NxTabLabelDirective, NxTabNavBarComponent, NxTabLinkDirective, NxTabGroupBase as ɵa };

//# sourceMappingURL=allianz-ngx-ndbx-tabs.js.map