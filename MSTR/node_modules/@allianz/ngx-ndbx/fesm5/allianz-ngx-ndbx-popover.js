import { __spread } from 'tslib';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { TemplatePortal } from '@angular/cdk/portal';
import { EventManager } from '@angular/platform-browser';
import { filter, map, takeUntil } from 'rxjs/operators';
import { Subject, fromEvent } from 'rxjs';
import { Directive, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, EventEmitter, Output, ViewChild, ElementRef, HostListener, Input, ViewContainerRef, NgModule } from '@angular/core';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { CommonModule } from '@angular/common';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Popover content that will be rendered lazily
 * after the popover is opened for the first time.
 */
var NxPopoverContentDirective = /** @class */ (function () {
    function NxPopoverContentDirective(_template) {
        this._template = _template;
    }
    NxPopoverContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ng-template[nxPopoverContent]'
                },] }
    ];
    /** @nocollapse */
    NxPopoverContentDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NxPopoverContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxPopoverComponent = /** @class */ (function () {
    function NxPopoverComponent() {
        /**
         * Event emitted when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * \@docs-private
         */
        this.closeButtonClick = new Subject();
        /**
         * \@docs-private
         */
        this.showCloseButton = false;
        /**
         * \@docs-private
         */
        this.arrowStyle = {};
    }
    /**
     * @return {?}
     */
    NxPopoverComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.closed.complete();
    };
    // emit to notify the popover trigger directive that the close button was clicked
    /** @docs-private */
    // emit to notify the popover trigger directive that the close button was clicked
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverComponent.prototype.emitButtonClick = 
    // emit to notify the popover trigger directive that the close button was clicked
    /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.closeButtonClick.next();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverComponent.prototype.emitClosedEvent = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.closed.emit();
    };
    Object.defineProperty(NxPopoverComponent.prototype, "classList", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.direction) {
                return ["nx-popover--" + this.direction];
            }
        },
        enumerable: true,
        configurable: true
    });
    NxPopoverComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-popover',
                    template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\">\n    <div class=\"nx-popover__content\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span aria-hidden=\"true\" class=\"nx-popover__close-icon\" (click)=\"emitButtonClick()\"\n            *ngIf=\"showCloseButton\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'nxPopover',
                    styles: [".nx-popover__content{background-color:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block;font-size:16px}.nx-popover__close-icon{position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;line-height:16px}[data-whatintent=mouse] .nx-popover__content:focus{outline:0}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-left:1px solid #d9d9d9}.nx-popover--top .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(225deg);transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(-45deg);transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(45deg);transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(135deg);transform:translate(0,-50%) rotate(135deg);right:-5px}"]
                }] }
    ];
    /** @nocollapse */
    NxPopoverComponent.ctorParameters = function () { return []; };
    NxPopoverComponent.propDecorators = {
        templateRef: [{ type: ViewChild, args: [TemplateRef,] }],
        _lazyContent: [{ type: ContentChild, args: [NxPopoverContentDirective,] }],
        closed: [{ type: Output, args: ['nxClosed',] }]
    };
    return NxPopoverComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextId = 0;
/** @type {?} */
var fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
var NxPopoverTriggerDirective = /** @class */ (function () {
    function NxPopoverTriggerDirective(overlay, elementRef, viewContainerRef, eventManager) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
    }
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "show", {
        get: /**
         * @return {?}
         */
        function () {
            return this._show;
        },
        /** Whether to show or hide the popover. */
        set: /**
         * Whether to show or hide the popover.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = coerceBooleanProperty(value);
            if (this._show !== value) {
                this._show = value;
                if (this._show) {
                    this.openPopover();
                }
                else {
                    this.closePopover();
                }
                this.changeShow.emit(this._show);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closeable;
        },
        /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
        set: /**
         * Whether to show a close button. By default a close icon is only shown for trigger type click.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._closeable = coerceBooleanProperty(value);
            if (this.popover) {
                this.popover.showCloseButton = this.isCloseable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.onMouseEnter = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'hover') {
            this.openPopover();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.onMouseExit = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'hover') {
            this.closePopover();
        }
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.popover.showCloseButton = this.isCloseable();
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
        if (this.popoverInitialVisible || this._show) {
            this.openPopover();
        }
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.closePopover();
        this._destroyed.next();
        this._destroyed.complete();
    };
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "isOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.overlayRef && this.createOverlay().hasAttached();
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.isCloseable = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    };
    /** Update the popover with the given position strategy. */
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.updatePosition = /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    function () {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.handleClick = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'click') {
            if (this.isOpen) {
                this.closePopover();
            }
            else {
                this.openPopover();
            }
        }
    };
    /** Open the popover instance. */
    /**
     * Open the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.open = /**
     * Open the popover instance.
     * @return {?}
     */
    function () {
        this.show = true;
    };
    /** Close the popover instance. */
    /**
     * Close the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.close = /**
     * Close the popover instance.
     * @return {?}
     */
    function () {
        this.show = false;
    };
    /** Toggle the popover instance. */
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.toggle = /**
     * Toggle the popover instance.
     * @return {?}
     */
    function () {
        this.show = !this.show;
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.openPopover = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            if (!this.modal && this.trigger === 'click') {
                this.waitForClose();
            }
        }
    };
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.closePopover = 
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    function () {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this._embeddedViewRef = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.createOverlay = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            var overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.subscribeToPositions = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var pair = change.connectionPair;
            _this.positionOverlay(pair);
            _this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                _this._embeddedViewRef.detectChanges();
            }
        }));
    };
    // for modal popovers close the popover on backdrop clicks
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToBackdropClick = 
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.closePopover();
        }));
    };
    // Emit the nxClosed event on the popover component when the overlay detaches
    // Emit the nxClosed event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToDetach = 
    // Emit the nxClosed event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.popover.emitClosedEvent();
        }));
    };
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.waitForClose = 
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.target; })), filter((/**
         * @param {?} target
         * @return {?}
         */
        function (target) { return !_this.elementRef.nativeElement.contains(target); })), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionOverlay = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionArrow = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        /** @type {?} */
        var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */
            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.getPosition = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var positions;
        /** @type {?} */
        var offsetX = 0;
        /** @type {?} */
        var offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions(__spread(positions, fallbacks))
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    };
    NxPopoverTriggerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxPopoverTriggerFor]',
                    exportAs: 'nxPopoverTrigger',
                    host: {
                        '(click)': 'handleClick()',
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'isOpen',
                        '[attr.aria-describedby]': 'isOpen ? id : null'
                    }
                },] }
    ];
    /** @nocollapse */
    NxPopoverTriggerDirective.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: EventManager }
    ]; };
    NxPopoverTriggerDirective.propDecorators = {
        changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
        show: [{ type: Input, args: ['nxPopoverShow',] }],
        closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
        popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
        direction: [{ type: Input, args: ['nxPopoverDirection',] }],
        popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
        visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
        modal: [{ type: Input, args: ['nxPopoverModal',] }],
        trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
        scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }],
        onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
        onMouseExit: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['touchstart',] }]
    };
    return NxPopoverTriggerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NxPopoverModule = /** @class */ (function () {
    function NxPopoverModule() {
    }
    NxPopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        OverlayModule,
                        NxIconModule
                    ],
                    declarations: [
                        NxPopoverTriggerDirective,
                        NxPopoverComponent,
                        NxPopoverContentDirective
                    ],
                    exports: [
                        NxPopoverTriggerDirective,
                        NxPopoverComponent,
                        NxPopoverContentDirective
                    ]
                },] }
    ];
    return NxPopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxPopoverModule, NxPopoverComponent, NxPopoverTriggerDirective, NxPopoverContentDirective };

//# sourceMappingURL=allianz-ngx-ndbx-popover.js.map