/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
/** @type {?} */
var DEFAULT_SIZE = 'auto';
var NxFigureComponent = /** @class */ (function () {
    function NxFigureComponent() {
    }
    Object.defineProperty(NxFigureComponent.prototype, "classNames", {
        get: /**
         * @return {?}
         */
        function () {
            return this._classNames;
        },
        /**
         * Sets the type of the visual appearance of the image.
         * The default value  is 'auto'.
         */
        set: /**
         * Sets the type of the visual appearance of the image.
         * The default value  is 'auto'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._classNames === value) {
                return;
            }
            this._classNames = value;
            /** @type {?} */
            var sizeRegex = /^(auto|1by1|1dot8by1|1dot2by1|1by1dot1|2dot6by1)$/;
            var _a = tslib_1.__read(this._classNames.match(sizeRegex) || [DEFAULT_SIZE], 1), _b = _a[0], size = _b === void 0 ? null : _b;
            this.size = (/** @type {?} */ (size));
            this.rounded = !!this._classNames.match(/rounded/);
        },
        enumerable: true,
        configurable: true
    });
    NxFigureComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'figure[nxFigure]',
                    template: '<ng-content></ng-content>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.nx-image--auto]': 'size === "auto" && !rounded',
                        '[class.nx-image--1by1]': 'size === "1by1"',
                        '[class.nx-image--1dot8by1]': 'size === "1dot8by1"',
                        '[class.nx-image--1dot2by1]': 'size === "1dot2by1"',
                        '[class.nx-image--1by1dot1]': 'size === "1by1dot1"',
                        '[class.nx-image--2dot6by1]': 'size === "2dot6by1"',
                        '[class.nx-image--rounded]': 'rounded'
                    },
                    styles: [":host{display:block;position:relative;line-height:0}:host ::ng-deep img{display:block;font-family:\"object-fit: cover;\";-o-object-fit:cover;object-fit:cover;height:100%;width:100%}:host(.nx-image--auto) ::ng-deep img{height:auto}:host(:not(.nx-image--auto)) ::ng-deep img{position:absolute;top:0;left:0}:host(.nx-image--rounded){padding-top:100%}:host(.nx-image--rounded) ::ng-deep img{border-radius:50%;bottom:0;left:0;position:absolute;right:0;top:0}:host(.nx-image--1by1){padding-top:100%}:host(.nx-image--1dot8by1){padding-top:55.55556%}:host(.nx-image--1dot2by1){padding-top:83.33333%}:host(.nx-image--1by1dot1){padding-top:110%}:host(.nx-image--2dot6by1){padding-top:38.46154%}:host(.nx-image--1by1dot4){padding-top:140%}"]
                }] }
    ];
    NxFigureComponent.propDecorators = {
        classNames: [{ type: Input, args: ['nxFigure',] }]
    };
    return NxFigureComponent;
}());
export { NxFigureComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxFigureComponent.prototype._classNames;
    /**
     * \@docs-private
     * @type {?}
     */
    NxFigureComponent.prototype.rounded;
    /**
     * \@docs-private
     * @type {?}
     */
    NxFigureComponent.prototype.size;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlndXJlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsiaW1hZ2UvZmlndXJlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDOztJQU9wRSxZQUFZLEdBQUcsTUFBTTtBQUUzQjtJQUFBO0lBOENBLENBQUM7SUFqQkMsc0JBQ0kseUNBQVU7Ozs7UUFhZDtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQixDQUFDO1FBcEJEOzs7V0FHRzs7Ozs7OztRQUNILFVBQ2UsS0FBaUI7WUFDOUIsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLEtBQUssRUFBRTtnQkFDOUIsT0FBTzthQUNSO1lBRUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7O2dCQUNuQixTQUFTLEdBQUcsbURBQW1EO1lBQy9ELElBQUEsMkVBQW1FLEVBQWxFLFVBQVcsRUFBWCxnQ0FBa0U7WUFDekUsSUFBSSxDQUFDLElBQUksR0FBRyxtQkFBQSxJQUFJLEVBQU8sQ0FBQztZQUV4QixJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNyRCxDQUFDOzs7T0FBQTs7Z0JBekNGLFNBQVMsU0FBQzs7b0JBRVQsUUFBUSxFQUFFLGtCQUFrQjtvQkFDNUIsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBRS9DLElBQUksRUFBRTt3QkFDSix3QkFBd0IsRUFBRSw2QkFBNkI7d0JBQ3ZELHdCQUF3QixFQUFFLGlCQUFpQjt3QkFDM0MsNEJBQTRCLEVBQUUscUJBQXFCO3dCQUNuRCw0QkFBNEIsRUFBRSxxQkFBcUI7d0JBQ25ELDRCQUE0QixFQUFFLHFCQUFxQjt3QkFDbkQsNEJBQTRCLEVBQUUscUJBQXFCO3dCQUNuRCwyQkFBMkIsRUFBRSxTQUFTO3FCQUN2Qzs7aUJBQ0Y7Ozs2QkFjRSxLQUFLLFNBQUMsVUFBVTs7SUFpQm5CLHdCQUFDO0NBQUEsQUE5Q0QsSUE4Q0M7U0E5QlksaUJBQWlCOzs7Ozs7SUFDNUIsd0NBQWdDOzs7OztJQUdoQyxvQ0FBaUI7Ozs7O0lBR2pCLGlDQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKiBUeXBlcyBvZiBmaWd1cmVzLiAqL1xuZXhwb3J0IHR5cGUgRmlndXJlVHlwZSA9ICdhdXRvJyB8ICcxYnkxJyB8ICcxZG90OGJ5MScgfCAnMWRvdDJieTEnIHwgJzFieTFkb3QxJyB8ICcyZG90NmJ5MScgfCAncm91bmRlZCc7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IHR5cGUgZmlndXJlU2l6ZXMgPSAnYXV0bycgfCAnMWJ5MScgfCAnMWRvdDhieTEnIHwgJzFkb3QyYnkxJyB8ICcxYnkxZG90MScgfCAnMmRvdDZieTEnO1xuXG5jb25zdCBERUZBVUxUX1NJWkUgPSAnYXV0byc7XG5cbkBDb21wb25lbnQoe1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnZmlndXJlW254RmlndXJlXScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBzdHlsZVVybHM6IFsnLi9maWd1cmUuY29tcG9uZW50LnNjc3MnXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MubngtaW1hZ2UtLWF1dG9dJzogJ3NpemUgPT09IFwiYXV0b1wiICYmICFyb3VuZGVkJyxcbiAgICAnW2NsYXNzLm54LWltYWdlLS0xYnkxXSc6ICdzaXplID09PSBcIjFieTFcIicsXG4gICAgJ1tjbGFzcy5ueC1pbWFnZS0tMWRvdDhieTFdJzogJ3NpemUgPT09IFwiMWRvdDhieTFcIicsXG4gICAgJ1tjbGFzcy5ueC1pbWFnZS0tMWRvdDJieTFdJzogJ3NpemUgPT09IFwiMWRvdDJieTFcIicsXG4gICAgJ1tjbGFzcy5ueC1pbWFnZS0tMWJ5MWRvdDFdJzogJ3NpemUgPT09IFwiMWJ5MWRvdDFcIicsXG4gICAgJ1tjbGFzcy5ueC1pbWFnZS0tMmRvdDZieTFdJzogJ3NpemUgPT09IFwiMmRvdDZieTFcIicsXG4gICAgJ1tjbGFzcy5ueC1pbWFnZS0tcm91bmRlZF0nOiAncm91bmRlZCdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOeEZpZ3VyZUNvbXBvbmVudCB7XG4gIHByaXZhdGUgX2NsYXNzTmFtZXM6IEZpZ3VyZVR5cGU7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgcm91bmRlZDogYm9vbGVhbjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzaXplOiBmaWd1cmVTaXplcztcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHlwZSBvZiB0aGUgdmlzdWFsIGFwcGVhcmFuY2Ugb2YgdGhlIGltYWdlLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSAgaXMgJ2F1dG8nLlxuICAgKi9cbiAgQElucHV0KCdueEZpZ3VyZScpXG4gIHNldCBjbGFzc05hbWVzKHZhbHVlOiBGaWd1cmVUeXBlKSB7XG4gICAgaWYgKHRoaXMuX2NsYXNzTmFtZXMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY2xhc3NOYW1lcyA9IHZhbHVlO1xuICAgIGNvbnN0IHNpemVSZWdleCA9IC9eKGF1dG98MWJ5MXwxZG90OGJ5MXwxZG90MmJ5MXwxYnkxZG90MXwyZG90NmJ5MSkkLztcbiAgICBjb25zdCBbc2l6ZSA9IG51bGxdID0gdGhpcy5fY2xhc3NOYW1lcy5tYXRjaChzaXplUmVnZXgpIHx8IFtERUZBVUxUX1NJWkVdO1xuICAgIHRoaXMuc2l6ZSA9IHNpemUgYXMgYW55O1xuXG4gICAgdGhpcy5yb3VuZGVkID0gISF0aGlzLl9jbGFzc05hbWVzLm1hdGNoKC9yb3VuZGVkLyk7XG4gIH1cblxuICBnZXQgY2xhc3NOYW1lcygpOiBGaWd1cmVUeXBlIHtcbiAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lcztcbiAgfVxufVxuIl19