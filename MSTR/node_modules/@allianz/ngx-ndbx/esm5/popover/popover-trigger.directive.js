/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, HostListener, Input, Output, ViewContainerRef } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { fromEvent, Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import { NxPopoverComponent } from './popover.component';
/** @type {?} */
var nextId = 0;
/** @type {?} */
var fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
var NxPopoverTriggerDirective = /** @class */ (function () {
    function NxPopoverTriggerDirective(overlay, elementRef, viewContainerRef, eventManager) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
    }
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "show", {
        get: /**
         * @return {?}
         */
        function () {
            return this._show;
        },
        /** Whether to show or hide the popover. */
        set: /**
         * Whether to show or hide the popover.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = coerceBooleanProperty(value);
            if (this._show !== value) {
                this._show = value;
                if (this._show) {
                    this.openPopover();
                }
                else {
                    this.closePopover();
                }
                this.changeShow.emit(this._show);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._closeable;
        },
        /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
        set: /**
         * Whether to show a close button. By default a close icon is only shown for trigger type click.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._closeable = coerceBooleanProperty(value);
            if (this.popover) {
                this.popover.showCloseButton = this.isCloseable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.onMouseEnter = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'hover') {
            this.openPopover();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.onMouseExit = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'hover') {
            this.closePopover();
        }
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.popover.showCloseButton = this.isCloseable();
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
        if (this.popoverInitialVisible || this._show) {
            this.openPopover();
        }
    };
    /**
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.closePopover();
        this._destroyed.next();
        this._destroyed.complete();
    };
    Object.defineProperty(NxPopoverTriggerDirective.prototype, "isOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.overlayRef && this.createOverlay().hasAttached();
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.isCloseable = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    };
    /** Update the popover with the given position strategy. */
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.updatePosition = /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    function () {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.handleClick = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this.trigger === 'click') {
            if (this.isOpen) {
                this.closePopover();
            }
            else {
                this.openPopover();
            }
        }
    };
    /** Open the popover instance. */
    /**
     * Open the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.open = /**
     * Open the popover instance.
     * @return {?}
     */
    function () {
        this.show = true;
    };
    /** Close the popover instance. */
    /**
     * Close the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.close = /**
     * Close the popover instance.
     * @return {?}
     */
    function () {
        this.show = false;
    };
    /** Toggle the popover instance. */
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.toggle = /**
     * Toggle the popover instance.
     * @return {?}
     */
    function () {
        this.show = !this.show;
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.openPopover = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            if (!this.modal && this.trigger === 'click') {
                this.waitForClose();
            }
        }
    };
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.closePopover = 
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    function () {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this._embeddedViewRef = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.createOverlay = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            var overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.subscribeToPositions = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var pair = change.connectionPair;
            _this.positionOverlay(pair);
            _this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                _this._embeddedViewRef.detectChanges();
            }
        }));
    };
    // for modal popovers close the popover on backdrop clicks
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToBackdropClick = 
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this.closePopover();
        }));
    };
    // Emit the nxClosed event on the popover component when the overlay detaches
    // Emit the nxClosed event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype._subscribeToDetach = 
    // Emit the nxClosed event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.popover.emitClosedEvent();
        }));
    };
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.waitForClose = 
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return event.target; })), filter((/**
         * @param {?} target
         * @return {?}
         */
        function (target) { return !_this.elementRef.nativeElement.contains(target); })), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this.closePopover();
        }));
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionOverlay = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    };
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.positionArrow = /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    function (pair) {
        /** @type {?} */
        var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            var direction = 'left';
            /** @type {?} */
            var arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    };
    /**
     * @private
     * @return {?}
     */
    NxPopoverTriggerDirective.prototype.getPosition = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var positions;
        /** @type {?} */
        var offsetX = 0;
        /** @type {?} */
        var offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions(tslib_1.__spread(positions, fallbacks))
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    };
    NxPopoverTriggerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxPopoverTriggerFor]',
                    exportAs: 'nxPopoverTrigger',
                    host: {
                        '(click)': 'handleClick()',
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'isOpen',
                        '[attr.aria-describedby]': 'isOpen ? id : null'
                    }
                },] }
    ];
    /** @nocollapse */
    NxPopoverTriggerDirective.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: EventManager }
    ]; };
    NxPopoverTriggerDirective.propDecorators = {
        changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
        show: [{ type: Input, args: ['nxPopoverShow',] }],
        closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
        popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
        direction: [{ type: Input, args: ['nxPopoverDirection',] }],
        popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
        visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
        modal: [{ type: Input, args: ['nxPopoverModal',] }],
        trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
        scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }],
        onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
        onMouseExit: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['touchstart',] }]
    };
    return NxPopoverTriggerDirective;
}());
export { NxPopoverTriggerDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUlMLE9BQU8sRUFDUCxhQUFhLEVBR2QsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLFlBQVksRUFDWixLQUFLLEVBR0wsTUFBTSxFQUNOLGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDekQsT0FBTyxFQUFFLFNBQVMsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7O0lBS3JELE1BQU0sR0FBRyxDQUFDOztJQUVSLFNBQVMsR0FBNkI7SUFDMUM7UUFDRSxPQUFPLEVBQUUsT0FBTztRQUNoQixPQUFPLEVBQUUsUUFBUTtRQUNqQixRQUFRLEVBQUUsT0FBTztRQUNqQixRQUFRLEVBQUUsS0FBSztRQUNmLE9BQU8sRUFBRSxDQUFDO1FBQ1YsT0FBTyxFQUFFLEVBQUU7S0FDWjtJQUNEO1FBQ0UsT0FBTyxFQUFFLEtBQUs7UUFDZCxPQUFPLEVBQUUsS0FBSztRQUNkLFFBQVEsRUFBRSxLQUFLO1FBQ2YsUUFBUSxFQUFFLFFBQVE7UUFDbEIsT0FBTyxFQUFFLENBQUM7UUFDVixP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V0M7U0E5VlkseUJBQXlCOzs7Ozs7SUFDcEMsK0NBQStCOzs7OztJQUMvQiwyQ0FBb0M7Ozs7O0lBQ3BDLCtDQUF5Qzs7Ozs7SUFDekMsMENBQStCOzs7OztJQUMvQiwrQ0FBbUM7Ozs7O0lBQ25DLHNEQUE0Qzs7Ozs7SUFDNUMscURBQStDOzs7OztJQUMvQyw2REFBeUQ7Ozs7O0lBR3pELHVDQUE4Qjs7Ozs7SUFHOUIsK0NBQ3VEOzs7OztJQW9DdkQsNENBQzRCOzs7OztJQUc1Qiw4Q0FDc0M7Ozs7O0lBR3RDLDBEQUN1Qzs7Ozs7SUFHdkMsa0RBQzBEOzs7OztJQUcxRCwwQ0FDdUI7Ozs7O0lBTXZCLDRDQUNzQzs7Ozs7SUFHdEMsbURBQ3VEOzs7OztJQUkzQyw0Q0FBd0I7Ozs7O0lBQ3hCLCtDQUE4Qjs7Ozs7SUFDOUIscURBQTBDOzs7OztJQUMxQyxpREFBa0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgQ29ubmVjdGVkUG9zaXRpb24sXG4gIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheUNvbmZpZyxcbiAgT3ZlcmxheVJlZixcbiAgUG9zaXRpb25TdHJhdGVneVxufSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFbWJlZGRlZFZpZXdSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOeFBvcG92ZXJDb21wb25lbnQgfSBmcm9tICcuL3BvcG92ZXIuY29tcG9uZW50JztcblxuZXhwb3J0IGRlY2xhcmUgdHlwZSBQb3BvdmVyRGlyZWN0aW9uID0gJ2xlZnQnIHwgJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbSc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnIHwgJ3JlcG9zaXRpb24nO1xubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IGZhbGxiYWNrczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdID0gW1xuICB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAxNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IC0xNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IDE2XG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnZW5kJyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ2VuZCcsXG4gICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdlbmQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICBvZmZzZXRYOiAxNixcbiAgICBvZmZzZXRZOiAwXG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgb2Zmc2V0WDogLTE2LFxuICAgIG9mZnNldFk6IDBcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgIG9yaWdpblk6ICd0b3AnLFxuICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAtMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogLTE2XG4gIH1cbl07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueFBvcG92ZXJUcmlnZ2VyRm9yXScsXG4gIGV4cG9ydEFzOiAnbnhQb3BvdmVyVHJpZ2dlcicsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdoYW5kbGVDbGljaygpJyxcbiAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnaXNPcGVuJyxcbiAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnaXNPcGVuID8gaWQgOiBudWxsJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE54UG9wb3ZlclRyaWdnZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByaXZhdGUgb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcbiAgcHJpdmF0ZSBwb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XG4gIHByaXZhdGUgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX3Nob3c6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2xvc2VhYmxlOiBib29sZWFuID0gbnVsbDtcbiAgcHJpdmF0ZSBfcG9zaXRpb25TdHJhdGVneTogUG9zaXRpb25TdHJhdGVneTtcbiAgcHJpdmF0ZSBfZW1iZWRkZWRWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcbiAgcHJpdmF0ZSBfZG9jdW1lbnRDbGlja09ic2VydmFibGU6IE9ic2VydmFibGU8TW91c2VFdmVudD47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgaWQgPSAnbngtcG9wb3Zlci0nICsgbmV4dElkKys7XG5cbiAgLyoqIEFuIGV2ZW50IGlzIGVtaXR0ZWQgaWYgdGhlIHZpc2liaWxpdHkgc3RhdHVzIG9mIHRoZSBwb3BvdmVyIGNoYW5nZXMuICovXG4gIEBPdXRwdXQoJ254UG9wb3ZlclNob3dDaGFuZ2UnKVxuICBjaGFuZ2VTaG93OiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqIFdoZXRoZXIgdG8gc2hvdyBvciBoaWRlIHRoZSBwb3BvdmVyLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlclNob3cnKVxuICBzZXQgc2hvdyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fc2hvdyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3Nob3cgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG93KSB7XG4gICAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhbmdlU2hvdy5lbWl0KHRoaXMuX3Nob3cpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzaG93KCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93O1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdG8gc2hvdyBhIGNsb3NlIGJ1dHRvbi4gQnkgZGVmYXVsdCBhIGNsb3NlIGljb24gaXMgb25seSBzaG93biBmb3IgdHJpZ2dlciB0eXBlIGNsaWNrLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlckNsb3NlYWJsZScpXG4gIHNldCBjbG9zZWFibGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jbG9zZWFibGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMucG9wb3Zlcikge1xuICAgICAgdGhpcy5wb3BvdmVyLnNob3dDbG9zZUJ1dHRvbiA9IHRoaXMuaXNDbG9zZWFibGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNsb3NlYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VhYmxlO1xuICB9XG5cbiAgLyoqIExpbmtzIHRoZSB0cmlnZ2VyIHdpdGggdGhlIHBvcG92ZXIgdG8gb3Blbi4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJUcmlnZ2VyRm9yJylcbiAgcG9wb3ZlcjogTnhQb3BvdmVyQ29tcG9uZW50O1xuXG4gIC8qKiBTZXRzIHRoZSBkZXNpcmVkIGRpcmVjdGlvbiB0byBvcGVuIHRoZSBwb3BvdmVyLiBFLmcuLCByaWdodCwgbGVmdCwgYm90dG9tLCB0b3AgKi9cbiAgQElucHV0KCdueFBvcG92ZXJEaXJlY3Rpb24nKVxuICBkaXJlY3Rpb246IFBvcG92ZXJEaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHdpbGwgYmUgb3BlbmVkIGF1dG9tYXRpY2FsbHkuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVySW5pdGlhbFZpc2libGUnKVxuICBwb3BvdmVySW5pdGlhbFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQW4gZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwb3BvcHZlciBjaGFuZ2VzLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlclZpc2libGVDaGFuZ2UnKVxuICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgb3BlbnMgaW4gbW9kYWwgc3RhdGUuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyTW9kYWwnKVxuICBtb2RhbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIElmIG54UG9wb3ZlclRyaWdnZXIgZXF1YWxzIHRvICdob3ZlcicgdGhlIHBvcG92ZXIgb3BlbnMgb24gbW91c2VlbnRlciBhbmQgY2xvc2VzIG9uIG1vdXNlb3V0LlxuICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnY2xpY2snIHRoZSBwb3BvdmVyIG9wZW5zIG9uIGNsaWNrIGFuZCBjbG9zZXMgb24gYSBjbGljayBvZiB0aGUgY2xvc2UgaWNvbiBvciBwcmVzc2luZyBFU0Mga2V5LlxuICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnbWFudWFsJyB0aGUgcG9wb3ZlciBvcGVucyBvbmx5IHdoZW4gcHJvZ3JhbWF0aWNhbGx5IHJlcXVlc3RlZC5cbiAgLyoqIFNldHMgdGhlIHdheSB0byB0cmlnZ2VyIHRoZSBwb3BvdmVyLiBPcHRpb25zIGFyZSBob3ZlciwgY2xpY2ssIG1hbnVhbCAqL1xuICBASW5wdXQoJ254UG9wb3ZlclRyaWdnZXInKVxuICB0cmlnZ2VyOiBQb3BvdmVyVHJpZ2dlclR5cGUgPSAnY2xpY2snO1xuXG4gIC8qKiBTZXRzIHRoZSBzY3JvbGwgc3RyYXRlZ3kuICdjbG9zZScgY2xvc2VzIHRoZSBwb3BvdmVyIG9uIHNjcm9sbCB3aGlsZSAncmVwb3NpdGlvbicgc2Nyb2xscyB0aGUgcG9wb3ZlciB3aXRoIHRoZSBvcmlnaW4uICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyU2Nyb2xsU3RyYXRlZ3knKVxuICBzY3JvbGxTdHJhdGVneTogUG9wb3ZlclRyaWdnZXJTY3JvbGxTdHJhdGVneSA9ICdjbG9zZSc7XG5cblxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIpIHtcbiAgICB0aGlzLl9kb2N1bWVudENsaWNrT2JzZXJ2YWJsZSA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pihkb2N1bWVudCwgJ2NsaWNrJyk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgb25Nb3VzZUVudGVyKCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJylcbiAgQEhvc3RMaXN0ZW5lcigndG91Y2hzdGFydCcpXG4gIG9uTW91c2VFeGl0KCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5wb3BvdmVyLnNob3dDbG9zZUJ1dHRvbiA9IHRoaXMuaXNDbG9zZWFibGUoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnBvcG92ZXIuaWQgPSB0aGlzLmlkO1xuXG4gICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignd2luZG93JywgJ2tleXVwLmVzYycsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBvcG92ZXIuY2xvc2VCdXR0b25DbGljay5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnBvcG92ZXJJbml0aWFsVmlzaWJsZSB8fCB0aGlzLl9zaG93KSB7XG4gICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB0aGlzLl9kZXN0cm95ZWQubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmICYmIHRoaXMuY3JlYXRlT3ZlcmxheSgpLmhhc0F0dGFjaGVkKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBpc0Nsb3NlYWJsZSgpIHtcbiAgICByZXR1cm4gKHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9jbG9zZWFibGUgPT09IG51bGwpIHx8IHRoaXMuX2Nsb3NlYWJsZTtcbiAgfVxuXG4gIC8qKiBVcGRhdGUgdGhlIHBvcG92ZXIgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gc3RyYXRlZ3kuICovXG4gIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5LmFwcGx5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIE9wZW4gdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBDbG9zZSB0aGUgcG9wb3ZlciBpbnN0YW5jZS4gKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gIH1cblxuICAvKiogVG9nZ2xlIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICB0b2dnbGUoKTogdm9pZCB7XG4gICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgfVxuXG4gIHByaXZhdGUgb3BlblBvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNyZWF0ZU92ZXJsYXkoKS5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICB0aGlzLl9lbWJlZGRlZFZpZXdSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5wb3J0YWwpO1xuXG4gICAgICBpZiAoIXRoaXMubW9kYWwgJiYgdGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMud2FpdEZvckNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZGV0YWNoZXMgdGhlIG92ZXJsYXlcbiAgLy8gd2UgYXJlIGxpc3RlbmluZyB0byB0aGUgZGV0YWNobWVudHMgb2JzZXJ2YWJsZSB3aGljaCB3aWxsIHRoZW4gZW1pdCB0aGUgbnhDbG9zZWQgZXZlbnRcbiAgLy8gb24gdGhlIHBvcG92ZXIgY29tcG9uZW50XG4gIHByaXZhdGUgY2xvc2VQb3BvdmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMub3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xuICAgIGlmICghdGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLnBvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLnBvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMudmlld0NvbnRhaW5lclJlZik7XG4gICAgICBjb25zdCBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheUNvbmZpZygpO1xuICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmdldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5ID0gb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3k7XG5cbiAgICAgIGlmICh0aGlzLnNjcm9sbFN0cmF0ZWd5ID09PSAncmVwb3NpdGlvbicpIHtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5LmVuYWJsZSgpO1xuXG4gICAgICBpZiAodGhpcy5tb2RhbCAmJiB0aGlzLnRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgb3ZlcmxheVN0YXRlLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdmVybGF5UmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZShvdmVybGF5U3RhdGUpO1xuICAgICAgdGhpcy5zdWJzY3JpYmVUb1Bvc2l0aW9ucyhvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2goKTtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1Bvc2l0aW9ucyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XG4gICAgcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgY29uc3QgcGFpciA9IGNoYW5nZS5jb25uZWN0aW9uUGFpcjtcbiAgICAgIHRoaXMucG9zaXRpb25PdmVybGF5KHBhaXIpO1xuICAgICAgdGhpcy5wb3NpdGlvbkFycm93KHBhaXIpO1xuXG4gICAgICAvLyBUaGVzZSBwb3NpdGlvbiBjaGFuZ2VzIGFycml2ZSB0b28gbGF0ZSxcbiAgICAgIC8vIFdlIGhhdmUgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseVxuICAgICAgLy8gYXMgaXQncyBkZXRhY2hlZCBmcm9tIGFueSByZW5kZXIgaGllcmFyY2h5XG4gICAgICAvLyBhbmQgb25seSB1cGRhdGVkIGJ5IHRoZSBvdmVybGF5IHdoZW4gYXR0YWNoZWQuXG4gICAgICBpZiAodGhpcy5fZW1iZWRkZWRWaWV3UmVmICYmICF0aGlzLl9lbWJlZGRlZFZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbW9kYWwgcG9wb3ZlcnMgY2xvc2UgdGhlIHBvcG92ZXIgb24gYmFja2Ryb3AgY2xpY2tzXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBFbWl0IHRoZSBueENsb3NlZCBldmVudCBvbiB0aGUgcG9wb3ZlciBjb21wb25lbnQgd2hlbiB0aGUgb3ZlcmxheSBkZXRhY2hlc1xuICBwcml2YXRlIF9zdWJzY3JpYmVUb0RldGFjaCgpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWYuZGV0YWNobWVudHMoKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5wb3BvdmVyLmVtaXRDbG9zZWRFdmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3Vic2NyaWJlIHRvIGRvY3VtZW50IGNsaWNrcyB3aGVuIHRyaWdnZXI9J2NsaWNrJyB0byBjbG9zZSB0aGUgcG9wb3ZlciBvbiBjbGlja3Mgb24gdGhlIGJhY2tncm91bmRcbiAgcHJpdmF0ZSB3YWl0Rm9yQ2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKGV2ZW50ID0+IGV2ZW50LnRhcmdldCksXG4gICAgICAgIGZpbHRlcih0YXJnZXQgPT4gIXRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyLmNsb3NlZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3NpdGlvbk92ZXJsYXkocGFpcjogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuICAgIGlmIChwYWlyLm9yaWdpblggPT09ICdlbmQnICYmIHBhaXIub3ZlcmxheVggPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgIH0gZWxzZSBpZiAocGFpci5vcmlnaW5ZID09PSAnYm90dG9tJyAmJiBwYWlyLm92ZXJsYXlZID09PSAndG9wJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9ICdib3R0b20nO1xuICAgIH0gZWxzZSBpZiAocGFpci5vcmlnaW5YID09PSAnc3RhcnQnICYmIHBhaXIub3ZlcmxheVggPT09ICdlbmQnKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAocGFpci5vcmlnaW5ZID09PSAndG9wJyAmJiBwYWlyLm92ZXJsYXlZID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9ICd0b3AnO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcG9zaXRpb25BcnJvdyhwYWlyOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKSB7XG5cbiAgICBjb25zdCBwYXJlbnRFbGVtZW50UG9zaXRpb25YID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50V2lkdGggPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDI7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudExlZnRPZmZzZXQgPSB0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQucGFyZW50RWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgIGNvbnN0IG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldCA9IHRoaXMub3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5vZmZzZXRMZWZ0O1xuXG4gICAgLy8gY2FsY3VsYXRpb24gZm9yIHggcG9zaXRpb24gb2YgdGhlIHBhcmVudCBlbGVtZW50LiBJbiB0aGlzIGNhc2UsIG92ZXJsYXkgbGVmdCBvZmZzZXQgaXMgdGhlIG9uZSB0aGluZyB0byBjb25zaWRlci5cbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IChwYXJlbnRFbGVtZW50UG9zaXRpb25YICsgcGFyZW50RWxlbWVudFdpZHRoKSAtIChwYXJlbnRFbGVtZW50TGVmdE9mZnNldCArIG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldCk7XG4gICAgaWYgKHBhaXIub3JpZ2luWCA9PT0gcGFpci5vdmVybGF5WCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgY29uc3QgYXJyb3dTdHlsZSA9IHt9O1xuXG4gICAgICBhcnJvd1N0eWxlW2RpcmVjdGlvbl0gPSB0YXJnZXRQb3NpdGlvbiArICdweCc7XG4gICAgICB0aGlzLnBvcG92ZXIuYXJyb3dTdHlsZSA9IGFycm93U3R5bGU7XG4gICAgfVxuICAgIGlmICgocGFpci5vcmlnaW5ZID09PSAnYm90dG9tJyB8fCBwYWlyLm9yaWdpblkgPT09ICd0b3AnKSAmJiBwYWlyLm92ZXJsYXlYID09PSAnY2VudGVyJykge1xuICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSB7IGxlZnQ6IHRhcmdldFBvc2l0aW9uICsgJ3B4JyB9O1xuICAgIH1cblxuICAgIGlmICgocGFpci5vcmlnaW5YID09PSAnZW5kJyB8fCBwYWlyLm9yaWdpblggPT09ICdzdGFydCcpICYmIHBhaXIub3ZlcmxheVkgPT09ICdjZW50ZXInKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuYXJyb3dTdHlsZSA9IHsgdG9wOiAnNTAlJyB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UG9zaXRpb24oKTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBsZXQgcG9zaXRpb25zOiBDb25uZWN0ZWRQb3NpdGlvbltdO1xuICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndG9wJykge1xuICAgICAgcG9zaXRpb25zID0gW3tcbiAgICAgICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgICAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5ZOiAndG9wJ1xuICAgICAgfV07XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICAgIG9mZnNldFkgPSAtMjA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcG9zaXRpb25zID0gW3tcbiAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInXG4gICAgICB9XTtcbiAgICAgIG9mZnNldFggPSAyMDtcbiAgICAgIG9mZnNldFkgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBwb3NpdGlvbnMgPSBbe1xuICAgICAgICBvdmVybGF5WDogJ2NlbnRlcicsXG4gICAgICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblk6ICdib3R0b20nXG4gICAgICB9XTtcbiAgICAgIG9mZnNldFggPSAwO1xuICAgICAgb2Zmc2V0WSA9IDIwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgcG9zaXRpb25zID0gW3tcbiAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInXG4gICAgICB9XTtcbiAgICAgIG9mZnNldFggPSAtMjA7XG4gICAgICBvZmZzZXRZID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheS5wb3NpdGlvbigpLmZsZXhpYmxlQ29ubmVjdGVkVG8odGhpcy5lbGVtZW50UmVmKVxuICAgICAgLndpdGhQb3NpdGlvbnMoWy4uLnBvc2l0aW9ucywgLi4uZmFsbGJhY2tzXSlcbiAgICAgIC53aXRoRGVmYXVsdE9mZnNldFgob2Zmc2V0WClcbiAgICAgIC53aXRoRGVmYXVsdE9mZnNldFkob2Zmc2V0WSk7XG4gIH1cbn1cbiJdfQ==