/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { NxFormfieldComponent, NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, SHIFT, TAB } from '@angular/cdk/keycodes';
import { CdkConnectedOverlay } from '@angular/cdk/overlay';
import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Input, isDevMode, NgZone, Optional, Output, Self, ViewChild, TemplateRef, ContentChild, } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { defer, merge, Observable, Subject } from 'rxjs';
import { filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';
import { getNxDropdownNonArrayValueError, getNxDropdownNonFunctionValueError } from './dropdown-errors';
import { NxDropdownControl } from './dropdown.control';
import { NxDropdownGroupComponent } from './group/dropdown-group';
import { NxDropdownItemComponent } from './item/dropdown-item';
import { NxDropdownClosedLabelDirective } from './closed-label.directive';
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
var /**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
NxDropdownSelectChange = /** @class */ (function () {
    function NxDropdownSelectChange(source, value) {
        this.source = source;
        this.value = value;
    }
    return NxDropdownSelectChange;
}());
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
export { NxDropdownSelectChange };
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
// used in calculation of scrolltop to correctly show some space to the top of the panel
/** @type {?} */
var itemPadding = 16;
// Max-height: 6 items x 44px + 16px padding before first item
/** @type {?} */
export var SELECT_PANEL_MAX_HEIGHT = 280;
var NxDropdownComponent = /** @class */ (function (_super) {
    tslib_1.__extends(NxDropdownComponent, _super);
    function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        var _this = _super.call(this) || this;
        _this._changeDetectorRef = _changeDetectorRef;
        _this._elementRef = _elementRef;
        _this._ngZone = _ngZone;
        _this.formFieldComponent = formFieldComponent;
        _this.ngControl = ngControl;
        _this._parentForm = _parentForm;
        _this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        _this.readonly = false;
        _this._disabled = false;
        _this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        _this._panelOpen = false;
        /**
         * \@docs-private
         */
        _this.errorState = false;
        /**
         * The scroltop of the panelBody.
         */
        _this._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */
        _this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        _this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        _this._optionIds = '';
        _this._tabIndex = 0;
        /**
         * \@docs-private
         */
        _this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        _this._ariaLabel = '';
        _this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        _this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        _this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        _this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        _this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        _this._openedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the select has been closed.
         */
        _this._closedStream = _this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return !o; })), map((/**
         * @return {?}
         */
        function () { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        _this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        _this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        _this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        _this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        function () {
            if (_this.options) {
                return merge.apply(void 0, tslib_1.__spread(_this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.onSelectionChange; }))));
            }
            return _this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            function () { return _this.optionSelectionChanges; })));
        }));
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */
        _this._positions = [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
        /**
         * Emits whenever the component is destroyed.
         */
        _this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        _this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        _this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        function (o1, o2) { return o1 === o2; });
        _this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        function (search, itemValue) {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        _this._onChange = (/**
         * @return {?}
         */
        function () { });
        /**
         * `View -> model callback called when select has been touched`
         */
        _this._onTouched = (/**
         * @return {?}
         */
        function () { });
        if (_this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            _this.ngControl.valueAccessor = _this;
        }
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
        get: /**
         * @return {?}
         */
        function () { return this.disabled ? -1 : this._tabIndex; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // If the specified tabIndex value is null or undefined, fall back to the default value.
            this._tabIndex = value != null ? value : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "value", {
        /** Selected value */
        get: /**
         * Selected value
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (newValue !== this._value) {
                this.writeValue(newValue);
                this._value = newValue;
                this._onChange(newValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
        /** Whether the dropdown is disabled. */
        get: /**
         * Whether the dropdown is disabled.
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "styles", {
        /** If set to 'negative', the component is displayed with the negative set of styles. */
        set: /**
         * If set to 'negative', the component is displayed with the negative set of styles.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._style === value) {
                return;
            }
            this._style = value;
            this._negative = !!this._style.match(/negative/);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._closedDropdownLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "selected", {
        /**
         * @docs-private
         * The currently selected option.
         */
        get: /**
         * \@docs-private
         * The currently selected option.
         * @return {?}
         */
        function () {
            return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._panelOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._panelOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "label", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.formFieldComponent ? this.formFieldComponent.label : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
        /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         */
        get: /**
         * Function to compare the option values with the selected values. The first argument
         * is a value from an option. The second is a value from the selection. A boolean
         * should be returned.
         * @return {?}
         */
        function () { return this._compareWith; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._compareWith = fn;
            if (this._selectionModel) {
                // A different comparator means the selection could change.
                this._initializeSelection();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
        /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         */
        get: /**
         * Function to be used when the user types into the search filter. The first argument is the user input,
         * the second argument is the dropdown item value. The dropdown items will use this function to set their
         * visibility state.
         * A boolean should be returned.
         * @return {?}
         */
        function () { return this._filterFn; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (typeof fn !== 'function') {
                throw getNxDropdownNonFunctionValueError();
            }
            this._filterFn = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "focused", {
        /**
         * @docs-private
         * Whether the select is focused.
         */
        get: /**
         * \@docs-private
         * Whether the select is focused.
         * @return {?}
         */
        function () {
            return this._focused || this.panelOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            this.updateErrorState();
        }
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.onChange.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.select(); }));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.deselect(); }));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            _this._resetOptions();
            _this._initializeSelection();
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next();
        this._destroy.complete();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    NxDropdownComponent.prototype.isErrorState = /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    };
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initKeyManager = /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item._hidden; }));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            _this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        function () {
            if (_this._panelOpen && _this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                _this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                function () { return _this._scrollActiveOptionIntoView(); }));
            }
            else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                _this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._resetOptions = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            _this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                _this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge.apply(void 0, tslib_1.__spread(this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._stateChanges; })))).pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this._changeDetectorRef.markForCheck();
                _this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    };
    /** Records option IDs to pass to the aria-owns property. */
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._setOptionIds = /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    function () {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option.id; })).join(' ');
    };
    /** Invoked when an option is clicked. */
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    NxDropdownComponent.prototype._onSelect = /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    function (option, isUserInput) {
        /** @type {?} */
        var wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
                if (isUserInput) {
                    // In case the user selected the option with their mouse, we
                    // want to restore focus back to the trigger, in order to
                    // prevent the select keyboard controls from clashing with
                    // the ones from `mat-option`.
                    this.focus();
                }
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    };
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._initializeSelection = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        function () {
            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
        }));
    };
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype._setSelectionByValue = /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            function (currentValue) { return _this._selectValue(currentValue); }));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            var correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Finds and selects and option based on its value.
     * @returns Option that has the corresponding value.
     */
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    NxDropdownComponent.prototype._selectValue = /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            try {
                // Treat null as a special reset value.
                return option.value != null && _this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    };
    /** Emits change event to set the model value. */
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    NxDropdownComponent.prototype._propagateChanges = /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    function (fallbackValue) {
        /** @type {?} */
        var valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.value; }));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    };
    /** Sorts the selected values in the selected based on their order in the panel. */
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._sortValues = /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    function () {
        if (this.isMultiSelect) {
            /** @type {?} */
            var options_1 = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
            this.stateChanges.next();
        }
    };
    /** Focuses the select element. */
    /**
     * Focuses the select element.
     * @return {?}
     */
    NxDropdownComponent.prototype.focus = /**
     * Focuses the select element.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /** Opens the panel of the dropdown. */
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.openPanel = /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    function () {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    };
    /** Closes the panel of the dropdown. */
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    NxDropdownComponent.prototype.closePanel = /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._panelOpen) {
            this._panelOpen = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.focus(); }));
        }
    };
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._calculateScrollTop = 
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    function () {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        this._scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            var offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            var panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */
            var activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                // to middle out the text a bit more add half of the height
                // (this is still a few pixels off because the container is a bit larger than the font)
                this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
                this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
        }
    };
    /** Scrolls the active option into view. */
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    function () {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        var activeOptionIndex = this._keyManager.activeItemIndex || 0;
        /** @type {?} */
        var itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);
        this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
    };
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    NxDropdownComponent.prototype._countGroupLabelsBeforeOption = /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    function (optionIndex, options, optionGroups) {
        if (optionGroups.length) {
            /** @type {?} */
            var optionsArray = options.toArray();
            /** @type {?} */
            var groups = optionGroups.toArray();
            /** @type {?} */
            var groupCounter = 0;
            for (var i = 0; i < optionIndex + 1; i++) {
                if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                    groupCounter++;
                }
            }
            return groupCounter;
        }
        return 0;
    };
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    NxDropdownComponent.prototype._getOptionScrollPosition = /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    function (optionIndex, optionHeight, currentScrollPosition, panelHeight) {
        /** @type {?} */
        var optionOffset = optionIndex * optionHeight + itemPadding;
        if (this.showFilter) {
            /** @type {?} */
            var filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
        }
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    NxDropdownComponent.prototype._getItemOffset = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top;
    };
    /**
     * @docs-private
     * Formfield Implementation
     */
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    NxDropdownComponent.prototype.setDescribedByIds = /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this.ariaDescribedby = ids.join(' ');
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.setAriaLabel = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._ariaLabel = value;
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaLabel = /**
     * @return {?}
     */
    function () {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    };
    Object.defineProperty(NxDropdownComponent.prototype, "empty", {
        /**
         * @docs-private
         * Whether the select has a value.
         */
        get: /**
         * \@docs-private
         * Whether the select has a value.
         * @return {?}
         */
        function () {
            return !this._selectionModel || this._selectionModel.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._selectionModel.hasValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.focused || !this.empty;
        },
        enumerable: true,
        configurable: true
    });
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param value New value to be written to the model.
     */
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    NxDropdownComponent.prototype.writeValue = /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    function (value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NxDropdownComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    NxDropdownComponent.prototype.setDisabledState = /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    };
    /** End ControlValueAccessor */
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleKeydown = /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleClosedKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        var isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._handleOpenKeydown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        // all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)) {
            return;
        }
        /** @type {?} */
        var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        var manager = this._keyManager;
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            var previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    NxDropdownComponent.prototype.formatValue = /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.valueFormatter(value);
    };
    /** Called when the user types in the filter input */
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    NxDropdownComponent.prototype._onFilter = /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        var allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return option._hidden; })).every((/**
         * @param {?} option
         * @return {?}
         */
        function (option) { return Boolean(option); }));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
        /**
         * @docs-private
         * The value displayed in the trigger.
         */
        get: /**
         * \@docs-private
         * The value displayed in the trigger.
         * @return {?}
         */
        function () {
            if (this.empty) {
                return '';
            }
            if (this.isMultiSelect) {
                /** @type {?} */
                var selectedOptions = this._selectionModel.selected.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.viewValue; }));
                return selectedOptions.join(', ');
            }
            return this._selectionModel.selected[0].viewValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     */
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    NxDropdownComponent.prototype._highlightCorrectOption = /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    function () {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    };
    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    NxDropdownComponent.prototype._onAttached = /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    function () {
        var _this = this;
        this._changeDetectorRef.markForCheck();
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.panelBody.nativeElement.focus();
            if (_this._keyManager.activeItem) {
                _this._calculateScrollTop();
            }
            _this._changeDetectorRef.markForCheck();
            _this.openedChange.emit(true);
            if (_this.showFilter) {
                _this.filterInput.nativeElement.focus();
            }
        }));
    };
    /**
     * @return {?}
     */
    NxDropdownComponent.prototype._onFocus = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    };
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     */
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    NxDropdownComponent.prototype._onBlur = /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    function () {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    };
    Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.currentFilter.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxDropdownComponent.prototype._clearFilter = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    };
    /** @docs-private determines the `aria-activedescendant` to be set on the host. */
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    NxDropdownComponent.prototype._getAriaActiveDescendant = /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    function () {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    };
    NxDropdownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-dropdown',
                    template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                        { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                    ],
                    host: {
                        'role': 'button',
                        '[class.nx-dropdown]': 'true',
                        '[class.is-filled]': 'hasValue',
                        '[class.has-focus]': 'focused',
                        '[class.nx-dropdown--negative]': '_negative',
                        '[class.nx-dropdown--disabled]': 'disabled',
                        '[attr.aria-describedby]': 'ariaDescribedby || null',
                        '[attr.aria-required]': 'required',
                        '[attr.aria-label]': '_getAriaLabel()',
                        '[attr.aria-haspopup]': '"listbox"',
                        '[attr.aria-expanded]': 'panelOpen',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.tabindex]': 'tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': '_onFocus()',
                        '(blur)': '_onBlur()',
                        '(click)': 'openPanel()'
                    },
                    styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
                }] }
    ];
    /** @nocollapse */
    NxDropdownComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
        { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    NxDropdownComponent.propDecorators = {
        tabIndex: [{ type: Input }],
        _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
        value: [{ type: Input, args: ['nxValue',] }],
        disabled: [{ type: Input, args: ['nxDisabled',] }],
        required: [{ type: Input, args: ['nxRequired',] }],
        styles: [{ type: Input, args: ['nxStyle',] }],
        showFilter: [{ type: Input, args: ['nxShowFilter',] }],
        filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
        openedChange: [{ type: Output }],
        _openedStream: [{ type: Output, args: ['opened',] }],
        _closedStream: [{ type: Output, args: ['closed',] }],
        filterChanges: [{ type: Output, args: ['filterInput',] }],
        valueChange: [{ type: Output, args: ['nxValueChange',] }],
        selectionChange: [{ type: Output }],
        panel: [{ type: ViewChild, args: ['panel',] }],
        panelBody: [{ type: ViewChild, args: ['panelBody',] }],
        trigger: [{ type: ViewChild, args: ['trigger',] }],
        filterInput: [{ type: ViewChild, args: ['filterInput',] }],
        overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
        options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
        groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
        _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective,] }],
        _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel',] }],
        valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
        compareWith: [{ type: Input }],
        filterFn: [{ type: Input }]
    };
    return NxDropdownComponent;
}(NxDropdownControl));
export { NxDropdownComponent };
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The scroltop of the panelBody.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._scrollTop;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC8iLCJzb3VyY2VzIjpbImRyb3Bkb3duL2Ryb3Bkb3duLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDdkYsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzSCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBRUwsU0FBUyxFQUNULHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULGVBQWUsRUFFZixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFDTCxTQUFTLEVBQ1QsTUFBTSxFQUdOLFFBQVEsRUFDUixNQUFNLEVBRU4sSUFBSSxFQUNKLFNBQVMsRUFDVCxXQUFXLEVBQ1gsWUFBWSxHQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBcUMsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekQsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEYsT0FBTyxFQUFF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cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTnhGb3JtZmllbGRDb21wb25lbnQsIE54Rm9ybWZpZWxkQ29udHJvbCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2Zvcm1maWVsZCc7XG5pbXBvcnQgeyBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IERPV05fQVJST1csIEVORCwgRU5URVIsIEhPTUUsIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBTUEFDRSwgVVBfQVJST1csIFNISUZULCBUQUIgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgQ2RrQ29ubmVjdGVkT3ZlcmxheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEF0dHJpYnV0ZSxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRG9DaGVjayxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgaXNEZXZNb2RlLFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNlbGYsXG4gIFZpZXdDaGlsZCxcbiAgVGVtcGxhdGVSZWYsXG4gIENvbnRlbnRDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cERpcmVjdGl2ZSwgTmdDb250cm9sLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBkZWZlciwgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBnZXROeERyb3Bkb3duTm9uQXJyYXlWYWx1ZUVycm9yLCBnZXROeERyb3Bkb3duTm9uRnVuY3Rpb25WYWx1ZUVycm9yIH0gZnJvbSAnLi9kcm9wZG93bi1lcnJvcnMnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkNvbnRyb2wgfSBmcm9tICcuL2Ryb3Bkb3duLmNvbnRyb2wnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9ncm91cC9kcm9wZG93bi1ncm91cCc7XG5pbXBvcnQgeyBOeERyb3Bkb3duSXRlbUNoYW5nZSwgTnhEcm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2l0ZW0vZHJvcGRvd24taXRlbSc7XG5pbXBvcnQgeyBOeERyb3Bkb3duQ2xvc2VkTGFiZWxEaXJlY3RpdmUgfSBmcm9tICcuL2Nsb3NlZC1sYWJlbC5kaXJlY3RpdmUnO1xuXG5cbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgdmFsdWUgaGFzIGNoYW5nZWQuICovXG5leHBvcnQgY2xhc3MgTnhEcm9wZG93blNlbGVjdENoYW5nZTxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHNlbGVjdCB0aGF0IGVtaXR0ZWQgdGhlIGNoYW5nZSBldmVudC4gKi9cbiAgICBwdWJsaWMgc291cmNlOiBOeERyb3Bkb3duQ29tcG9uZW50LFxuICAgIC8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBzZWxlY3QgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBwdWJsaWMgdmFsdWU6IFQpIHsgfVxufVxuXG4vLyB1c2VkIGluIGNhbGN1bGF0aW9uIG9mIHNjcm9sbHRvcCB0byBjb3JyZWN0bHkgc2hvdyBzb21lIHNwYWNlIHRvIHRoZSB0b3Agb2YgdGhlIHBhbmVsXG5jb25zdCBpdGVtUGFkZGluZyA9IDE2O1xuXG4vLyBNYXgtaGVpZ2h0OiA2IGl0ZW1zIHggNDRweCArIDE2cHggcGFkZGluZyBiZWZvcmUgZmlyc3QgaXRlbVxuZXhwb3J0IGNvbnN0IFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gMjgwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1kcm9wZG93bicsXG4gIHRlbXBsYXRlVXJsOiAnZHJvcGRvd24uaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBzdHlsZVVybHM6IFsnZHJvcGRvd24uc2NzcyddLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IE54RHJvcGRvd25Db250cm9sLCB1c2VFeGlzdGluZzogTnhEcm9wZG93bkNvbXBvbmVudCB9LFxuICAgIHsgcHJvdmlkZTogTnhGb3JtZmllbGRDb250cm9sLCB1c2VFeGlzdGluZzogTnhEcm9wZG93bkNvbXBvbmVudCB9LFxuICBdLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmlzLWZpbGxlZF0nOiAnaGFzVmFsdWUnLFxuICAgICdbY2xhc3MuaGFzLWZvY3VzXSc6ICdmb2N1c2VkJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duLS1uZWdhdGl2ZV0nOiAnX25lZ2F0aXZlJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duLS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkYnkgfHwgbnVsbCcsXG4gICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnX2dldEFyaWFMYWJlbCgpJyxcbiAgICAnW2F0dHIuYXJpYS1oYXNwb3B1cF0nOiAnXCJsaXN0Ym94XCInLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4nLFxuICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQgfHwgbnVsbCcsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgJyhjbGljayknOiAnb3BlblBhbmVsKCknXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIE54RHJvcGRvd25Db250cm9sIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBEb0NoZWNrIHtcblxuICAvLyBUaGUgZHJvcGRvd24gY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCByZWFkb25seSBvZiB0aGUgTnhGb3JtZmllbGRDb250cm9sIHNvIHdlIGhhcmRjb2RlIGl0IGhlcmVcbiAgcmVhZG9ubHkgcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9zZWxlY3Rpb25Nb2RlbDogU2VsZWN0aW9uTW9kZWw8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+O1xuXG4gIHByb3RlY3RlZCBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gIHByaXZhdGUgX3BhbmVsT3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogSG9sZHMgdGhlIHZhbHVlIGZyb20gbnhWYWx1ZS4gKi9cbiAgcHJpdmF0ZSBfdmFsdWU6IGFueTtcblxuICAvKiogVGhlIHNjcm9sdG9wIG9mIHRoZSBwYW5lbEJvZHkuICovXG4gIHByaXZhdGUgX3Njcm9sbFRvcDogbnVtYmVyID0gMDtcblxuICAvKiogVGhlIG1pbmltYWwgc3BhY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgYW5kIHRoZSBvdmVybGF5ICovXG4gIF9vdmVybGF5Vmlld3BvcnRNYXJnaW46IG51bWJlciA9IDE2O1xuXG4gIC8qKiBUaGUgbGFzdCBtZWFzdXJlZCB2YWx1ZSBmb3IgdGhlIHRyaWdnZXIncyBjbGllbnQgYm91bmRpbmcgcmVjdC4gKi9cbiAgX3RyaWdnZXJSZWN0OiBDbGllbnRSZWN0O1xuXG4gIC8qKiBIb2xkcyB0aGUgcGFuZWxXaWR0aCBhZnRlciBwYW5lbCB3YXMgYXR0YWNoZWQuICovXG4gIF9wYW5lbFdpZHRoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogRW1pdHMgd2hlbiBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIHRvIGluZm9ybSBmb3JtZmllbGQgYWJvdXQgaXQuXG4gICAqL1xuICByZWFkb25seSBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuICovXG4gIF9vcHRpb25JZHM6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGFyaWFEZXNjcmliZWRieTogc3RyaW5nO1xuXG4gIHByaXZhdGUgX3RhYkluZGV4OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGN1cnJlbnRGaWx0ZXI6IHN0cmluZyA9ICcnO1xuXG5cbiAgQElucHV0KClcbiAgZ2V0IHRhYkluZGV4KCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiB0aGlzLl90YWJJbmRleDsgfVxuICBzZXQgdGFiSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgdGFiSW5kZXggdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICB0aGlzLl90YWJJbmRleCA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IDA7XG4gIH1cblxuICAvKiogTGFiZWwgdG8gZGVzY3JpYmUgdGhlIGNvbXBvbmVudC4gKi9cbiAgQElucHV0KCdueEFyaWFMYWJlbCcpIF9hcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBTZWxlY3RlZCB2YWx1ZSAqL1xuICBASW5wdXQoJ254VmFsdWUnKVxuICBnZXQgdmFsdWUoKTogYW55IHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZTogYW55KSB7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy53cml0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9vbkNoYW5nZShuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGRyb3Bkb3duIGlzIGRpc2FibGVkLiAqL1xuICBASW5wdXQoJ254RGlzYWJsZWQnKVxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWU7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlcXVpcmVkLiBUaGlzIGFkZHMgYW4gYXJpYS1yZXF1aXJlZCBsYWJlbCB0byB0aGUgY29tcG9uZW50LiAqL1xuICBASW5wdXQoJ254UmVxdWlyZWQnKSByZXF1aXJlZDogYm9vbGVhbjtcblxuICBwcml2YXRlIF9zdHlsZTogc3RyaW5nID0gJyc7XG4gIC8qKiBXaGV0aGVyIHRoZSBkcm9wZG93biBzaG91bGQgcmVuZGVyIGluIGl0cyBuZWdhdGl2ZSBzdHlsZSBvciBub3QuICovXG4gIF9uZWdhdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBJZiBzZXQgdG8gJ25lZ2F0aXZlJywgdGhlIGNvbXBvbmVudCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgbmVnYXRpdmUgc2V0IG9mIHN0eWxlcy4gKi9cbiAgQElucHV0KCdueFN0eWxlJylcbiAgc2V0IHN0eWxlcyh2YWx1ZTogc3RyaW5nKSB7XG5cbiAgICBpZiAodGhpcy5fc3R5bGUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3R5bGUgPSB2YWx1ZTtcbiAgICB0aGlzLl9uZWdhdGl2ZSA9ICEhdGhpcy5fc3R5bGUubWF0Y2goL25lZ2F0aXZlLyk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIHNob3duIHdpdGggYW4gYWRkaXRpb25hbCBmaWx0ZXIgaW5wdXQuICovXG4gIEBJbnB1dCgnbnhTaG93RmlsdGVyJykgc2hvd0ZpbHRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUZXh0IGRpc3BsYXllZCBhcyBwbGFjZWhvbGRlciBmb3IgdGhlIGZpbHRlci4gKi9cbiAgQElucHV0KCdueEZpbHRlclBsYWNlaG9sZGVyJykgZmlsdGVyUGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBwYW5lbCBoYXMgYmVlbiB0b2dnbGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgb3BlbmVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgnb3BlbmVkJykgcmVhZG9ubHkgX29wZW5lZFN0cmVhbTogT2JzZXJ2YWJsZTx2b2lkPiA9XG4gICAgdGhpcy5vcGVuZWRDaGFuZ2UucGlwZShmaWx0ZXIobyA9PiBvKSwgbWFwKCgpID0+IHsgfSkpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBjbG9zZWQuICovXG4gIEBPdXRwdXQoJ2Nsb3NlZCcpIHJlYWRvbmx5IF9jbG9zZWRTdHJlYW06IE9ic2VydmFibGU8dm9pZD4gPVxuICAgIHRoaXMub3BlbmVkQ2hhbmdlLnBpcGUoZmlsdGVyKG8gPT4gIW8pLCBtYXAoKCkgPT4geyB9KSk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdXNlciB0eXBlcyBpbiB0aGUgZmlsdGVyIGlucHV0LiAqL1xuICBAT3V0cHV0KCdmaWx0ZXJJbnB1dCcpIHJlYWRvbmx5IGZpbHRlckNoYW5nZXM6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzZWxlY3QgY2hhbmdlcy4gVGhpcyBpcyBoZXJlIHByaW1hcmlseVxuICAgKiB0byBmYWNpbGl0YXRlIHRoZSB0d28td2F5IGJpbmRpbmcgZm9yIHRoZSBgdmFsdWVgIGlucHV0LlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqL1xuICBAT3V0cHV0KCdueFZhbHVlQ2hhbmdlJykgcmVhZG9ubHkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPE54RHJvcGRvd25TZWxlY3RDaGFuZ2U+ID1cbiAgICBuZXcgRXZlbnRFbWl0dGVyPE54RHJvcGRvd25TZWxlY3RDaGFuZ2U+KCk7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgcmVhZG9ubHkgb3B0aW9uU2VsZWN0aW9uQ2hhbmdlczogT2JzZXJ2YWJsZTxOeERyb3Bkb3duSXRlbUNoYW5nZT4gPSBkZWZlcjxPYnNlcnZhYmxlPE54RHJvcGRvd25JdGVtQ2hhbmdlPj4oKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtZXJnZSguLi50aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24ub25TZWxlY3Rpb25DaGFuZ2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbmdab25lLm9uU3RhYmxlXG4gICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgIC5waXBlKHRha2UoMSksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLm9wdGlvblNlbGVjdGlvbkNoYW5nZXMpKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgcG9zaXRpb24gY29uZmlnIGVuc3VyZXMgdGhhdCB0aGUgdG9wIFwic3RhcnRcIiBjb3JuZXIgb2YgdGhlIG92ZXJsYXlcbiAgICogaXMgYWxpZ25lZCB3aXRoIHdpdGggdGhlIHRvcCBcInN0YXJ0XCIgb2YgdGhlIG9yaWdpbiBieSBkZWZhdWx0IChvdmVybGFwcGluZ1xuICAgKiB0aGUgdHJpZ2dlciBjb21wbGV0ZWx5KS4gSWYgdGhlIHBhbmVsIGNhbm5vdCBmaXQgYmVsb3cgdGhlIHRyaWdnZXIsIGl0XG4gICAqIHdpbGwgZmFsbCBiYWNrIHRvIGEgcG9zaXRpb24gYWJvdmUgdGhlIHRyaWdnZXIuXG4gICAqL1xuICBfcG9zaXRpb25zID0gW3tcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICd0b3AnLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAndG9wJ1xuICB9LCB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ2NlbnRlcidcbiAgfSwge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nXG4gIH1dO1xuXG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogUGFuZWwgY29udGFpbmluZyB0aGUgc2VsZWN0IG9wdGlvbnMuXG4gICAqL1xuICBAVmlld0NoaWxkKCdwYW5lbCcpIHBhbmVsOiBFbGVtZW50UmVmO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsQm9keScpIHBhbmVsQm9keTogRWxlbWVudFJlZjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKCd0cmlnZ2VyJykgdHJpZ2dlcjogRWxlbWVudFJlZjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKCdmaWx0ZXJJbnB1dCcpIGZpbHRlcklucHV0OiBFbGVtZW50UmVmO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIE92ZXJsYXkgcGFuZSBjb250YWluaW5nIHRoZSBvcHRpb25zLlxuICAgKi9cbiAgQFZpZXdDaGlsZChDZGtDb25uZWN0ZWRPdmVybGF5KSBvdmVybGF5RGlyOiBDZGtDb25uZWN0ZWRPdmVybGF5O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTnhEcm9wZG93bkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSkgb3B0aW9ucztcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAQ29udGVudENoaWxkcmVuKE54RHJvcGRvd25Hcm91cENvbXBvbmVudCkgZ3JvdXBzO1xuXG4gIEBDb250ZW50Q2hpbGQoTnhEcm9wZG93bkNsb3NlZExhYmVsRGlyZWN0aXZlKVxuICBfY3VzdG9tQ2xvc2VkRHJvcGRvd25MYWJlbDogTnhEcm9wZG93bkNsb3NlZExhYmVsRGlyZWN0aXZlO1xuXG4gIEBWaWV3Q2hpbGQoJ2RlZmF1bHRDbG9zZWREcm9wZG93bkxhYmVsJylcbiAgcHJpdmF0ZSBfZGVmYXVsdENsb3NlZERyb3Bkb3duTGFiZWw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGNsb3NlZERyb3Bkb3duTGFiZWwoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZERyb3Bkb3duTGFiZWw7XG4gIH1cbiAgcHJpdmF0ZSBfY2xvc2VkRHJvcGRvd25MYWJlbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogRW1pdHMgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkKCk6IE54RHJvcGRvd25JdGVtQ29tcG9uZW50IHwgTnhEcm9wZG93bkl0ZW1Db21wb25lbnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXNNdWx0aVNlbGVjdCA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF07XG4gIH1cblxuICBwcml2YXRlIF9rZXlNYW5hZ2VyOiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeERyb3Bkb3duSXRlbUNvbXBvbmVudD47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IHBhbmVsT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICB9XG4gIHNldCBwYW5lbE9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9wYW5lbE9wZW4gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHZhbHVlIGludG8gYSBzdHJpbmcuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgZGlzcGxheWluZyBhbmQgZmlsdGVyaW5nIHRoZSBjb250ZW50XG4gICAqICggRGVmYXVsdDogKHZhbHVlKSA9PiB2YWx1ZSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsOyApLlxuICAgKi9cbiAgQElucHV0KCdueFZhbHVlRm9ybWF0dGVyJykgdmFsdWVGb3JtYXR0ZXIgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmZvcm1GaWVsZENvbXBvbmVudCA/IHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50LmxhYmVsIDogJyc7XG4gIH1cblxuICAvKiogQ29tcGFyaXNvbiBmdW5jdGlvbiB0byBzcGVjaWZ5IHdoaWNoIG9wdGlvbiBpcyBkaXNwbGF5ZWQuIERlZmF1bHRzIHRvIG9iamVjdCBlcXVhbGl0eS4gKi9cbiAgcHJpdmF0ZSBfY29tcGFyZVdpdGggPSAobzE6IGFueSwgbzI6IGFueSkgPT4gbzEgPT09IG8yO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjb21wYXJlIHRoZSBvcHRpb24gdmFsdWVzIHdpdGggdGhlIHNlbGVjdGVkIHZhbHVlcy4gVGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIGlzIGEgdmFsdWUgZnJvbSBhbiBvcHRpb24uIFRoZSBzZWNvbmQgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3Rpb24uIEEgYm9vbGVhblxuICAgKiBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgY29tcGFyZVdpdGgoKSB7IHJldHVybiB0aGlzLl9jb21wYXJlV2l0aDsgfVxuICBzZXQgY29tcGFyZVdpdGgoZm46IChvMTogc3RyaW5nLCBvMjogc3RyaW5nKSA9PiBib29sZWFuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZ2V0TnhEcm9wZG93bk5vbkZ1bmN0aW9uVmFsdWVFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLl9jb21wYXJlV2l0aCA9IGZuO1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgLy8gQSBkaWZmZXJlbnQgY29tcGFyYXRvciBtZWFucyB0aGUgc2VsZWN0aW9uIGNvdWxkIGNoYW5nZS5cbiAgICAgIHRoaXMuX2luaXRpYWxpemVTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9maWx0ZXJGbiA9IChzZWFyY2g6IHN0cmluZywgaXRlbVZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gaXRlbVZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBiZSB1c2VkIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGUgc2VhcmNoIGZpbHRlci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSB1c2VyIGlucHV0LFxuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBkcm9wZG93biBpdGVtIHZhbHVlLiBUaGUgZHJvcGRvd24gaXRlbXMgd2lsbCB1c2UgdGhpcyBmdW5jdGlvbiB0byBzZXQgdGhlaXJcbiAgICogdmlzaWJpbGl0eSBzdGF0ZS5cbiAgICogQSBib29sZWFuIHNob3VsZCBiZSByZXR1cm5lZC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBmaWx0ZXJGbigpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlckZuOyB9XG4gIHNldCBmaWx0ZXJGbihmbjogKHNlYXJjaDogc3RyaW5nLCBpdGVtVmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGdldE54RHJvcGRvd25Ob25GdW5jdGlvblZhbHVlRXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5fZmlsdGVyRm4gPSBmbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBmb2N1c2VkLlxuICAgKi9cbiAgZ2V0IGZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQgfHwgdGhpcy5wYW5lbE9wZW47XG4gIH1cblxuICAvKiogYFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlc2AgKi9cbiAgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAvKiogYFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gc2VsZWN0IGhhcyBiZWVuIHRvdWNoZWRgICovXG4gIF9vblRvdWNoZWQgPSAoKSA9PiB7IH07XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGVsZW1lbnRSZWYoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBAQXR0cmlidXRlKCd0YWJpbmRleCcpIHRhYkluZGV4OiBzdHJpbmcsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb3JtRmllbGRDb21wb25lbnQ6IE54Rm9ybWZpZWxkQ29tcG9uZW50LFxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgQFNlbGYoKSBAT3B0aW9uYWwoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybTogTmdGb3JtLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLm5nQ29udHJvbCkge1xuICAgICAgLy8gTm90ZTogd2UgcHJvdmlkZSB0aGUgdmFsdWUgYWNjZXNzb3IgdGhyb3VnaCBoZXJlLCBpbnN0ZWFkIG9mXG4gICAgICAvLyB0aGUgYHByb3ZpZGVyc2AgdG8gYXZvaWQgcnVubmluZyBpbnRvIGEgY2lyY3VsYXIgaW1wb3J0LlxuICAgICAgdGhpcy5uZ0NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy50YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4LCAxMCkgfHwgMDtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgIHRoaXMudXBkYXRlRXJyb3JTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsPE54RHJvcGRvd25JdGVtQ29tcG9uZW50Pih0aGlzLmlzTXVsdGlTZWxlY3QpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2Nsb3NlZERyb3Bkb3duTGFiZWwgPVxuICAgICAgdGhpcy5fY3VzdG9tQ2xvc2VkRHJvcGRvd25MYWJlbCAmJiB0aGlzLl9jdXN0b21DbG9zZWREcm9wZG93bkxhYmVsLnRlbXBsYXRlUmVmIHx8IHRoaXMuX2RlZmF1bHRDbG9zZWREcm9wZG93bkxhYmVsO1xuICAgIHRoaXMuX2luaXRLZXlNYW5hZ2VyKCk7XG5cbiAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5vbkNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmFkZGVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5zZWxlY3QoKSk7XG4gICAgICBldmVudC5yZW1vdmVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5kZXNlbGVjdCgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKG51bGwpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9yZXNldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoY29udHJvbCAmJiBjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCAoZm9ybSAmJiBmb3JtLnN1Ym1pdHRlZCkpKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHVwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMubmdDb250cm9sID8gdGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCA6IG51bGw7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5ld1N0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgdGhpcy5lcnJvclN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdXAgYSBrZXkgbWFuYWdlciB0byBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBwcml2YXRlIF9pbml0S2V5TWFuYWdlcigpIHtcbiAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE54RHJvcGRvd25JdGVtQ29tcG9uZW50Pih0aGlzLm9wdGlvbnMpXG4gICAgICAud2l0aFR5cGVBaGVhZCgpXG4gICAgICAud2l0aFdyYXAoKVxuICAgICAgLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKClcbiAgICAgIC53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKCdsdHInKVxuICAgICAgLnNraXBQcmVkaWNhdGUoaXRlbSA9PiBpdGVtLl9oaWRkZW4pO1xuXG4gICAgdGhpcy5fa2V5TWFuYWdlci50YWJPdXQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSB0cmlnZ2VyIGJlZm9yZSBjbG9zaW5nLiBFbnN1cmVzIHRoYXQgdGhlIGZvY3VzXG4gICAgICAvLyBwb3NpdGlvbiB3b24ndCBiZSBsb3N0IGlmIHRoZSB1c2VyIGdvdCBmb2N1cyBpbnRvIHRoZSBvdmVybGF5LlxuICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9rZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wYW5lbE9wZW4gJiYgdGhpcy5wYW5lbCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgYXV0byBzY3JvbGxpbmcgdW50aWwgYWxsIGl0ZW1zIGhhdmUgc2V0dGxlZCBvdGhlcndpc2UgdGhlIGl0ZW0gY29udGFpbmVycyBtaWdodFxuICAgICAgICAvLyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZVxuICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgIC5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BhbmVsT3BlbiAmJiAhdGhpcy5pc011bHRpU2VsZWN0ICYmIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSkge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9yZXNldE9wdGlvbnMoKTogdm9pZCB7XG4gICAgY29uc3QgY2hhbmdlZE9yRGVzdHJveWVkID0gbWVyZ2UodGhpcy5vcHRpb25zLmNoYW5nZXMsIHRoaXMuX2Rlc3Ryb3kpO1xuXG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKGNoYW5nZWRPckRlc3Ryb3llZCkpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICB0aGlzLl9vblNlbGVjdChldmVudC5pdGVtLCBldmVudC5pc1VzZXJJbnB1dCk7XG5cbiAgICAgIGlmIChldmVudC5pc1VzZXJJbnB1dCAmJiAhdGhpcy5pc011bHRpU2VsZWN0ICYmIHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgb3B0aW9ucyBhbmQgcmVhY3QgYWNjb3JkaW5nbHkuXG4gICAgLy8gSGFuZGxlcyBjYXNlcyBsaWtlIHRoZSBsYWJlbHMgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbnMgY2hhbmdpbmcuXG4gICAgbWVyZ2UoLi4udGhpcy5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLl9zdGF0ZUNoYW5nZXMpKVxuICAgICAgLnBpcGUodGFrZVVudGlsKGNoYW5nZWRPckRlc3Ryb3llZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgLy8gZGVmZXIgaXQgZm9yIHRoZSBuZXh0IGN5Y2xlIHRvIG5vdCBydW4gaW4gY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgICAvLyB0aGUgY29tYmluYXRpb24gb2YgZHJvcGRvd24taXRlbSBub3RpZnlpbmcgcGFyZW50IGFuZCB3aGVuIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gdHJpZXMgdG8gZmV0Y2ggdGhlIHRyaWdnZXJWYWx1ZSBmcm9tIHRoZSBjaGlsZCB0aHJvd3MgdGhlc2UgZXJyb3JzXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuX3NldE9wdGlvbklkcygpO1xuICB9XG5cbiAgLyoqIFJlY29yZHMgb3B0aW9uIElEcyB0byBwYXNzIHRvIHRoZSBhcmlhLW93bnMgcHJvcGVydHkuICovXG4gIHByaXZhdGUgX3NldE9wdGlvbklkcygpIHtcbiAgICB0aGlzLl9vcHRpb25JZHMgPSB0aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uaWQpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8qKiBJbnZva2VkIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWQuICovXG4gIHByaXZhdGUgX29uU2VsZWN0KG9wdGlvbjogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQsIGlzVXNlcklucHV0OiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3Qgd2FzU2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbik7XG5cbiAgICBpZiAob3B0aW9uLnZhbHVlID09IG51bGwgJiYgIXRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgb3B0aW9uLmRlc2VsZWN0KCk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcyhvcHRpb24udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3B0aW9uKSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KG9wdGlvbik7XG5cbiAgICAgIGlmIChpc1VzZXJJbnB1dCkge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0ob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgICB0aGlzLl9zb3J0VmFsdWVzKCk7XG5cbiAgICAgICAgaWYgKGlzVXNlcklucHV0KSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSB0aGUgdXNlciBzZWxlY3RlZCB0aGUgb3B0aW9uIHdpdGggdGhlaXIgbW91c2UsIHdlXG4gICAgICAgICAgLy8gd2FudCB0byByZXN0b3JlIGZvY3VzIGJhY2sgdG8gdGhlIHRyaWdnZXIsIGluIG9yZGVyIHRvXG4gICAgICAgICAgLy8gcHJldmVudCB0aGUgc2VsZWN0IGtleWJvYXJkIGNvbnRyb2xzIGZyb20gY2xhc2hpbmcgd2l0aFxuICAgICAgICAgIC8vIHRoZSBvbmVzIGZyb20gYG1hdC1vcHRpb25gLlxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3YXNTZWxlY3RlZCAhPT0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZChvcHRpb24pKSB7XG4gICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZVNlbGVjdGlvbigpOiB2b2lkIHtcbiAgICAvLyBEZWZlciBzZXR0aW5nIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCB0aGUgXCJFeHByZXNzaW9uXG4gICAgLy8gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWRcIiBlcnJvcnMgZnJvbSBBbmd1bGFyLlxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh0aGlzLm5nQ29udHJvbCA/IHRoaXMubmdDb250cm9sLnZhbHVlIDogdGhpcy5fdmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGVkIG9wdGlvbiBiYXNlZCBvbiBhIHZhbHVlLiBJZiBubyBvcHRpb24gY2FuIGJlXG4gICAqIGZvdW5kIHdpdGggdGhlIGRlc2lnbmF0ZWQgdmFsdWUsIHRoZSBzZWxlY3QgdHJpZ2dlciBpcyBjbGVhcmVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZTogYW55IHwgYW55W10pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0ICYmIHZhbHVlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IGdldE54RHJvcGRvd25Ob25BcnJheVZhbHVlRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgIHZhbHVlLmZvckVhY2goKGN1cnJlbnRWYWx1ZTogYW55KSA9PiB0aGlzLl9zZWxlY3RWYWx1ZShjdXJyZW50VmFsdWUpKTtcbiAgICAgIHRoaXMuX3NvcnRWYWx1ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLl9zZWxlY3RWYWx1ZSh2YWx1ZSk7XG4gICAgICAvLyBTaGlmdCBmb2N1cyB0byB0aGUgYWN0aXZlIGl0ZW0uIE5vdGUgdGhhdCB3ZSBzaG91bGRuJ3QgZG8gdGhpcyBpbiBtdWx0aXBsZVxuICAgICAgLy8gbW9kZSwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IHdoYXQgb3B0aW9uIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCBsYXN0LlxuICAgICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuZCBzZWxlY3RzIGFuZCBvcHRpb24gYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgKiBAcmV0dXJucyBPcHRpb24gdGhhdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIF9zZWxlY3RWYWx1ZSh2YWx1ZTogYW55KTogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZCgob3B0aW9uOiBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJlYXQgbnVsbCBhcyBhIHNwZWNpYWwgcmVzZXQgdmFsdWUuXG4gICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgIT0gbnVsbCAmJiB0aGlzLl9jb21wYXJlV2l0aChvcHRpb24udmFsdWUsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgIC8vIE5vdGlmeSBkZXZlbG9wZXJzIG9mIGVycm9ycyBpbiB0aGVpciBjb21wYXJhdG9yLlxuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdChjb3JyZXNwb25kaW5nT3B0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlc3BvbmRpbmdPcHRpb247XG4gIH1cblxuICAvKiogRW1pdHMgY2hhbmdlIGV2ZW50IHRvIHNldCB0aGUgbW9kZWwgdmFsdWUuICovXG4gIHByaXZhdGUgX3Byb3BhZ2F0ZUNoYW5nZXMoZmFsbGJhY2tWYWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGxldCB2YWx1ZVRvRW1pdDogYW55ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmlzTXVsdGlTZWxlY3QpIHtcbiAgICAgIHZhbHVlVG9FbWl0ID0gKHRoaXMuc2VsZWN0ZWQgYXMgTnhEcm9wZG93bkl0ZW1Db21wb25lbnRbXSkubWFwKG9wdGlvbiA9PiBvcHRpb24udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQgPyAodGhpcy5zZWxlY3RlZCBhcyBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCkudmFsdWUgOiBmYWxsYmFja1ZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVUb0VtaXQ7XG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlVG9FbWl0KTtcbiAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZVRvRW1pdCk7XG4gICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChuZXcgTnhEcm9wZG93blNlbGVjdENoYW5nZSh0aGlzLCB2YWx1ZVRvRW1pdCkpO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFNvcnRzIHRoZSBzZWxlY3RlZCB2YWx1ZXMgaW4gdGhlIHNlbGVjdGVkIGJhc2VkIG9uIHRoZWlyIG9yZGVyIGluIHRoZSBwYW5lbC4gKi9cbiAgcHJpdmF0ZSBfc29ydFZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnRvQXJyYXkoKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaW5kZXhPZihhKSAtIG9wdGlvbnMuaW5kZXhPZihiKSk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEZvY3VzZXMgdGhlIHNlbGVjdCBlbGVtZW50LiAqL1xuICBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcGFuZWwgb2YgdGhlIGRyb3Bkb3duLiAqL1xuICBvcGVuUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl90cmlnZ2VyUmVjdCA9IHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2tleU1hbmFnZXIud2l0aEhvcml6b250YWxPcmllbnRhdGlvbihudWxsKTtcbiAgICB0aGlzLl9oaWdobGlnaHRDb3JyZWN0T3B0aW9uKCk7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBwYW5lbCBvZiB0aGUgZHJvcGRvd24uICovXG4gIGNsb3NlUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLndpdGhIb3Jpem9udGFsT3JpZW50YXRpb24oJ2x0cicpO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMub3BlbmVkQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgLy8gZGVmZXIgdGhlIGZvY3VzIGlmIHRoZSBkcm9wZG93biB0cmlnZ2VycyBhY3Rpb25zIHRoYXQgZGV0YWNoXG4gICAgICAvLyBhIHRlbXBsYXRlL3ZpZXcgZnJvbSB0aGUgRE9NIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBpbml0YWwgc2Nyb2xsVG9wIHdoZW4gdGhlIGRyb3Bkb3duIG9wZW5zXG4gIC8vIHNjcm9sbHMgdGhlIHNlbGVjdGVkIGl0ZW0gdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgaWYgcG9zc2libGVcbiAgcHJpdmF0ZSBfY2FsY3VsYXRlU2Nyb2xsVG9wKCkge1xuICAgIC8vIHJlc2V0IHRoZSBzY3JvbGx0b3AgdG8gbWFrZSBjYWxjdWxhdGlvbiBlYXNpZXJcbiAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy5fc2Nyb2xsVG9wID0gMDtcbiAgICBpZiAoIXRoaXMuZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2dldEl0ZW1PZmZzZXQodGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKTtcbiAgICAgIGNvbnN0IHBhbmVsSGVpZ2h0ID0gdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBwYW5lbFJlY3QgPSB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgbWlkZGxlT2ZQYW5lbCA9IHBhbmVsUmVjdC50b3AgKyBwYW5lbEhlaWdodCAvIDI7XG4gICAgICBjb25zdCBhY3RpdmVJdGVtUmVjdCA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5jb250YWluZXJFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAob2Zmc2V0ID4gbWlkZGxlT2ZQYW5lbCkge1xuICAgICAgICAvLyBiZWNhdXNlIHdlIHJlc2V0IHRoZSBzY3JvbGxUb3AgdG8gMCBhdCB0aGUgdG9wIHdlIGNhbiBzaW1wbHkgdGFrZSB0aGUgbWlkZGxlT2ZQYW5lbCB3aGljaCBpcyBvdXJcbiAgICAgICAgLy8gdGFyZ2V0IHBvc2l0aW9uIGZvciB0aGUgaXRlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgb2Zmc2V0ICh3aGljaCBpcyBub3cgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydClcbiAgICAgICAgLy8gdG8gbWlkZGxlIG91dCB0aGUgdGV4dCBhIGJpdCBtb3JlIGFkZCBoYWxmIG9mIHRoZSBoZWlnaHRcbiAgICAgICAgLy8gKHRoaXMgaXMgc3RpbGwgYSBmZXcgcGl4ZWxzIG9mZiBiZWNhdXNlIHRoZSBjb250YWluZXIgaXMgYSBiaXQgbGFyZ2VyIHRoYW4gdGhlIGZvbnQpXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IG9mZnNldCAtIG1pZGRsZU9mUGFuZWwgKyAoYWN0aXZlSXRlbVJlY3QuaGVpZ2h0IC0gaXRlbVBhZGRpbmcpIC8gMjtcbiAgICAgICAgdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNjcm9sbHMgdGhlIGFjdGl2ZSBvcHRpb24gaW50byB2aWV3LiAqL1xuICBwcml2YXRlIF9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGFuZWxPcGVuIHx8ICF0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlT3B0aW9uSW5kZXggPSB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCB8fCAwO1xuICAgIGNvbnN0IGl0ZW1SZWN0ID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtLmNvbnRhaW5lckVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbihhY3RpdmVPcHRpb25JbmRleCwgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5ncm91cHMpO1xuXG4gICAgdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9nZXRPcHRpb25TY3JvbGxQb3NpdGlvbihcbiAgICAgIGFjdGl2ZU9wdGlvbkluZGV4ICsgbGFiZWxDb3VudCxcbiAgICAgIGl0ZW1SZWN0LmhlaWdodCxcbiAgICAgIHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFRcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbihvcHRpb25JbmRleDogbnVtYmVyLCBvcHRpb25zOiBRdWVyeUxpc3Q8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+LFxuICAgIG9wdGlvbkdyb3VwczogUXVlcnlMaXN0PE54RHJvcGRvd25Hcm91cENvbXBvbmVudD4pOiBudW1iZXIge1xuXG4gICAgaWYgKG9wdGlvbkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IG9wdGlvbnMudG9BcnJheSgpO1xuICAgICAgY29uc3QgZ3JvdXBzID0gb3B0aW9uR3JvdXBzLnRvQXJyYXkoKTtcbiAgICAgIGxldCBncm91cENvdW50ZXIgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbkluZGV4ICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChvcHRpb25zQXJyYXlbaV0uZ3JvdXAgJiYgb3B0aW9uc0FycmF5W2ldLmdyb3VwID09PSBncm91cHNbZ3JvdXBDb3VudGVyXSkge1xuICAgICAgICAgIGdyb3VwQ291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cENvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPcHRpb25TY3JvbGxQb3NpdGlvbihvcHRpb25JbmRleDogbnVtYmVyLCBvcHRpb25IZWlnaHQ6IG51bWJlcixcbiAgICBjdXJyZW50U2Nyb2xsUG9zaXRpb246IG51bWJlciwgcGFuZWxIZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IG9wdGlvbk9mZnNldCA9IG9wdGlvbkluZGV4ICogb3B0aW9uSGVpZ2h0ICsgaXRlbVBhZGRpbmc7XG5cbiAgICBpZiAodGhpcy5zaG93RmlsdGVyKSB7XG4gICAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm54LWRyb3Bkb3duX19maWx0ZXInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICBvcHRpb25PZmZzZXQgPSBvcHRpb25JbmRleCAqIG9wdGlvbkhlaWdodCArIGZpbHRlckhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uT2Zmc2V0IDwgY3VycmVudFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25PZmZzZXQgKyBvcHRpb25IZWlnaHQgPiBjdXJyZW50U2Nyb2xsUG9zaXRpb24gKyBwYW5lbEhlaWdodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG9wdGlvbk9mZnNldCAtIHBhbmVsSGVpZ2h0ICsgb3B0aW9uSGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFNjcm9sbFBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0SXRlbU9mZnNldChpdGVtKSB7XG4gICAgY29uc3QgaXRlbVJlY3QgPSBpdGVtLmNvbnRhaW5lckVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiBpdGVtUmVjdC50b3A7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBGb3JtZmllbGQgSW1wbGVtZW50YXRpb25cbiAgICovXG4gIHNldERlc2NyaWJlZEJ5SWRzKGlkczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICB0aGlzLmFyaWFEZXNjcmliZWRieSA9IGlkcy5qb2luKCcgJyk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzZXRBcmlhTGFiZWwodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2FyaWFMYWJlbCA9IHZhbHVlO1xuICB9XG5cbiAgX2dldEFyaWFMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJpYUxhYmVsIHx8ICh0aGlzLmZvcm1GaWVsZENvbXBvbmVudCA/IHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50LmxhYmVsIDogbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3QgaGFzIGEgdmFsdWUuXG4gICAqL1xuICBnZXQgZW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLl9zZWxlY3Rpb25Nb2RlbCB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmhhc1ZhbHVlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgc2hvdWxkTGFiZWxGbG9hdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c2VkIHx8ICF0aGlzLmVtcHR5O1xuICB9XG4gIC8qKiBFbmQgRm9ybWZpZWxkICovXG5cbiAgLyoqIENvbnRyb2xWYWx1ZUFjY2Vzc29yICovXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QncyB2YWx1ZS4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX29uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG4gIC8qKiBFbmQgQ29udHJvbFZhbHVlQWNjZXNzb3IgKi9cblxuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24oZXZlbnQpIDogdGhpcy5faGFuZGxlQ2xvc2VkS2V5ZG93bihldmVudCk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVDbG9zZWRLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgY29uc3QgaXNBcnJvd0tleSA9IGtleUNvZGUgPT09IERPV05fQVJST1cgfHwga2V5Q29kZSA9PT0gVVBfQVJST1cgfHxcbiAgICAgIGtleUNvZGUgPT09IExFRlRfQVJST1cgfHwga2V5Q29kZSA9PT0gUklHSFRfQVJST1c7XG4gICAgY29uc3QgaXNPcGVuS2V5ID0ga2V5Q29kZSA9PT0gRU5URVIgfHwga2V5Q29kZSA9PT0gU1BBQ0U7XG5cbiAgICAvLyBPcGVuIHRoZSBzZWxlY3Qgb24gQUxUICsgYXJyb3cga2V5IHRvIG1hdGNoIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAgICBpZiAoaXNPcGVuS2V5IHx8ICgodGhpcy5pc011bHRpU2VsZWN0IHx8IGV2ZW50LmFsdEtleSkgJiYgaXNBcnJvd0tleSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTXVsdGlTZWxlY3QgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPcGVuS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIC8vIGFsbCBldmVudHMgb3RoZXIgdGhhbiB0aGUgbGlzdGVkIG9uZXMgc2hvdWxkIGJlIGlnbm9yZWQgb3IgaGFuZGxlZCBpbiBfb25GaWx0ZXIoKVxuICAgIGlmICghKFtET1dOX0FSUk9XLCBVUF9BUlJPVywgSE9NRSwgRU5ELCBFTlRFUiwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFNISUZULCBTUEFDRSwgVEFCXS5pbmRleE9mKGtleUNvZGUpID49IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Fycm93S2V5ID0ga2V5Q29kZSA9PT0gRE9XTl9BUlJPVyB8fCBrZXlDb2RlID09PSBVUF9BUlJPVztcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcy5fa2V5TWFuYWdlcjtcblxuICAgIGNvbnN0IGFsbEhpZGRlbiA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5faGlkZGVuKS5ldmVyeShvcHRpb24gPT4gQm9vbGVhbihvcHRpb24pKTtcblxuICAgIGlmIChrZXlDb2RlID09PSBIT01FIHx8IGtleUNvZGUgPT09IEVORCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGtleUNvZGUgPT09IEhPTUUgPyBtYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpIDogbWFuYWdlci5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJvd0tleSAmJiBldmVudC5hbHRLZXkpIHtcbiAgICAgIC8vIENsb3NlIHRoZSBzZWxlY3Qgb24gQUxUICsgYXJyb3cga2V5IHRvIG1hdGNoIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEVOVEVSICYmIG1hbmFnZXIuYWN0aXZlSXRlbSAmJiAhYWxsSGlkZGVuKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBFTlRFUiAmJiBhbGxIaWRkZW4pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2hvd0ZpbHRlciAmJiBrZXlDb2RlID09PSBTUEFDRSAmJiBtYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBUQUIpIHtcbiAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEluZGV4ID0gbWFuYWdlci5hY3RpdmVJdGVtSW5kZXg7XG4gICAgICBtYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG5cbiAgICAgIGlmICh0aGlzLmlzTXVsdGlTZWxlY3QgJiYgaXNBcnJvd0tleSAmJiBldmVudC5zaGlmdEtleSAmJiBtYW5hZ2VyLmFjdGl2ZUl0ZW0gJiZcbiAgICAgICAgbWFuYWdlci5hY3RpdmVJdGVtSW5kZXggIT09IHByZXZpb3VzbHlGb2N1c2VkSW5kZXgpIHtcbiAgICAgICAgbWFuYWdlci5hY3RpdmVJdGVtLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGZvcm1hdFZhbHVlKHZhbHVlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZUZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW4gdGhlIGZpbHRlciBpbnB1dCAqL1xuICBfb25GaWx0ZXIoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY3VycmVudEZpbHRlciA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLmZpbHRlckNoYW5nZXMubmV4dChldmVudC50YXJnZXQudmFsdWUpO1xuICAgIGNvbnN0IGFsbEhpZGRlbiA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5faGlkZGVuKS5ldmVyeShvcHRpb24gPT4gQm9vbGVhbihvcHRpb24pKTtcbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogVGhlIHZhbHVlIGRpc3BsYXllZCBpbiB0aGUgdHJpZ2dlci5cbiAgICovXG4gIGdldCB0cmlnZ2VyVmFsdWUoKTogc3RyaW5nIHtcblxuICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWQubWFwKG9wdGlvbiA9PiBvcHRpb24udmlld1ZhbHVlKTtcblxuICAgICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0udmlld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2hsaWdodHMgdGhlIHNlbGVjdGVkIGl0ZW0uIElmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZCwgaXQgd2lsbCBoaWdobGlnaHRcbiAgICogdGhlIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICovXG4gIHByaXZhdGUgX2hpZ2hsaWdodENvcnJlY3RPcHRpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2tleU1hbmFnZXIpIHtcbiAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0odGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiB0aGUgb3ZlcmxheSBwYW5lbCBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICovXG4gIF9vbkF0dGFjaGVkKCk6IHZvaWQge1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIHRoaXMub3ZlcmxheURpci5wb3NpdGlvbkNoYW5nZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICBpZiAodGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNjcm9sbFRvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLm9wZW5lZENoYW5nZS5lbWl0KHRydWUpO1xuICAgICAgaWYgKHRoaXMuc2hvd0ZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9vbkZvY3VzKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSB0b3VjaGVkIGNhbGxiYWNrIG9ubHkgaWYgdGhlIHBhbmVsIGlzIGNsb3NlZC4gT3RoZXJ3aXNlLCB0aGUgdHJpZ2dlciB3aWxsXG4gICAqIFwiYmx1clwiIHRvIHRoZSBwYW5lbCB3aGVuIGl0IG9wZW5zLCBjYXVzaW5nIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAqL1xuICBfb25CbHVyKCkge1xuICAgIHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmZpbHRlcklucHV0ICYmIHRoaXMuc2hvd0ZpbHRlcikge1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucGFuZWxPcGVuKSB7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBpc0ZpbHRlckVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgX2NsZWFyRmlsdGVyKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIHRoaXMuY3VycmVudEZpbHRlciA9ICcnO1xuICAgIHRoaXMuZmlsdGVyQ2hhbmdlcy5uZXh0KCcnKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlIGRldGVybWluZXMgdGhlIGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgIHRvIGJlIHNldCBvbiB0aGUgaG9zdC4gKi9cbiAgX2dldEFyaWFBY3RpdmVEZXNjZW5kYW50KCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLnBhbmVsT3BlbiAmJiB0aGlzLl9rZXlNYW5hZ2VyICYmIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl19