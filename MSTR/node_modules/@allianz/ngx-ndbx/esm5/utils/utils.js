/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @param {?} value
 * @return {?}
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
export function pad(str, length, padCharacter) {
    if (length === void 0) { length = 2; }
    if (padCharacter === void 0) { padCharacter = '0'; }
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
export function formatDate(date) {
    /** @type {?} */
    var dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
export function formatDateHuman(date) {
    /** @type {?} */
    var dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
export function mapClassNames(value, DEFAULTS, MAPPING) {
    if (DEFAULTS === void 0) { DEFAULTS = []; }
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var sanitizedList = tslib_1.__spread(DEFAULTS);
    if (typeof value === 'string') {
        /** @type {?} */
        var mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = tslib_1.__spread(sanitizedList, mappedClasses);
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
export function getClassNameList(value, MAPPING) {
    if (MAPPING === void 0) { MAPPING = {}; }
    /** @type {?} */
    var mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        var classNames = value.split(' ');
        /** @type {?} */
        var keys_1 = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (keys_1.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
export function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
export function getFontShorthand(style) {
    var font = style.font, fontStyle = style.fontStyle, fontVariant = style.fontVariant, fontWeight = style.fontWeight, fontSize = style.fontSize, lineHeight = style.lineHeight, fontFamily = style.fontFamily;
    if (font.length > 0) {
        return font;
    }
    return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSize + "/" + lineHeight + " " + fontFamily;
}
/**
 * @param {?} number
 * @return {?}
 */
export function numberOfDecimals(number) {
    /** @type {?} */
    var parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    var match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
export function clamp(value, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
var ErrorStateMatcher = /** @class */ (function () {
    function ErrorStateMatcher() {
    }
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    ErrorStateMatcher.prototype.isErrorState = /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    ErrorStateMatcher.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = i0.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
    return ErrorStateMatcher;
}());
export { ErrorStateMatcher };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC91dGlscy8iLCJzb3VyY2VzIjpbInV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFjLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7O0FBR3ZELE1BQU0sVUFBVSxRQUFRLENBQUMsS0FBVTtJQUNqQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNuQyxDQUFDOzs7Ozs7O0FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFXLEVBQUUsTUFBa0IsRUFBRSxZQUEwQjtJQUE5Qyx1QkFBQSxFQUFBLFVBQWtCO0lBQUUsNkJBQUEsRUFBQSxrQkFBMEI7SUFDM0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLE1BQU0sRUFBRTtRQUMxQyxPQUFPLEdBQUcsQ0FBQztLQUNaO0lBQ0QsT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtRQUMxQixHQUFHLEdBQUcsWUFBWSxHQUFHLEdBQUcsQ0FBQztLQUMxQjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQzs7Ozs7O0FBR0gsTUFBTSxVQUFVLFVBQVUsQ0FBQyxJQUFVOztRQUMzQixXQUFXLEdBQUk7UUFDakIsTUFBTSxDQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMzQixHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNoQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQzVCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUViLE9BQU8sV0FBVyxDQUFDO0FBQ3ZCLENBQUM7Ozs7O0FBQ0QsTUFBTSxVQUFVLGVBQWUsQ0FBQyxJQUFVOztRQUNoQyxXQUFXLEdBQUk7UUFDakIsR0FB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QUFVLEVBQUUsTUFBTSxFQUFDOzs7NEJBbkloQztDQXdJQyxBQUxELElBS0M7U0FKWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKHN0cjogc3RyaW5nLCBsZW5ndGg6IG51bWJlciA9IDIsIHBhZENoYXJhY3Rlcjogc3RyaW5nID0gJzAnKTogc3RyaW5nIHtcbiAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgc3RyLmxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBzdHIgPSBwYWRDaGFyYWN0ZXIgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuLy8gREFURSAtPiBZWVlZLU1NLUREXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgZGF0ZU9mQmlydGggPSAgW1xuICAgICAgICBTdHJpbmcgKGRhdGUuZ2V0RnVsbFllYXIoKSksXG4gICAgICAgIHBhZChTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSlcbiAgICAgIF0uam9pbignLScpO1xuXG4gICAgcmV0dXJuIGRhdGVPZkJpcnRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVIdW1hbihkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgZGF0ZU9mQmlydGggPSAgW1xuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSksXG4gICAgICAgIHBhZChTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkpLFxuICAgICAgICBTdHJpbmcgKGRhdGUuZ2V0RnVsbFllYXIoKSlcbiAgICAgIF0uam9pbignLScpO1xuXG4gICAgcmV0dXJuIGRhdGVPZkJpcnRoO1xufVxuLypcbiAgUHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGFsbG93IGEgbGlzdCBvZiBzaG9ydCBrZXl3b3Jkc1xuICBleHBhbmQgdG8gbG9uZ2VyIGJlbSBjbGFzcyBuYW1lcyB3aXRoIHdpbGwgdGhlbiBiZSBhcHBsaWVkIHRvIHRoZSBjbGFzc25hbWUgdmFsdWUuXG5cbiAgVGhpcyBmdW5jdGlvbiB3aWxsIG1hcCBhIGxpc3Qgb2Yga2V5cyB0byB2YWx1ZXMgaW4gYSBNQVBQSU5HIGxpc3QuXG4gIFdoYXRldmVyIHZhbHVlIGlzIGZvdW5kIHdpbGwgcmVwbGFjZSB0aGUga2V5d29yZC5cbiAgRXZlcnkga2V5d29yZCBub3QgZm91bmQgd2lsbCBqdXN0IHRyYW5zZmVyZWQgd2lpdGhtb3V0IG1vZGlmeWluZy5cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBDbGFzc05hbWVzKHZhbHVlLCBERUZBVUxUUyA9IFtdLCBNQVBQSU5HID0ge30pIHtcbiAgbGV0IHNhbml0aXplZExpc3QgPSBbIC4uLkRFRkFVTFRTIF07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtYXBwZWRDbGFzc2VzID0gZ2V0Q2xhc3NOYW1lTGlzdCh2YWx1ZSwgTUFQUElORyk7XG4gICAgc2FuaXRpemVkTGlzdCA9IFsuLi5zYW5pdGl6ZWRMaXN0LCAuLi5tYXBwZWRDbGFzc2VzXTtcbiAgfVxuXG4gIHJldHVybiBzYW5pdGl6ZWRMaXN0LmpvaW4oJyAnKS50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWVMaXN0KHZhbHVlLCBNQVBQSU5HID0ge30pIHtcbiAgbGV0IG1hcHBlZENsYXNzZXMgPSBbXTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhNQVBQSU5HKTtcblxuICAgIG1hcHBlZENsYXNzZXMgPSBjbGFzc05hbWVzLm1hcChjbGFzc05hbWUgPT4ge1xuICAgICAgaWYgKGtleXMuaW5kZXhPZihjbGFzc05hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIE1BUFBJTkdbY2xhc3NOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbWFwcGVkQ2xhc3Nlcztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2xhc3NlcyhyZW5kZXJlcjogUmVuZGVyZXIyLCBlbGVtZW50OiBFbGVtZW50UmVmLCBjbGFzc2VzOiBzdHJpbmcpIHtcbiAgaWYgKHJlbmRlcmVyICYmIGVsZW1lbnQgJiYgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgcmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBpdGVtKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cblxuLy8gWVlZWS1NTS1ERCAtPiBEQVRFXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xufVxuXG4vLyBNYW51YWxseSBjb21wb3NlIGEgZm9udCBzaG9ydGhhbmQgZGVmaW50aW9uIGFzIGl0J3Mgbm90XG4vLyBndWFyYW50ZWVkIHRvIGJlIGdpdmVuIGJ5IHRoZSBjb21wdXRlZCBzdHlsZSBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9udFNob3J0aGFuZChzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbikge1xuICBjb25zdCB7XG4gICAgZm9udCwgZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGxpbmVIZWlnaHQsIGZvbnRGYW1pbHlcbiAgfSA9IHN0eWxlO1xuXG4gIGlmIChmb250Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZm9udDtcbiAgfVxuXG4gIHJldHVybiBgJHtmb250U3R5bGV9ICR7Zm9udFZhcmlhbnR9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX0vJHtsaW5lSGVpZ2h0fSAke2ZvbnRGYW1pbHl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlck9mRGVjaW1hbHMobnVtYmVyKSB7XG4gIGNvbnN0IHBhcnNlZCA9IE51bWJlcihudW1iZXIpO1xuICBpZiAoTnVtYmVyLmlzTmFOKHBhcnNlZCkgfHwgTnVtYmVyLmlzSW50ZWdlcihwYXJzZWQpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSAocGFyc2VkLnRvU3RyaW5nKCkpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuICBpZiAoIW1hdGNoWzFdKSB7XG4gICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gbWF0Y2hbMV0ubGVuZ3RoO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLyoqIFByb3ZpZGVyIHRoYXQgZGVmaW5lcyB3aGVuIGZvcm0gY29udHJvbHMgaGF2ZSBhbiBlcnJvci4gKi9cbkBJbmplY3RhYmxlKHtwcm92aWRlZEluOiAncm9vdCd9KVxuZXhwb3J0IGNsYXNzIEVycm9yU3RhdGVNYXRjaGVyIHtcbiAgaXNFcnJvclN0YXRlKGNvbnRyb2w6IEZvcm1Db250cm9sIHwgbnVsbCwgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZCAmJiAoY29udHJvbC50b3VjaGVkIHx8IChmb3JtICYmIGZvcm0uc3VibWl0dGVkKSkpO1xuICB9XG59XG4iXX0=