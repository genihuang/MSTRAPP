/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge } from 'rxjs';
import { map, take } from 'rxjs/operators';
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
var /**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
NxTreeFlattener = /** @class */ (function () {
    function NxTreeFlattener() {
    }
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    NxTreeFlattener.prototype.transformFunction = /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    function (node, level) {
        var children = node.children, rest = tslib_1.__rest(node, ["children"]);
        return (/** @type {?} */ (tslib_1.__assign({}, rest, { level: level, expandable: Array.isArray(children) && children.length > 0 })));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getLevel = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.level;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.isExpandable = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.expandable;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NxTreeFlattener.prototype.getChildren = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return (/** @type {?} */ (node.children));
    };
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenNode = /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (node, level, resultNodes, parentMap) {
        var _this = this;
        /** @type {?} */
        var flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            var childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                function (children) {
                    _this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    };
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    NxTreeFlattener.prototype._flattenChildren = /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    function (children, level, resultNodes, parentMap) {
        var _this = this;
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        function (child, index) {
            /** @type {?} */
            var childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            _this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    };
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     */
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    NxTreeFlattener.prototype.flattenNodes = /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    function (structuredData) {
        var _this = this;
        /** @type {?} */
        var resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) { return _this._flattenNode(node, 0, resultNodes, []); }));
        return resultNodes;
    };
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     */
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    NxTreeFlattener.prototype.expandFlattenedNodes = /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    function (nodes, treeControl) {
        var _this = this;
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var expand = true;
            for (var i = 0; i <= _this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (_this.isExpandable(node)) {
                currentExpand[_this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    };
    return NxTreeFlattener;
}());
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
var /**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
NxTreeFlatDataSource = /** @class */ (function (_super) {
    tslib_1.__extends(NxTreeFlatDataSource, _super);
    function NxTreeFlatDataSource(treeControl, initialData) {
        if (initialData === void 0) { initialData = []; }
        var _this = _super.call(this) || this;
        _this.treeControl = treeControl;
        _this._flattenedData = new BehaviorSubject([]);
        _this._expandedData = new BehaviorSubject([]);
        _this._data = new BehaviorSubject([]);
        _this._treeFlattener = new NxTreeFlattener();
        _this.data = initialData;
        return _this;
    }
    Object.defineProperty(NxTreeFlatDataSource.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this._data.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data.next(value);
            this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
            this.treeControl.dataNodes = this._flattenedData.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.connect = /**
     * @param {?} collectionViewer
     * @return {?}
     */
    function (collectionViewer) {
        var _this = this;
        /** @type {?} */
        var changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.onChange,
            this._flattenedData
        ];
        return merge.apply(void 0, tslib_1.__spread(changes)).pipe(map((/**
         * @return {?}
         */
        function () {
            _this._expandedData.next(_this._treeFlattener.expandFlattenedNodes(_this._flattenedData.value, _this.treeControl));
            return _this._expandedData.value;
        })));
    };
    /**
     * @return {?}
     */
    NxTreeFlatDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () {
        // no op
    };
    return NxTreeFlatDataSource;
}(DataSource));
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
export { NxTreeFlatDataSource };
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdC1kYXRhLXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3RyZWUvIiwic291cmNlcyI6WyJkYXRhLXNvdXJjZS9mbGF0LWRhdGEtc291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFtQixVQUFVLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RSxPQUFPLEVBQUMsZUFBZSxFQUFFLEtBQUssRUFBaUIsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUN6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7SUFtRkEsQ0FBQzs7Ozs7O0lBbEZDLDJDQUFpQjs7Ozs7SUFBakIsVUFBa0IsSUFBZ0IsRUFBRSxLQUFhO1FBQ3ZDLElBQUEsd0JBQVEsRUFBRSx5Q0FBTztRQUN6QixPQUFPLHdDQUNGLElBQUksSUFDUCxLQUFLLE9BQUEsRUFDTCxVQUFVLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsS0FDdEQsQ0FBQztJQUNULENBQUM7Ozs7O0lBRUQsa0NBQVE7Ozs7SUFBUixVQUFTLElBQU87UUFDZCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQzs7Ozs7SUFFRCxzQ0FBWTs7OztJQUFaLFVBQWEsSUFBTztRQUNsQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQzs7Ozs7SUFFRCxxQ0FBVzs7OztJQUFYLFVBQVksSUFBTztRQUNqQixPQUFPLG1CQUFBLElBQUksQ0FBQyxRQUFRLEVBQU8sQ0FBQztJQUM5QixDQUFDOzs7Ozs7OztJQUVELHNDQUFZOzs7Ozs7O0lBQVosVUFBYSxJQUFPLEVBQUUsS0FBYSxFQUN0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O1lBQ3hDLElBQUksQ0FBQyxjQUFjO1NBQ3BCO1FBQ0QsT0FBTyxLQUFLLGdDQUFJLE9BQU8sR0FBRSxJQUFJLENBQUMsR0FBRzs7O1FBQUM7WUFDaEMsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLEtBQUksQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUMsS0FBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsS0FBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDekYsT0FBTyxLQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztRQUNsQyxDQUFDLEVBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQzs7OztJQUVELHlDQUFVOzs7SUFBVjtRQUNFLFFBQVE7SUFDVixDQUFDO0lBQ0gsMkJBQUM7QUFBRCxDQUFDLEFBdkNELENBQTBGLFVBQVUsR0F1Q25HOzs7Ozs7Ozs7Ozs7SUF0Q0MsOENBQXNDOztJQUV0Qyw4Q0FBOEM7O0lBRTlDLDZDQUE2Qzs7SUFFN0MscUNBQXFDOzs7OztJQVN6QiwyQ0FBdUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbGxlY3Rpb25WaWV3ZXIsIERhdGFTb3VyY2V9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgbWVyZ2UsIE9ic2VydmFibGUsIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7bWFwLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOeFRyZWVOb2RlLCBOeEZsYXRUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcbmltcG9ydCB7IE54RmxhdFRyZWVDb250cm9sIH0gZnJvbSAnLi9mbGF0LXRyZWUtY29udHJvbCc7XG5pbXBvcnQgeyBUcmVlQ29udHJvbCwgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuXG4vKipcbiAqIFRyZWUgZmxhdHRlbmVyIHRvIGNvbnZlcnQgYSBub3JtYWwgdHlwZSBvZiBub2RlIHRvIG5vZGUgd2l0aCBjaGlsZHJlbiAmIGxldmVsIGluZm9ybWF0aW9uLlxuICogVHJhbnNmb3JtIG5lc3RlZCBub2RlcyBvZiB0eXBlIGBUIGV4dGVuZHMgTnhUcmVlTm9kZWAgdG8gZmxhdHRlbmVkIG5vZGVzIG9mIHR5cGUgYEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZSBpbnB1dCBkYXRhIG9mIHR5cGUgYFRgIGlzIG5lc3RlZCwgYW5kIGNvbnRhaW5zIGl0cyBjaGlsZHJlbiBkYXRhOlxuICogICBTb21lTm9kZToge1xuICogICAgIGtleTogJ0ZydWl0cycsXG4gKiAgICAgY2hpbGRyZW46IFtcbiAqICAgICAgIE5vZGVPbmU6IHtcbiAqICAgICAgICAga2V5OiAnQXBwbGUnLFxuICogICAgICAgfSxcbiAqICAgICAgIE5vZGVUd286IHtcbiAqICAgICAgICBrZXk6ICdQZWFyJyxcbiAqICAgICAgfVxuICogICAgXVxuICogIH1cbiAqICBBZnRlciBmbGF0dGVuZXIgZmxhdHRlbiB0aGUgdHJlZSwgdGhlIHN0cnVjdHVyZSB3aWxsIGJlY29tZVxuICogIFNvbWVOb2RlOiB7XG4gKiAgICBrZXk6ICdGcnVpdHMnLFxuICogICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAqICAgIGxldmVsOiAxXG4gKiAgfSxcbiAqICBOb2RlT25lOiB7XG4gKiAgICBrZXk6ICdBcHBsZScsXG4gKiAgICBleHBhbmRhYmxlOiBmYWxzZSxcbiAqICAgIGxldmVsOiAyXG4gKiAgfSxcbiAqICBOb2RlVHdvOiB7XG4gKiAgIGtleTogJ1BlYXInLFxuICogICBleHBhbmRhYmxlOiBmYWxzZSxcbiAqICAgbGV2ZWw6IDJcbiAqIH1cbiAqIGFuZCB0aGUgb3V0cHV0IGZsYXR0ZW5lZCB0eXBlIGlzIGBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGVgIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTnhUcmVlRmxhdHRlbmVyPFQgZXh0ZW5kcyBOeFRyZWVOb2RlLCBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGU+IHtcbiAgdHJhbnNmb3JtRnVuY3Rpb24obm9kZTogTnhUcmVlTm9kZSwgbGV2ZWw6IG51bWJlcik6IEYge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBsZXZlbCxcbiAgICAgIGV4cGFuZGFibGU6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcbiAgICB9IGFzIEY7XG4gIH1cblxuICBnZXRMZXZlbChub2RlOiBGKTogbnVtYmVyIHtcbiAgICByZXR1cm4gbm9kZS5sZXZlbDtcbiAgfVxuXG4gIGlzRXhwYW5kYWJsZShub2RlOiBGKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgfVxuXG4gIGdldENoaWxkcmVuKG5vZGU6IFQpOiBPYnNlcnZhYmxlPFRbXT4gfCBUW10ge1xuICAgIHJldHVybiBub2RlLmNoaWxkcmVuIGFzIFRbXTtcbiAgfVxuXG4gIF9mbGF0dGVuTm9kZShub2RlOiBULCBsZXZlbDogbnVtYmVyLFxuICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXM6IEZbXSwgcGFyZW50TWFwOiBib29sZWFuW10pOiBGW10ge1xuICAgIGNvbnN0IGZsYXROb2RlID0gdGhpcy50cmFuc2Zvcm1GdW5jdGlvbihub2RlLCBsZXZlbCk7XG4gICAgcmVzdWx0Tm9kZXMucHVzaChmbGF0Tm9kZSk7XG5cbiAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoZmxhdE5vZGUpKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbk5vZGVzID0gdGhpcy5nZXRDaGlsZHJlbihub2RlKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuTm9kZXMpKSB7XG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbk5vZGVzLCBsZXZlbCwgcmVzdWx0Tm9kZXMsIHBhcmVudE1hcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbk5vZGVzLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKGNoaWxkcmVuID0+IHtcbiAgICAgICAgICB0aGlzLl9mbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIGxldmVsLCByZXN1bHROb2RlcywgcGFyZW50TWFwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgfVxuXG4gIF9mbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW46IFRbXSwgbGV2ZWw6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICByZXN1bHROb2RlczogRltdLCBwYXJlbnRNYXA6IGJvb2xlYW5bXSk6IHZvaWQge1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRQYXJlbnRNYXA6IGJvb2xlYW5bXSA9IHBhcmVudE1hcC5zbGljZSgpO1xuICAgICAgY2hpbGRQYXJlbnRNYXAucHVzaChpbmRleCAhPSBjaGlsZHJlbi5sZW5ndGggLSAxKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgdGhpcy5fZmxhdHRlbk5vZGUoY2hpbGQsIGxldmVsICsgMSwgcmVzdWx0Tm9kZXMsIGNoaWxkUGFyZW50TWFwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIGEgbGlzdCBvZiBub2RlIHR5cGUgVCB0byBmbGF0dGVuZWQgdmVyc2lvbiBvZiBub2RlIEYuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdHlwZSBUIG1heSBiZSBuZXN0ZWQsIGFuZCB0aGUgbGVuZ3RoIG9mIGBzdHJ1Y3R1cmVkRGF0YWAgbWF5IGJlIGRpZmZlcmVudFxuICAgKiBmcm9tIHRoYXQgb2YgcmV0dXJuZWQgbGlzdCBgRltdYC5cbiAgICovXG4gIGZsYXR0ZW5Ob2RlcyhzdHJ1Y3R1cmVkRGF0YTogVFtdKTogRltdIHtcbiAgICBjb25zdCByZXN1bHROb2RlczogRltdID0gW107XG4gICAgc3RydWN0dXJlZERhdGEuZm9yRWFjaChub2RlID0+IHRoaXMuX2ZsYXR0ZW5Ob2RlKG5vZGUsIDAsIHJlc3VsdE5vZGVzLCBbXSkpO1xuICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgZmxhdHRlbmVkIG5vZGUgd2l0aCBjdXJyZW50IGV4cGFuc2lvbiBzdGF0dXMuXG4gICAqIFRoZSByZXR1cm5lZCBsaXN0IG1heSBoYXZlIGRpZmZlcmVudCBsZW5ndGguXG4gICAqL1xuICBleHBhbmRGbGF0dGVuZWROb2Rlcyhub2RlczogRltdLCB0cmVlQ29udHJvbDogVHJlZUNvbnRyb2w8Rj4pOiBGW10ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEZbXSA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRFeHBhbmQ6IGJvb2xlYW5bXSA9IFtdO1xuICAgIGN1cnJlbnRFeHBhbmRbMF0gPSB0cnVlO1xuXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGxldCBleHBhbmQgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5nZXRMZXZlbChub2RlKTsgaSsrKSB7XG4gICAgICAgIGV4cGFuZCA9IGV4cGFuZCAmJiBjdXJyZW50RXhwYW5kW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUobm9kZSkpIHtcbiAgICAgICAgY3VycmVudEV4cGFuZFt0aGlzLmdldExldmVsKG5vZGUpICsgMV0gPSB0cmVlQ29udHJvbC5pc0V4cGFuZGVkKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBzb3VyY2UgZm9yIGZsYXQgdHJlZS5cbiAqIFRoZSBkYXRhIHNvdXJjZSBuZWVkIHRvIGhhbmRsZSBleHBhbnNpb24vY29sbGFwc2lvbiBvZiB0aGUgdHJlZSBub2RlIGFuZCBjaGFuZ2UgdGhlIGRhdGEgZmVlZFxuICogdG8gYE54VHJlZWAuXG4gKiBUaGUgbmVzdGVkIHRyZWUgbm9kZXMgb2YgdHlwZSBgVCBleHRlbmRzIE54VHJlZU5vZGVgIGFyZSBmbGF0dGVuZWQgdGhyb3VnaCBgTnhUcmVlRmxhdHRlbmVyYCwgYW5kIGNvbnZlcnRlZFxuICogdG8gdHlwZSBgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlYCBmb3IgYE54VHJlZWAgdG8gY29uc3VtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE54VHJlZUZsYXREYXRhU291cmNlPFQgZXh0ZW5kcyBOeFRyZWVOb2RlLCBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGU+IGV4dGVuZHMgRGF0YVNvdXJjZTxGPiB7XG4gIF90cmVlRmxhdHRlbmVyOiBOeFRyZWVGbGF0dGVuZXI8VCwgRj47XG5cbiAgX2ZsYXR0ZW5lZERhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZbXT4oW10pO1xuXG4gIF9leHBhbmRlZERhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZbXT4oW10pO1xuXG4gIF9kYXRhID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUW10+KFtdKTtcblxuICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuX2RhdGEudmFsdWU7IH1cbiAgc2V0IGRhdGEodmFsdWU6IFRbXSkge1xuICAgIHRoaXMuX2RhdGEubmV4dCh2YWx1ZSk7XG4gICAgdGhpcy5fZmxhdHRlbmVkRGF0YS5uZXh0KHRoaXMuX3RyZWVGbGF0dGVuZXIuZmxhdHRlbk5vZGVzKHRoaXMuZGF0YSkpO1xuICAgIHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzID0gdGhpcy5fZmxhdHRlbmVkRGF0YS52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJlZUNvbnRyb2w6IEZsYXRUcmVlQ29udHJvbDxGPixcbiAgICAgICAgICAgICAgaW5pdGlhbERhdGE6IFRbXSA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90cmVlRmxhdHRlbmVyID0gbmV3IE54VHJlZUZsYXR0ZW5lcigpO1xuICAgIHRoaXMuZGF0YSA9IGluaXRpYWxEYXRhO1xuICB9XG5cbiAgY29ubmVjdChjb2xsZWN0aW9uVmlld2VyOiBDb2xsZWN0aW9uVmlld2VyKTogT2JzZXJ2YWJsZTxGW10+IHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW1xuICAgICAgY29sbGVjdGlvblZpZXdlci52aWV3Q2hhbmdlLFxuICAgICAgdGhpcy50cmVlQ29udHJvbC5leHBhbnNpb25Nb2RlbC5vbkNoYW5nZSxcbiAgICAgIHRoaXMuX2ZsYXR0ZW5lZERhdGFcbiAgICBdO1xuICAgIHJldHVybiBtZXJnZSguLi5jaGFuZ2VzKS5waXBlKG1hcCgoKSA9PiB7XG4gICAgICB0aGlzLl9leHBhbmRlZERhdGEubmV4dChcbiAgICAgICAgdGhpcy5fdHJlZUZsYXR0ZW5lci5leHBhbmRGbGF0dGVuZWROb2Rlcyh0aGlzLl9mbGF0dGVuZWREYXRhLnZhbHVlLCB0aGlzLnRyZWVDb250cm9sKSk7XG4gICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWREYXRhLnZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgLy8gbm8gb3BcbiAgfVxufVxuXG4iXX0=