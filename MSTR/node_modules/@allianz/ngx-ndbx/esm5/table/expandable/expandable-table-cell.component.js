/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ChangeDetectionStrategy, Component, ChangeDetectorRef } from '@angular/core';
import { NxExpandableTableRowComponent } from './expandable-table-row.component';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/**
 * This is an expandable table cell.
 * Only works in conjunction with the `[nxExpandableTableRow]` component.
 */
var NxExpandableTableCellComponent = /** @class */ (function () {
    function NxExpandableTableCellComponent(_row, _changeDetectorRef) {
        var _this = this;
        this._changeDetectorRef = _changeDetectorRef;
        this._destroyed = new Subject();
        this._open = false;
        _row.expanded.pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            _this._open = open;
            _this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @return {?}
     */
    NxExpandableTableCellComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed.next();
        this._destroyed.complete();
    };
    NxExpandableTableCellComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'td[nxExpandableTableCell]',
                    template: "<div [@openClose]=\"_open ? 'open' : 'closed'\" class=\"nx-expandable-table-cell__content\">\n  <div class=\"nx-expandable-table-cell__wrapper\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                    host: {
                        'class': 'nx-expandable-table-cell'
                    },
                    animations: [
                        trigger('openClose', [
                            state('open', style({
                                height: '*'
                            })),
                            state('closed, void', style({
                                height: '0'
                            })),
                            transition('closed <=> open, void => closed', [
                                animate('225ms cubic-bezier(0.4,0.0,0.2,1)')
                            ])
                        ])
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxExpandableTableCellComponent.ctorParameters = function () { return [
        { type: NxExpandableTableRowComponent },
        { type: ChangeDetectorRef }
    ]; };
    return NxExpandableTableCellComponent;
}());
export { NxExpandableTableCellComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxExpandableTableCellComponent.prototype._destroyed;
    /** @type {?} */
    NxExpandableTableCellComponent.prototype._open;
    /**
     * @type {?}
     * @private
     */
    NxExpandableTableCellComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS10YWJsZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3RhYmxlLyIsInNvdXJjZXMiOlsiZXhwYW5kYWJsZS9leHBhbmRhYmxlLXRhYmxlLWNlbGwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDakcsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDakYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBTTNDO0lBMkJFLHdDQUNJLElBQW1DLEVBQzNCLGtCQUFxQztRQUZqRCxpQkFTQztRQVBXLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFOekMsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFFbkMsVUFBSyxHQUFZLEtBQUssQ0FBQztRQU1yQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzNDLFNBQVM7Ozs7UUFBQyxVQUFBLElBQUk7WUFDYixLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztZQUNsQixLQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDekMsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDOzs7O0lBRUQsb0RBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdCLENBQUM7O2dCQXpDRixTQUFTLFNBQUM7O29CQUVULFFBQVEsRUFBRSwyQkFBMkI7b0JBQ3JDLGdOQUFxRDtvQkFDckQsSUFBSSxFQUFFO3dCQUNKLE9BQU8sRUFBRSwwQkFBMEI7cUJBQ3BDO29CQUNELFVBQVUsRUFBRTt3QkFDVixPQUFPLENBQUMsV0FBVyxFQUFFOzRCQUNuQixLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQztnQ0FDbEIsTUFBTSxFQUFFLEdBQUc7NkJBQ1osQ0FBQyxDQUFDOzRCQUNILEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDO2dDQUMxQixNQUFNLEVBQUUsR0FBRzs2QkFDWixDQUFDLENBQUM7NEJBQ0gsVUFBVSxDQUFDLGlDQUFpQyxFQUFFO2dDQUM1QyxPQUFPLENBQUMsbUNBQW1DLENBQUM7NkJBQzdDLENBQUM7eUJBQ0gsQ0FBQztxQkFDSDtvQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQ7Ozs7Z0JBN0JRLDZCQUE2QjtnQkFETyxpQkFBaUI7O0lBbUQ5RCxxQ0FBQztDQUFBLEFBMUNELElBMENDO1NBcEJZLDhCQUE4Qjs7Ozs7O0lBQ3pDLG9EQUFtQzs7SUFFbkMsK0NBQXVCOzs7OztJQUluQiw0REFBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENoYW5nZURldGVjdG9yUmVmLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE54RXhwYW5kYWJsZVRhYmxlUm93Q29tcG9uZW50IH0gZnJvbSAnLi9leHBhbmRhYmxlLXRhYmxlLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gZXhwYW5kYWJsZSB0YWJsZSBjZWxsLlxuICogT25seSB3b3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgW254RXhwYW5kYWJsZVRhYmxlUm93XWAgY29tcG9uZW50LlxuICovXG5AQ29tcG9uZW50KHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ3RkW254RXhwYW5kYWJsZVRhYmxlQ2VsbF0nLFxuICB0ZW1wbGF0ZVVybDogJy4vZXhwYW5kYWJsZS10YWJsZS1jZWxsLmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdueC1leHBhbmRhYmxlLXRhYmxlLWNlbGwnXG4gIH0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdvcGVuQ2xvc2UnLCBbXG4gICAgICBzdGF0ZSgnb3BlbicsIHN0eWxlKHtcbiAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgIH0pKSxcbiAgICAgIHN0YXRlKCdjbG9zZWQsIHZvaWQnLCBzdHlsZSh7XG4gICAgICAgIGhlaWdodDogJzAnXG4gICAgICB9KSksXG4gICAgICB0cmFuc2l0aW9uKCdjbG9zZWQgPD0+IG9wZW4sIHZvaWQgPT4gY2xvc2VkJywgW1xuICAgICAgICBhbmltYXRlKCcyMjVtcyBjdWJpYy1iZXppZXIoMC40LDAuMCwwLjIsMSknKVxuICAgICAgXSlcbiAgICBdKVxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBOeEV4cGFuZGFibGVUYWJsZUNlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdCgpO1xuXG4gIF9vcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBfcm93OiBOeEV4cGFuZGFibGVUYWJsZVJvd0NvbXBvbmVudCxcbiAgICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuXG4gICAgX3Jvdy5leHBhbmRlZC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgLnN1YnNjcmliZShvcGVuID0+IHtcbiAgICAgICAgdGhpcy5fb3BlbiA9IG9wZW47XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICB9XG59XG4iXX0=