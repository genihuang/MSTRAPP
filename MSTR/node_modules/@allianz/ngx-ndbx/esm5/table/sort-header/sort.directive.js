/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, Input } from '@angular/core';
import { Subject } from 'rxjs';
var SortEvent = /** @class */ (function () {
    function SortEvent(active, direction) {
        this.active = active;
        this.direction = direction;
    }
    return SortEvent;
}());
export { SortEvent };
if (false) {
    /**
     * The name of the column that is being sorted by.
     * @type {?}
     */
    SortEvent.prototype.active;
    /**
     * The sort direction.
     * @type {?}
     */
    SortEvent.prototype.direction;
}
var NxSortDirective = /** @class */ (function () {
    function NxSortDirective() {
        this._stateChanges = new Subject();
        this._direction = 'asc';
        /**
         * \@docs-private
         * An event emitted when the active value has changed.
         */
        this.activeChange = new EventEmitter();
        /**
         * \@docs-private
         * An event emitted when the direction value has changed.
         */
        this.directionChange = new EventEmitter();
        /**
         * An event emitted when either the active sort or sort direction changes.
         */
        this.sortChange = new EventEmitter();
    }
    Object.defineProperty(NxSortDirective.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        /** Sets the key of the most recently sorted column. */
        set: /**
         * Sets the key of the most recently sorted column.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._active !== value) {
                this._active = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxSortDirective.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            return this._direction;
        },
        /** Sets the direction of the currently active sorted column. Default: 'asc'. */
        set: /**
         * Sets the direction of the currently active sorted column. Default: 'asc'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._direction !== value) {
                this._direction = value;
                this.sortChange.emit(new SortEvent(this.active, this.direction));
                this._stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxSortDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     */
    /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    NxSortDirective.prototype.sort = /**
     * Sets the active sort key and determines the new sort direction.
     * Afterwards the output event `sortChange` is called.
     *
     * If `sortable` is not the key of the active sort header, the initial direction to sort is 'asc'.
     * Otherwise the direction of the sorted column changes.
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (this._active !== sortable) {
            this._active = sortable;
            this.activeChange.emit(this.active);
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        else if (this._direction === 'asc') {
            this._direction = 'desc';
            this.directionChange.emit(this.direction);
        }
        else {
            this._direction = 'asc';
            this.directionChange.emit(this.direction);
        }
        this.sortChange.emit(new SortEvent(this.active, this.direction));
        this._stateChanges.next();
    };
    NxSortDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'table[nxSort]',
                    exportAs: 'NxSortDirective'
                },] }
    ];
    NxSortDirective.propDecorators = {
        active: [{ type: Input }],
        direction: [{ type: Input }],
        activeChange: [{ type: Output }],
        directionChange: [{ type: Output }],
        sortChange: [{ type: Output }]
    };
    return NxSortDirective;
}());
export { NxSortDirective };
if (false) {
    /** @type {?} */
    NxSortDirective.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._active;
    /**
     * @type {?}
     * @private
     */
    NxSortDirective.prototype._direction;
    /**
     * \@docs-private
     * An event emitted when the active value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.activeChange;
    /**
     * \@docs-private
     * An event emitted when the direction value has changed.
     * @type {?}
     */
    NxSortDirective.prototype.directionChange;
    /**
     * An event emitted when either the active sort or sort direction changes.
     * @type {?}
     */
    NxSortDirective.prototype.sortChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC90YWJsZS8iLCJzb3VyY2VzIjpbInNvcnQtaGVhZGVyL3NvcnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJL0I7SUFPRSxtQkFBWSxNQUFNLEVBQUUsU0FBUztRQUMzQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztJQUM3QixDQUFDO0lBQ0gsZ0JBQUM7QUFBRCxDQUFDLEFBWEQsSUFXQzs7Ozs7OztJQVRDLDJCQUFlOzs7OztJQUdmLDhCQUF5Qjs7QUFRM0I7SUFBQTtRQU1XLGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQWlCckMsZUFBVSxHQUFrQixLQUFLLENBQUM7Ozs7O1FBbUJ2QixpQkFBWSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDOzs7OztRQU1oRSxvQkFBZSxHQUFnQyxJQUFJLFlBQVksRUFBaUIsQ0FBQzs7OztRQUdqRixlQUFVLEdBQTRCLElBQUksWUFBWSxFQUFhLENBQUM7SUErQnpGLENBQUM7SUF2RUMsc0JBQ0ksbUNBQU07Ozs7UUFPVjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDO1FBWEQsdURBQXVEOzs7Ozs7UUFDdkQsVUFDVyxLQUFhO1lBQ3RCLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2dCQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNqRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQzNCO1FBQ0gsQ0FBQzs7O09BQUE7SUFRRCxzQkFDSSxzQ0FBUzs7OztRQU9iO1lBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3pCLENBQUM7UUFYRCxnRkFBZ0Y7Ozs7OztRQUNoRixVQUNjLEtBQW9CO1lBQ2hDLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxLQUFLLEVBQUU7Z0JBQzdCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO2dCQUN4QixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNqRSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQzNCO1FBQ0gsQ0FBQzs7O09BQUE7Ozs7SUFvQkQscUNBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7OztPQU1HOzs7Ozs7Ozs7O0lBQ0gsOEJBQUk7Ozs7Ozs7OztJQUFKLFVBQUssUUFBZ0I7UUFDbkIsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUM3QixJQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQztZQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7WUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssRUFBRTtZQUNwQyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztZQUN6QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDM0M7YUFBTTtZQUNMLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzQztRQUVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDakUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM1QixDQUFDOztnQkFoRkYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxlQUFlO29CQUN6QixRQUFRLEVBQUUsaUJBQWlCO2lCQUM1Qjs7O3lCQVFFLEtBQUs7NEJBZUwsS0FBSzsrQkFnQkwsTUFBTTtrQ0FNTixNQUFNOzZCQUdOLE1BQU07O0lBK0JULHNCQUFDO0NBQUEsQUFsRkQsSUFrRkM7U0E5RVksZUFBZTs7O0lBRTFCLHdDQUE2Qzs7Ozs7SUFFN0Msa0NBQXdCOzs7OztJQWV4QixxQ0FBMEM7Ozs7OztJQW1CMUMsdUNBQW1GOzs7Ozs7SUFNbkYsMENBQW9HOzs7OztJQUdwRyxxQ0FBdUYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCB0eXBlIFNvcnREaXJlY3Rpb24gPSAnYXNjJyB8ICdkZXNjJztcblxuZXhwb3J0IGNsYXNzIFNvcnRFdmVudCB7XG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uIHRoYXQgaXMgYmVpbmcgc29ydGVkIGJ5LiAqL1xuICBhY3RpdmU6IHN0cmluZztcblxuICAvKiogVGhlIHNvcnQgZGlyZWN0aW9uLiAqL1xuICBkaXJlY3Rpb246IFNvcnREaXJlY3Rpb247XG5cbiAgY29uc3RydWN0b3IoYWN0aXZlLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICd0YWJsZVtueFNvcnRdJyxcbiAgZXhwb3J0QXM6ICdOeFNvcnREaXJlY3RpdmUnXG59KVxuZXhwb3J0IGNsYXNzIE54U29ydERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcmVhZG9ubHkgX3N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgcHJpdmF0ZSBfYWN0aXZlOiBzdHJpbmc7XG5cbiAgLyoqIFNldHMgdGhlIGtleSBvZiB0aGUgbW9zdCByZWNlbnRseSBzb3J0ZWQgY29sdW1uLiAqL1xuICBASW5wdXQoKVxuICBzZXQgYWN0aXZlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdmFsdWU7XG4gICAgICB0aGlzLnNvcnRDaGFuZ2UuZW1pdChuZXcgU29ydEV2ZW50KHRoaXMuYWN0aXZlLCB0aGlzLmRpcmVjdGlvbikpO1xuICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICBwcml2YXRlIF9kaXJlY3Rpb246IFNvcnREaXJlY3Rpb24gPSAnYXNjJztcblxuICAvKiogU2V0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNvcnRlZCBjb2x1bW4uIERlZmF1bHQ6ICdhc2MnLiAqL1xuICBASW5wdXQoKVxuICBzZXQgZGlyZWN0aW9uKHZhbHVlOiBTb3J0RGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHZhbHVlO1xuICAgICAgdGhpcy5zb3J0Q2hhbmdlLmVtaXQobmV3IFNvcnRFdmVudCh0aGlzLmFjdGl2ZSwgdGhpcy5kaXJlY3Rpb24pKTtcbiAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXJlY3Rpb24oKTogU29ydERpcmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGFjdGl2ZUNoYW5nZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIGRpcmVjdGlvbiB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBkaXJlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxTb3J0RGlyZWN0aW9uPiA9IG5ldyBFdmVudEVtaXR0ZXI8U29ydERpcmVjdGlvbj4oKTtcblxuICAvKiogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIGVpdGhlciB0aGUgYWN0aXZlIHNvcnQgb3Igc29ydCBkaXJlY3Rpb24gY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNvcnRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTb3J0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxTb3J0RXZlbnQ+KCk7XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIHNvcnQga2V5IGFuZCBkZXRlcm1pbmVzIHRoZSBuZXcgc29ydCBkaXJlY3Rpb24uXG4gICAqIEFmdGVyd2FyZHMgdGhlIG91dHB1dCBldmVudCBgc29ydENoYW5nZWAgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBJZiBgc29ydGFibGVgIGlzIG5vdCB0aGUga2V5IG9mIHRoZSBhY3RpdmUgc29ydCBoZWFkZXIsIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB0byBzb3J0IGlzICdhc2MnLlxuICAgKiBPdGhlcndpc2UgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc29ydGVkIGNvbHVtbiBjaGFuZ2VzLlxuICAgKi9cbiAgc29ydChzb3J0YWJsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSAhPT0gc29ydGFibGUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHNvcnRhYmxlO1xuICAgICAgdGhpcy5hY3RpdmVDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZSk7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgIHRoaXMuZGlyZWN0aW9uQ2hhbmdlLmVtaXQodGhpcy5kaXJlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnYXNjJykge1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gJ2Rlc2MnO1xuICAgICAgdGhpcy5kaXJlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLmRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9ICdhc2MnO1xuICAgICAgdGhpcy5kaXJlY3Rpb25DaGFuZ2UuZW1pdCh0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0Q2hhbmdlLmVtaXQobmV3IFNvcnRFdmVudCh0aGlzLmFjdGl2ZSwgdGhpcy5kaXJlY3Rpb24pKTtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG5cbn1cbiJdfQ==