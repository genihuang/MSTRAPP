/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CdkAccordionItem } from '@angular/cdk/accordion';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { TemplatePortal } from '@angular/cdk/portal';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Input, Optional, SkipSelf, ViewContainerRef } from '@angular/core';
import { Subject } from 'rxjs';
import { filter, startWith, take } from 'rxjs/operators';
import { NxAccordionDirective } from './accordion';
import { nxAccordionAnimations } from './accordion-animations';
import { NxExpansionPanelBodyDirective } from './expansion-panel-body';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
/** @type {?} */
var nextId = 0;
/** @type {?} */
var DEFAULT_TYPE = 'regular';
var ɵ0 = undefined;
var NxExpansionPanelComponent = /** @class */ (function (_super) {
    tslib_1.__extends(NxExpansionPanelComponent, _super);
    function NxExpansionPanelComponent(accordion, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
        var _this = _super.call(this, accordion, _changeDetectorRef, _expansionDispatcher) || this;
        _this._viewContainerRef = _viewContainerRef;
        _this._negative = null;
        _this._accordionStyle = DEFAULT_TYPE;
        _this._style = null;
        _this._headerId = "nx-expansion-panel-header-" + nextId++;
        /**
         * Stream that emits for changes in `\@Input` properties.
         */
        _this._inputChanges = new Subject();
        _this.accordion = accordion;
        return _this;
    }
    Object.defineProperty(NxExpansionPanelComponent.prototype, "negative", {
        get: /**
         * @return {?}
         */
        function () {
            return this._negative;
        },
        /** Whether the negative set of styles should be used. */
        set: /**
         * Whether the negative set of styles should be used.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._negative = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxExpansionPanelComponent.prototype, "style", {
        get: /**
         * @return {?}
         */
        function () {
            return this._style;
        },
        /**
         * Value for the styling that should be chosen.
         * Default value: 'regular'.
         */
        set: /**
         * Value for the styling that should be chosen.
         * Default value: 'regular'.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = value ? value : DEFAULT_TYPE;
            var _a = tslib_1.__read(value.match(/regular|light/) || [DEFAULT_TYPE], 1), newValue = _a[0];
            this._style = (/** @type {?} */ (newValue));
            this._accordionStyle = (/** @type {?} */ (newValue));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxExpansionPanelComponent.prototype, "portal", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._portal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxExpansionPanelComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.lazyContent) {
            // Render the content as soon as the panel becomes open.
            this.opened.pipe(startWith(null), filter((/**
             * @return {?}
             */
            function () { return _this.expanded && !_this._portal; })), take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._portal = new TemplatePortal(_this.lazyContent._template, _this._viewContainerRef);
            }));
        }
        // Inherit appearance given by the accordion (if any).
        if (Boolean(this.accordion)) {
            if (this.style === null && this.accordion.style !== null) {
                this.style = this.accordion.style;
            }
            if (this.negative === null && this.accordion.negative !== null) {
                this.negative = this.accordion.negative;
            }
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NxExpansionPanelComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this._inputChanges.next(changes);
    };
    /**
     * @return {?}
     */
    NxExpansionPanelComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        this._inputChanges.complete();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxExpansionPanelComponent.prototype.getOpenState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.expanded ? 'open' : 'closed';
    };
    NxExpansionPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-expansion-panel',
                    exportAs: 'NxExpansionPanelComponent',
                    template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [nxAccordionAnimations.bodyExpansion],
                    host: {
                        '[class.nx-expanded]': 'expanded',
                        '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
                        '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
                        '[class.nx-expansion-panel--negative]': 'negative'
                    },
                    providers: [
                        // Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
                        // to the same accordion.
                        { provide: NxAccordionDirective, useValue: ɵ0 },
                    ],
                    styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;line-height:24px;padding:24px 88px 32px 32px}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host:last-child ::ng-deep .nx-expansion-panel__header-content,:host:only-child ::ng-deep .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-content{border-top:1px solid #d9d9d9;border-bottom:none}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__body{padding-top:0}:host(.nx-expansion-panel--light):first-child ::ng-deep .nx-expansion-panel__header-content{border-top:none}"]
                }] }
    ];
    /** @nocollapse */
    NxExpansionPanelComponent.ctorParameters = function () { return [
        { type: NxAccordionDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: ChangeDetectorRef },
        { type: UniqueSelectionDispatcher },
        { type: ViewContainerRef }
    ]; };
    NxExpansionPanelComponent.propDecorators = {
        negative: [{ type: Input }],
        style: [{ type: Input, args: ['nxStyle',] }],
        lazyContent: [{ type: ContentChild, args: [NxExpansionPanelBodyDirective,] }]
    };
    return NxExpansionPanelComponent;
}(CdkAccordionItem));
export { NxExpansionPanelComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._negative;
    /** @type {?} */
    NxExpansionPanelComponent.prototype._accordionStyle;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._style;
    /**
     * \@docs-private
     * @type {?}
     */
    NxExpansionPanelComponent.prototype.lazyContent;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._portal;
    /**
     * \@docs-private
     * @type {?}
     */
    NxExpansionPanelComponent.prototype.accordion;
    /** @type {?} */
    NxExpansionPanelComponent.prototype._headerId;
    /**
     * Stream that emits for changes in `\@Input` properties.
     * @type {?}
     */
    NxExpansionPanelComponent.prototype._inputChanges;
    /**
     * @type {?}
     * @private
     */
    NxExpansionPanelComponent.prototype._viewContainerRef;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5zaW9uLXBhbmVsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJhY2NvcmRpb24vZXhwYW5zaW9uLXBhbmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUdMLFFBQVEsRUFFUixRQUFRLEVBQ1IsZ0JBQWdCLEVBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFekQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQy9ELE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztJQUcxRCxNQUFNLEdBQUcsQ0FBQzs7SUFJUixZQUFZLEdBQUcsU0FBUztTQWtCaUIsU0FBUztBQWhCeEQ7SUFtQitDLHFEQUFnQjtJQStDN0QsbUNBQW9DLFNBQStCLEVBQ2pFLGtCQUFxQyxFQUNyQyxvQkFBK0MsRUFDdkMsaUJBQW1DO1FBSDdDLFlBS0Usa0JBQU0sU0FBUyxFQUFFLGtCQUFrQixFQUFFLG9CQUFvQixDQUFDLFNBRTNEO1FBSlMsdUJBQWlCLEdBQWpCLGlCQUFp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Q0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQzNDLENBQUM7O2dCQWhIRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsNFhBQW1DO29CQUVuQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsVUFBVSxFQUFFLENBQUMscUJBQXFCLENBQUMsYUFBYSxDQUFDO29CQUNqRCxJQUFJLEVBQUU7d0JBQ0oscUJBQXFCLEVBQUUsVUFBVTt3QkFDakMsbUNBQW1DLEVBQUUsNkJBQTZCO3dCQUNsRSxxQ0FBcUMsRUFBRSwrQkFBK0I7d0JBQ3RFLHNDQUFzQyxFQUFFLFVBQVU7cUJBQ25EO29CQUNELFNBQVMsRUFBRTt3QkFDVCxnR0FBZ0c7d0JBQ2hHLHlCQUF5Qjt3QkFDekIsRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxJQUFXLEVBQUU7cUJBQ3ZEOztpQkFDRjs7OztnQkE5QlEsb0JBQW9CLHVCQThFZCxRQUFRLFlBQUksUUFBUTtnQkE1RmpDLGlCQUFpQjtnQkFMVix5QkFBeUI7Z0JBY2hDLGdCQUFnQjs7OzJCQXNDZixLQUFLO3dCQWNMLEtBQUssU0FBQyxTQUFTOzhCQWVmLFlBQVksU0FBQyw2QkFBNkI7O0lBK0Q3QyxnQ0FBQztDQUFBLEFBakhELENBbUIrQyxnQkFBZ0IsR0E4RjlEO1NBOUZZLHlCQUF5Qjs7Ozs7O0lBU3BDLDhDQUFrQzs7SUFDbEMsb0RBQStDOzs7OztJQWtCL0MsMkNBQXNDOzs7OztJQUd0QyxnREFBeUQ7Ozs7O0lBRXpELDRDQUFnQzs7Ozs7SUFRaEMsOENBQWdDOztJQUNoQyw4Q0FBb0Q7Ozs7O0lBR3BELGtEQUFzRDs7Ozs7SUFLcEQsc0RBQTJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrQWNjb3JkaW9uSXRlbSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hY2NvcmRpb24nO1xuaW1wb3J0IHsgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgU2tpcFNlbGYsXG4gIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHN0YXJ0V2l0aCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhBY2NvcmRpb25EaXJlY3RpdmUgfSBmcm9tICcuL2FjY29yZGlvbic7XG5pbXBvcnQgeyBueEFjY29yZGlvbkFuaW1hdGlvbnMgfSBmcm9tICcuL2FjY29yZGlvbi1hbmltYXRpb25zJztcbmltcG9ydCB7IE54RXhwYW5zaW9uUGFuZWxCb2R5RGlyZWN0aXZlIH0gZnJvbSAnLi9leHBhbnNpb24tcGFuZWwtYm9keSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuXG5cbmxldCBuZXh0SWQgPSAwO1xuXG4vKiogVGhlIHN0eWxpbmcgb2YgdGhlIGFjY29yZGlvbi4gKi9cbmV4cG9ydCB0eXBlIEFjY29yZGlvblN0eWxlID0gJ3JlZ3VsYXInIHwgJ2xpZ2h0JztcbmNvbnN0IERFRkFVTFRfVFlQRSA9ICdyZWd1bGFyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtZXhwYW5zaW9uLXBhbmVsJyxcbiAgZXhwb3J0QXM6ICdOeEV4cGFuc2lvblBhbmVsQ29tcG9uZW50JyxcbiAgdGVtcGxhdGVVcmw6ICdleHBhbnNpb24tcGFuZWwuaHRtbCcsXG4gIHN0eWxlVXJsczogWydleHBhbnNpb24tcGFuZWwuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgYW5pbWF0aW9uczogW254QWNjb3JkaW9uQW5pbWF0aW9ucy5ib2R5RXhwYW5zaW9uXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MubngtZXhwYW5kZWRdJzogJ2V4cGFuZGVkJyxcbiAgICAnW2NsYXNzLm54LWV4cGFuc2lvbi1wYW5lbC0tbGlnaHRdJzogJ19hY2NvcmRpb25TdHlsZSA9PT0gXCJsaWdodFwiJyxcbiAgICAnW2NsYXNzLm54LWV4cGFuc2lvbi1wYW5lbC0tcmVndWxhcl0nOiAnX2FjY29yZGlvblN0eWxlID09PSBcInJlZ3VsYXJcIicsXG4gICAgJ1tjbGFzcy5ueC1leHBhbnNpb24tcGFuZWwtLW5lZ2F0aXZlXSc6ICduZWdhdGl2ZSdcbiAgfSxcbiAgcHJvdmlkZXJzOiBbXG4gICAgLy8gUHJvdmlkZSBOeEFjY29yZGlvbkRpcmVjdGl2ZSBhcyB1bmRlZmluZWQgdG8gcHJldmVudCBuZXN0ZWQgZXhwYW5zaW9uIHBhbmVscyBmcm9tIHJlZ2lzdGVyaW5nXG4gICAgLy8gdG8gdGhlIHNhbWUgYWNjb3JkaW9uLlxuICAgIHsgcHJvdmlkZTogTnhBY2NvcmRpb25EaXJlY3RpdmUsIHVzZVZhbHVlOiB1bmRlZmluZWQgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTnhFeHBhbnNpb25QYW5lbENvbXBvbmVudCBleHRlbmRzIENka0FjY29yZGlvbkl0ZW0gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIC8qKiBXaGV0aGVyIHRoZSBuZWdhdGl2ZSBzZXQgb2Ygc3R5bGVzIHNob3VsZCBiZSB1c2VkLiAqL1xuICBASW5wdXQoKVxuICBzZXQgbmVnYXRpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uZWdhdGl2ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IG5lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZTtcbiAgfVxuICBwcml2YXRlIF9uZWdhdGl2ZTogYm9vbGVhbiA9IG51bGw7XG4gIF9hY2NvcmRpb25TdHlsZTogQWNjb3JkaW9uU3R5bGUgPSBERUZBVUxUX1RZUEU7XG5cbiAgLyoqXG4gICAqIFZhbHVlIGZvciB0aGUgc3R5bGluZyB0aGF0IHNob3VsZCBiZSBjaG9zZW4uXG4gICAqIERlZmF1bHQgdmFsdWU6ICdyZWd1bGFyJy5cbiAgICovXG4gIEBJbnB1dCgnbnhTdHlsZScpXG4gIHNldCBzdHlsZSh2YWx1ZTogQWNjb3JkaW9uU3R5bGUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBERUZBVUxUX1RZUEU7XG5cbiAgICBjb25zdCBbbmV3VmFsdWVdID0gdmFsdWUubWF0Y2goL3JlZ3VsYXJ8bGlnaHQvKSB8fCBbREVGQVVMVF9UWVBFXTtcbiAgICB0aGlzLl9zdHlsZSA9IG5ld1ZhbHVlIGFzIEFjY29yZGlvblN0eWxlO1xuICAgIHRoaXMuX2FjY29yZGlvblN0eWxlID0gbmV3VmFsdWUgYXMgQWNjb3JkaW9uU3R5bGU7XG4gIH1cblxuICBnZXQgc3R5bGUoKTogQWNjb3JkaW9uU3R5bGUge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxuICBwcml2YXRlIF9zdHlsZTogQWNjb3JkaW9uU3R5bGUgPSBudWxsO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGQoTnhFeHBhbnNpb25QYW5lbEJvZHlEaXJlY3RpdmUpIGxhenlDb250ZW50O1xuXG4gIHByaXZhdGUgX3BvcnRhbDogVGVtcGxhdGVQb3J0YWw7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IHBvcnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydGFsO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgYWNjb3JkaW9uOiBOeEFjY29yZGlvbkRpcmVjdGl2ZTtcbiAgX2hlYWRlcklkID0gYG54LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXItJHtuZXh0SWQrK31gO1xuXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyBmb3IgY2hhbmdlcyBpbiBgQElucHV0YCBwcm9wZXJ0aWVzLiAqL1xuICByZWFkb25seSBfaW5wdXRDaGFuZ2VzID0gbmV3IFN1YmplY3Q8U2ltcGxlQ2hhbmdlcz4oKTtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBhY2NvcmRpb246IE54QWNjb3JkaW9uRGlyZWN0aXZlLFxuICAgIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgX2V4cGFuc2lvbkRpc3BhdGNoZXI6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZlxuICApIHtcbiAgICBzdXBlcihhY2NvcmRpb24sIF9jaGFuZ2VEZXRlY3RvclJlZiwgX2V4cGFuc2lvbkRpc3BhdGNoZXIpO1xuICAgIHRoaXMuYWNjb3JkaW9uID0gYWNjb3JkaW9uO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICh0aGlzLmxhenlDb250ZW50KSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGNvbnRlbnQgYXMgc29vbiBhcyB0aGUgcGFuZWwgYmVjb21lcyBvcGVuLlxuICAgICAgdGhpcy5vcGVuZWQucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKG51bGwpLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5leHBhbmRlZCAmJiAhdGhpcy5fcG9ydGFsKSxcbiAgICAgICAgdGFrZSgxKVxuICAgICAgKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5sYXp5Q29udGVudC5fdGVtcGxhdGUsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdCBhcHBlYXJhbmNlIGdpdmVuIGJ5IHRoZSBhY2NvcmRpb24gKGlmIGFueSkuXG4gICAgaWYgKEJvb2xlYW4odGhpcy5hY2NvcmRpb24pKSB7XG5cbiAgICAgIGlmICh0aGlzLnN0eWxlID09PSBudWxsICYmIHRoaXMuYWNjb3JkaW9uLnN0eWxlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmFjY29yZGlvbi5zdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IG51bGwgJiYgdGhpcy5hY2NvcmRpb24ubmVnYXRpdmUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHRoaXMuYWNjb3JkaW9uLm5lZ2F0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICB0aGlzLl9pbnB1dENoYW5nZXMubmV4dChjaGFuZ2VzKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgdGhpcy5faW5wdXRDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXRPcGVuU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kZWQgPyAnb3BlbicgOiAnY2xvc2VkJztcbiAgfVxufVxuIl19