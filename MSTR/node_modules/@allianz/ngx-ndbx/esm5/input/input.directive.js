/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { getSupportedInputTypes } from '@angular/cdk/platform';
import { Inject, Directive, ElementRef, Input, Optional, Self, InjectionToken } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { Subject } from 'rxjs';
import { NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
/** @type {?} */
export var NX_INPUT_VALUE_ACCESSOR = new InjectionToken('NX_INPUT_VALUE_ACCESSOR');
/** @type {?} */
var INVALID_TYPES = [
    'button',
    'checkbox',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
var ɵ0 = /**
 * @param {?} t
 * @return {?}
 */
function (t) { return getSupportedInputTypes().has(t); };
/** @type {?} */
var NEVER_EMPTY = [
    'date',
    'datetime',
    'datetime-local',
    'month',
    'time',
    'week'
].filter((ɵ0));
/** @type {?} */
var nextUniqueId = 0;
var NxInputDirective = /** @class */ (function () {
    function NxInputDirective(_elementRef, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor) {
        this._elementRef = _elementRef;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._errorStateMatcher = _errorStateMatcher;
        this._type = 'text';
        this._uid = "nx-input-" + nextUniqueId++;
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * \@docs-private
         */
        this.stateChanges = new Subject();
        /**
         * \@docs-private
         */
        this.focused = false;
        this.id = this.id;
        // This will enable other directives to plugin itself as the value accessor
        // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
        // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
        // See the datefield for details.
        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
        this._previousNativeValue = this.value;
    }
    Object.defineProperty(NxInputDirective.prototype, "id", {
        /** The id of the input. */
        get: /**
         * The id of the input.
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value || this._uid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "value", {
        /** The input element's value. */
        get: /**
         * The input element's value.
         * @return {?}
         */
        function () { return this._inputValueAccessor.value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this.value) {
                this._inputValueAccessor.value = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "readonly", {
        /** Whether the element is readonly. */
        get: /**
         * Whether the element is readonly.
         * @return {?}
         */
        function () { return this._readonly; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._readonly = coerceBooleanProperty(value);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "disabled", {
        /** Whether the input is disabled. */
        get: /**
         * Whether the input is disabled.
         * @return {?}
         */
        function () {
            if (this.ngControl && this.ngControl.disabled !== null) {
                return this.ngControl.disabled;
            }
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
            // Browsers may not fire the blur event if the input is disabled too quickly.
            // Reset from here to ensure that the element doesn't become stuck.
            if (this.focused) {
                this.focused = false;
                this.stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "required", {
        /** Whether the element is required. */
        get: /**
         * Whether the element is required.
         * @return {?}
         */
        function () { return this._required; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._required = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "type", {
        /** Sets the type of the input element (e.g. password, text etc). */
        get: /**
         * Sets the type of the input element (e.g. password, text etc).
         * @return {?}
         */
        function () { return this._type; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._type = value || 'text';
            this._validateType();
            // When using Angular inputs, developers are no longer able to set the properties on the native
            // input element. To ensure that bindings for `type` work, we need to sync the setter
            // with the native property. Textarea elements don't support the type property or attribute.
            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
                this._elementRef.nativeElement.type = this._type;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxInputDirective.prototype, "elementRef", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NxInputDirective.prototype._onInput = /**
     * @return {?}
     */
    function () {
        // force to to run change detection so we know about changes in the native form input
    };
    /**
     * @param {?} isFocused
     * @return {?}
     */
    NxInputDirective.prototype._focusChanged = /**
     * @param {?} isFocused
     * @return {?}
     */
    function (isFocused) {
        if (isFocused !== this.focused && !this.readonly) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.stateChanges.next();
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stateChanges.complete();
    };
    /**
     * @return {?}
     */
    NxInputDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        else {
            // When the input isn't used together with `@angular/forms`, we need to check manually for
            // changes to the native `value` property in order to update the floating label.
            this._dirtyCheckNativeValue();
        }
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxInputDirective.prototype.updateErrorState = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldState = this.errorState;
        /** @type {?} */
        var parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        var control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        var newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    };
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     */
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     * @param {?} ids
     * @return {?}
     */
    NxInputDirective.prototype.setDescribedByIds = /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     * @param {?} ids
     * @return {?}
     */
    function (ids) {
        this._ariaDescribedby = ids.join(' ');
    };
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     */
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     * @param {?} value
     * @return {?}
     */
    NxInputDirective.prototype.setAriaLabel = 
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._ariaLabel = value;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isBadInput = /**
     * @protected
     * @return {?}
     */
    function () {
        // The `validity` property won't be present on platform-server.
        /** @type {?} */
        var validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;
        return validity && validity.badInput;
    };
    Object.defineProperty(NxInputDirective.prototype, "empty", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isNeverEmpty = /**
     * @protected
     * @return {?}
     */
    function () {
        return NEVER_EMPTY.indexOf(this._type) > -1;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._isTextarea = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nativeElement = this._elementRef.nativeElement;
        return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
    };
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._validateType = /**
     * @protected
     * @return {?}
     */
    function () {
        if (INVALID_TYPES.indexOf(this._type) > -1) {
            throw new Error("Input of type '" + this._type + "' is not supported");
        }
    };
    Object.defineProperty(NxInputDirective.prototype, "shouldLabelFloat", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.focused || !this.empty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    NxInputDirective.prototype._dirtyCheckNativeValue = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newValue = this.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    };
    NxInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                    host: {
                        '[class.c-input]': 'true',
                        '[attr.id]': 'id',
                        '[class.is-filled]': 'empty === false',
                        '[class.is-disabled]': 'disabled',
                        '[class.has-error]': 'errorState',
                        '[class.is-focused]': 'focused',
                        '[attr.aria-label]': '_ariaLabel || null',
                        '[attr.aria-describedby]': '_ariaDescribedby || null',
                        '[attr.aria-invalid]': 'errorState',
                        '[attr.aria-required]': 'required.toString()',
                        '(blur)': '_focusChanged(false)',
                        '(focus)': '_focusChanged(true)',
                        '(input)': '_onInput()',
                    },
                    providers: [{ provide: NxFormfieldControl, useExisting: NxInputDirective }],
                },] }
    ];
    /** @nocollapse */
    NxInputDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] },
        { type: ErrorStateMatcher },
        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NX_INPUT_VALUE_ACCESSOR,] }] }
    ]; };
    NxInputDirective.propDecorators = {
        _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
        id: [{ type: Input }],
        value: [{ type: Input }],
        readonly: [{ type: Input }],
        disabled: [{ type: Input }],
        required: [{ type: Input }],
        type: [{ type: Input }]
    };
    return NxInputDirective;
}());
export { NxInputDirective };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._type;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._id;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._uid;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._previousNativeValue;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._disabled;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._required;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._readonly;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._inputValueAccessor;
    /** @type {?} */
    NxInputDirective.prototype._ariaDescribedby;
    /** @type {?} */
    NxInputDirective.prototype._ariaLabel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.errorState;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.stateChanges;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.focused;
    /**
     * @type {?}
     * @protected
     */
    NxInputDirective.prototype._elementRef;
    /**
     * \@docs-private
     * @type {?}
     */
    NxInputDirective.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._parentFormGroup;
    /**
     * @type {?}
     * @private
     */
    NxInputDirective.prototype._errorStateMatcher;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvaW5wdXQvIiwic291cmNlcyI6WyJpbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFXLFVBQVUsRUFBRSxLQUFLLEVBQXdCLFFBQVEsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BJLE9BQU8sRUFBZSxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7QUFFNUQsTUFBTSxLQUFPLHVCQUF1QixHQUFHLElBQUksY0FBYyxDQUFlLHlCQUF5QixDQUFDOztJQUU1RixhQUFhLEdBQUc7SUFDcEIsUUFBUTtJQUNSLFVBQVU7SUFDVixNQUFNO0lBQ04sUUFBUTtJQUNSLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxRQUFRO0NBQ1Q7Ozs7O0FBU1EsVUFBQSxDQUFDLElBQUksT0FBQSxzQkFBc0IsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBL0IsQ0FBK0I7O0lBUHZDLFdBQVcsR0FBRztJQUNsQixNQUFNO0lBQ04sVUFBVTtJQUNWLGdCQUFnQjtJQUNoQixPQUFPO0lBQ1AsTUFBTTtJQUNOLE1BQU07Q0FDUCxDQUFDLE1BQU0sTUFBc0M7O0lBRTFDLFlBQVksR0FBRyxD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YUFBYTtxQkFZbkIsS0FBSzt3QkFTTCxLQUFLOzJCQVNMLEtBQUs7MkJBUUwsS0FBSzsyQkFtQkwsS0FBSzt1QkFLTCxLQUFLOztJQTZJUix1QkFBQztDQUFBLEFBMU9ELElBME9DO1NBdk5ZLGdCQUFnQjs7Ozs7O0lBQzNCLGlDQUF5Qjs7Ozs7SUFFekIsK0JBQXNCOzs7OztJQUN0QixnQ0FBOEM7Ozs7O0lBQzlDLGdEQUFvQzs7Ozs7SUFDcEMscUNBQTRCOzs7OztJQUM1QixxQ0FBNEI7Ozs7O0lBQzVCLHFDQUFtQzs7Ozs7SUFDbkMsK0NBQTBDOztJQUMxQyw0Q0FBZ0M7O0lBRWhDLHNDQUF5Qzs7Ozs7SUFHekMsc0NBQTRCOzs7OztJQUc1Qix3Q0FBbUM7Ozs7O0lBR25DLG1DQUFnQjs7Ozs7SUFvRWQsdUNBQWlDOzs7OztJQUVqQyxxQ0FBK0M7Ozs7O0lBQy9DLHVDQUF1Qzs7Ozs7SUFDdkMsNENBQXdEOzs7OztJQUN4RCw4Q0FBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBJbmplY3QsIERpcmVjdGl2ZSwgRG9DaGVjaywgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPcHRpb25hbCwgU2VsZiwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nQ29udHJvbCwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOeEZvcm1maWVsZENvbnRyb2wgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC9mb3JtZmllbGQnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjx7dmFsdWU6IGFueX0+KCdOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUicpO1xuXG5jb25zdCBJTlZBTElEX1RZUEVTID0gW1xuICAnYnV0dG9uJyxcbiAgJ2NoZWNrYm94JyxcbiAgJ2ZpbGUnLFxuICAnaGlkZGVuJyxcbiAgJ2ltYWdlJyxcbiAgJ3JhZGlvJyxcbiAgJ3JhbmdlJyxcbiAgJ3Jlc2V0JyxcbiAgJ3N1Ym1pdCdcbl07XG5cbmNvbnN0IE5FVkVSX0VNUFRZID0gW1xuICAnZGF0ZScsXG4gICdkYXRldGltZScsXG4gICdkYXRldGltZS1sb2NhbCcsXG4gICdtb250aCcsXG4gICd0aW1lJyxcbiAgJ3dlZWsnXG5dLmZpbHRlcih0ID0+IGdldFN1cHBvcnRlZElucHV0VHlwZXMoKS5oYXModCkpO1xuXG5sZXQgbmV4dFVuaXF1ZUlkID0gMDtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbbnhJbnB1dF0sIHRleHRhcmVhW254SW5wdXRdLCBzZWxlY3RbbnhJbnB1dF0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jLWlucHV0XSc6ICd0cnVlJyxcbiAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAnW2NsYXNzLmlzLWZpbGxlZF0nOiAnZW1wdHkgPT09IGZhbHNlJyxcbiAgICAnW2NsYXNzLmlzLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5oYXMtZXJyb3JdJzogJ2Vycm9yU3RhdGUnLFxuICAgICdbY2xhc3MuaXMtZm9jdXNlZF0nOiAnZm9jdXNlZCcsXG4gICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ19hcmlhTGFiZWwgfHwgbnVsbCcsXG4gICAgJ1thdHRyLmFyaWEtZGVzY3JpYmVkYnldJzogJ19hcmlhRGVzY3JpYmVkYnkgfHwgbnVsbCcsXG4gICAgJ1thdHRyLmFyaWEtaW52YWxpZF0nOiAnZXJyb3JTdGF0ZScsXG4gICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkLnRvU3RyaW5nKCknLFxuICAgICcoYmx1ciknOiAnX2ZvY3VzQ2hhbmdlZChmYWxzZSknLFxuICAgICcoZm9jdXMpJzogJ19mb2N1c0NoYW5nZWQodHJ1ZSknLFxuICAgICcoaW5wdXQpJzogJ19vbklucHV0KCknLFxuICB9LFxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogTnhGb3JtZmllbGRDb250cm9sLCB1c2VFeGlzdGluZzogTnhJbnB1dERpcmVjdGl2ZX1dLFxufSlcbmV4cG9ydCBjbGFzcyBOeElucHV0RGlyZWN0aXZlIGltcGxlbWVudHMgRG9DaGVjaywgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE54Rm9ybWZpZWxkQ29udHJvbDxhbnk+IHtcbiAgcHJvdGVjdGVkIF90eXBlID0gJ3RleHQnO1xuXG4gIHByb3RlY3RlZCBfaWQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIF91aWQgPSBgbngtaW5wdXQtJHtuZXh0VW5pcXVlSWQrK31gO1xuICBwcm90ZWN0ZWQgX3ByZXZpb3VzTmF0aXZlVmFsdWU6IGFueTtcbiAgcHJvdGVjdGVkIF9kaXNhYmxlZCA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgX3JlcXVpcmVkID0gZmFsc2U7XG4gIHByaXZhdGUgX3JlYWRvbmx5OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2lucHV0VmFsdWVBY2Nlc3Nvcjoge3ZhbHVlOiBhbnl9O1xuICBwdWJsaWMgX2FyaWFEZXNjcmliZWRieTogc3RyaW5nO1xuXG4gIEBJbnB1dCgnbnhBcmlhTGFiZWwnKSBfYXJpYUxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZXJyb3JTdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHN0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZm9jdXNlZCA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgaWQgb2YgdGhlIGlucHV0LiAqL1xuICBASW5wdXQoKVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5faWQgPSB2YWx1ZSB8fCB0aGlzLl91aWQ7XG4gIH1cblxuICAvKiogVGhlIGlucHV0IGVsZW1lbnQncyB2YWx1ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHZhbHVlKCk6IGFueSB7IHJldHVybiB0aGlzLl9pbnB1dFZhbHVlQWNjZXNzb3IudmFsdWU7IH1cbiAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMuX2lucHV0VmFsdWVBY2Nlc3Nvci52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHJlYWRvbmx5LiAqL1xuICBASW5wdXQoKVxuICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9yZWFkb25seTsgfVxuICBzZXQgcmVhZG9ubHkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZWFkb25seSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubmdDb250cm9sICYmIHRoaXMubmdDb250cm9sLmRpc2FibGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZ0NvbnRyb2wuZGlzYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG5cbiAgICAvLyBCcm93c2VycyBtYXkgbm90IGZpcmUgdGhlIGJsdXIgZXZlbnQgaWYgdGhlIGlucHV0IGlzIGRpc2FibGVkIHRvbyBxdWlja2x5LlxuICAgIC8vIFJlc2V0IGZyb20gaGVyZSB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBkb2Vzbid0IGJlY29tZSBzdHVjay5cbiAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyByZXF1aXJlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHJlcXVpcmVkKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH1cbiAgc2V0IHJlcXVpcmVkKHZhbHVlOiBhbnkpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgLyoqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGlucHV0IGVsZW1lbnQgKGUuZy4gcGFzc3dvcmQsIHRleHQgZXRjKS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90eXBlOyB9XG4gIHNldCB0eXBlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl90eXBlID0gdmFsdWUgfHwgJ3RleHQnO1xuICAgIHRoaXMuX3ZhbGlkYXRlVHlwZSgpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBBbmd1bGFyIGlucHV0cywgZGV2ZWxvcGVycyBhcmUgbm8gbG9uZ2VyIGFibGUgdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBuYXRpdmVcbiAgICAvLyBpbnB1dCBlbGVtZW50LiBUbyBlbnN1cmUgdGhhdCBiaW5kaW5ncyBmb3IgYHR5cGVgIHdvcmssIHdlIG5lZWQgdG8gc3luYyB0aGUgc2V0dGVyXG4gICAgLy8gd2l0aCB0aGUgbmF0aXZlIHByb3BlcnR5LiBUZXh0YXJlYSBlbGVtZW50cyBkb24ndCBzdXBwb3J0IHRoZSB0eXBlIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAgICBpZiAoIXRoaXMuX2lzVGV4dGFyZWEoKSAmJiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHRoaXMuX3R5cGUpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgQE9wdGlvbmFsKCkgQFNlbGYoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybTogTmdGb3JtLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlLFxuICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICBAT3B0aW9uYWwoKSBAU2VsZigpIEBJbmplY3QoTlhfSU5QVVRfVkFMVUVfQUNDRVNTT1IpIGlucHV0VmFsdWVBY2Nlc3NvcjogYW55XG4gICkge1xuICAgIHRoaXMuaWQgPSB0aGlzLmlkO1xuXG4gICAgLy8gVGhpcyB3aWxsIGVuYWJsZSBvdGhlciBkaXJlY3RpdmVzIHRvIHBsdWdpbiBpdHNlbGYgYXMgdGhlIHZhbHVlIGFjY2Vzc29yXG4gICAgLy8gYnkgdXNpbmcgdGhlIE5YX0lOUFVUX1ZBTFVFX0FDQ0VTU09SIFRva2VuLiBEZWZhdWx0IGlzIHRoZSBnaXZlbiBpbnB1dCBmaWVsZC5cbiAgICAvLyBUT0RPIGVsaW1pbmF0ZSBpbmplY3RlZCBkYXRlVmFsdWVBY2Nlc3NvciBvbmNlIHdlIGhhdmUgaW50cmEtcGFja2FnZSBzdXBwb3J0IGluIG5nLXBhY2thZ3JcbiAgICAvLyBTZWUgdGhlIGRhdGVmaWVsZCBmb3IgZGV0YWlscy5cbiAgICB0aGlzLl9pbnB1dFZhbHVlQWNjZXNzb3IgPSBpbnB1dFZhbHVlQWNjZXNzb3IgfHwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuX3ByZXZpb3VzTmF0aXZlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGVsZW1lbnRSZWYoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICBfb25JbnB1dCgpIHtcbiAgICAvLyBmb3JjZSB0byB0byBydW4gY2hhbmdlIGRldGVjdGlvbiBzbyB3ZSBrbm93IGFib3V0IGNoYW5nZXMgaW4gdGhlIG5hdGl2ZSBmb3JtIGlucHV0XG4gIH1cblxuICBfZm9jdXNDaGFuZ2VkKGlzRm9jdXNlZDogYm9vbGVhbikge1xuICAgIGlmIChpc0ZvY3VzZWQgIT09IHRoaXMuZm9jdXNlZCAmJiAhdGhpcy5yZWFkb25seSkge1xuICAgICAgdGhpcy5mb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJlLWV2YWx1YXRlIHRoaXMgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZVxuICAgICAgLy8gZXJyb3IgdHJpZ2dlcnMgdGhhdCB3ZSBjYW4ndCBzdWJzY3JpYmUgdG8gKGUuZy4gcGFyZW50IGZvcm0gc3VibWlzc2lvbnMpLiBUaGlzIG1lYW5zXG4gICAgICAvLyB0aGF0IHdoYXRldmVyIGxvZ2ljIGlzIGluIGhlcmUgaGFzIHRvIGJlIHN1cGVyIGxlYW4gb3Igd2UgcmlzayBkZXN0cm95aW5nIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgIHRoaXMudXBkYXRlRXJyb3JTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIHRoZSBpbnB1dCBpc24ndCB1c2VkIHRvZ2V0aGVyIHdpdGggYEBhbmd1bGFyL2Zvcm1zYCwgd2UgbmVlZCB0byBjaGVjayBtYW51YWxseSBmb3JcbiAgICAgIC8vIGNoYW5nZXMgdG8gdGhlIG5hdGl2ZSBgdmFsdWVgIHByb3BlcnR5IGluIG9yZGVyIHRvIHVwZGF0ZSB0aGUgZmxvYXRpbmcgbGFiZWwuXG4gICAgICB0aGlzLl9kaXJ0eUNoZWNrTmF0aXZlVmFsdWUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICB1cGRhdGVFcnJvclN0YXRlKCkge1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5lcnJvclN0YXRlO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLm5nQ29udHJvbCA/IHRoaXMubmdDb250cm9sLmNvbnRyb2wgYXMgRm9ybUNvbnRyb2wgOiBudWxsO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5fZXJyb3JTdGF0ZU1hdGNoZXIuaXNFcnJvclN0YXRlKGNvbnRyb2wsIHBhcmVudCk7XG5cbiAgICBpZiAobmV3U3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB0aGlzLmVycm9yU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbGlzdCBvZiBpZHMgdGhhdCBpcyBjdXJyZW50bHkgZGVzY3JpYmluZyB0aGlzIGlucHV0XG4gICAqIChpZiB5b3UgaGF2ZSBoaW50cyBhbmQgZXJyb3JzIGZvciBleGFtcGxlKS5cbiAgICovXG4gIHNldERlc2NyaWJlZEJ5SWRzKGlkczogc3RyaW5nW10pIHtcbiAgICB0aGlzLl9hcmlhRGVzY3JpYmVkYnkgPSBpZHMuam9pbignICcpO1xuICB9XG5cbiAgLy8gYWxsb3cgdG8gc2V0IGEgYXJpYWwgbGFiZWwgdmFsdWUgaW4gY2FzZSB0aGVyZVxuICAvLyBpcyBub3QgcG9zc2liaWxpdHkgdG8gZGlzcGxheSBhIHByb3BlciBsYWJlbFxuICAvKipcbiAgICogTWV0aG9kIHRvIHNldCB0aGUgYXJpYSBsYWJlbC5cbiAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB5b3UgdXNlIHRoZSBpbnB1dCBvdXRzaWRlIG9mIGEgZm9ybWZpZWxkXG4gICAqIHdoZXJlIHlvdSBkb24ndCBoYXZlIGEgbGFiZWwgY29ubmVjdGVkLlxuICAgKi9cbiAgc2V0QXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9hcmlhTGFiZWwgPSB2YWx1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNCYWRJbnB1dCgpIHtcbiAgICAvLyBUaGUgYHZhbGlkaXR5YCBwcm9wZXJ0eSB3b24ndCBiZSBwcmVzZW50IG9uIHBsYXRmb3JtLXNlcnZlci5cbiAgICBjb25zdCB2YWxpZGl0eSA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsaWRpdHk7XG4gICAgcmV0dXJuIHZhbGlkaXR5ICYmIHZhbGlkaXR5LmJhZElucHV0O1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGVtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5faXNOZXZlckVtcHR5KCkgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSAmJiAhdGhpcy5faXNCYWRJbnB1dCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9pc05ldmVyRW1wdHkoKSB7XG4gICAgcmV0dXJuIE5FVkVSX0VNUFRZLmluZGV4T2YodGhpcy5fdHlwZSkgPiAtMTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNUZXh0YXJlYSgpIHtcbiAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIHJldHVybiBuYXRpdmVFbGVtZW50Lm5vZGVOYW1lID8gbmF0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dGFyZWEnIDogZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlVHlwZSgpIHtcbiAgICBpZiAoSU5WQUxJRF9UWVBFUy5pbmRleE9mKHRoaXMuX3R5cGUpID4gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgb2YgdHlwZSAnJHt0aGlzLl90eXBlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBzaG91bGRMYWJlbEZsb2F0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZvY3VzZWQgfHwgIXRoaXMuZW1wdHk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2RpcnR5Q2hlY2tOYXRpdmVWYWx1ZSgpIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAodGhpcy5fcHJldmlvdXNOYXRpdmVWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzTmF0aXZlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==