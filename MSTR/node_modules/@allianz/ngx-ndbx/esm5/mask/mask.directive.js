/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, ElementRef, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE, ZERO, NINE, NUMPAD_ZERO, NUMPAD_NINE, A, Z } from '@angular/cdk/keycodes';
/** @type {?} */
export var NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
/** @type {?} */
export var NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    function () { return NxMaskDirective; })),
    multi: true
};
var NxMaskDirective = /** @class */ (function () {
    function NxMaskDirective(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._position = null;
        this._validateMask = true;
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        function () { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
    }
    Object.defineProperty(NxMaskDirective.prototype, "mask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mask;
        },
        /** Sets the mask.  */
        set: /**
         * Sets the mask.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            if (value !== this._mask) {
                this._mask = value;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "separators", {
        get: /**
         * @return {?}
         */
        function () {
            return this._separators;
        },
        /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         */
        set: /**
         * Sets the keys that are recognized as separators.
         * Default separators: / ( ) . : - + , and space.
         * @param {?} values
         * @return {?}
         */
        function (values) {
            this._separators = values;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "dropSpecialCharacters", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropSpecialCharacters;
        },
        /** Whether the separators should be dropped in the control value accessor. */
        set: /**
         * Whether the separators should be dropped in the control value accessor.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._dropSpecialCharacters) {
                this._dropSpecialCharacters = newValue;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxMaskDirective.prototype, "validateMask", {
        get: /**
         * @return {?}
         */
        function () {
            return this._validateMask;
        },
        /** Whether the mask validation should be applied on the input. Default: true. */
        set: /**
         * Whether the mask validation should be applied on the input. Default: true.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var newValue = coerceBooleanProperty(value);
            if (newValue !== this._validateMask) {
                this._validateMask = newValue;
                this._validatorOnChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    /** Returns the unmasked value. */
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    NxMaskDirective.prototype.getUnmaskedValue = /**
     * Returns the unmasked value.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    };
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     */
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onKeydown = /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyCode = event.keyCode;
        /** @type {?} */
        var location = event.location;
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var currentValue = this._elementRef.nativeElement.value;
        // row of characters is selected: set cursor position to end of new entered character
        if (input.selectionStart !== input.selectionEnd) {
            /** @type {?} */
            var nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            /** @type {?} */
            var positionChange = this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this.mask[nextCharacterInMask])))
                ? this._calculateCursorShift(input.selectionStart)
                : 0;
            this._position = input.selectionStart + positionChange;
        }
        else if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            var backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            var lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            var selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            // if last character is deleted: only delete last character, do not trigger input event again
            // (here the separator would be added again)
            if (selectionAtLastCharacter) {
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                event.preventDefault();
                // do not delete a separator, only set cursor position
            }
            else if (this.isSeparator(lastCharacter)) {
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
                // for any other character: decrease cursor position by one.
                // the input is modified and will be validated in _onInputChange().
            }
            else {
                this._position = input.selectionStart - backspaceShift;
            }
        }
        else {
            this._position = input.selectionStart;
            /** @type {?} */
            var nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            if (this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this._mask[nextCharacterInMask])))) {
                // if mask is already filled up, do not allow any inputs
                if (currentValue.length === this.mask.length) {
                    input.setSelectionRange(nextCharacterInMask, nextCharacterInMask);
                    event.preventDefault();
                }
                else {
                    this._position = nextCharacterInMask + 1;
                }
            }
        }
    };
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     */
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    NxMaskDirective.prototype._calculateCursorShift = /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        /** @type {?} */
        var shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        var characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    NxMaskDirective.prototype._keyCodeIsNumber = /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    function (value, location) {
        return ((value >= ZERO && value <= NINE)
            || (location === 3 && value >= NUMPAD_ZERO && value <= NUMPAD_NINE));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype._keyCodeIsLetter = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (value >= A && value <= Z);
    };
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    NxMaskDirective.prototype._isKeyCodeAllowed = /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    function (value, location, maskedValue) {
        if ((maskedValue === '0' && this._keyCodeIsNumber(value, location))
            || (maskedValue === 'A' && (this._keyCodeIsNumber(value, location) || this._keyCodeIsLetter(value)))
            || (maskedValue === 'S' && this._keyCodeIsLetter(value))) {
            return true;
        }
        return false;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    NxMaskDirective.prototype._isStringAllowed = /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    function (value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onInputChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        this.updateValue(this.getMaskedString(input.value));
        if (this._position !== null) {
            input.setSelectionRange(this._position, this._position);
            this._position = null;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NxMaskDirective.prototype._onPaste = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var input = (/** @type {?} */ (event.target));
        /** @type {?} */
        var pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        var maskedString = this.getMaskedString(pastedData, input.selectionStart);
        this._position = input.selectionStart + maskedString.length;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._elementRef.nativeElement.value = value;
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    };
    /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    NxMaskDirective.prototype.getMaskedString = /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    function (inputValue, maskStartIndex) {
        if (maskStartIndex === void 0) { maskStartIndex = 0; }
        /** @type {?} */
        var formattedValue = '';
        /** @type {?} */
        var maskIndex = maskStartIndex;
        /** @type {?} */
        var inputIndex = 0;
        /** @type {?} */
        var carot = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                // shift for _position
                if (maskIndex === this._position + carot) {
                    carot++;
                }
                maskIndex++;
            }
        }
        if (carot > 0) {
            this._position = this._position + carot;
        }
        return formattedValue;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.isSeparator = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (this._separators.indexOf(value) !== -1);
    };
    // control value accessor
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    NxMaskDirective.prototype.writeValue = 
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            value = '';
        }
        this.updateValue(this.getMaskedString(value));
    };
    /**
     * @param {?} onChange
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnChange = /**
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._onChangeCallback = onChange;
    };
    /**
     * @param {?} onTouched
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnTouched = /**
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._onTouchedCallback = onTouched;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    NxMaskDirective.prototype.registerOnValidatorChange = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._validatorOnChange = fn;
    };
    /**
     * @return {?}
     */
    NxMaskDirective.prototype._validateFn = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        var maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    NxMaskDirective.prototype.validate = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        return this.validateMask ? this._validateFn() : null;
    };
    NxMaskDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[nxMask]',
                    host: {
                        '(input)': '_onInputChange($event)',
                        '(keydown)': '_onKeydown($event)',
                        '(paste)': '_onPaste($event)',
                        '(blur)': '_onTouchedCallback()'
                    },
                    exportAs: 'nxMaskDirective',
                    providers: [
                        NX_MASK_VALUE_ACCESSOR,
                        { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                        NX_MASK_VALIDATORS
                    ]
                },] }
    ];
    /** @nocollapse */
    NxMaskDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NxMaskDirective.propDecorators = {
        mask: [{ type: Input, args: ['nxMask',] }],
        separators: [{ type: Input }],
        dropSpecialCharacters: [{ type: Input }],
        validateMask: [{ type: Input }]
    };
    return NxMaskDirective;
}());
export { NxMaskDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._mask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._separators;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._dropSpecialCharacters;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._position;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validateMask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9tYXNrLyIsInNvdXJjZXMiOlsibWFzay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekUsT0FBTyxFQUVMLGlCQUFpQixFQUNqQixhQUFhLEVBRWQsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztBQUl0RyxNQUFNLEtBQU8sc0JBQXNCLEdBQVE7SUFDekMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsY0FBTSxPQUFBLGVBQWUsRUFBZixDQUFlLEVBQUM7SUFDOUMsS0FBSyxFQUFFLElBQUk7Q0FDWjs7QUFFRCxNQUFNLEtBQU8sa0JBQWtCLEdBQVE7SUFDckMsT0FBTyxFQUFFLGFBQWE7SUFDdEIsV0FBVyxFQUFFLFVBQVU7OztJQUFDLGNBQU0sT0FBQSxlQUFlLEVBQWYsQ0FBZSxFQUFDO0lBQzlDLEtBQUssRUFBRSxJQUFJO0NBQ1o7QUFFRDtJQW1GRSx5QkFDVSxXQUF1QjtRQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQWxFekIsZ0JBQVcsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxD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LENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUN2RCxDQUFDOztnQkE3VEYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxlQUFlO29CQUN6QixJQUFJLEVBQUU7d0JBQ0osU0FBUyxFQUFFLHdCQUF3Qjt3QkFDbkMsV0FBVyxFQUFFLG9CQUFvQjt3QkFDakMsU0FBUyxFQUFFLGtCQUFrQjt3QkFDN0IsUUFBUSxFQUFFLHNCQUFzQjtxQkFDakM7b0JBQ0QsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsU0FBUyxFQUFFO3dCQUNULHNCQUFzQjt3QkFDdEIsRUFBRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsV0FBVyxFQUFFLGVBQWUsRUFBRTt3QkFDbEUsa0JBQWtCO3FCQUNuQjtpQkFDRjs7OztnQkF4QzBCLFVBQVU7Ozt1QkFzRGxDLEtBQUssU0FBQyxRQUFROzZCQW1CZCxLQUFLO3dDQVdMLEtBQUs7K0JBYUwsS0FBSzs7SUF1UFIsc0JBQUM7Q0FBQSxBQTlURCxJQThUQztTQS9TWSxlQUFlOzs7Ozs7SUFFMUIsZ0NBQXNCOzs7OztJQUN0QixzQ0FBb0U7Ozs7O0lBQ3BFLGlEQUFnRDs7Ozs7SUFDaEQsb0NBQWlDOzs7OztJQUNqQyx3Q0FBc0M7Ozs7O0lBRXRDLDRDQUE0Qzs7Ozs7SUFDNUMsNkNBQXVDOzs7OztJQUN2Qyw2Q0FBdUM7Ozs7O0lBMkRyQyxzQ0FBK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgTkdfVkFMSURBVE9SUyxcbiAgVmFsaWRhdG9yXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2lucHV0JztcbmltcG9ydCB7IEJBQ0tTUEFDRSwgREVMRVRFLCBaRVJPLCBOSU5FLCBOVU1QQURfWkVSTywgTlVNUEFEX05JTkUsIEEsIFogfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuXG50eXBlIE1BU0tfVFlQRSA9ICcwJyB8ICdBJyB8ICdTJztcblxuZXhwb3J0IGNvbnN0IE5YX01BU0tfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE54TWFza0RpcmVjdGl2ZSksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5leHBvcnQgY29uc3QgTlhfTUFTS19WQUxJREFUT1JTOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE54TWFza0RpcmVjdGl2ZSksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpbnB1dFtueE1hc2tdJyxcbiAgaG9zdDoge1xuICAgICcoaW5wdXQpJzogJ19vbklucHV0Q2hhbmdlKCRldmVudCknLFxuICAgICcoa2V5ZG93biknOiAnX29uS2V5ZG93bigkZXZlbnQpJyxcbiAgICAnKHBhc3RlKSc6ICdfb25QYXN0ZSgkZXZlbnQpJyxcbiAgICAnKGJsdXIpJzogJ19vblRvdWNoZWRDYWxsYmFjaygpJ1xuICB9LFxuICBleHBvcnRBczogJ254TWFza0RpcmVjdGl2ZScsXG4gIHByb3ZpZGVyczogW1xuICAgIE5YX01BU0tfVkFMVUVfQUNDRVNTT1IsXG4gICAgeyBwcm92aWRlOiBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IE54TWFza0RpcmVjdGl2ZSB9LFxuICAgIE5YX01BU0tfVkFMSURBVE9SU1xuICBdXG59KVxuZXhwb3J0IGNsYXNzIE54TWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gIHByaXZhdGUgX21hc2s6IHN0cmluZztcbiAgcHJpdmF0ZSBfc2VwYXJhdG9ycyA9IFsnLycsICcoJywgJyknLCAnLicsICc6JywgJy0nLCAnICcsICcrJywgJywnXTtcbiAgcHJpdmF0ZSBfZHJvcFNwZWNpYWxDaGFyYWN0ZXJzOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXIgPSBudWxsO1xuICBwcml2YXRlIF92YWxpZGF0ZU1hc2s6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgX29uQ2hhbmdlQ2FsbGJhY2sgPSAoXzogYW55KSA9PiB7IH07XG4gIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrID0gKCkgPT4geyB9O1xuICBwcml2YXRlIF92YWxpZGF0b3JPbkNoYW5nZSA9ICgpID0+IHsgfTtcblxuICAvKiogU2V0cyB0aGUgbWFzay4gICovXG4gIEBJbnB1dCgnbnhNYXNrJylcbiAgc2V0IG1hc2sodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbWFzaykge1xuICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGdldCBtYXNrKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUga2V5cyB0aGF0IGFyZSByZWNvZ25pemVkIGFzIHNlcGFyYXRvcnMuXG4gICAqIERlZmF1bHQgc2VwYXJhdG9yczogLyAoICkgLiA6IC0gKyAsIGFuZCBzcGFjZS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBzZXBhcmF0b3JzKHZhbHVlczogc3RyaW5nW10pIHtcbiAgICB0aGlzLl9zZXBhcmF0b3JzID0gdmFsdWVzO1xuICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5nZXRNYXNrZWRTdHJpbmcodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuICBnZXQgc2VwYXJhdG9ycygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlcGFyYXRvcnM7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgc2VwYXJhdG9ycyBzaG91bGQgYmUgZHJvcHBlZCBpbiB0aGUgY29udHJvbCB2YWx1ZSBhY2Nlc3Nvci4gKi9cbiAgQElucHV0KClcbiAgc2V0IGRyb3BTcGVjaWFsQ2hhcmFjdGVycyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX2Ryb3BTcGVjaWFsQ2hhcmFjdGVycykge1xuICAgICAgdGhpcy5fZHJvcFNwZWNpYWxDaGFyYWN0ZXJzID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZ2V0TWFza2VkU3RyaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBnZXQgZHJvcFNwZWNpYWxDaGFyYWN0ZXJzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU3BlY2lhbENoYXJhY3RlcnM7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgbWFzayB2YWxpZGF0aW9uIHNob3VsZCBiZSBhcHBsaWVkIG9uIHRoZSBpbnB1dC4gRGVmYXVsdDogdHJ1ZS4gKi9cbiAgQElucHV0KClcbiAgc2V0IHZhbGlkYXRlTWFzayh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX3ZhbGlkYXRlTWFzaykge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXNrID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgdmFsaWRhdGVNYXNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZU1hc2s7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmXG4gICkgeyB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHVubWFza2VkIHZhbHVlLiAqL1xuICBnZXRVbm1hc2tlZFZhbHVlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdW5tYXNrZWRWYWx1ZSA9IHRoaXMuc2VwYXJhdG9ycy5yZWR1Y2UoZnVuY3Rpb24odW5tYXNrZWQsIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHVubWFza2VkLnNwbGl0KHNlcGFyYXRvcikuam9pbignJyk7XG4gICAgfSwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKTtcblxuICAgIHJldHVybiB1bm1hc2tlZFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMuX3Bvc2l0aW9uIGNhbiBiZSBzZXQgdG8gYSBuZXcgdmFsdWUgaW4gdGhpcyBmdW5jdGlvbjtcbiAgICogaXQgaXMgdXNlZCB0byBzZXQgdGhlIGN1cnNvciBwb3NpdGlvbiBhZnRlciBjaGVja2luZyB0aGUgbWFza2VkIGlucHV0IGluIF9vbklucHV0Q2hhbmdlKCkuXG4gICAqL1xuICBfb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgY29uc3QgbG9jYXRpb24gPSBldmVudC5sb2NhdGlvbjtcblxuICAgIGNvbnN0IGlucHV0OiBIVE1MSW5wdXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuXG4gICAgLy8gcm93IG9mIGNoYXJhY3RlcnMgaXMgc2VsZWN0ZWQ6IHNldCBjdXJzb3IgcG9zaXRpb24gdG8gZW5kIG9mIG5ldyBlbnRlcmVkIGNoYXJhY3RlclxuICAgIGlmIChpbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gaW5wdXQuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBsZXQgbmV4dENoYXJhY3RlckluTWFzayA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5fbWFza1tuZXh0Q2hhcmFjdGVySW5NYXNrXSkpIHtcbiAgICAgICAgbmV4dENoYXJhY3RlckluTWFzaysrO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB0aGlzLl9pc0tleUNvZGVBbGxvd2VkKGtleUNvZGUsIGxvY2F0aW9uLCB0aGlzLm1hc2tbbmV4dENoYXJhY3RlckluTWFza10gYXMgTUFTS19UWVBFKVxuICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fY2FsY3VsYXRlQ3Vyc29yU2hpZnQoaW5wdXQuc2VsZWN0aW9uU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBpbnB1dC5zZWxlY3Rpb25TdGFydCArIHBvc2l0aW9uQ2hhbmdlO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gQkFDS1NQQUNFIHx8IGtleUNvZGUgPT09IERFTEVURSkge1xuICAgICAgLy8gaWYgYmFja3NwYWNlIHByZXNzZWQsIGN1cnNvciBoYXMgdG8gbW92ZSBvbmUgY2hhcmFjdGVyIHRvIHN0YXJ0XG4gICAgICBjb25zdCBiYWNrc3BhY2VTaGlmdCA9IGtleUNvZGUgPT09IEJBQ0tTUEFDRSA/IDEgOiAwO1xuICAgICAgY29uc3QgbGFzdENoYXJhY3RlciA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoaW5wdXQuc2VsZWN0aW9uU3RhcnQgLSBiYWNrc3BhY2VTaGlmdCwgaW5wdXQuc2VsZWN0aW9uRW5kIC0gYmFja3NwYWNlU2hpZnQgKyAxKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkF0TGFzdENoYXJhY3RlciA9IChpbnB1dC5zZWxlY3Rpb25TdGFydCA9PT0gY3VycmVudFZhbHVlLmxlbmd0aCAtIDEgKyBiYWNrc3BhY2VTaGlmdCk7XG5cbiAgICAgIC8vIGlmIGxhc3QgY2hhcmFjdGVyIGlzIGRlbGV0ZWQ6IG9ubHkgZGVsZXRlIGxhc3QgY2hhcmFjdGVyLCBkbyBub3QgdHJpZ2dlciBpbnB1dCBldmVudCBhZ2FpblxuICAgICAgLy8gKGhlcmUgdGhlIHNlcGFyYXRvciB3b3VsZCBiZSBhZGRlZCBhZ2FpbilcbiAgICAgIGlmIChzZWxlY3Rpb25BdExhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIGN1cnJlbnRWYWx1ZS5sZW5ndGggLSAxKSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBkbyBub3QgZGVsZXRlIGEgc2VwYXJhdG9yLCBvbmx5IHNldCBjdXJzb3IgcG9zaXRpb25cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1NlcGFyYXRvcihsYXN0Q2hhcmFjdGVyKSkge1xuICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShpbnB1dC5zZWxlY3Rpb25TdGFydCAtIGJhY2tzcGFjZVNoaWZ0LCBpbnB1dC5zZWxlY3Rpb25FbmQgLSBiYWNrc3BhY2VTaGlmdCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBmb3IgYW55IG90aGVyIGNoYXJhY3RlcjogZGVjcmVhc2UgY3Vyc29yIHBvc2l0aW9uIGJ5IG9uZS5cbiAgICAgIC8vIHRoZSBpbnB1dCBpcyBtb2RpZmllZCBhbmQgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gX29uSW5wdXRDaGFuZ2UoKS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQgLSBiYWNrc3BhY2VTaGlmdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGxldCBuZXh0Q2hhcmFjdGVySW5NYXNrID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLl9tYXNrW25leHRDaGFyYWN0ZXJJbk1hc2tdKSkge1xuICAgICAgICBuZXh0Q2hhcmFjdGVySW5NYXNrKys7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc0tleUNvZGVBbGxvd2VkKGtleUNvZGUsIGxvY2F0aW9uLCB0aGlzLl9tYXNrW25leHRDaGFyYWN0ZXJJbk1hc2tdIGFzIE1BU0tfVFlQRSkpIHtcbiAgICAgICAgLy8gaWYgbWFzayBpcyBhbHJlYWR5IGZpbGxlZCB1cCwgZG8gbm90IGFsbG93IGFueSBpbnB1dHNcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZS5sZW5ndGggPT09IHRoaXMubWFzay5sZW5ndGgpIHtcbiAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShuZXh0Q2hhcmFjdGVySW5NYXNrLCBuZXh0Q2hhcmFjdGVySW5NYXNrKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV4dENoYXJhY3RlckluTWFzayArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIGEgbGV0dGVyIGlzIGVudGVyZWQgYXQgYHNlbGVjdGlvblN0YXJ0YCBwb3NpdGlvbiBpbiB0aGUgbWFzay5cbiAgICogVGhlcmUgYXJlIHR3byBjYXNlcyB0byBjb25zaWRlciAoJ3wnID0+IGN1cnNvciBwb3NpdGlvbiB3aGVyZSB0aGUgY2hhcmFjdGVyIGlzIGVudGVyZWQsIG1hc2s6IDAwOjAwOjAwKTpcbiAgICogLSBiZWZvcmUgdGhlIHNlcGFyYXRvcnMgdGhlcmUgaXMgc3BhY2UgZm9yIGVudGVyaW5nIHRoZSBsZXR0ZXI6ICcxMjozfDQ6NScgPT4gJzEyOjMwOnw0NSdcbiAgICogLSB0aGUgbGV0dGVyIGhhcyB0byBiZSBzaGlmdGVkIGFuZCBpcyBlbnRlcmVkIGFmdGVyIHRoZSBzZXBhcmF0b3JzOiAnMTI6MzR8OjUnID0+ICcxMjozNDowfDUnXG4gICAqL1xuICBwcml2YXRlIF9jYWxjdWxhdGVDdXJzb3JTaGlmdChwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIC8vIHRyYWNrcyBpZiB0aGUgZW50ZXJlZCBsZXR0ZXIgd2FzIGFscmVhZHkgcGxhY2VkIGluIHRoZSBjdXJyZW50IG1hc2tcbiAgICAvLyBhbmQgdGhlcmVmb3Igd2FzIGNvbnNpZGVyZWQgaW4gdGhlIGN1cnNvciBjYWxjdWxhdGlvbi5cbiAgICBsZXQgY2hhcmFjdGVyV2FzRW50ZXJlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1twb3NpdGlvbiArIHNoaWZ0XSkpIHtcbiAgICAgIHNoaWZ0Kys7XG4gICAgICBjaGFyYWN0ZXJXYXNFbnRlcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLm1hc2tbcG9zaXRpb24gKyBzaGlmdF0pKSB7XG4gICAgICBzaGlmdCsrO1xuICAgIH1cblxuICAgIGlmICghY2hhcmFjdGVyV2FzRW50ZXJlZCkge1xuICAgICAgc2hpZnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gc2hpZnQ7XG4gIH1cblxuICBwcml2YXRlIF9rZXlDb2RlSXNOdW1iZXIodmFsdWU6IG51bWJlciwgbG9jYXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoKHZhbHVlID49IFpFUk8gJiYgdmFsdWUgPD0gTklORSlcbiAgICAgICAgICAgfHwgKGxvY2F0aW9uID09PSAzICYmIHZhbHVlID49IE5VTVBBRF9aRVJPICYmIHZhbHVlIDw9IE5VTVBBRF9OSU5FKSk7XG4gIH1cblxuICBwcml2YXRlIF9rZXlDb2RlSXNMZXR0ZXIodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodmFsdWUgPj0gQSAmJiB2YWx1ZSA8PSBaKTtcbiAgfVxuXG4gIHByaXZhdGUgX2lzS2V5Q29kZUFsbG93ZWQodmFsdWU6IG51bWJlciwgbG9jYXRpb246IG51bWJlciwgbWFza2VkVmFsdWU6IE1BU0tfVFlQRSkge1xuICAgIGlmICgobWFza2VkVmFsdWUgPT09ICcwJyAmJiB0aGlzLl9rZXlDb2RlSXNOdW1iZXIodmFsdWUsIGxvY2F0aW9uKSlcbiAgICAgICAgfHwgKG1hc2tlZFZhbHVlID09PSAnQScgJiYgKHRoaXMuX2tleUNvZGVJc051bWJlcih2YWx1ZSwgbG9jYXRpb24pIHx8IHRoaXMuX2tleUNvZGVJc0xldHRlcih2YWx1ZSkpKVxuICAgICAgICB8fCAobWFza2VkVmFsdWUgPT09ICdTJyAmJiB0aGlzLl9rZXlDb2RlSXNMZXR0ZXIodmFsdWUpKSkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNTdHJpbmdBbGxvd2VkKHZhbHVlOiBzdHJpbmcsIG1hc2tlZFZhbHVlOiBNQVNLX1RZUEUpIHtcbiAgICBpZiAoKG1hc2tlZFZhbHVlID09PSAnMCcgJiYgL15bMC05XXsxfSQvLnRlc3QodmFsdWUpKVxuICAgICAgICAgIHx8IChtYXNrZWRWYWx1ZSA9PT0gJ0EnICYmIC9eW2EtekEtWjAtOV17MX0kLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICB8fCAobWFza2VkVmFsdWUgPT09ICdTJyAmJiAvXlthLXpBLVpdezF9JC8udGVzdCh2YWx1ZSkpKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfb25JbnB1dENoYW5nZShldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGlucHV0OiBIVE1MSW5wdXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyhpbnB1dC52YWx1ZSkpO1xuICAgIGlmICh0aGlzLl9wb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5fcG9zaXRpb24sIHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfb25QYXN0ZShldmVudDogQ2xpcGJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IHBhc3RlZERhdGEgPSAoZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCAoPGFueT4gd2luZG93KS5jbGlwYm9hcmREYXRhKS5nZXREYXRhKCd0ZXh0Jyk7XG4gICAgY29uc3QgbWFza2VkU3RyaW5nID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcocGFzdGVkRGF0YSwgaW5wdXQuc2VsZWN0aW9uU3RhcnQpO1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQgKyBtYXNrZWRTdHJpbmcubGVuZ3RoO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLmRyb3BTcGVjaWFsQ2hhcmFjdGVycykge1xuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy5nZXRVbm1hc2tlZFZhbHVlKCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWFza2VkU3RyaW5nKGlucHV0VmFsdWU6IHN0cmluZywgbWFza1N0YXJ0SW5kZXg6IG51bWJlciA9IDApOiBzdHJpbmcge1xuICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgIGxldCBtYXNrSW5kZXggPSBtYXNrU3RhcnRJbmRleDtcbiAgICBsZXQgaW5wdXRJbmRleCA9IDA7XG4gICAgbGV0IGNhcm90ID0gMDtcblxuICAgIC8vIGluc2VydCBpZiBuZXh0IGluIG1hc2sgaXMgc2VwYXJhdG9yXG4gICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW21hc2tJbmRleF0pKSB7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZSArPSB0aGlzLm1hc2tbbWFza0luZGV4XTtcbiAgICAgIG1hc2tJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChpbnB1dEluZGV4IDwgaW5wdXRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgIC8vIHRlc3QgaWYgbGV0dGVycyBhcmUgdmFsaWRcbiAgICAgIGlmICh0aGlzLl9pc1N0cmluZ0FsbG93ZWQoaW5wdXRWYWx1ZVtpbnB1dEluZGV4XSwgdGhpcy5tYXNrW21hc2tJbmRleF0gYXMgTUFTS19UWVBFKSkge1xuICAgICAgICBmb3JtYXR0ZWRWYWx1ZSArPSBpbnB1dFZhbHVlW2lucHV0SW5kZXhdO1xuICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICAgIG1hc2tJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBpbnNlcnQgaWYgbmV4dCBpbiBtYXNrIGlzIHNlcGFyYXRvclxuICAgICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW21hc2tJbmRleF0pKSB7XG4gICAgICAgIGZvcm1hdHRlZFZhbHVlICs9IHRoaXMubWFza1ttYXNrSW5kZXhdO1xuXG4gICAgICAgIC8vIHNoaWZ0IGZvciBfcG9zaXRpb25cbiAgICAgICAgaWYgKG1hc2tJbmRleCA9PT0gdGhpcy5fcG9zaXRpb24gKyBjYXJvdCkge1xuICAgICAgICAgIGNhcm90Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2Fyb3QgPiAwKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICsgY2Fyb3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1NlcGFyYXRvcih2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLl9zZXBhcmF0b3JzLmluZGV4T2YodmFsdWUpICE9PSAtMSk7XG4gIH1cblxuICAvLyBjb250cm9sIHZhbHVlIGFjY2Vzc29yXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5nZXRNYXNrZWRTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIF92YWxpZGF0ZUZuKCkge1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlLmxlbmd0aDtcbiAgICBjb25zdCBtYXNrTGVuZ3RoID0gdGhpcy5fbWFzay5sZW5ndGg7XG4gICAgaWYgKGlucHV0TGVuZ3RoICE9PSBtYXNrTGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBueE1hc2tMZW5ndGhFcnJvcjogeydsZW5ndGgnOiBtYXNrTGVuZ3RoLCAnYWN0dWFsJzogaW5wdXRMZW5ndGh9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNYXNrID8gdGhpcy5fdmFsaWRhdGVGbigpIDogbnVsbDtcbiAgfVxufVxuIl19