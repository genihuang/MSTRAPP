/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CdkStepper, CdkStepperNext, CdkStepperPrevious } from '@angular/cdk/stepper';
import { ChangeDetectorRef, Directive } from '@angular/core';
import { NxProgressStepperDirective } from './progress-stepper.component';
// tslint:disable:use-input-property-decorator
var NxStepperNextDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepperNextDirective, _super);
    function NxStepperNextDirective(_stepper, changeDetectorRef) {
        var _this = _super.call(this, _stepper) || this;
        _this.changeDetectorRef = changeDetectorRef;
        /**
         * \@docs-private
         */
        _this.disabled = false;
        return _this;
    }
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     */
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    NxStepperNextDirective.prototype.ngDoCheck = /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var stepper = (/** @type {?} */ (this._stepper));
        if (this.disabled !== !stepper.hasNext) {
            this.disabled = !stepper.hasNext;
            this.changeDetectorRef.markForCheck();
        }
    };
    NxStepperNextDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'button[nxStepperNext]',
                    host: {
                        '(click)': '_stepper.next()',
                        '[type]': 'type',
                        '[disabled]': 'disabled'
                    },
                    inputs: ['type'],
                    providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
                },] }
    ];
    /** @nocollapse */
    NxStepperNextDirective.ctorParameters = function () { return [
        { type: CdkStepper },
        { type: ChangeDetectorRef }
    ]; };
    return NxStepperNextDirective;
}(CdkStepperNext));
export { NxStepperNextDirective };
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxStepperNextDirective.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    NxStepperNextDirective.prototype.changeDetectorRef;
}
var NxStepperPreviousDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepperPreviousDirective, _super);
    function NxStepperPreviousDirective(_stepper, changeDetectorRef) {
        var _this = _super.call(this, _stepper) || this;
        _this.changeDetectorRef = changeDetectorRef;
        return _this;
    }
    NxStepperPreviousDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'button[nxStepperPrevious]',
                    host: {
                        '(click)': '_stepper.previous()',
                        '[type]': 'type',
                        '[disabled]': '!_stepper.hasPrevious'
                    },
                    inputs: ['type'],
                    providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
                },] }
    ];
    /** @nocollapse */
    NxStepperPreviousDirective.ctorParameters = function () { return [
        { type: CdkStepper },
        { type: ChangeDetectorRef }
    ]; };
    return NxStepperPreviousDirective;
}(CdkStepperPrevious));
export { NxStepperPreviousDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxStepperPreviousDirective.prototype.changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9ucy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3Byb2dyZXNzLXN0ZXBwZXIvIiwic291cmNlcyI6WyJidXR0b25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFtQixNQUFNLGVBQWUsQ0FBQztBQUU5RSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7QUFJMUU7SUFVNEMsa0RBQWM7SUFLeEQsZ0NBQVksUUFBb0IsRUFBVSxpQkFBb0M7UUFBOUUsWUFDRSxrQkFBTSxRQUFRLENBQUMsU0FDaEI7UUFGeUMsdUJBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjs7OztRQUY5RSxjQUFRLEdBQUcsS0FBSyxDQUFDOztJQUlqQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRzs7Ozs7Ozs7OztJQUNILDBDQUFTOzs7Ozs7Ozs7SUFBVDs7WUFDUSxPQUFPLEdBQUcsbUJBQUEsSUFBSSxDQUFDLFFBQVEsRUFBOEI7UUFDM0QsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUN0QyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUNqQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkM7SUFDSCxDQUFDOztnQkFqQ0YsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSx1QkFBdUI7b0JBQ2pDLElBQUksRUFBRTt3QkFDSixTQUFTLEVBQUUsaUJBQWlCO3dCQUM1QixRQUFRLEVBQUUsTUFBTTt3QkFDaEIsWUFBWSxFQUFFLFVBQVU7cUJBQ3pCO29CQUNELE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQztvQkFDaEIsU0FBUyxFQUFFLENBQUMsRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSwwQkFBMEIsRUFBQyxDQUFDO2lCQUM1RTs7OztnQkFoQlEsVUFBVTtnQkFDVixpQkFBaUI7O0lBd0MxQiw2QkFBQztDQUFBLEFBbENELENBVTRDLGNBQWMsR0F3QnpEO1NBeEJZLHNCQUFzQjs7Ozs7O0lBR2pDLDBDQUFpQjs7Ozs7SUFFaUIsbURBQTRDOztBQXFCaEY7SUFVZ0Qsc0RBQWtCO0lBQ2hFLG9DQUFZLFFBQW9CLEVBQVUsaUJBQW9DO1FBQTlFLFlBQ0Usa0JBQU0sUUFBUSxDQUFDLFNBQ2hCO1FBRnlDLHVCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7O0lBRTlFLENBQUM7O2dCQWJGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsMkJBQTJCO29CQUNyQyxJQUFJLEVBQUU7d0JBQ0osU0FBUyxFQUFFLHFCQUFxQjt3QkFDaEMsUUFBUSxFQUFFLE1BQU07d0JBQ2hCLFlBQVksRUFBRSx1QkFBdUI7cUJBQ3RDO29CQUNELE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQztvQkFDaEIsU0FBUyxFQUFFLENBQUMsRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSwwQkFBMEIsRUFBQyxDQUFDO2lCQUM1RTs7OztnQkFwRFEsVUFBVTtnQkFDVixpQkFBaUI7O0lBeUQxQixpQ0FBQztDQUFBLEFBZkQsQ0FVZ0Qsa0JBQWtCLEdBS2pFO1NBTFksMEJBQTBCOzs7Ozs7SUFDSCx1REFBNEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZGtTdGVwcGVyLCBDZGtTdGVwcGVyTmV4dCwgQ2RrU3RlcHBlclByZXZpb3VzIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3N0ZXBwZXInO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgRG9DaGVjaywgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9wcm9ncmVzcy1zdGVwcGVyLmNvbXBvbmVudCc7XG5cbi8vIHRzbGludDpkaXNhYmxlOnVzZS1pbnB1dC1wcm9wZXJ0eS1kZWNvcmF0b3JcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYnV0dG9uW254U3RlcHBlck5leHRdJyxcbiAgaG9zdDoge1xuICAgICcoY2xpY2spJzogJ19zdGVwcGVyLm5leHQoKScsXG4gICAgJ1t0eXBlXSc6ICd0eXBlJyxcbiAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCdcbiAgfSxcbiAgaW5wdXRzOiBbJ3R5cGUnXSxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IENka1N0ZXBwZXIsIHVzZUV4aXN0aW5nOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZX1dXG59KVxuZXhwb3J0IGNsYXNzIE54U3RlcHBlck5leHREaXJlY3RpdmUgZXh0ZW5kcyBDZGtTdGVwcGVyTmV4dCBpbXBsZW1lbnRzIERvQ2hlY2sge1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoX3N0ZXBwZXI6IENka1N0ZXBwZXIsIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgc3VwZXIoX3N0ZXBwZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGVkIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yIGFmdGVyIHN0ZXBwZXIgaW5pdC5cbiAgICogV2hlbiB0aGUgc3RlcHBlciBpbml0aWFsaXplcyB0aGUgZGlyZWN0aXZlIGlzIGNoZWNrZWQgZmlyc3QgYmVmb3JlXG4gICAqIHRoZSBzdGVwcGVyIGNhbiBjaGVjayBpdHMgY29udGVudCB0aHVzIGl0IGRvZXNuJ3Qga25vdyBhYm91dCBpdCdzIGNoaWxkcmVuIHlldFxuICAgKiBzbyBfc3RlcHBlci5oYXNOZXh0IHJldHVybnMgZmFsc2UgYW5kIGRpc2FibGVzIHRoZSBidXR0b25zLiBJbiB0aGUgc2FtZSBDRCBjeWNsZVxuICAgKiBhZnRlciB0aGUgc3RlcHBlciBoYXMgY2hlY2tlZCBpdHMgY29udGVudHMgdGhlIGJ1dHRvbiBuZWVkcyB0byBiZSBlbmFibGVkIHJlc3VsdGluZ1xuICAgKiBpbiB0aGUgZXJyb3IuXG4gICAqL1xuICBuZ0RvQ2hlY2soKSB7XG4gICAgY29uc3Qgc3RlcHBlciA9IHRoaXMuX3N0ZXBwZXIgYXMgTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmU7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgIT09ICFzdGVwcGVyLmhhc05leHQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhc3RlcHBlci5oYXNOZXh0O1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYnV0dG9uW254U3RlcHBlclByZXZpb3VzXScsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdfc3RlcHBlci5wcmV2aW91cygpJyxcbiAgICAnW3R5cGVdJzogJ3R5cGUnLFxuICAgICdbZGlzYWJsZWRdJzogJyFfc3RlcHBlci5oYXNQcmV2aW91cydcbiAgfSxcbiAgaW5wdXRzOiBbJ3R5cGUnXSxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IENka1N0ZXBwZXIsIHVzZUV4aXN0aW5nOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZX1dXG59KVxuZXhwb3J0IGNsYXNzIE54U3RlcHBlclByZXZpb3VzRGlyZWN0aXZlIGV4dGVuZHMgQ2RrU3RlcHBlclByZXZpb3VzIHtcbiAgY29uc3RydWN0b3IoX3N0ZXBwZXI6IENka1N0ZXBwZXIsIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgc3VwZXIoX3N0ZXBwZXIpO1xuICB9XG5cbn1cbiJdfQ==