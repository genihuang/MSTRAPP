/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CdkStep, CdkStepper } from '@angular/cdk/stepper';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, Input, QueryList, SkipSelf } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
// tslint:disable:use-input-property-decorator
// We need to reference steps in stepper and stepper in steps. To prevent circular depenedency errors
// Provide both components in a single file. Otherwise we would have to introduce interface/abstract classes
// shared between both implementations.
var NxStepComponent = /** @class */ (function (_super) {
    tslib_1.__extends(NxStepComponent, _super);
    function NxStepComponent(stepper, _errorStateMatcher) {
        var _this = _super.call(this, stepper) || this;
        _this._errorStateMatcher = _errorStateMatcher;
        return _this;
    }
    /** Custom error state matcher that checks for validity of the step form. */
    /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    NxStepComponent.prototype.isErrorState = /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        /** @type {?} */
        var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
        // Checks for the validity of a step form that is not submitted or touched,
        // e.g when the user directly clicks the "next" button or directly on the step
        /** @type {?} */
        var customErrorState = !!(control && control.invalid && this.interacted);
        return originalErrorState || customErrorState;
    };
    NxStepComponent.decorators = [
        { type: Component, args: [{
                    selector: 'nx-step',
                    template: "<ng-template><ng-content></ng-content></ng-template>\n",
                    exportAs: 'nxStep',
                    providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }],
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NxStepComponent.ctorParameters = function () { return [
        { type: NxProgressStepperDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                         * @return {?}
                         */
                        function () { return NxProgressStepperDirective; })),] }] },
        { type: ErrorStateMatcher, decorators: [{ type: SkipSelf }] }
    ]; };
    return NxStepComponent;
}(CdkStep));
export { NxStepComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._errorStateMatcher;
}
var NxProgressStepperDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NxProgressStepperDirective, _super);
    function NxProgressStepperDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._stepHeader = new QueryList();
        return _this;
    }
    /**
     * @return {?}
     */
    NxProgressStepperDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Mark the component for change detection whenever the content children query changes
        this._steps.changes
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        function () {
            _this._stateChanged();
        }));
    };
    Object.defineProperty(NxProgressStepperDirective.prototype, "hasPrevious", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this.selectedIndex - 1) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "hasNext", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return (this.selectedIndex + 1) < this.count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "count", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._steps ? this._steps.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "currentStep", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.count === 0 || this.selectedIndex === -1) {
                return null;
            }
            /** @type {?} */
            var steps = this._steps.toArray();
            return steps[this.selectedIndex];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "nextStep", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            if (this.selectedIndex + 1 >= this._steps.length) {
                return null;
            }
            else {
                return this._steps.toArray()[this.selectedIndex + 1];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "steps", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._steps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxProgressStepperDirective.prototype, "currentLabel", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var step = this.currentStep;
            /** @type {?} */
            var label = step.stepLabel || step.label;
            return "\n    " + this.currentStepLabel + " " + (this.selectedIndex + 1) + "/" + this.count + ": " + label + "\n    ";
        },
        enumerable: true,
        configurable: true
    });
    NxProgressStepperDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[nxProgressStepper]',
                    exportAs: 'nxProgressStepper',
                },] }
    ];
    NxProgressStepperDirective.propDecorators = {
        _steps: [{ type: ContentChildren, args: [NxStepComponent,] }],
        currentStepLabel: [{ type: Input }],
        title: [{ type: Input }]
    };
    return NxProgressStepperDirective;
}(CdkStepper));
export { NxProgressStepperDirective };
if (false) {
    /** @type {?} */
    NxProgressStepperDirective.prototype._steps;
    /** @type {?} */
    NxProgressStepperDirective.prototype._stepHeader;
    /**
     * Sets the label on the left side showing the current step label. Used for mobile viewports.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.currentStepLabel;
    /**
     * Sets the title to be rendered above the progress bar.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.title;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9wcm9ncmVzcy1zdGVwcGVyLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzNELE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULGVBQWUsRUFDZixTQUFTLEVBQ1QsVUFBVSxFQUNWLE1BQU0sRUFDTixLQUFLLEVBQ0wsU0FBUyxFQUNULFFBQVEsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7O0FBVTVEO0lBUXFDLDJDQUFPO0lBRTFDLHlCQUFrRSxPQUFtQyxFQUNqRixrQkFBcUM7UUFEekQsWUFFRSxrQkFBTSxPQUFPLENBQUMsU0FDZjtRQUZtQix3QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1COztJQUV6RCxDQUFDO0lBRUQsNEVBQTRFOzs7Ozs7O0lBQzVFLHNDQUFZOzs7Ozs7SUFBWixVQUFhLE9BQTJCLEVBQUUsSUFBd0M7O1lBQzFFLGtCQUFrQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQzs7OztZQUl4RSxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzFFLE9BQU8sa0JBQWtCLElBQUksZ0JBQWdCLENBQUM7SUFDaEQsQ0FBQzs7Z0JBdkJGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsU0FBUztvQkFDbkIsa0VBQThDO29CQUM5QyxR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SSxDQUFDLEtBQUssVUFBSyxLQUFLLFdBQ3hFLENBQUM7UUFDSixDQUFDOzs7T0FBQTs7Z0JBdkVGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUscUJBQXFCO29CQUMvQixRQUFRLEVBQUUsbUJBQW1CO2lCQUM5Qjs7O3lCQUlFLGVBQWUsU0FBQyxlQUFlO21DQUkvQixLQUFLO3dCQUVMLEtBQUs7O0lBMkRSLGlDQUFDO0NBQUEsQUF4RUQsQ0FJZ0QsVUFBVSxHQW9FekQ7U0FwRVksMEJBQTBCOzs7SUFHckMsNENBQXFFOztJQUNyRSxpREFBK0M7Ozs7O0lBRy9DLHNEQUFrQzs7Ozs7SUFFbEMsMkNBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrU3RlcCwgQ2RrU3RlcHBlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBRdWVyeUxpc3QsXG4gIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbi8vIHRzbGludDpkaXNhYmxlOnVzZS1pbnB1dC1wcm9wZXJ0eS1kZWNvcmF0b3JcblxuXG4vLyBXZSBuZWVkIHRvIHJlZmVyZW5jZSBzdGVwcyBpbiBzdGVwcGVyIGFuZCBzdGVwcGVyIGluIHN0ZXBzLiBUbyBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZWRlbmN5IGVycm9yc1xuLy8gUHJvdmlkZSBib3RoIGNvbXBvbmVudHMgaW4gYSBzaW5nbGUgZmlsZS4gT3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gaW50cm9kdWNlIGludGVyZmFjZS9hYnN0cmFjdCBjbGFzc2VzXG4vLyBzaGFyZWQgYmV0d2VlbiBib3RoIGltcGxlbWVudGF0aW9ucy5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtc3RlcCcsXG4gIHRlbXBsYXRlVXJsOiAncHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuaHRtbCcsXG4gIGV4cG9ydEFzOiAnbnhTdGVwJyxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IEVycm9yU3RhdGVNYXRjaGVyLCB1c2VFeGlzdGluZzogTnhTdGVwQ29tcG9uZW50fV0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTnhTdGVwQ29tcG9uZW50IGV4dGVuZHMgQ2RrU3RlcCBpbXBsZW1lbnRzIEVycm9yU3RhdGVNYXRjaGVyIHtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUpKSBzdGVwcGVyOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSxcbiAgQFNraXBTZWxmKCkgcHJpdmF0ZSBfZXJyb3JTdGF0ZU1hdGNoZXI6IEVycm9yU3RhdGVNYXRjaGVyKSB7XG4gICAgc3VwZXIoc3RlcHBlcik7XG4gIH1cblxuICAvKiogQ3VzdG9tIGVycm9yIHN0YXRlIG1hdGNoZXIgdGhhdCBjaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBzdGVwIGZvcm0uICovXG4gIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICBjb25zdCBvcmlnaW5hbEVycm9yU3RhdGUgPSB0aGlzLl9lcnJvclN0YXRlTWF0Y2hlci5pc0Vycm9yU3RhdGUoY29udHJvbCwgZm9ybSk7XG5cbiAgICAvLyBDaGVja3MgZm9yIHRoZSB2YWxpZGl0eSBvZiBhIHN0ZXAgZm9ybSB0aGF0IGlzIG5vdCBzdWJtaXR0ZWQgb3IgdG91Y2hlZCxcbiAgICAvLyBlLmcgd2hlbiB0aGUgdXNlciBkaXJlY3RseSBjbGlja3MgdGhlIFwibmV4dFwiIGJ1dHRvbiBvciBkaXJlY3RseSBvbiB0aGUgc3RlcFxuICAgIGNvbnN0IGN1c3RvbUVycm9yU3RhdGUgPSAhIShjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZCAmJiB0aGlzLmludGVyYWN0ZWQpO1xuICAgIHJldHVybiBvcmlnaW5hbEVycm9yU3RhdGUgfHwgY3VzdG9tRXJyb3JTdGF0ZTtcbiAgfVxufVxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW254UHJvZ3Jlc3NTdGVwcGVyXScsXG4gIGV4cG9ydEFzOiAnbnhQcm9ncmVzc1N0ZXBwZXInLFxufSlcbmV4cG9ydCBjbGFzcyBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSBleHRlbmRzIENka1N0ZXBwZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLy8gRG8gbm90IGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSBRdWVyeUxpc3Qgb3IgdGhlIGhhc05leHQoKSBmdW5jdGlvbiBwcm9kdWNlc1xuICAvLyB3cm9uZyByZXN1bHRzIG9uIGluaXRcbiAgQENvbnRlbnRDaGlsZHJlbihOeFN0ZXBDb21wb25lbnQpIF9zdGVwczogUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD47XG4gIF9zdGVwSGVhZGVyOiBRdWVyeUxpc3Q8bnVsbD4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgLyoqIFNldHMgdGhlIGxhYmVsIG9uIHRoZSBsZWZ0IHNpZGUgc2hvd2luZyB0aGUgY3VycmVudCBzdGVwIGxhYmVsLiBVc2VkIGZvciBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKSBjdXJyZW50U3RlcExhYmVsOiBzdHJpbmc7XG4gIC8qKiBTZXRzIHRoZSB0aXRsZSB0byBiZSByZW5kZXJlZCBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgZm9yIGNoYW5nZSBkZXRlY3Rpb24gd2hlbmV2ZXIgdGhlIGNvbnRlbnQgY2hpbGRyZW4gcXVlcnkgY2hhbmdlc1xuICAgIHRoaXMuX3N0ZXBzLmNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlZCgpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzUHJldmlvdXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggLSAxKSA+PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSA8IHRoaXMuY291bnQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzID8gdGhpcy5fc3RlcHMubGVuZ3RoIDogMDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBjdXJyZW50U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuX3N0ZXBzLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gc3RlcHNbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBuZXh0U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ICsgMSA+PSB0aGlzLl9zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RlcHMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleCArIDFdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBzdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHM7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY3VycmVudExhYmVsKCkge1xuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmN1cnJlbnRTdGVwO1xuICAgIGNvbnN0IGxhYmVsID0gc3RlcC5zdGVwTGFiZWwgfHwgc3RlcC5sYWJlbDtcblxuICAgIHJldHVybiBgXG4gICAgJHt0aGlzLmN1cnJlbnRTdGVwTGFiZWx9ICR7dGhpcy5zZWxlY3RlZEluZGV4ICsgMX0vJHt0aGlzLmNvdW50fTogJHtsYWJlbH1cbiAgICBgO1xuICB9XG59XG5cbiJdfQ==