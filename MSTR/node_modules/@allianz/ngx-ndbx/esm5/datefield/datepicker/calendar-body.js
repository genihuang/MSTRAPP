/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, NgZone, } from '@angular/core';
import { take } from 'rxjs/operators';
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
var /**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
NxCalendarCell = /** @class */ (function () {
    function NxCalendarCell(value, displayValue, ariaLabel, enabled) {
        this.value = value;
        this.displayValue = displayValue;
        this.ariaLabel = ariaLabel;
        this.enabled = enabled;
    }
    return NxCalendarCell;
}());
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
export { NxCalendarCell };
if (false) {
    /** @type {?} */
    NxCalendarCell.prototype.value;
    /** @type {?} */
    NxCalendarCell.prototype.displayValue;
    /** @type {?} */
    NxCalendarCell.prototype.ariaLabel;
    /** @type {?} */
    NxCalendarCell.prototype.enabled;
}
/**
 * An internal component used to display calendar data in a table.
 * \@docs-private
 */
var NxCalendarBodyComponent = /** @class */ (function () {
    function NxCalendarBodyComponent(_elementRef, _ngZone) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        /**
         * The number of columns in the table.
         */
        this.numCols = 7;
        /**
         * Whether to allow selection of disabled cells.
         */
        this.allowDisabledSelection = false;
        /**
         * The cell number of the active cell in the table.
         */
        this.activeCell = 0;
        /**
         * The items to display in the first row in the offset space.
         */
        this.previousItems = [];
        /**
         * The items to display in the last row in the offset space.
         */
        this.followingItems = [[]];
        /**
         * Emits when a new value is selected.
         */
        this.selectedValueChange = new EventEmitter();
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    NxCalendarBodyComponent.prototype._cellClicked = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        if (!this.allowDisabledSelection && !cell.enabled) {
            return;
        }
        this.selectedValueChange.emit(cell.value);
    };
    Object.defineProperty(NxCalendarBodyComponent.prototype, "_firstRowOffset", {
        /** The number of blank cells to put at the beginning for the first row. */
        get: /**
         * The number of blank cells to put at the beginning for the first row.
         * @return {?}
         */
        function () {
            return this.rows && this.rows.length && this.rows[0].length ?
                this.numCols - this.rows[0].length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxCalendarBodyComponent.prototype, "_lastRowOffset", {
        /** The number of blank cells to put at the end of the last filled row. */
        get: /**
         * The number of blank cells to put at the end of the last filled row.
         * @return {?}
         */
        function () {
            return this.rows && this.rows.length && this.rows[this.rows.length - 1].length ?
                this.numCols - this.rows[this.rows.length - 1].length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxCalendarBodyComponent.prototype, "_lastRowIndex", {
        /** The index of the last row. */
        get: /**
         * The index of the last row.
         * @return {?}
         */
        function () {
            return this.rows && this.rows.length ?
                this.rows.length - 1 : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NxCalendarBodyComponent.prototype, "_followingRows", {
        /**
         * The following full rows to display and fill up the calendar.
         */
        get: /**
         * The following full rows to display and fill up the calendar.
         * @return {?}
         */
        function () {
            if (this.followingItems && this.followingItems.length) {
                // if first row is not a full row => display them in offset space
                if (this.followingItems[0].length < this.numCols) {
                    return this.followingItems.slice(1, this.followingItems.length);
                }
                return this.followingItems;
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    NxCalendarBodyComponent.prototype._isActiveCell = /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        /** @type {?} */
        var cellNumber = rowIndex * this.numCols + colIndex;
        // Account for the fact that the first row may not have as many cells.
        if (rowIndex) {
            cellNumber -= this._firstRowOffset;
        }
        return cellNumber === this.activeCell;
    };
    /** Focuses the active cell after the microtask queue is empty. */
    /**
     * Focuses the active cell after the microtask queue is empty.
     * @return {?}
     */
    NxCalendarBodyComponent.prototype._focusActiveCell = /**
     * Focuses the active cell after the microtask queue is empty.
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._elementRef.nativeElement.querySelector('.nx-calendar-body-active').focus();
            }));
        }));
    };
    NxCalendarBodyComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: '[nx-calendar-body]',
                    template: "<!-- Create the first and last row separately so we can include special spacer cells. -->\n<tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\">\n  <!--\n    We mark this cell as aria-hidden so it doesn't get read out as one of the days in the week.\n    The aspect ratio of the table cells is maintained by setting the top and bottom padding as a\n    percentage of the width (a variant of the trick described here:\n    https://www.w3schools.com/howto/howto_css_aspect_ratio.asp).\n  -->\n  <ng-container *ngIf=\"rowIndex === 0\">\n    <td *ngFor=\"let item of previousItems\"\n        aria-hidden=\"true\"\n        class=\"nx-calendar-adjacent-cell\">\n      <div aria-hidden=\"true\"\n           class=\"nx-calendar-adjacent-cell-content\">\n        {{ item.displayValue }}\n      </div>\n    </td>\n  </ng-container>\n\n  <td *ngFor=\"let item of row; let colIndex = index\"\n      role=\"gridcell\"\n      class=\"nx-calendar-body-cell\"\n      [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\"\n      [class.nx-calendar-body-disabled]=\"!item.enabled\"\n      [class.nx-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\n      [attr.aria-label]=\"item.ariaLabel\"\n      [attr.aria-disabled]=\"!item.enabled || null\"\n      (click)=\"_cellClicked(item)\"\n      [style.width.%]=\"100 / numCols\">\n    <div class=\"nx-calendar-body-cell-content\"\n         [class.nx-calendar-body-selected]=\"selectedValue === item.value\"\n         [class.nx-calendar-body-today]=\"todayValue === item.value\">\n      {{item.displayValue}}\n    </div>\n  </td>\n\n  <ng-container *ngIf=\"rowIndex === _lastRowIndex && _lastRowOffset\">\n    <td *ngFor=\"let item of followingItems[0]\"\n        aria-hidden=\"true\"\n        class=\"nx-calendar-adjacent-cell\">\n      <div aria-hidden=\"true\"\n           class=\"nx-calendar-adjacent-cell-content\">\n        {{ item.displayValue }}\n      </div>\n    </td>\n  </ng-container>\n\n</tr>\n\n<!-- \n  if there are still elements remaining in 'following-elements', then create some extra rows\n  to fill up the space\n-->\n<tr *ngFor=\"let row of _followingRows\"\n    aria-hidden=\"true\">\n  <td *ngFor=\"let item of row\"\n      class=\"nx-calendar-adjacent-cell\">\n    <div class=\"nx-calendar-adjacent-cell-content\">\n      {{ item.displayValue }}\n    </div>\n  </td>\n</tr>\n",
                    host: {
                        'class': 'nx-calendar-body',
                        'role': 'grid',
                        'attr.aria-readonly': 'true'
                    },
                    exportAs: 'nxCalendarBody',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".nx-calendar-adjacent-cell,.nx-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;vertical-align:text-bottom}.nx-calendar-body-cell{cursor:pointer}.nx-calendar-body-disabled{cursor:default}.nx-calendar-body-cell-content{display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:40px;height:40px;margin:0 auto;font-size:16px;font-weight:600;color:#414141;border-radius:50%;line-height:1;box-shadow:0 0 0 6px transparent}.nx-calendar-body-cell-content.nx-calendar-body-selected{background-color:#007ab3;color:#fff}.nx-calendar-body-disabled>.nx-calendar-body-cell-content:not(.nx-calendar-body-selected){color:#c2c2c2;font-weight:400}.nx-calendar-body-active:not(.nx-calendar-body-disabled)>.nx-calendar-body-cell-content:not(.nx-calendar-body-selected),:not(.nx-calendar-body-disabled):hover>.nx-calendar-body-cell-content:not(.nx-calendar-body-selected){background-color:#ececec;color:#414141}:host-context([data-whatinput=keyboard]) .nx-calendar-body-cell:focus .nx-calendar-body-cell-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]) .nx-calendar-body-cell:focus.nx-calendar-body-disabled .nx-calendar-body-cell-content{color:#c2c2c2}:host-context([data-whatinput=keyboard]) .nx-calendar-body-cell:focus .nx-calendar-body-cell-content:not(.nx-calendar-body-selected){background-color:#fff}.nx-calendar-adjacent-cell-content{display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:40px;height:40px;margin:0 auto;font-size:16px;font-weight:400;color:#c2c2c2;border-radius:50%;line-height:1}"]
                }] }
    ];
    /** @nocollapse */
    NxCalendarBodyComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    NxCalendarBodyComponent.propDecorators = {
        label: [{ type: Input }],
        rows: [{ type: Input }],
        todayValue: [{ type: Input }],
        selectedValue: [{ type: Input }],
        numCols: [{ type: Input }],
        allowDisabledSelection: [{ type: Input }],
        activeCell: [{ type: Input }],
        previousItems: [{ type: Input }],
        followingItems: [{ type: Input }],
        selectedValueChange: [{ type: Output }]
    };
    return NxCalendarBodyComponent;
}());
export { NxCalendarBodyComponent };
if (false) {
    /**
     * The label for the table. (e.g. "Jan 2017").
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.label;
    /**
     * The cells to display in the table.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.rows;
    /**
     * The value in the table that corresponds to today.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.todayValue;
    /**
     * The value in the table that is currently selected.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.selectedValue;
    /**
     * The number of columns in the table.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.numCols;
    /**
     * Whether to allow selection of disabled cells.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.allowDisabledSelection;
    /**
     * The cell number of the active cell in the table.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.activeCell;
    /**
     * The items to display in the first row in the offset space.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.previousItems;
    /**
     * The items to display in the last row in the offset space.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.followingItems;
    /**
     * Emits when a new value is selected.
     * @type {?}
     */
    NxCalendarBodyComponent.prototype.selectedValueChange;
    /**
     * @type {?}
     * @private
     */
    NxCalendarBodyComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxCalendarBodyComponent.prototype._ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItYm9keS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L2RhdGVmaWVsZC8iLCJzb3VyY2VzIjpbImRhdGVwaWNrZXIvY2FsZW5kYXItYm9keS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7OztBQU1wQzs7Ozs7SUFDRSx3QkFBbUIsS0FBYSxFQUNiLFlBQW9CLEVBQ3BCLFNBQWtCLEVBQ2xCLE9BQWlCO1FBSGpCLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUNwQixjQUFTLEdBQVQsU0FBUyxDQUFTO1FBQ2xCLFlBQU8sR0FBUCxPQUFPLENBQVU7SUFBRyxDQUFDO0lBQzFDLHFCQUFDO0FBQUQsQ0FBQyxBQUxELElBS0M7Ozs7Ozs7O0lBSmEsK0JBQW9COztJQUNwQixzQ0FBMkI7O0lBQzNCLG1DQUF5Qjs7SUFDekIsaUNBQXdCOzs7Ozs7QUFRdEM7SUE0Q0UsaUNBQW9CLFdBQXVCLEVBQVUsT0FBZTtRQUFoRCxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUFVLFlBQU8sR0FBUCxPQUFPLENBQVE7Ozs7UUFqQjNELFlBQU8sR0FBRyxDQUFDLENBQUM7Ozs7UUFHWiwyQkFBc0IsR0FBRyxLQUFLLENBQUM7Ozs7UUFHL0IsZUFBVSxHQUFHLENBQUMsQ0FBQzs7OztRQUdmLGtCQUFhLEdBQXFCLEVBQUUsQ0FBQzs7OztRQUdyQyxtQkFBYyxHQUF1QixDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7O1FBR2hDLHdCQUFtQixHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO0lBRWxCLENBQUM7Ozs7O0lBRXpFLDhD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bkYsQ0FBQyxFQUFDLENBQUM7UUFDTCxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7O2dCQXhHRixTQUFTLFNBQUM7O29CQUVULFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLGcwRUFBaUM7b0JBRWpDLElBQUksRUFBRTt3QkFDSixPQUFPLEVBQUUsa0JBQWtCO3dCQUMzQixNQUFNLEVBQUUsTUFBTTt3QkFDZCxvQkFBb0IsRUFBRSxNQUFNO3FCQUM3QjtvQkFDRCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7aUJBQ2hEOzs7O2dCQXBDQyxVQUFVO2dCQUlWLE1BQU07Ozt3QkFtQ0wsS0FBSzt1QkFHTCxLQUFLOzZCQUdMLEtBQUs7Z0NBR0wsS0FBSzswQkFHTCxLQUFLO3lDQUdMLEtBQUs7NkJBR0wsS0FBSztnQ0FHTCxLQUFLO2lDQUdMLEtBQUs7c0NBR0wsTUFBTTs7SUErRFQsOEJBQUM7Q0FBQSxBQXpHRCxJQXlHQztTQTVGWSx1QkFBdUI7Ozs7OztJQUVsQyx3Q0FBdUI7Ozs7O0lBR3ZCLHVDQUFrQzs7Ozs7SUFHbEMsNkNBQTRCOzs7OztJQUc1QixnREFBK0I7Ozs7O0lBRy9CLDBDQUFxQjs7Ozs7SUFHckIseURBQXdDOzs7OztJQUd4Qyw2Q0FBd0I7Ozs7O0lBR3hCLGdEQUE4Qzs7Ozs7SUFHOUMsaURBQW1EOzs7OztJQUduRCxzREFBMEY7Ozs7O0lBRTlFLDhDQUErQjs7Ozs7SUFBRSwwQ0FBdUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBOZ1pvbmUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHt0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY2xhc3MgdGhhdCByZXByZXNlbnRzIHRoZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUgY2FsZW5kYXIgY2VsbC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIE54Q2FsZW5kYXJDZWxsIHtcbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBudW1iZXIsXG4gICAgICAgICAgICAgIHB1YmxpYyBkaXNwbGF5VmFsdWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgcHVibGljIGFyaWFMYWJlbD86IHN0cmluZyxcbiAgICAgICAgICAgICAgcHVibGljIGVuYWJsZWQ/OiBib29sZWFuKSB7fVxufVxuXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBjYWxlbmRhciBkYXRhIGluIGEgdGFibGUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnW254LWNhbGVuZGFyLWJvZHldJyxcbiAgdGVtcGxhdGVVcmw6ICdjYWxlbmRhci1ib2R5Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnY2FsZW5kYXItYm9keS5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbngtY2FsZW5kYXItYm9keScsXG4gICAgJ3JvbGUnOiAnZ3JpZCcsXG4gICAgJ2F0dHIuYXJpYS1yZWFkb25seSc6ICd0cnVlJ1xuICB9LFxuICBleHBvcnRBczogJ254Q2FsZW5kYXJCb2R5JyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE54Q2FsZW5kYXJCb2R5Q29tcG9uZW50IHtcbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhlIHRhYmxlLiAoZS5nLiBcIkphbiAyMDE3XCIpLiAqL1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgY2VsbHMgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUuICovXG4gIEBJbnB1dCgpIHJvd3M6IE54Q2FsZW5kYXJDZWxsW11bXTtcblxuICAvKiogVGhlIHZhbHVlIGluIHRoZSB0YWJsZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRvZGF5LiAqL1xuICBASW5wdXQoKSB0b2RheVZhbHVlOiBudW1iZXI7XG5cbiAgLyoqIFRoZSB2YWx1ZSBpbiB0aGUgdGFibGUgdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICovXG4gIEBJbnB1dCgpIHNlbGVjdGVkVmFsdWU6IG51bWJlcjtcblxuICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0YWJsZS4gKi9cbiAgQElucHV0KCkgbnVtQ29scyA9IDc7XG5cbiAgLyoqIFdoZXRoZXIgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRpc2FibGVkIGNlbGxzLiAqL1xuICBASW5wdXQoKSBhbGxvd0Rpc2FibGVkU2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgLyoqIFRoZSBjZWxsIG51bWJlciBvZiB0aGUgYWN0aXZlIGNlbGwgaW4gdGhlIHRhYmxlLiAqL1xuICBASW5wdXQoKSBhY3RpdmVDZWxsID0gMDtcblxuICAvKiogVGhlIGl0ZW1zIHRvIGRpc3BsYXkgaW4gdGhlIGZpcnN0IHJvdyBpbiB0aGUgb2Zmc2V0IHNwYWNlLiAqL1xuICBASW5wdXQoKSBwcmV2aW91c0l0ZW1zOiBOeENhbGVuZGFyQ2VsbFtdID0gW107XG5cbiAgLyoqIFRoZSBpdGVtcyB0byBkaXNwbGF5IGluIHRoZSBsYXN0IHJvdyBpbiB0aGUgb2Zmc2V0IHNwYWNlLiAqL1xuICBASW5wdXQoKSBmb2xsb3dpbmdJdGVtczogTnhDYWxlbmRhckNlbGxbXVtdID0gW1tdXTtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyB2YWx1ZSBpcyBzZWxlY3RlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkVmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIF9jZWxsQ2xpY2tlZChjZWxsOiBOeENhbGVuZGFyQ2VsbCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hbGxvd0Rpc2FibGVkU2VsZWN0aW9uICYmICFjZWxsLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZFZhbHVlQ2hhbmdlLmVtaXQoY2VsbC52YWx1ZSk7XG4gIH1cblxuICAvKiogVGhlIG51bWJlciBvZiBibGFuayBjZWxscyB0byBwdXQgYXQgdGhlIGJlZ2lubmluZyBmb3IgdGhlIGZpcnN0IHJvdy4gKi9cbiAgZ2V0IF9maXJzdFJvd09mZnNldCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJvd3MgJiYgdGhpcy5yb3dzLmxlbmd0aCAmJiB0aGlzLnJvd3NbMF0ubGVuZ3RoID9cbiAgICAgICAgdGhpcy5udW1Db2xzIC0gdGhpcy5yb3dzWzBdLmxlbmd0aCA6IDA7XG4gIH1cblxuICAvKiogVGhlIG51bWJlciBvZiBibGFuayBjZWxscyB0byBwdXQgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBmaWxsZWQgcm93LiAqL1xuICBnZXQgX2xhc3RSb3dPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzICYmIHRoaXMucm93cy5sZW5ndGggJiYgdGhpcy5yb3dzW3RoaXMucm93cy5sZW5ndGggLSAxXS5sZW5ndGggP1xuICAgICAgICB0aGlzLm51bUNvbHMgLSB0aGlzLnJvd3NbdGhpcy5yb3dzLmxlbmd0aCAtIDFdLmxlbmd0aCA6IDA7XG4gIH1cblxuICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdy4gKi9cbiAgZ2V0IF9sYXN0Um93SW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzICYmIHRoaXMucm93cy5sZW5ndGggP1xuICAgICAgICB0aGlzLnJvd3MubGVuZ3RoIC0gMSA6IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBmdWxsIHJvd3MgdG8gZGlzcGxheSBhbmQgZmlsbCB1cCB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBnZXQgX2ZvbGxvd2luZ1Jvd3MoKTogTnhDYWxlbmRhckNlbGxbXVtdIHtcbiAgICBpZiAodGhpcy5mb2xsb3dpbmdJdGVtcyAmJiB0aGlzLmZvbGxvd2luZ0l0ZW1zLmxlbmd0aCkge1xuICAgICAgLy8gaWYgZmlyc3Qgcm93IGlzIG5vdCBhIGZ1bGwgcm93ID0+IGRpc3BsYXkgdGhlbSBpbiBvZmZzZXQgc3BhY2VcbiAgICAgIGlmICh0aGlzLmZvbGxvd2luZ0l0ZW1zWzBdLmxlbmd0aCA8IHRoaXMubnVtQ29scykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdJdGVtcy5zbGljZSgxLCB0aGlzLmZvbGxvd2luZ0l0ZW1zLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdJdGVtcztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBfaXNBY3RpdmVDZWxsKHJvd0luZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgY2VsbE51bWJlciA9IHJvd0luZGV4ICogdGhpcy5udW1Db2xzICsgY29sSW5kZXg7XG5cbiAgICAvLyBBY2NvdW50IGZvciB0aGUgZmFjdCB0aGF0IHRoZSBmaXJzdCByb3cgbWF5IG5vdCBoYXZlIGFzIG1hbnkgY2VsbHMuXG4gICAgaWYgKHJvd0luZGV4KSB7XG4gICAgICBjZWxsTnVtYmVyIC09IHRoaXMuX2ZpcnN0Um93T2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsTnVtYmVyID09PSB0aGlzLmFjdGl2ZUNlbGw7XG4gIH1cblxuICAvKiogRm9jdXNlcyB0aGUgYWN0aXZlIGNlbGwgYWZ0ZXIgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBlbXB0eS4gKi9cbiAgX2ZvY3VzQWN0aXZlQ2VsbCgpIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ueC1jYWxlbmRhci1ib2R5LWFjdGl2ZScpLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl19