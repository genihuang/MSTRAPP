/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @param {?} value
 * @return {?}
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} str
 * @param {?=} length
 * @param {?=} padCharacter
 * @return {?}
 */
export function pad(str, length = 2, padCharacter = '0') {
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
/**
 * @param {?} date
 * @return {?}
 */
export function formatDate(date) {
    /** @type {?} */
    const dateOfBirth = [
        String(date.getFullYear()),
        pad(String(date.getMonth() + 1)),
        pad(String(date.getDate()))
    ].join('-');
    return dateOfBirth;
}
/**
 * @param {?} date
 * @return {?}
 */
export function formatDateHuman(date) {
    /** @type {?} */
    const dateOfBirth = [
        pad(String(date.getDate())),
        pad(String(date.getMonth() + 1)),
        String(date.getFullYear())
    ].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
/**
 * @param {?} value
 * @param {?=} DEFAULTS
 * @param {?=} MAPPING
 * @return {?}
 */
export function mapClassNames(value, DEFAULTS = [], MAPPING = {}) {
    /** @type {?} */
    let sanitizedList = [...DEFAULTS];
    if (typeof value === 'string') {
        /** @type {?} */
        const mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [...sanitizedList, ...mappedClasses];
    }
    return sanitizedList.join(' ').trim();
}
/**
 * @param {?} value
 * @param {?=} MAPPING
 * @return {?}
 */
export function getClassNameList(value, MAPPING = {}) {
    /** @type {?} */
    let mappedClasses = [];
    if (typeof value === 'string') {
        /** @type {?} */
        const classNames = value.split(' ');
        /** @type {?} */
        const keys = Object.keys(MAPPING);
        mappedClasses = classNames.map((/**
         * @param {?} className
         * @return {?}
         */
        className => {
            if (keys.indexOf(className) > -1) {
                return MAPPING[className];
            }
            else {
                return className;
            }
        }));
    }
    return mappedClasses;
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.addClass(element.nativeElement, item);
        }));
    }
}
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} classes
 * @return {?}
 */
export function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            renderer.removeClass(element.nativeElement, item);
        }));
    }
}
// YYYY-MM-DD -> DATE
/**
 * @param {?} dateString
 * @return {?}
 */
export function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
/**
 * @param {?} style
 * @return {?}
 */
export function getFontShorthand(style) {
    const { font, fontStyle, fontVariant, fontWeight, fontSize, lineHeight, fontFamily } = style;
    if (font.length > 0) {
        return font;
    }
    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;
}
/**
 * @param {?} number
 * @return {?}
 */
export function numberOfDecimals(number) {
    /** @type {?} */
    const parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    /** @type {?} */
    const match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match[1]) {
        return 0;
    }
    return match[1].length;
}
/**
 * @param {?} value
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
export function clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(max, value));
}
/**
 * Provider that defines when form controls have an error.
 */
export class ErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
}
ErrorStateMatcher.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ ErrorStateMatcher.ngInjectableDef = i0.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC91dGlscy8iLCJzb3VyY2VzIjpbInV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7Ozs7QUFHdkQsTUFBTSxVQUFVLFFBQVEsQ0FBQyxLQUFVO0lBQ2pDLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQ25DLENBQUM7Ozs7Ozs7QUFFRCxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQVcsRUFBRSxTQUFpQixDQUFDLEVBQUUsZUFBdUIsR0FBRztJQUMzRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksTUFBTSxFQUFFO1FBQzFDLE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFDRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFO1FBQzFCLEdBQUcsR0FBRyxZQUFZLEdBQUcsR0FBRyxDQUFDO0tBQzFCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDOzs7Ozs7QUFHSCxNQUFNLFVBQVUsVUFBVSxDQUFDLElBQVU7O1VBQzNCLFdBQVcsR0FBSTtRQUNqQixNQUFNLENBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzNCLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDNUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBRWIsT0FBTyxXQUFXLENBQUM7QUFDdkIsQ0FBQzs7Ozs7QUFDRCxNQUFNLFVBQVUsZUFBZSxDQUFDLElBQVU7O1VBQ2hDLFdBQVcsR0FBSTtRQUNqQixHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUs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bXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKHN0cjogc3RyaW5nLCBsZW5ndGg6IG51bWJlciA9IDIsIHBhZENoYXJhY3Rlcjogc3RyaW5nID0gJzAnKTogc3RyaW5nIHtcbiAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgc3RyLmxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBzdHIgPSBwYWRDaGFyYWN0ZXIgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuLy8gREFURSAtPiBZWVlZLU1NLUREXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgZGF0ZU9mQmlydGggPSAgW1xuICAgICAgICBTdHJpbmcgKGRhdGUuZ2V0RnVsbFllYXIoKSksXG4gICAgICAgIHBhZChTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkpLFxuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSlcbiAgICAgIF0uam9pbignLScpO1xuXG4gICAgcmV0dXJuIGRhdGVPZkJpcnRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVIdW1hbihkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgZGF0ZU9mQmlydGggPSAgW1xuICAgICAgICBwYWQoU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSksXG4gICAgICAgIHBhZChTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkpLFxuICAgICAgICBTdHJpbmcgKGRhdGUuZ2V0RnVsbFllYXIoKSlcbiAgICAgIF0uam9pbignLScpO1xuXG4gICAgcmV0dXJuIGRhdGVPZkJpcnRoO1xufVxuLypcbiAgUHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGFsbG93IGEgbGlzdCBvZiBzaG9ydCBrZXl3b3Jkc1xuICBleHBhbmQgdG8gbG9uZ2VyIGJlbSBjbGFzcyBuYW1lcyB3aXRoIHdpbGwgdGhlbiBiZSBhcHBsaWVkIHRvIHRoZSBjbGFzc25hbWUgdmFsdWUuXG5cbiAgVGhpcyBmdW5jdGlvbiB3aWxsIG1hcCBhIGxpc3Qgb2Yga2V5cyB0byB2YWx1ZXMgaW4gYSBNQVBQSU5HIGxpc3QuXG4gIFdoYXRldmVyIHZhbHVlIGlzIGZvdW5kIHdpbGwgcmVwbGFjZSB0aGUga2V5d29yZC5cbiAgRXZlcnkga2V5d29yZCBub3QgZm91bmQgd2lsbCBqdXN0IHRyYW5zZmVyZWQgd2lpdGhtb3V0IG1vZGlmeWluZy5cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBDbGFzc05hbWVzKHZhbHVlLCBERUZBVUxUUyA9IFtdLCBNQVBQSU5HID0ge30pIHtcbiAgbGV0IHNhbml0aXplZExpc3QgPSBbIC4uLkRFRkFVTFRTIF07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtYXBwZWRDbGFzc2VzID0gZ2V0Q2xhc3NOYW1lTGlzdCh2YWx1ZSwgTUFQUElORyk7XG4gICAgc2FuaXRpemVkTGlzdCA9IFsuLi5zYW5pdGl6ZWRMaXN0LCAuLi5tYXBwZWRDbGFzc2VzXTtcbiAgfVxuXG4gIHJldHVybiBzYW5pdGl6ZWRMaXN0LmpvaW4oJyAnKS50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWVMaXN0KHZhbHVlLCBNQVBQSU5HID0ge30pIHtcbiAgbGV0IG1hcHBlZENsYXNzZXMgPSBbXTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhNQVBQSU5HKTtcblxuICAgIG1hcHBlZENsYXNzZXMgPSBjbGFzc05hbWVzLm1hcChjbGFzc05hbWUgPT4ge1xuICAgICAgaWYgKGtleXMuaW5kZXhPZihjbGFzc05hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIE1BUFBJTkdbY2xhc3NOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbWFwcGVkQ2xhc3Nlcztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2xhc3NlcyhyZW5kZXJlcjogUmVuZGVyZXIyLCBlbGVtZW50OiBFbGVtZW50UmVmLCBjbGFzc2VzOiBzdHJpbmcpIHtcbiAgaWYgKHJlbmRlcmVyICYmIGVsZW1lbnQgJiYgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgcmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBpdGVtKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNsYXNzZXM6IHN0cmluZykge1xuICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICByZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cblxuLy8gWVlZWS1NTS1ERCAtPiBEQVRFXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xufVxuXG4vLyBNYW51YWxseSBjb21wb3NlIGEgZm9udCBzaG9ydGhhbmQgZGVmaW50aW9uIGFzIGl0J3Mgbm90XG4vLyBndWFyYW50ZWVkIHRvIGJlIGdpdmVuIGJ5IHRoZSBjb21wdXRlZCBzdHlsZSBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9udFNob3J0aGFuZChzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbikge1xuICBjb25zdCB7XG4gICAgZm9udCwgZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGxpbmVIZWlnaHQsIGZvbnRGYW1pbHlcbiAgfSA9IHN0eWxlO1xuXG4gIGlmIChmb250Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZm9udDtcbiAgfVxuXG4gIHJldHVybiBgJHtmb250U3R5bGV9ICR7Zm9udFZhcmlhbnR9ICR7Zm9udFdlaWdodH0gJHtmb250U2l6ZX0vJHtsaW5lSGVpZ2h0fSAke2ZvbnRGYW1pbHl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlck9mRGVjaW1hbHMobnVtYmVyKSB7XG4gIGNvbnN0IHBhcnNlZCA9IE51bWJlcihudW1iZXIpO1xuICBpZiAoTnVtYmVyLmlzTmFOKHBhcnNlZCkgfHwgTnVtYmVyLmlzSW50ZWdlcihwYXJzZWQpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSAocGFyc2VkLnRvU3RyaW5nKCkpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuICBpZiAoIW1hdGNoWzFdKSB7XG4gICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gbWF0Y2hbMV0ubGVuZ3RoO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLyoqIFByb3ZpZGVyIHRoYXQgZGVmaW5lcyB3aGVuIGZvcm0gY29udHJvbHMgaGF2ZSBhbiBlcnJvci4gKi9cbkBJbmplY3RhYmxlKHtwcm92aWRlZEluOiAncm9vdCd9KVxuZXhwb3J0IGNsYXNzIEVycm9yU3RhdGVNYXRjaGVyIHtcbiAgaXNFcnJvclN0YXRlKGNvbnRyb2w6IEZvcm1Db250cm9sIHwgbnVsbCwgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZCAmJiAoY29udHJvbC50b3VjaGVkIHx8IChmb3JtICYmIGZvcm0uc3VibWl0dGVkKSkpO1xuICB9XG59XG4iXX0=