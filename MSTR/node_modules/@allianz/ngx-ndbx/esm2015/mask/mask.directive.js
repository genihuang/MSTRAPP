/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, ElementRef, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE, ZERO, NINE, NUMPAD_ZERO, NUMPAD_NINE, A, Z } from '@angular/cdk/keycodes';
/** @type {?} */
export const NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
/** @type {?} */
export const NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
export class NxMaskDirective {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._position = null;
        this._validateMask = true;
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Sets the mask.
     * @param {?} value
     * @return {?}
     */
    set mask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get mask() {
        return this._mask;
    }
    /**
     * Sets the keys that are recognized as separators.
     * Default separators: / ( ) . : - + , and space.
     * @param {?} values
     * @return {?}
     */
    set separators(values) {
        this._separators = values;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._validatorOnChange();
    }
    /**
     * @return {?}
     */
    get separators() {
        return this._separators;
    }
    /**
     * Whether the separators should be dropped in the control value accessor.
     * @param {?} value
     * @return {?}
     */
    set dropSpecialCharacters(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._dropSpecialCharacters) {
            this._dropSpecialCharacters = newValue;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        }
    }
    /**
     * @return {?}
     */
    get dropSpecialCharacters() {
        return this._dropSpecialCharacters;
    }
    /**
     * Whether the mask validation should be applied on the input. Default: true.
     * @param {?} value
     * @return {?}
     */
    set validateMask(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._validateMask) {
            this._validateMask = newValue;
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get validateMask() {
        return this._validateMask;
    }
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    getUnmaskedValue() {
        /** @type {?} */
        const unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    }
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const location = event.location;
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const currentValue = this._elementRef.nativeElement.value;
        // row of characters is selected: set cursor position to end of new entered character
        if (input.selectionStart !== input.selectionEnd) {
            /** @type {?} */
            let nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            /** @type {?} */
            const positionChange = this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this.mask[nextCharacterInMask])))
                ? this._calculateCursorShift(input.selectionStart)
                : 0;
            this._position = input.selectionStart + positionChange;
        }
        else if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            const backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            const selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            // if last character is deleted: only delete last character, do not trigger input event again
            // (here the separator would be added again)
            if (selectionAtLastCharacter) {
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                event.preventDefault();
                // do not delete a separator, only set cursor position
            }
            else if (this.isSeparator(lastCharacter)) {
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
                // for any other character: decrease cursor position by one.
                // the input is modified and will be validated in _onInputChange().
            }
            else {
                this._position = input.selectionStart - backspaceShift;
            }
        }
        else {
            this._position = input.selectionStart;
            /** @type {?} */
            let nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            if (this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this._mask[nextCharacterInMask])))) {
                // if mask is already filled up, do not allow any inputs
                if (currentValue.length === this.mask.length) {
                    input.setSelectionRange(nextCharacterInMask, nextCharacterInMask);
                    event.preventDefault();
                }
                else {
                    this._position = nextCharacterInMask + 1;
                }
            }
        }
    }
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    _calculateCursorShift(position) {
        /** @type {?} */
        let shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        let characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    _keyCodeIsNumber(value, location) {
        return ((value >= ZERO && value <= NINE)
            || (location === 3 && value >= NUMPAD_ZERO && value <= NUMPAD_NINE));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _keyCodeIsLetter(value) {
        return (value >= A && value <= Z);
    }
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    _isKeyCodeAllowed(value, location, maskedValue) {
        if ((maskedValue === '0' && this._keyCodeIsNumber(value, location))
            || (maskedValue === 'A' && (this._keyCodeIsNumber(value, location) || this._keyCodeIsLetter(value)))
            || (maskedValue === 'S' && this._keyCodeIsLetter(value))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    _isStringAllowed(value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        this.updateValue(this.getMaskedString(input.value));
        if (this._position !== null) {
            input.setSelectionRange(this._position, this._position);
            this._position = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onPaste(event) {
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        const maskedString = this.getMaskedString(pastedData, input.selectionStart);
        this._position = input.selectionStart + maskedString.length;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this._elementRef.nativeElement.value = value;
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    }
    /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    getMaskedString(inputValue, maskStartIndex = 0) {
        /** @type {?} */
        let formattedValue = '';
        /** @type {?} */
        let maskIndex = maskStartIndex;
        /** @type {?} */
        let inputIndex = 0;
        /** @type {?} */
        let carot = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                // shift for _position
                if (maskIndex === this._position + carot) {
                    carot++;
                }
                maskIndex++;
            }
        }
        if (carot > 0) {
            this._position = this._position + carot;
        }
        return formattedValue;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isSeparator(value) {
        return (this._separators.indexOf(value) !== -1);
    }
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!value) {
            value = '';
        }
        this.updateValue(this.getMaskedString(value));
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this._onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this._onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    /**
     * @return {?}
     */
    _validateFn() {
        /** @type {?} */
        const inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        const maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    validate() {
        return this.validateMask ? this._validateFn() : null;
    }
}
NxMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxMask]',
                host: {
                    '(input)': '_onInputChange($event)',
                    '(keydown)': '_onKeydown($event)',
                    '(paste)': '_onPaste($event)',
                    '(blur)': '_onTouchedCallback()'
                },
                exportAs: 'nxMaskDirective',
                providers: [
                    NX_MASK_VALUE_ACCESSOR,
                    { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                    NX_MASK_VALIDATORS
                ]
            },] }
];
/** @nocollapse */
NxMaskDirective.ctorParameters = () => [
    { type: ElementRef }
];
NxMaskDirective.propDecorators = {
    mask: [{ type: Input, args: ['nxMask',] }],
    separators: [{ type: Input }],
    dropSpecialCharacters: [{ type: Input }],
    validateMask: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._mask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._separators;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._dropSpecialCharacters;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._position;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validateMask;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    NxMaskDirective.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9tYXNrLyIsInNvdXJjZXMiOlsibWFzay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekUsT0FBTyxFQUVMLGlCQUFpQixFQUNqQixhQUFhLEVBRWQsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztBQUl0RyxNQUFNLE9BQU8sc0JBQXNCLEdBQVE7SUFDekMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxFQUFDO0lBQzlDLEtBQUssRUFBRSxJQUFJO0NBQ1o7O0FBRUQsTUFBTSxPQUFPLGtCQUFrQixHQUFRO0lBQ3JDLE9BQU8sRUFBRSxhQUFhO0lBQ3RCLFdBQVcsRUFBRSxVQUFVOzs7SUFBQyxHQUFHLEVBQUUsQ0FBQyxlQUFlLEVBQUM7SUFDOUMsS0FBSyxFQUFFLElBQUk7Q0FDWjtBQWlCRCxNQUFNLE9BQU8sZUFBZTs7OztJQW9FMUIsWUFDVSxXQUF1QjtRQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQWxFekIsZ0JBQVcsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVB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WUF4QzBCLFVBQVU7OzttQkFzRGxDLEtBQUssU0FBQyxRQUFRO3lCQW1CZCxLQUFLO29DQVdMLEtBQUs7MkJBYUwsS0FBSzs7Ozs7OztJQXRETixnQ0FBc0I7Ozs7O0lBQ3RCLHNDQUFvRTs7Ozs7SUFDcEUsaURBQWdEOzs7OztJQUNoRCxvQ0FBaUM7Ozs7O0lBQ2pDLHdDQUFzQzs7Ozs7SUFFdEMsNENBQTRDOzs7OztJQUM1Qyw2Q0FBdUM7Ozs7O0lBQ3ZDLDZDQUF1Qzs7Ozs7SUEyRHJDLHNDQUErQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE5HX1ZBTFVFX0FDQ0VTU09SLFxuICBOR19WQUxJREFUT1JTLFxuICBWYWxpZGF0b3Jcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IE5YX0lOUFVUX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvaW5wdXQnO1xuaW1wb3J0IHsgQkFDS1NQQUNFLCBERUxFVEUsIFpFUk8sIE5JTkUsIE5VTVBBRF9aRVJPLCBOVU1QQURfTklORSwgQSwgWiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbnR5cGUgTUFTS19UWVBFID0gJzAnIHwgJ0EnIHwgJ1MnO1xuXG5leHBvcnQgY29uc3QgTlhfTUFTS19WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnhNYXNrRGlyZWN0aXZlKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbmV4cG9ydCBjb25zdCBOWF9NQVNLX1ZBTElEQVRPUlM6IGFueSA9IHtcbiAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnhNYXNrRGlyZWN0aXZlKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W254TWFza10nLFxuICBob3N0OiB7XG4gICAgJyhpbnB1dCknOiAnX29uSW5wdXRDaGFuZ2UoJGV2ZW50KScsXG4gICAgJyhrZXlkb3duKSc6ICdfb25LZXlkb3duKCRldmVudCknLFxuICAgICcocGFzdGUpJzogJ19vblBhc3RlKCRldmVudCknLFxuICAgICcoYmx1ciknOiAnX29uVG91Y2hlZENhbGxiYWNrKCknXG4gIH0sXG4gIGV4cG9ydEFzOiAnbnhNYXNrRGlyZWN0aXZlJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAgTlhfTUFTS19WQUxVRV9BQ0NFU1NPUixcbiAgICB7IHByb3ZpZGU6IE5YX0lOUFVUX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogTnhNYXNrRGlyZWN0aXZlIH0sXG4gICAgTlhfTUFTS19WQUxJREFUT1JTXG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgTnhNYXNrRGlyZWN0aXZlIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG5cbiAgcHJpdmF0ZSBfbWFzazogc3RyaW5nO1xuICBwcml2YXRlIF9zZXBhcmF0b3JzID0gWycvJywgJygnLCAnKScsICcuJywgJzonLCAnLScsICcgJywgJysnLCAnLCddO1xuICBwcml2YXRlIF9kcm9wU3BlY2lhbENoYXJhY3RlcnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfcG9zaXRpb246IG51bWJlciA9IG51bGw7XG4gIHByaXZhdGUgX3ZhbGlkYXRlTWFzazogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfb25DaGFuZ2VDYWxsYmFjayA9IChfOiBhbnkpID0+IHsgfTtcbiAgcHJpdmF0ZSBfb25Ub3VjaGVkQ2FsbGJhY2sgPSAoKSA9PiB7IH07XG4gIHByaXZhdGUgX3ZhbGlkYXRvck9uQ2hhbmdlID0gKCkgPT4geyB9O1xuXG4gIC8qKiBTZXRzIHRoZSBtYXNrLiAgKi9cbiAgQElucHV0KCdueE1hc2snKVxuICBzZXQgbWFzayh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9tYXNrKSB7XG4gICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZ2V0TWFza2VkU3RyaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSkpO1xuICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1hc2soKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBrZXlzIHRoYXQgYXJlIHJlY29nbml6ZWQgYXMgc2VwYXJhdG9ycy5cbiAgICogRGVmYXVsdCBzZXBhcmF0b3JzOiAvICggKSAuIDogLSArICwgYW5kIHNwYWNlLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IHNlcGFyYXRvcnModmFsdWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuX3NlcGFyYXRvcnMgPSB2YWx1ZXM7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG4gIGdldCBzZXBhcmF0b3JzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fc2VwYXJhdG9ycztcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBzZXBhcmF0b3JzIHNob3VsZCBiZSBkcm9wcGVkIGluIHRoZSBjb250cm9sIHZhbHVlIGFjY2Vzc29yLiAqL1xuICBASW5wdXQoKVxuICBzZXQgZHJvcFNwZWNpYWxDaGFyYWN0ZXJzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fZHJvcFNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICB0aGlzLl9kcm9wU3BlY2lhbENoYXJhY3RlcnMgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5nZXRNYXNrZWRTdHJpbmcodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU3BlY2lhbENoYXJhY3RlcnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTcGVjaWFsQ2hhcmFjdGVycztcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBtYXNrIHZhbGlkYXRpb24gc2hvdWxkIGJlIGFwcGxpZWQgb24gdGhlIGlucHV0LiBEZWZhdWx0OiB0cnVlLiAqL1xuICBASW5wdXQoKVxuICBzZXQgdmFsaWRhdGVNYXNrKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fdmFsaWRhdGVNYXNrKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hc2sgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGdldCB2YWxpZGF0ZU1hc2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlTWFzaztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWZcbiAgKSB7IH1cblxuICAvKiogUmV0dXJucyB0aGUgdW5tYXNrZWQgdmFsdWUuICovXG4gIGdldFVubWFza2VkVmFsdWUoKTogc3RyaW5nIHtcbiAgICBjb25zdCB1bm1hc2tlZFZhbHVlID0gdGhpcy5zZXBhcmF0b3JzLnJlZHVjZShmdW5jdGlvbih1bm1hc2tlZCwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdW5tYXNrZWQuc3BsaXQoc2VwYXJhdG9yKS5qb2luKCcnKTtcbiAgICB9LCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuXG4gICAgcmV0dXJuIHVubWFza2VkVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogdGhpcy5fcG9zaXRpb24gY2FuIGJlIHNldCB0byBhIG5ldyB2YWx1ZSBpbiB0aGlzIGZ1bmN0aW9uO1xuICAgKiBpdCBpcyB1c2VkIHRvIHNldCB0aGUgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIGNoZWNraW5nIHRoZSBtYXNrZWQgaW5wdXQgaW4gX29uSW5wdXRDaGFuZ2UoKS5cbiAgICovXG4gIF9vbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IGV2ZW50LmxvY2F0aW9uO1xuXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgICAvLyByb3cgb2YgY2hhcmFjdGVycyBpcyBzZWxlY3RlZDogc2V0IGN1cnNvciBwb3NpdGlvbiB0byBlbmQgb2YgbmV3IGVudGVyZWQgY2hhcmFjdGVyXG4gICAgaWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBpbnB1dC5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIGxldCBuZXh0Q2hhcmFjdGVySW5NYXNrID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLl9tYXNrW25leHRDaGFyYWN0ZXJJbk1hc2tdKSkge1xuICAgICAgICBuZXh0Q2hhcmFjdGVySW5NYXNrKys7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHRoaXMuX2lzS2V5Q29kZUFsbG93ZWQoa2V5Q29kZSwgbG9jYXRpb24sIHRoaXMubWFza1tuZXh0Q2hhcmFjdGVySW5NYXNrXSBhcyBNQVNLX1RZUEUpXG4gICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jYWxjdWxhdGVDdXJzb3JTaGlmdChpbnB1dC5zZWxlY3Rpb25TdGFydClcbiAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IGlucHV0LnNlbGVjdGlvblN0YXJ0ICsgcG9zaXRpb25DaGFuZ2U7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBCQUNLU1BBQ0UgfHwga2V5Q29kZSA9PT0gREVMRVRFKSB7XG4gICAgICAvLyBpZiBiYWNrc3BhY2UgcHJlc3NlZCwgY3Vyc29yIGhhcyB0byBtb3ZlIG9uZSBjaGFyYWN0ZXIgdG8gc3RhcnRcbiAgICAgIGNvbnN0IGJhY2tzcGFjZVNoaWZ0ID0ga2V5Q29kZSA9PT0gQkFDS1NQQUNFID8gMSA6IDA7XG4gICAgICBjb25zdCBsYXN0Q2hhcmFjdGVyID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhpbnB1dC5zZWxlY3Rpb25TdGFydCAtIGJhY2tzcGFjZVNoaWZ0LCBpbnB1dC5zZWxlY3Rpb25FbmQgLSBiYWNrc3BhY2VTaGlmdCArIDEpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQXRMYXN0Q2hhcmFjdGVyID0gKGlucHV0LnNlbGVjdGlvblN0YXJ0ID09PSBjdXJyZW50VmFsdWUubGVuZ3RoIC0gMSArIGJhY2tzcGFjZVNoaWZ0KTtcblxuICAgICAgLy8gaWYgbGFzdCBjaGFyYWN0ZXIgaXMgZGVsZXRlZDogb25seSBkZWxldGUgbGFzdCBjaGFyYWN0ZXIsIGRvIG5vdCB0cmlnZ2VyIGlucHV0IGV2ZW50IGFnYWluXG4gICAgICAvLyAoaGVyZSB0aGUgc2VwYXJhdG9yIHdvdWxkIGJlIGFkZGVkIGFnYWluKVxuICAgICAgaWYgKHNlbGVjdGlvbkF0TGFzdENoYXJhY3Rlcikge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoMCwgY3VycmVudFZhbHVlLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIGRvIG5vdCBkZWxldGUgYSBzZXBhcmF0b3IsIG9ubHkgc2V0IGN1cnNvciBwb3NpdGlvblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2VwYXJhdG9yKGxhc3RDaGFyYWN0ZXIpKSB7XG4gICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKGlucHV0LnNlbGVjdGlvblN0YXJ0IC0gYmFja3NwYWNlU2hpZnQsIGlucHV0LnNlbGVjdGlvbkVuZCAtIGJhY2tzcGFjZVNoaWZ0KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIGZvciBhbnkgb3RoZXIgY2hhcmFjdGVyOiBkZWNyZWFzZSBjdXJzb3IgcG9zaXRpb24gYnkgb25lLlxuICAgICAgLy8gdGhlIGlucHV0IGlzIG1vZGlmaWVkIGFuZCB3aWxsIGJlIHZhbGlkYXRlZCBpbiBfb25JbnB1dENoYW5nZSgpLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBpbnB1dC5zZWxlY3Rpb25TdGFydCAtIGJhY2tzcGFjZVNoaWZ0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgbGV0IG5leHRDaGFyYWN0ZXJJbk1hc2sgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMuX21hc2tbbmV4dENoYXJhY3RlckluTWFza10pKSB7XG4gICAgICAgIG5leHRDaGFyYWN0ZXJJbk1hc2srKztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzS2V5Q29kZUFsbG93ZWQoa2V5Q29kZSwgbG9jYXRpb24sIHRoaXMuX21hc2tbbmV4dENoYXJhY3RlckluTWFza10gYXMgTUFTS19UWVBFKSkge1xuICAgICAgICAvLyBpZiBtYXNrIGlzIGFscmVhZHkgZmlsbGVkIHVwLCBkbyBub3QgYWxsb3cgYW55IGlucHV0c1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlLmxlbmd0aCA9PT0gdGhpcy5tYXNrLmxlbmd0aCkge1xuICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKG5leHRDaGFyYWN0ZXJJbk1hc2ssIG5leHRDaGFyYWN0ZXJJbk1hc2spO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBuZXh0Q2hhcmFjdGVySW5NYXNrICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgYSBsZXR0ZXIgaXMgZW50ZXJlZCBhdCBgc2VsZWN0aW9uU3RhcnRgIHBvc2l0aW9uIGluIHRoZSBtYXNrLlxuICAgKiBUaGVyZSBhcmUgdHdvIGNhc2VzIHRvIGNvbnNpZGVyICgnfCcgPT4gY3Vyc29yIHBvc2l0aW9uIHdoZXJlIHRoZSBjaGFyYWN0ZXIgaXMgZW50ZXJlZCwgbWFzazogMDA6MDA6MDApOlxuICAgKiAtIGJlZm9yZSB0aGUgc2VwYXJhdG9ycyB0aGVyZSBpcyBzcGFjZSBmb3IgZW50ZXJpbmcgdGhlIGxldHRlcjogJzEyOjN8NDo1JyA9PiAnMTI6MzA6fDQ1J1xuICAgKiAtIHRoZSBsZXR0ZXIgaGFzIHRvIGJlIHNoaWZ0ZWQgYW5kIGlzIGVudGVyZWQgYWZ0ZXIgdGhlIHNlcGFyYXRvcnM6ICcxMjozNHw6NScgPT4gJzEyOjM0OjB8NSdcbiAgICovXG4gIHByaXZhdGUgX2NhbGN1bGF0ZUN1cnNvclNoaWZ0KHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgLy8gdHJhY2tzIGlmIHRoZSBlbnRlcmVkIGxldHRlciB3YXMgYWxyZWFkeSBwbGFjZWQgaW4gdGhlIGN1cnJlbnQgbWFza1xuICAgIC8vIGFuZCB0aGVyZWZvciB3YXMgY29uc2lkZXJlZCBpbiB0aGUgY3Vyc29yIGNhbGN1bGF0aW9uLlxuICAgIGxldCBjaGFyYWN0ZXJXYXNFbnRlcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW3Bvc2l0aW9uICsgc2hpZnRdKSkge1xuICAgICAgc2hpZnQrKztcbiAgICAgIGNoYXJhY3Rlcldhc0VudGVyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1twb3NpdGlvbiArIHNoaWZ0XSkpIHtcbiAgICAgIHNoaWZ0Kys7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFyYWN0ZXJXYXNFbnRlcmVkKSB7XG4gICAgICBzaGlmdCsrO1xuICAgIH1cblxuICAgIHJldHVybiBzaGlmdDtcbiAgfVxuXG4gIHByaXZhdGUgX2tleUNvZGVJc051bWJlcih2YWx1ZTogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICgodmFsdWUgPj0gWkVSTyAmJiB2YWx1ZSA8PSBOSU5FKVxuICAgICAgICAgICB8fCAobG9jYXRpb24gPT09IDMgJiYgdmFsdWUgPj0gTlVNUEFEX1pFUk8gJiYgdmFsdWUgPD0gTlVNUEFEX05JTkUpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2tleUNvZGVJc0xldHRlcih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh2YWx1ZSA+PSBBICYmIHZhbHVlIDw9IFopO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNLZXlDb2RlQWxsb3dlZCh2YWx1ZTogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyLCBtYXNrZWRWYWx1ZTogTUFTS19UWVBFKSB7XG4gICAgaWYgKChtYXNrZWRWYWx1ZSA9PT0gJzAnICYmIHRoaXMuX2tleUNvZGVJc051bWJlcih2YWx1ZSwgbG9jYXRpb24pKVxuICAgICAgICB8fCAobWFza2VkVmFsdWUgPT09ICdBJyAmJiAodGhpcy5fa2V5Q29kZUlzTnVtYmVyKHZhbHVlLCBsb2NhdGlvbikgfHwgdGhpcy5fa2V5Q29kZUlzTGV0dGVyKHZhbHVlKSkpXG4gICAgICAgIHx8IChtYXNrZWRWYWx1ZSA9PT0gJ1MnICYmIHRoaXMuX2tleUNvZGVJc0xldHRlcih2YWx1ZSkpKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9pc1N0cmluZ0FsbG93ZWQodmFsdWU6IHN0cmluZywgbWFza2VkVmFsdWU6IE1BU0tfVFlQRSkge1xuICAgIGlmICgobWFza2VkVmFsdWUgPT09ICcwJyAmJiAvXlswLTldezF9JC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgfHwgKG1hc2tlZFZhbHVlID09PSAnQScgJiYgL15bYS16QS1aMC05XXsxfSQvLnRlc3QodmFsdWUpKVxuICAgICAgICAgIHx8IChtYXNrZWRWYWx1ZSA9PT0gJ1MnICYmIC9eW2EtekEtWl17MX0kLy50ZXN0KHZhbHVlKSkpIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9vbklucHV0Q2hhbmdlKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZ2V0TWFza2VkU3RyaW5nKGlucHV0LnZhbHVlKSk7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLl9wb3NpdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9vblBhc3RlKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkge1xuICAgIGNvbnN0IGlucHV0OiBIVE1MSW5wdXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgcGFzdGVkRGF0YSA9IChldmVudC5jbGlwYm9hcmREYXRhIHx8ICg8YW55PiB3aW5kb3cpLmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKTtcbiAgICBjb25zdCBtYXNrZWRTdHJpbmcgPSB0aGlzLmdldE1hc2tlZFN0cmluZyhwYXN0ZWREYXRhLCBpbnB1dC5zZWxlY3Rpb25TdGFydCk7XG4gICAgdGhpcy5fcG9zaXRpb24gPSBpbnB1dC5zZWxlY3Rpb25TdGFydCArIG1hc2tlZFN0cmluZy5sZW5ndGg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMuZHJvcFNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLmdldFVubWFza2VkVmFsdWUoKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNYXNrZWRTdHJpbmcoaW5wdXRWYWx1ZTogc3RyaW5nLCBtYXNrU3RhcnRJbmRleDogbnVtYmVyID0gMCk6IHN0cmluZyB7XG4gICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gJyc7XG4gICAgbGV0IG1hc2tJbmRleCA9IG1hc2tTdGFydEluZGV4O1xuICAgIGxldCBpbnB1dEluZGV4ID0gMDtcbiAgICBsZXQgY2Fyb3QgPSAwO1xuXG4gICAgLy8gaW5zZXJ0IGlmIG5leHQgaW4gbWFzayBpcyBzZXBhcmF0b3JcbiAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLm1hc2tbbWFza0luZGV4XSkpIHtcbiAgICAgIGZvcm1hdHRlZFZhbHVlICs9IHRoaXMubWFza1ttYXNrSW5kZXhdO1xuICAgICAgbWFza0luZGV4Kys7XG4gICAgfVxuXG4gICAgd2hpbGUgKGlucHV0SW5kZXggPCBpbnB1dFZhbHVlLmxlbmd0aCkge1xuICAgICAgLy8gdGVzdCBpZiBsZXR0ZXJzIGFyZSB2YWxpZFxuICAgICAgaWYgKHRoaXMuX2lzU3RyaW5nQWxsb3dlZChpbnB1dFZhbHVlW2lucHV0SW5kZXhdLCB0aGlzLm1hc2tbbWFza0luZGV4XSBhcyBNQVNLX1RZUEUpKSB7XG4gICAgICAgIGZvcm1hdHRlZFZhbHVlICs9IGlucHV0VmFsdWVbaW5wdXRJbmRleF07XG4gICAgICAgIGlucHV0SW5kZXgrKztcbiAgICAgICAgbWFza0luZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIC8vIGluc2VydCBpZiBuZXh0IGluIG1hc2sgaXMgc2VwYXJhdG9yXG4gICAgICB3aGlsZSAodGhpcy5pc1NlcGFyYXRvcih0aGlzLm1hc2tbbWFza0luZGV4XSkpIHtcbiAgICAgICAgZm9ybWF0dGVkVmFsdWUgKz0gdGhpcy5tYXNrW21hc2tJbmRleF07XG5cbiAgICAgICAgLy8gc2hpZnQgZm9yIF9wb3NpdGlvblxuICAgICAgICBpZiAobWFza0luZGV4ID09PSB0aGlzLl9wb3NpdGlvbiArIGNhcm90KSB7XG4gICAgICAgICAgY2Fyb3QrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tJbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXJvdCA+IDApIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKyBjYXJvdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGlzU2VwYXJhdG9yKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuX3NlcGFyYXRvcnMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcbiAgfVxuXG4gIC8vIGNvbnRyb2wgdmFsdWUgYWNjZXNzb3JcbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IG9uQ2hhbmdlO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgX3ZhbGlkYXRlRm4oKSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUubGVuZ3RoO1xuICAgIGNvbnN0IG1hc2tMZW5ndGggPSB0aGlzLl9tYXNrLmxlbmd0aDtcbiAgICBpZiAoaW5wdXRMZW5ndGggIT09IG1hc2tMZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IG54TWFza0xlbmd0aEVycm9yOiB7J2xlbmd0aCc6IG1hc2tMZW5ndGgsICdhY3R1YWwnOiBpbnB1dExlbmd0aH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU1hc2sgPyB0aGlzLl92YWxpZGF0ZUZuKCkgOiBudWxsO1xuICB9XG59XG4iXX0=