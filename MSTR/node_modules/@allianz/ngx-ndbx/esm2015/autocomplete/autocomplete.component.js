/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Component, ElementRef, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewChildren, ContentChildren, QueryList, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { NxAutocompleteOptionComponent } from './autocomplete-option.component';
import { Observable } from 'rxjs';
/**
 * Autocomplete IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 * @type {?}
 */
let _uniqueAutocompleteIdCounter = 0;
/**
 * Event object that is emitted when an autocomplete option is selected.
 */
export class NxAutocompleteSelectedEvent {
    /**
     * @param {?} source
     * @param {?} option
     */
    constructor(source, option) {
        this.source = source;
        this.option = option;
    }
}
if (false) {
    /**
     * Reference to the autocomplete panel that emitted the event.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.source;
    /**
     * Option that was selected.
     * @type {?}
     */
    NxAutocompleteSelectedEvent.prototype.option;
}
export class NxAutocompleteComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_changeDetectorRef, _elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * Whether the autocomplete panel should be visible, depending on option length.
         */
        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /**
         * Event that is emitted whenever an option from the list is selected.
         */
        this.optionSelected = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event that is emitted when the autocomplete panel is closed.
         */
        this.closed = new EventEmitter();
        this._classList = {};
        /**
         * Unique ID to be used by autocomplete trigger's "aria-owns" property.
         */
        this.id = `nx-autocomplete-${_uniqueAutocompleteIdCounter++}`;
        // As autocomplete option can hold any value, we might need a converter
        // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
        /**
         * Value to string converter.
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => value ? value.toString() : null);
    }
    /**
     * Whether the autocomplete panel is open.
     * @return {?}
     */
    get isOpen() { return this._isOpen && this.showPanel; }
    /**
     * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
     * @param {?} val
     * @return {?}
     */
    set items(val) {
        this._hasItems = true;
        if (Array.isArray(val)) {
            this._items = val;
        }
        else if (val instanceof Observable) {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
            this._itemsSubscription = val.subscribe((/**
             * @param {?} itms
             * @return {?}
             */
            (itms) => {
                this._items = itms;
                this._changeDetectorRef.markForCheck();
                // and check visibility in next cycle, when options are set
                setTimeout((/**
                 * @return {?}
                 */
                () => this._setVisibility()));
            }));
        }
        else if (val === null) {
            this._items = val;
        }
        else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
        }
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * \@docs-private
     * Is items observable set
     * @return {?}
     */
    get hasItems() {
        return this._hasItems;
    }
    /**
     * Autocomplete options
     * @return {?}
     */
    get options() {
        return this.hasItems ? this._vOptions : this._cOptions;
    }
    /**
     * Takes classes set on the host nx-autocomplete element and applies them to the panel
     * inside the overlay container to allow for easy styling.
     * @param {?} value
     * @return {?}
     */
    set classList(value) {
        if (value && value.length) {
            value.split(' ').forEach((/**
             * @param {?} className
             * @return {?}
             */
            className => this._classList[className.trim()] = true));
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        this._setVisibility();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    /**
     * Sets the panel scrollTop. This allows us to manually scroll to display options
     * above or below the fold, as they are not actually being focused when active.
     * @param {?} scrollTop
     * @return {?}
     */
    _setScrollTop(scrollTop) {
        if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
        }
    }
    /**
     * Returns the panel's scrollTop.
     * @return {?}
     */
    _getScrollTop() {
        return this.panel ? this.panel.nativeElement.scrollTop : 0;
    }
    /**
     * Panel should hide itself when the option list is empty.
     * @return {?}
     */
    _setVisibility() {
        this.showPanel = !!(this.options && this.options.length);
        this._classList['nx-autocomplete-visible'] = this.showPanel;
        this._classList['nx-autocomplete-hidden'] = !this.showPanel;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emits the `select` event.
     * @param {?} option
     * @return {?}
     */
    _emitSelectEvent(option) {
        /** @type {?} */
        const event = new NxAutocompleteSelectedEvent(this, option);
        this.optionSelected.emit(event);
    }
}
NxAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-autocomplete',
                template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'nxAutocomplete',
                host: {
                    'class': 'nx-autocomplete'
                },
                styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:24px;overflow-y:auto;overflow-x:hidden;max-height:336px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
            }] }
];
/** @nocollapse */
NxAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NxAutocompleteComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef,] }],
    panel: [{ type: ViewChild, args: ['panel',] }],
    items: [{ type: Input }],
    optionSelected: [{ type: Output }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    _vOptions: [{ type: ViewChildren, args: [NxAutocompleteOptionComponent,] }],
    _cOptions: [{ type: ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
    classList: [{ type: Input, args: ['class',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }]
};
if (false) {
    /**
     * Manages active item in option list based on key events.
     * @type {?}
     */
    NxAutocompleteComponent.prototype._keyManager;
    /**
     * Whether the autocomplete panel should be visible, depending on option length.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.showPanel;
    /** @type {?} */
    NxAutocompleteComponent.prototype._isOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxAutocompleteComponent.prototype.template;
    /**
     * \@docs-private
     * Element for the panel containing the autocomplete options.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._items;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._itemsSubscription;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._hasItems;
    /**
     * Event that is emitted whenever an option from the list is selected.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.optionSelected;
    /**
     * Event that is emitted when the autocomplete panel is opened.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.opened;
    /**
     * Event that is emitted when the autocomplete panel is closed.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.closed;
    /**
     * Autocomplete options in view - ie from items
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._vOptions;
    /**
     * Autocomplete options in content - ie user provided
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._cOptions;
    /** @type {?} */
    NxAutocompleteComponent.prototype._classList;
    /**
     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.id;
    /**
     * Value to string converter.
     * @type {?}
     */
    NxAutocompleteComponent.prototype.valueFormatter;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxAutocompleteComponent.prototype._elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsiYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQy9ELE9BQU8sRUFFTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFdBQVcsRUFDWCxTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixTQUFTLEVBQ1QsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQzNDLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBRWhGLE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sTUFBTSxDQUFDOzs7Ozs7SUFNNUMsNEJBQTRCLEdBQUcsQ0FBQzs7OztBQUdwQyxNQUFNLE9BQU8sMkJBQTJCOzs7OztJQUN0QyxZQUVTLE1BQStCLEVBRS9CLE1BQXFDO1FBRnJDLFdBQU0sR0FBTixNQUFNLENBQXlCO1FBRS9CLFdBQU0sR0FBTixNQUFNLENBQStCO0lBQUksQ0FBQztDQUNwRDs7Ozs7O0lBSEcsNkNBQXNDOzs7OztJQUV0Qyw2Q0FBNEM7O0FBYWhELE1BQU0sT0FBTyx1QkFBdUI7Ozs7O0lBeUdsQyxZQUNVLGtCQUFxQyxFQUNyQyxXQUF1QjtRQUR2Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBQ3JDLGdCQUFXLEdBQVgsV0FBVyxDQUFZOzs7O1FBckdqQyxjQUFTLEdBQVksS0FBSyxDQUFDO1FBSTNCLFlBQU8sR0FBWSxLQUFLLENBQUM7UUFvQ2pCLFdBQU0sR0FBa0IsSUFBSSxDQUFDO1FBVTdCLGNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7UUFHUCxtQkFBYyxHQUM3QixJQUFJLFlB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LFNBQVMsU0FBQyxXQUFXO29CQU1yQixTQUFTLFNBQUMsT0FBTztvQkFHakIsS0FBSzs2QkFxQ0wsTUFBTTtxQkFJTixNQUFNO3FCQUdOLE1BQU07d0JBR04sWUFBWSxTQUFDLDZCQUE2Qjt3QkFJMUMsZUFBZSxTQUFDLDZCQUE2QixFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBQzt3QkFZbkUsS0FBSyxTQUFDLE9BQU87NkJBaUJiLEtBQUssU0FBQyxrQkFBa0I7Ozs7Ozs7SUFuR3pCLDhDQUF1RTs7Ozs7SUFHdkUsNENBQTJCOztJQUkzQiwwQ0FBeUI7Ozs7O0lBR3pCLDJDQUFtRDs7Ozs7O0lBTW5ELHdDQUFzQzs7Ozs7SUEyQnRDLHlDQUFxQzs7Ozs7SUFDckMscURBQXlDOzs7OztJQVN6Qyw0Q0FBMEI7Ozs7O0lBRzFCLGlEQUNvRDs7Ozs7SUFHcEQseUNBQXlFOzs7OztJQUd6RSx5Q0FBeUU7Ozs7OztJQUd6RSw0Q0FDNEQ7Ozs7OztJQUc1RCw0Q0FDNEQ7O0lBa0I1RCw2Q0FBMEM7Ozs7O0lBRzFDLHFDQUFpRTs7Ozs7SUFPakUsaURBQytGOzs7OztJQUc3RixxREFBNkM7Ozs7O0lBQzdDLDhDQUErQiIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NoaWxkcmVuLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIFF1ZXJ5TGlzdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9hdXRvY29tcGxldGUtb3B0aW9uLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5sZXQgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlciA9IDA7XG5cbi8qKiBFdmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYW4gYXV0b2NvbXBsZXRlIG9wdGlvbiBpcyBzZWxlY3RlZC4gKi9cbmV4cG9ydCBjbGFzcyBOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBwdWJsaWMgc291cmNlOiBOeEF1dG9jb21wbGV0ZUNvbXBvbmVudCxcbiAgICAvKiogT3B0aW9uIHRoYXQgd2FzIHNlbGVjdGVkLiAqL1xuICAgIHB1YmxpYyBvcHRpb246IE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50KSB7IH1cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtYXV0b2NvbXBsZXRlJyxcbiAgdGVtcGxhdGVVcmw6ICdhdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ254QXV0b2NvbXBsZXRlJyxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdueC1hdXRvY29tcGxldGUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBNYW5hZ2VzIGFjdGl2ZSBpdGVtIGluIG9wdGlvbiBsaXN0IGJhc2VkIG9uIGtleSBldmVudHMuICovXG4gIF9rZXlNYW5hZ2VyOiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD47XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBzaG91bGQgYmUgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIG9wdGlvbiBsZW5ndGguICovXG4gIHNob3dQYW5lbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgb3Blbi4gKi9cbiAgZ2V0IGlzT3BlbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzT3BlbiAmJiB0aGlzLnNob3dQYW5lbDsgfVxuICBfaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogRWxlbWVudCBmb3IgdGhlIHBhbmVsIGNvbnRhaW5pbmcgdGhlIGF1dG9jb21wbGV0ZSBvcHRpb25zLlxuICAgKi9cbiAgQFZpZXdDaGlsZCgncGFuZWwnKSBwYW5lbDogRWxlbWVudFJlZjtcblxuICAvKiogSXRlbXMgb2JzZXJ2YWJsZS4gSWYgZ2l2ZW4sIGF1dG9jb21wbGV0ZSB0YWtlcyBjYXJlIG9mIHRoZSBvcHRpb25zIGFuZCBuZy1jb250ZW50IGlzIGRpc2NhcmRlcmQgKi9cbiAgQElucHV0KClcbiAgc2V0IGl0ZW1zKHZhbDogQXJyYXk8c3RyaW5nPiB8IE9ic2VydmFibGU8QXJyYXk8c3RyaW5nPj4pIHtcbiAgICB0aGlzLl9oYXNJdGVtcyA9IHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdGhpcy5faXRlbXMgPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICBpZiAodGhpcy5faXRlbXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5faXRlbXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uID0gdmFsLnN1YnNjcmliZSgoaXRtcykgPT4ge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0bXM7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAvLyBhbmQgY2hlY2sgdmlzaWJpbGl0eSBpbiBuZXh0IGN5Y2xlLCB3aGVuIG9wdGlvbnMgYXJlIHNldFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3NldFZpc2liaWxpdHkoKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5faXRlbXMgPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBmb3IgYXV0b2NvbXBsZXRlIGl0ZW1zLiBJdCBoYXMgdG8gYmUgQXJyYXk8c3RyaW5nPiBvciBPYnNlcnZhYmxlPEFycmF5PHN0cmluZz4+Jyk7XG4gICAgfVxuICB9XG4gIGdldCBpdGVtcygpOiBBcnJheTxzdHJpbmc+IHwgT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmc+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICB9XG4gIHByaXZhdGUgX2l0ZW1zOiBBcnJheTxzdHJpbmc+ID0gbnVsbDtcbiAgcHJpdmF0ZSBfaXRlbXNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBJcyBpdGVtcyBvYnNlcnZhYmxlIHNldFxuICAgKi9cbiAgcHVibGljIGdldCBoYXNJdGVtcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faGFzSXRlbXM7XG4gIH1cbiAgcHJpdmF0ZSBfaGFzSXRlbXMgPSBmYWxzZTtcblxuICAvKiogRXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW5ldmVyIGFuIG9wdGlvbiBmcm9tIHRoZSBsaXN0IGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgb3B0aW9uU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQ+ID1cbiAgICAgIG5ldyBFdmVudEVtaXR0ZXI8TnhBdXRvY29tcGxldGVTZWxlY3RlZEV2ZW50PigpO1xuXG4gIC8qKiBFdmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsIGlzIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IG9wZW5lZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFdmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsIGlzIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGNsb3NlZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBBdXRvY29tcGxldGUgb3B0aW9ucyBpbiB2aWV3IC0gaWUgZnJvbSBpdGVtcyAqL1xuICBAVmlld0NoaWxkcmVuKE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50KVxuICBwcml2YXRlIF92T3B0aW9uczogUXVlcnlMaXN0PE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50PjtcblxuICAvKiogQXV0b2NvbXBsZXRlIG9wdGlvbnMgaW4gY29udGVudCAtIGllIHVzZXIgcHJvdmlkZWQgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZX0pXG4gIHByaXZhdGUgX2NPcHRpb25zOiBRdWVyeUxpc3Q8TnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQ+O1xuXG4gIC8qKiBBdXRvY29tcGxldGUgb3B0aW9ucyAqL1xuICBwdWJsaWMgZ2V0IG9wdGlvbnMoKTogUXVlcnlMaXN0PE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSXRlbXMgPyB0aGlzLl92T3B0aW9ucyA6IHRoaXMuX2NPcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG54LWF1dG9jb21wbGV0ZSBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIHBhbmVsXG4gICAqIGluc2lkZSB0aGUgb3ZlcmxheSBjb250YWluZXIgdG8gYWxsb3cgZm9yIGVhc3kgc3R5bGluZy5cbiAgICovXG4gIEBJbnB1dCgnY2xhc3MnKVxuICBzZXQgY2xhc3NMaXN0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICB2YWx1ZS5zcGxpdCgnICcpLmZvckVhY2goY2xhc3NOYW1lID0+IHRoaXMuX2NsYXNzTGlzdFtjbGFzc05hbWUudHJpbSgpXSA9IHRydWUpO1xuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xuICAgIH1cbiAgfVxuICBfY2xhc3NMaXN0OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcblxuICAvKiogVW5pcXVlIElEIHRvIGJlIHVzZWQgYnkgYXV0b2NvbXBsZXRlIHRyaWdnZXIncyBcImFyaWEtb3duc1wiIHByb3BlcnR5LiAqL1xuICBpZDogc3RyaW5nID0gYG54LWF1dG9jb21wbGV0ZS0ke191bmlxdWVBdXRvY29tcGxldGVJZENvdW50ZXIrK31gO1xuXG4gIC8vIEFzIGF1dG9jb21wbGV0ZSBvcHRpb24gY2FuIGhvbGQgYW55IHZhbHVlLCB3ZSBtaWdodCBuZWVkIGEgY29udmVydGVyXG4gIC8vIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgd2hpY2ggY2FuIGJlIHN0b3JlZCBpbiBpbnB1dC4gRGVmYXVsdCB2YWx1ZSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsLlxuICAvKipcbiAgICogVmFsdWUgdG8gc3RyaW5nIGNvbnZlcnRlci5cbiAgICovXG4gIEBJbnB1dCgnbnhWYWx1ZUZvcm1hdHRlcicpXG4gIHB1YmxpYyB2YWx1ZUZvcm1hdHRlcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZyA9ICh2YWx1ZTogYW55KSA9PiB2YWx1ZSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50Pih0aGlzLm9wdGlvbnMpLndpdGhXcmFwKCk7XG4gICAgdGhpcy5fc2V0VmlzaWJpbGl0eSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYW5lbCBzY3JvbGxUb3AuIFRoaXMgYWxsb3dzIHVzIHRvIG1hbnVhbGx5IHNjcm9sbCB0byBkaXNwbGF5IG9wdGlvbnNcbiAgICogYWJvdmUgb3IgYmVsb3cgdGhlIGZvbGQsIGFzIHRoZXkgYXJlIG5vdCBhY3R1YWxseSBiZWluZyBmb2N1c2VkIHdoZW4gYWN0aXZlLlxuICAgKi9cbiAgX3NldFNjcm9sbFRvcChzY3JvbGxUb3A6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnBhbmVsKSB7XG4gICAgICB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBwYW5lbCdzIHNjcm9sbFRvcC4gKi9cbiAgX2dldFNjcm9sbFRvcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhbmVsID8gdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA6IDA7XG4gIH1cblxuICAvKiogUGFuZWwgc2hvdWxkIGhpZGUgaXRzZWxmIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGlzIGVtcHR5LiAqL1xuICBfc2V0VmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLnNob3dQYW5lbCA9ICEhKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubGVuZ3RoKTtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ254LWF1dG9jb21wbGV0ZS12aXNpYmxlJ10gPSB0aGlzLnNob3dQYW5lbDtcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ254LWF1dG9jb21wbGV0ZS1oaWRkZW4nXSA9ICF0aGlzLnNob3dQYW5lbDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBFbWl0cyB0aGUgYHNlbGVjdGAgZXZlbnQuICovXG4gIF9lbWl0U2VsZWN0RXZlbnQob3B0aW9uOiBOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE54QXV0b2NvbXBsZXRlU2VsZWN0ZWRFdmVudCh0aGlzLCBvcHRpb24pO1xuICAgIHRoaXMub3B0aW9uU2VsZWN0ZWQuZW1pdChldmVudCk7XG4gIH1cbn1cbiJdfQ==