/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Input, Component, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
/** @type {?} */
const visibilityIcons = {
    show: 'password-show-o',
    hide: 'password-hide-o'
};
export class NxPasswordToggleComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * \@docs-private
         */
        this._currentIcon = visibilityIcons['show'];
        /**
         * \@docs-private
         */
        this._pressed = false;
        this._ariaLabel = 'Show password';
    }
    /**
     * Sets the aria-label needed for accessibility.
     * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
     * E.g if you have an `input[type=password]` at the beginning then the
     * password will be hidden and the correct aria-label would be 'Show password.'
     * @param {?} value
     * @return {?}
     */
    set ariaLabel(value) {
        if (value !== this._ariaLabel) {
            this._ariaLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get ariaLabel() {
        return this._ariaLabel;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.control) {
            console.warn('You need to pass an input as a control to the password toggle.');
        }
        else {
            // show the right icon according to the initial type of the input
            this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
        }
    }
    /**
     * Toggles the type of the input.
     * @return {?}
     */
    toggleInputType() {
        if (this.control) {
            this.control.type = this.control.type === 'password' ? 'text' : 'password';
            this._pressed = !this._pressed;
            this.toggleIcon();
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    toggleIcon() {
        this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
    }
    /**
     * \@docs-private
     * @param {?} $event
     * @return {?}
     */
    _onKeydown($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.toggleInputType();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get tabindex() {
        if (this.control) {
            return this.control.disabled ? -1 : 0;
        }
        return null;
    }
}
NxPasswordToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-password-toggle',
                template: `<nx-icon
      aria-hidden="true"
      [name]="_currentIcon">
    </nx-icon>`,
                host: {
                    '[attr.aria-label]': 'ariaLabel',
                    '[attr.tabindex]': 'tabindex',
                    '[attr.aria-pressed]': '_pressed',
                    'role': 'button',
                    '(click)': 'toggleInputType()',
                    '(keydown)': '_onKeydown($event)'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}:host:focus{outline:0}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}:host-context(.is-disabled){pointer-events:none}"]
            }] }
];
/** @nocollapse */
NxPasswordToggleComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxPasswordToggleComponent.propDecorators = {
    control: [{ type: Input }],
    ariaLabel: [{ type: Input }]
};
if (false) {
    /**
     * Input element using the toggle functionality.
     * @type {?}
     */
    NxPasswordToggleComponent.prototype.control;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPasswordToggleComponent.prototype._currentIcon;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPasswordToggleComponent.prototype._pressed;
    /**
     * @type {?}
     * @private
     */
    NxPasswordToggleComponent.prototype._ariaLabel;
    /**
     * @type {?}
     * @private
     */
    NxPasswordToggleComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFzc3dvcmQtdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L2lucHV0LyIsInNvdXJjZXMiOlsicGFzc3dvcmQtdG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQWlCLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVHLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7O01BRS9DLGVBQWUsR0FBRztJQUN0QixJQUFJLEVBQUUsaUJBQWlCO0lBQ3ZCLElBQUksRUFBRSxpQkFBaUI7Q0FDeEI7QUFvQkQsTUFBTSxPQUFPLHlCQUF5Qjs7OztJQTJCcEMsWUFBcUIsa0JBQXFDO1FBQXJDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7Ozs7UUFyQjFELGlCQUFZLEdBQVcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7O1FBRS9DLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFDbEIsZUFBVSxHQUFXLGVBQWUsQ0FBQztJQWtCaUIsQ0FBQzs7Ozs7Ozs7O0lBWC9ELElBQ0ksU0FBUyxDQUFDLEtBQWE7UUFDekIsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztZQUN4QixJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDeEM7SUFDSCxDQUFDOzs7O0lBQ0QsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7Ozs7SUFJRCxlQUFlO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO1NBQ2hGO2FBQU07WUFDTCxpRUFBaUU7WUFDakUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzFHO0lBQ0gsQ0FBQzs7Ozs7SUFHRCxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7WUFDM0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN4QztJQUNILENBQUM7Ozs7O0lBR0QsVUFBVTtRQUNSLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksS0FBSyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hILENBQUM7Ozs7OztJQUdELFVBQVUsQ0FBQyxNQUFNO1FBQ2YsSUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxLQUFLLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLEtBQUssQ0FBQyxFQUFFO1lBQ3BFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN4QjtJQUNILENBQUM7Ozs7O0lBR0QsSUFBSSxRQUFRO1FBQ1YsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7OztZQXBGRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUNOOzs7ZUFHVztnQkFFYixJQUFJLEVBQUU7b0JBQ0osbUJBQW1CLEVBQUUsV0FBVztvQkFDaEMsaUJBQWlCLEVBQUUsVUFBVTtvQkFDN0IscUJBQXFCLEVBQUUsVUFBVTtvQkFDakMsTUFBTSxFQUFFLFFBQVE7b0JBQ2hCLFNBQVMsRUFBRSxtQkFBbUI7b0JBQzlCLFdBQVcsRUFBRSxvQkFBb0I7aUJBQ2xDO2dCQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzthQUNoRDs7OztZQXpCeUMsaUJBQWlCOzs7c0JBNkJ4RCxLQUFLO3dCQWFMLEtBQUs7Ozs7Ozs7SUFiTiw0Q0FBbUM7Ozs7O0lBR25DLGlEQUErQzs7Ozs7SUFFL0MsNkNBQTBCOzs7OztJQUMxQiwrQ0FBNkM7Ozs7O0lBa0JoQyx1REFBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnB1dCwgQ29tcG9uZW50LCBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVOVEVSLCBTUEFDRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbmNvbnN0IHZpc2liaWxpdHlJY29ucyA9IHtcbiAgc2hvdzogJ3Bhc3N3b3JkLXNob3ctbycsXG4gIGhpZGU6ICdwYXNzd29yZC1oaWRlLW8nXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1wYXNzd29yZC10b2dnbGUnLFxuICB0ZW1wbGF0ZTpcbiAgICBgPG54LWljb25cbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICBbbmFtZV09XCJfY3VycmVudEljb25cIj5cbiAgICA8L254LWljb24+YCxcbiAgc3R5bGVVcmxzOiBbJy4vcGFzc3dvcmQtdG9nZ2xlLmNvbXBvbmVudC5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnYXJpYUxhYmVsJyxcbiAgICAnW2F0dHIudGFiaW5kZXhdJzogJ3RhYmluZGV4JyxcbiAgICAnW2F0dHIuYXJpYS1wcmVzc2VkXSc6ICdfcHJlc3NlZCcsXG4gICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAnKGNsaWNrKSc6ICd0b2dnbGVJbnB1dFR5cGUoKScsXG4gICAgJyhrZXlkb3duKSc6ICdfb25LZXlkb3duKCRldmVudCknXG4gIH0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIE54UGFzc3dvcmRUb2dnbGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAvKiogSW5wdXQgZWxlbWVudCB1c2luZyB0aGUgdG9nZ2xlIGZ1bmN0aW9uYWxpdHkuICovXG4gIEBJbnB1dCgpIGNvbnRyb2w6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgLyoqQGRvY3MtcHJpdmF0ZSAqL1xuICBfY3VycmVudEljb246IHN0cmluZyA9IHZpc2liaWxpdHlJY29uc1snc2hvdyddO1xuICAvKipAZG9jcy1wcml2YXRlICovXG4gIF9wcmVzc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2FyaWFMYWJlbDogc3RyaW5nID0gJ1Nob3cgcGFzc3dvcmQnO1xuXG4gIC8qKiBTZXRzIHRoZSBhcmlhLWxhYmVsIG5lZWRlZCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICogTm90aWNlIHRoYXQgdGhpcyBgYXJpYS1sYWJlbGAgc2hvdWxkIGRlc2NyaWJlIHRoZSBpbml0aWFsIGFjdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHN0YXR1cyBvZiB0aGUgdmlzaWJpbGl0eS5cbiAgICogRS5nIGlmIHlvdSBoYXZlIGFuIGBpbnB1dFt0eXBlPXBhc3N3b3JkXWAgYXQgdGhlIGJlZ2lubmluZyB0aGVuIHRoZVxuICAgKiBwYXNzd29yZCB3aWxsIGJlIGhpZGRlbiBhbmQgdGhlIGNvcnJlY3QgYXJpYS1sYWJlbCB3b3VsZCBiZSAnU2hvdyBwYXNzd29yZC4nXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYXJpYUxhYmVsKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FyaWFMYWJlbCkge1xuICAgICAgdGhpcy5fYXJpYUxhYmVsID0gdmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFyaWFMYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hcmlhTGFiZWw7XG4gIH1cblxuICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgIGNvbnNvbGUud2FybignWW91IG5lZWQgdG8gcGFzcyBhbiBpbnB1dCBhcyBhIGNvbnRyb2wgdG8gdGhlIHBhc3N3b3JkIHRvZ2dsZS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2hvdyB0aGUgcmlnaHQgaWNvbiBhY2NvcmRpbmcgdG8gdGhlIGluaXRpYWwgdHlwZSBvZiB0aGUgaW5wdXRcbiAgICAgIHRoaXMuX2N1cnJlbnRJY29uID0gdGhpcy5jb250cm9sLnR5cGUgPT09ICdwYXNzd29yZCcgPyB2aXNpYmlsaXR5SWNvbnNbJ3Nob3cnXSA6IHZpc2liaWxpdHlJY29uc1snaGlkZSddO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUb2dnbGVzIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC4gKi9cbiAgdG9nZ2xlSW5wdXRUeXBlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuY29udHJvbC50eXBlID0gdGhpcy5jb250cm9sLnR5cGUgPT09ICdwYXNzd29yZCcgPyAndGV4dCcgOiAncGFzc3dvcmQnO1xuICAgICAgdGhpcy5fcHJlc3NlZCA9ICF0aGlzLl9wcmVzc2VkO1xuICAgICAgdGhpcy50b2dnbGVJY29uKCk7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipAZG9jcy1wcml2YXRlICovXG4gIHRvZ2dsZUljb24oKTogdm9pZCB7XG4gICAgdGhpcy5fY3VycmVudEljb24gPSB0aGlzLl9jdXJyZW50SWNvbiA9PT0gdmlzaWJpbGl0eUljb25zWydzaG93J10gPyB2aXNpYmlsaXR5SWNvbnNbJ2hpZGUnXSA6IHZpc2liaWxpdHlJY29uc1snc2hvdyddO1xuICB9XG5cbiAgLyoqQGRvY3MtcHJpdmF0ZSAqL1xuICBfb25LZXlkb3duKCRldmVudCkge1xuICAgIGlmICgkZXZlbnQgJiYgKCRldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCAkZXZlbnQua2V5Q29kZSA9PT0gU1BBQ0UpKSB7XG4gICAgICB0aGlzLnRvZ2dsZUlucHV0VHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKkBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IHRhYmluZGV4KCk6IG51bWJlcsKge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wuZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gfVxuIl19