/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ContentChildren, QueryList, Directive } from '@angular/core';
import { NxExpandableTableRowComponent } from './expandable-table-row.component';
import { flatMap, startWith, map, distinctUntilChanged } from 'rxjs/operators';
import { combineLatest, BehaviorSubject } from 'rxjs';
/**
 * The nxExpandableTable adds row expansion functionality to the nxTable.
 * It provides the logic to expand/collapse all expandable rows simultanously.
 */
export class NxExpandableTableDirective {
    constructor() {
        this.expanded = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.rows.changes.pipe(startWith(this.rows), flatMap((/**
         * @param {?} rows
         * @return {?}
         */
        (rows) => {
            return combineLatest(rows.map((/**
             * @param {?} row
             * @return {?}
             */
            row => row.expanded)));
        })), map((/**
         * @param {?} values
         * @return {?}
         */
        (values) => values.reduce((/**
         * @param {?} a
         * @param {?} x
         * @return {?}
         */
        (a, x) => a && x), true))), distinctUntilChanged())
            .subscribe((/**
         * @param {?} rowsOpen
         * @return {?}
         */
        (rowsOpen) => {
            this.expanded.next(rowsOpen);
        }));
    }
    /**
     * Toggles the expandable rows. If all rows are open it will close them, otherwise it will open them.
     * @return {?}
     */
    toggle() {
        if (this.expanded.value) {
            this.close();
        }
        else {
            this.expand();
        }
    }
    /**
     * Expands all expandable rows.
     * @return {?}
     */
    expand() {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        row => row.expanded.next(true)));
    }
    /**
     * Closes all expandable rows.
     * @return {?}
     */
    close() {
        this.rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        row => row.expanded.next(false)));
    }
}
NxExpandableTableDirective.decorators = [
    { type: Directive, args: [{
                selector: 'table[nxExpandableTable]',
                exportAs: 'nxExpandableTable'
            },] }
];
NxExpandableTableDirective.propDecorators = {
    rows: [{ type: ContentChildren, args: [NxExpandableTableRowComponent,] }]
};
if (false) {
    /** @type {?} */
    NxExpandableTableDirective.prototype.rows;
    /** @type {?} */
    NxExpandableTableDirective.prototype.expanded;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS10YWJsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC90YWJsZS8iLCJzb3VyY2VzIjpbImV4cGFuZGFibGUvZXhwYW5kYWJsZS10YWJsZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFpQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckYsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDakYsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7O0FBV3RELE1BQU0sT0FBTywwQkFBMEI7SUFKdkM7UUFPRSxhQUFRLEdBQTZCLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBMENsRSxDQUFDOzs7O0lBeENDLGVBQWU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ3BCLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQ3BCLE9BQU87Ozs7UUFBQyxDQUFDLElBQXFDLEVBQUUsRUFBRTtZQUNoRCxPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRzs7OztZQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUM7UUFDdEQsQ0FBQyxFQUFDLEVBQ0YsR0FBRzs7OztRQUFDLENBQUMsTUFBaUIsRUFBRSxFQUFFLENBQ3hCLE1BQU0sQ0FBQyxNQUFNOzs7OztRQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRSxJQUFJLENBQUMsRUFDdEMsRUFDRCxvQkFBb0IsRUFBRSxDQUN2QjthQUNBLFNBQVM7Ozs7UUFBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9CLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7SUFLRCxNQUFNO1FBQ0osSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRTtZQUN2QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDZDthQUFNO1lBQ0wsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2Y7SUFDSCxDQUFDOzs7OztJQUtELE1BQU07UUFDSixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU87Ozs7UUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUM7SUFDcEQsQ0FBQzs7Ozs7SUFLRCxLQUFLO1FBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPOzs7O1FBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDO0lBQ3JELENBQUM7OztZQWhERixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDBCQUEwQjtnQkFDcEMsUUFBUSxFQUFFLG1CQUFtQjthQUM5Qjs7O21CQUVFLGVBQWUsU0FBQyw2QkFBNkI7Ozs7SUFBOUMsMENBQStGOztJQUUvRiw4Q0FBZ0UiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOeEV4cGFuZGFibGVUYWJsZVJvd0NvbXBvbmVudCB9IGZyb20gJy4vZXhwYW5kYWJsZS10YWJsZS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IGZsYXRNYXAsIHN0YXJ0V2l0aCwgbWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTnhFeHBhbmRhYmxlIH0gZnJvbSAnLi90b2dnbGUtYnV0dG9uLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVGhlIG54RXhwYW5kYWJsZVRhYmxlIGFkZHMgcm93IGV4cGFuc2lvbiBmdW5jdGlvbmFsaXR5IHRvIHRoZSBueFRhYmxlLlxuICogSXQgcHJvdmlkZXMgdGhlIGxvZ2ljIHRvIGV4cGFuZC9jb2xsYXBzZSBhbGwgZXhwYW5kYWJsZSByb3dzIHNpbXVsdGFub3VzbHkuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ3RhYmxlW254RXhwYW5kYWJsZVRhYmxlXScsXG4gIGV4cG9ydEFzOiAnbnhFeHBhbmRhYmxlVGFibGUnXG59KVxuZXhwb3J0IGNsYXNzIE54RXhwYW5kYWJsZVRhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgTnhFeHBhbmRhYmxlIHtcbiAgQENvbnRlbnRDaGlsZHJlbihOeEV4cGFuZGFibGVUYWJsZVJvd0NvbXBvbmVudCkgcm93czogUXVlcnlMaXN0PE54RXhwYW5kYWJsZVRhYmxlUm93Q29tcG9uZW50PjtcblxuICBleHBhbmRlZDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMucm93cy5jaGFuZ2VzLnBpcGUoXG4gICAgICBzdGFydFdpdGgodGhpcy5yb3dzKSxcbiAgICAgIGZsYXRNYXAoKHJvd3M6IE54RXhwYW5kYWJsZVRhYmxlUm93Q29tcG9uZW50W10pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3Qocm93cy5tYXAocm93ID0+IHJvdy5leHBhbmRlZCkpO1xuICAgICAgfSksXG4gICAgICBtYXAoKHZhbHVlczogYm9vbGVhbltdKSA9PlxuICAgICAgICB2YWx1ZXMucmVkdWNlKChhLCB4KSA9PiBhICYmIHgsIHRydWUpXG4gICAgICApLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgIClcbiAgICAuc3Vic2NyaWJlKChyb3dzT3BlbikgPT4ge1xuICAgICAgdGhpcy5leHBhbmRlZC5uZXh0KHJvd3NPcGVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBleHBhbmRhYmxlIHJvd3MuIElmIGFsbCByb3dzIGFyZSBvcGVuIGl0IHdpbGwgY2xvc2UgdGhlbSwgb3RoZXJ3aXNlIGl0IHdpbGwgb3BlbiB0aGVtLlxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkLnZhbHVlKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZHMgYWxsIGV4cGFuZGFibGUgcm93cy5cbiAgICovXG4gIGV4cGFuZCgpIHtcbiAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4gcm93LmV4cGFuZGVkLm5leHQodHJ1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgZXhwYW5kYWJsZSByb3dzLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHJvdy5leHBhbmRlZC5uZXh0KGZhbHNlKSk7XG4gIH1cbn1cbiJdfQ==