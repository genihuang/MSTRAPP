/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge } from 'rxjs';
import { map, take } from 'rxjs/operators';
/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 * @template T, F
 */
class NxTreeFlattener {
    /**
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    transformFunction(node, level) {
        const { children } = node, rest = tslib_1.__rest(node, ["children"]);
        return (/** @type {?} */ (Object.assign({}, rest, { level, expandable: Array.isArray(children) && children.length > 0 })));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getLevel(node) {
        return node.level;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isExpandable(node) {
        return node.expandable;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getChildren(node) {
        return (/** @type {?} */ (node.children));
    }
    /**
     * @param {?} node
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenNode(node, level, resultNodes, parentMap) {
        /** @type {?} */
        const flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            /** @type {?} */
            const childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe((/**
                 * @param {?} children
                 * @return {?}
                 */
                children => {
                    this._flattenChildren(children, level, resultNodes, parentMap);
                }));
            }
        }
        return resultNodes;
    }
    /**
     * @param {?} children
     * @param {?} level
     * @param {?} resultNodes
     * @param {?} parentMap
     * @return {?}
     */
    _flattenChildren(children, level, resultNodes, parentMap) {
        children.forEach((/**
         * @param {?} child
         * @param {?} index
         * @return {?}
         */
        (child, index) => {
            /** @type {?} */
            const childParentMap = parentMap.slice();
            childParentMap.push(index != children.length - 1); // tslint:disable-line
            this._flattenNode(child, level + 1, resultNodes, childParentMap);
        }));
    }
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     * @param {?} structuredData
     * @return {?}
     */
    flattenNodes(structuredData) {
        /** @type {?} */
        const resultNodes = [];
        structuredData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => this._flattenNode(node, 0, resultNodes, [])));
        return resultNodes;
    }
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     * @param {?} nodes
     * @param {?} treeControl
     * @return {?}
     */
    expandFlattenedNodes(nodes, treeControl) {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => {
            /** @type {?} */
            let expand = true;
            for (let i = 0; i <= this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (this.isExpandable(node)) {
                currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        }));
        return results;
    }
}
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 * @template T, F
 */
export class NxTreeFlatDataSource extends DataSource {
    /**
     * @param {?} treeControl
     * @param {?=} initialData
     */
    constructor(treeControl, initialData = []) {
        super();
        this.treeControl = treeControl;
        this._flattenedData = new BehaviorSubject([]);
        this._expandedData = new BehaviorSubject([]);
        this._data = new BehaviorSubject([]);
        this._treeFlattener = new NxTreeFlattener();
        this.data = initialData;
    }
    /**
     * @return {?}
     */
    get data() { return this._data.value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data.next(value);
        this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
        this.treeControl.dataNodes = this._flattenedData.value;
    }
    /**
     * @param {?} collectionViewer
     * @return {?}
     */
    connect(collectionViewer) {
        /** @type {?} */
        const changes = [
            collectionViewer.viewChange,
            this.treeControl.expansionModel.onChange,
            this._flattenedData
        ];
        return merge(...changes).pipe(map((/**
         * @return {?}
         */
        () => {
            this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this.treeControl));
            return this._expandedData.value;
        })));
    }
    /**
     * @return {?}
     */
    disconnect() {
        // no op
    }
}
if (false) {
    /** @type {?} */
    NxTreeFlatDataSource.prototype._treeFlattener;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._flattenedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._expandedData;
    /** @type {?} */
    NxTreeFlatDataSource.prototype._data;
    /**
     * @type {?}
     * @private
     */
    NxTreeFlatDataSource.prototype.treeControl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdC1kYXRhLXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3RyZWUvIiwic291cmNlcyI6WyJkYXRhLXNvdXJjZS9mbGF0LWRhdGEtc291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFtQixVQUFVLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RSxPQUFPLEVBQUMsZUFBZSxFQUFFLEtBQUssRUFBaUIsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUN6QyxNQUFNLGVBQWU7Ozs7OztJQUNuQixpQkFBaUIsQ0FBQyxJQUFnQixFQUFFLEtBQWE7Y0FDekMsRUFBRSxRQUFRLEtBQWMsSUFBSSxFQUFoQix5Q0FBTztRQUN6QixPQUFPLHFDQUNGLElBQUksSUFDUCxLQUFLLEVBQ0wsVUFBVSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEtBQ3RELENBQUM7SUFDVCxDQUFDOzs7OztJQUVELFFBQVEsQ0FBQyxJQUFPO1FBQ2QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7Ozs7O0lBRUQsWUFBWSxDQUFDLElBQU87UUFDbEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7Ozs7O0lBRUQsV0FBVyxDQUFDLElBQU87UUFDakIsT0FBTyxtQkFBQSxJQUFJLENBQUMsUUFBUSxFQUFPLENBQUM7SUFDOUIsQ0FBQzs7Ozs7Ozs7SUFFRCxZQUFZLENBQUMsSUFBTyxFQUFFLEtBQWEsRUFDdEIsV0FBZ0IsRUFBRSxTQUFvQjs7Y0FDM0MsUUFBUSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO1FBQ3BELFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFM0IsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFOztrQkFDekIsYUFBYSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1lBQzVDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDaEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQ3JFO2lCQUFNO2dCQUNMLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUzs7OztnQkFBQyxRQUFRLENBQUMsRUFBRTtvQkFDL0MsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUNqRSxDQUFDLEVBQUMsQ0FBQzthQUNKO1NBQ0Y7UUFDRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDOzs7Ozs7OztJQUVELGdCQUFnQixDQUFDLFFBQWEsRUFBRSxLQUFhLEVBQzVCLFdBQWdCLEVBQUUsU0FBb0I7UUFDckQsUUFBUSxDQUFDLE9BQU87Ozs7O1FBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7O2tCQUMxQixjQUFjLEdBQWMsU0FBUyxDQUFDLEtBQUssRUFBRTtZQUNuRCxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsc0JBQXNCO1lBQ3pFLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ25FLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7Ozs7SUFPRCxZQUFZLENBQUMsY0FBbUI7O2NBQ3hCLFdBQVcsR0FBUSxFQUFFO1FBQzNCLGNBQWMsQ0FBQyxPQUFPOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFDLENBQUM7UUFDNUUsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQzs7Ozs7Ozs7SUFNRCxvQkFBb0IsQ0FBQyxLQUFVLEVBQUUsV0FBMkI7O2NBQ3BELE9BQU8sR0FBUSxFQUFFOztjQUNqQixhQUFhLEdBQWMsRUFBRTtRQUNuQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBRXhCLEtBQUssQ0FBQyxPQUFPOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUU7O2dCQUNmLE1BQU0sR0FBRyxJQUFJO1lBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM3QyxNQUFNLEdBQUcsTUFBTSxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksTUFBTSxFQUFFO2dCQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDcEI7WUFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzNCLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdkU7UUFDSCxDQUFDLEVBQUMsQ0FBQztRQUNILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7Q0FDRjs7Ozs7Ozs7O0FBU0QsTUFBTSxPQUFPLG9CQUFxRSxTQUFRLFVBQWE7Ozs7O0lBZ0JyRyxZQUFvQixXQUErQixFQUN2QyxjQUFtQixFQUFFO1FBQy9CLEtBQUssRUFBRSxDQUFDO1FBRlUsZ0JBQVcsR0FBWCxXQUFXLENBQW9CO1FBYm5ELG1CQUFjLEdBQUcsSUFBSSxlQUFlLENBQU0sRUFBRSxDQUFDLENBQUM7UUFFOUMsa0JBQWEsR0FBRyxJQUFJLGVBQWUsQ0FBTSxFQUFFLENBQUMsQ0FBQztRQUU3QyxVQUFLLEdBQUcsSUFBSSxlQUFlLENBQU0sRUFBRSxDQUFDLENBQUM7UUFZbkMsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1FBQzVDLElBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDO0lBQzFCLENBQUM7Ozs7SUFaRCxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFDdkMsSUFBSSxJQUFJLENBQUMsS0FBVTtRQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN6RCxDQUFDOzs7OztJQVNELE9BQU8sQ0FBQyxnQkFBa0M7O2NBQ2xDLE9BQU8sR0FBRztZQUNkLGdCQUFnQixDQUFDLFVBQVU7WUFDM0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsUUFBUTtZQUN4QyxJQUFJLENBQUMsY0FBYztTQUNwQjtRQUNELE9BQU8sS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUc7OztRQUFDLEdBQUcsRUFBRTtZQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUN6RixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO1FBQ2xDLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDTixDQUFDOzs7O0lBRUQsVUFBVTtRQUNSLFFBQVE7SUFDVixDQUFDO0NBQ0Y7OztJQXRDQyw4Q0FBc0M7O0lBRXRDLDhDQUE4Qzs7SUFFOUMsNkNBQTZDOztJQUU3QyxxQ0FBcUM7Ozs7O0lBU3pCLDJDQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29sbGVjdGlvblZpZXdlciwgRGF0YVNvdXJjZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHttYXAsIHRha2V9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE54VHJlZU5vZGUsIE54RmxhdFRyZWVOb2RlIH0gZnJvbSAnLi90cmVlLW5vZGUnO1xuaW1wb3J0IHsgTnhGbGF0VHJlZUNvbnRyb2wgfSBmcm9tICcuL2ZsYXQtdHJlZS1jb250cm9sJztcbmltcG9ydCB7IFRyZWVDb250cm9sLCBGbGF0VHJlZUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9jZGsvdHJlZSc7XG5cbi8qKlxuICogVHJlZSBmbGF0dGVuZXIgdG8gY29udmVydCBhIG5vcm1hbCB0eXBlIG9mIG5vZGUgdG8gbm9kZSB3aXRoIGNoaWxkcmVuICYgbGV2ZWwgaW5mb3JtYXRpb24uXG4gKiBUcmFuc2Zvcm0gbmVzdGVkIG5vZGVzIG9mIHR5cGUgYFQgZXh0ZW5kcyBOeFRyZWVOb2RlYCB0byBmbGF0dGVuZWQgbm9kZXMgb2YgdHlwZSBgRiBleHRlbmRzIE54RmxhdFRyZWVOb2RlYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGlucHV0IGRhdGEgb2YgdHlwZSBgVGAgaXMgbmVzdGVkLCBhbmQgY29udGFpbnMgaXRzIGNoaWxkcmVuIGRhdGE6XG4gKiAgIFNvbWVOb2RlOiB7XG4gKiAgICAga2V5OiAnRnJ1aXRzJyxcbiAqICAgICBjaGlsZHJlbjogW1xuICogICAgICAgTm9kZU9uZToge1xuICogICAgICAgICBrZXk6ICdBcHBsZScsXG4gKiAgICAgICB9LFxuICogICAgICAgTm9kZVR3bzoge1xuICogICAgICAgIGtleTogJ1BlYXInLFxuICogICAgICB9XG4gKiAgICBdXG4gKiAgfVxuICogIEFmdGVyIGZsYXR0ZW5lciBmbGF0dGVuIHRoZSB0cmVlLCB0aGUgc3RydWN0dXJlIHdpbGwgYmVjb21lXG4gKiAgU29tZU5vZGU6IHtcbiAqICAgIGtleTogJ0ZydWl0cycsXG4gKiAgICBleHBhbmRhYmxlOiB0cnVlLFxuICogICAgbGV2ZWw6IDFcbiAqICB9LFxuICogIE5vZGVPbmU6IHtcbiAqICAgIGtleTogJ0FwcGxlJyxcbiAqICAgIGV4cGFuZGFibGU6IGZhbHNlLFxuICogICAgbGV2ZWw6IDJcbiAqICB9LFxuICogIE5vZGVUd286IHtcbiAqICAga2V5OiAnUGVhcicsXG4gKiAgIGV4cGFuZGFibGU6IGZhbHNlLFxuICogICBsZXZlbDogMlxuICogfVxuICogYW5kIHRoZSBvdXRwdXQgZmxhdHRlbmVkIHR5cGUgaXMgYEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZWAgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOeFRyZWVGbGF0dGVuZXI8VCBleHRlbmRzIE54VHJlZU5vZGUsIEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZT4ge1xuICB0cmFuc2Zvcm1GdW5jdGlvbihub2RlOiBOeFRyZWVOb2RlLCBsZXZlbDogbnVtYmVyKTogRiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gbm9kZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdCxcbiAgICAgIGxldmVsLFxuICAgICAgZXhwYW5kYWJsZTogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuICAgIH0gYXMgRjtcbiAgfVxuXG4gIGdldExldmVsKG5vZGU6IEYpOiBudW1iZXIge1xuICAgIHJldHVybiBub2RlLmxldmVsO1xuICB9XG5cbiAgaXNFeHBhbmRhYmxlKG5vZGU6IEYpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbm9kZS5leHBhbmRhYmxlO1xuICB9XG5cbiAgZ2V0Q2hpbGRyZW4obm9kZTogVCk6IE9ic2VydmFibGU8VFtdPiB8IFRbXSB7XG4gICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4gYXMgVFtdO1xuICB9XG5cbiAgX2ZsYXR0ZW5Ob2RlKG5vZGU6IFQsIGxldmVsOiBudW1iZXIsXG4gICAgICAgICAgICAgICByZXN1bHROb2RlczogRltdLCBwYXJlbnRNYXA6IGJvb2xlYW5bXSk6IEZbXSB7XG4gICAgY29uc3QgZmxhdE5vZGUgPSB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uKG5vZGUsIGxldmVsKTtcbiAgICByZXN1bHROb2Rlcy5wdXNoKGZsYXROb2RlKTtcblxuICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZShmbGF0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZXMgPSB0aGlzLmdldENoaWxkcmVuKG5vZGUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5Ob2RlcykpIHtcbiAgICAgICAgdGhpcy5fZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuTm9kZXMsIGxldmVsLCByZXN1bHROb2RlcywgcGFyZW50TWFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuTm9kZXMucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoY2hpbGRyZW4gPT4ge1xuICAgICAgICAgIHRoaXMuX2ZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbiwgbGV2ZWwsIHJlc3VsdE5vZGVzLCBwYXJlbnRNYXApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICB9XG5cbiAgX2ZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbjogVFtdLCBsZXZlbDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzOiBGW10sIHBhcmVudE1hcDogYm9vbGVhbltdKTogdm9pZCB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZFBhcmVudE1hcDogYm9vbGVhbltdID0gcGFyZW50TWFwLnNsaWNlKCk7XG4gICAgICBjaGlsZFBhcmVudE1hcC5wdXNoKGluZGV4ICE9IGNoaWxkcmVuLmxlbmd0aCAtIDEpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lXG4gICAgICB0aGlzLl9mbGF0dGVuTm9kZShjaGlsZCwgbGV2ZWwgKyAxLCByZXN1bHROb2RlcywgY2hpbGRQYXJlbnRNYXApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW4gYSBsaXN0IG9mIG5vZGUgdHlwZSBUIHRvIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIG5vZGUgRi5cbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0eXBlIFQgbWF5IGJlIG5lc3RlZCwgYW5kIHRoZSBsZW5ndGggb2YgYHN0cnVjdHVyZWREYXRhYCBtYXkgYmUgZGlmZmVyZW50XG4gICAqIGZyb20gdGhhdCBvZiByZXR1cm5lZCBsaXN0IGBGW11gLlxuICAgKi9cbiAgZmxhdHRlbk5vZGVzKHN0cnVjdHVyZWREYXRhOiBUW10pOiBGW10ge1xuICAgIGNvbnN0IHJlc3VsdE5vZGVzOiBGW10gPSBbXTtcbiAgICBzdHJ1Y3R1cmVkRGF0YS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5fZmxhdHRlbk5vZGUobm9kZSwgMCwgcmVzdWx0Tm9kZXMsIFtdKSk7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCBmbGF0dGVuZWQgbm9kZSB3aXRoIGN1cnJlbnQgZXhwYW5zaW9uIHN0YXR1cy5cbiAgICogVGhlIHJldHVybmVkIGxpc3QgbWF5IGhhdmUgZGlmZmVyZW50IGxlbmd0aC5cbiAgICovXG4gIGV4cGFuZEZsYXR0ZW5lZE5vZGVzKG5vZGVzOiBGW10sIHRyZWVDb250cm9sOiBUcmVlQ29udHJvbDxGPik6IEZbXSB7XG4gICAgY29uc3QgcmVzdWx0czogRltdID0gW107XG4gICAgY29uc3QgY3VycmVudEV4cGFuZDogYm9vbGVhbltdID0gW107XG4gICAgY3VycmVudEV4cGFuZFswXSA9IHRydWU7XG5cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGV0IGV4cGFuZCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aGlzLmdldExldmVsKG5vZGUpOyBpKyspIHtcbiAgICAgICAgZXhwYW5kID0gZXhwYW5kICYmIGN1cnJlbnRFeHBhbmRbaV07XG4gICAgICB9XG4gICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZShub2RlKSkge1xuICAgICAgICBjdXJyZW50RXhwYW5kW3RoaXMuZ2V0TGV2ZWwobm9kZSkgKyAxXSA9IHRyZWVDb250cm9sLmlzRXhwYW5kZWQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgZmxhdCB0cmVlLlxuICogVGhlIGRhdGEgc291cmNlIG5lZWQgdG8gaGFuZGxlIGV4cGFuc2lvbi9jb2xsYXBzaW9uIG9mIHRoZSB0cmVlIG5vZGUgYW5kIGNoYW5nZSB0aGUgZGF0YSBmZWVkXG4gKiB0byBgTnhUcmVlYC5cbiAqIFRoZSBuZXN0ZWQgdHJlZSBub2RlcyBvZiB0eXBlIGBUIGV4dGVuZHMgTnhUcmVlTm9kZWAgYXJlIGZsYXR0ZW5lZCB0aHJvdWdoIGBOeFRyZWVGbGF0dGVuZXJgLCBhbmQgY29udmVydGVkXG4gKiB0byB0eXBlIGBGIGV4dGVuZHMgTnhGbGF0VHJlZU5vZGVgIGZvciBgTnhUcmVlYCB0byBjb25zdW1lLlxuICovXG5leHBvcnQgY2xhc3MgTnhUcmVlRmxhdERhdGFTb3VyY2U8VCBleHRlbmRzIE54VHJlZU5vZGUsIEYgZXh0ZW5kcyBOeEZsYXRUcmVlTm9kZT4gZXh0ZW5kcyBEYXRhU291cmNlPEY+IHtcbiAgX3RyZWVGbGF0dGVuZXI6IE54VHJlZUZsYXR0ZW5lcjxULCBGPjtcblxuICBfZmxhdHRlbmVkRGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RltdPihbXSk7XG5cbiAgX2V4cGFuZGVkRGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RltdPihbXSk7XG5cbiAgX2RhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRbXT4oW10pO1xuXG4gIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy5fZGF0YS52YWx1ZTsgfVxuICBzZXQgZGF0YSh2YWx1ZTogVFtdKSB7XG4gICAgdGhpcy5fZGF0YS5uZXh0KHZhbHVlKTtcbiAgICB0aGlzLl9mbGF0dGVuZWREYXRhLm5leHQodGhpcy5fdHJlZUZsYXR0ZW5lci5mbGF0dGVuTm9kZXModGhpcy5kYXRhKSk7XG4gICAgdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMgPSB0aGlzLl9mbGF0dGVuZWREYXRhLnZhbHVlO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0cmVlQ29udHJvbDogRmxhdFRyZWVDb250cm9sPEY+LFxuICAgICAgICAgICAgICBpbml0aWFsRGF0YTogVFtdID0gW10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3RyZWVGbGF0dGVuZXIgPSBuZXcgTnhUcmVlRmxhdHRlbmVyKCk7XG4gICAgdGhpcy5kYXRhID0gaW5pdGlhbERhdGE7XG4gIH1cblxuICBjb25uZWN0KGNvbGxlY3Rpb25WaWV3ZXI6IENvbGxlY3Rpb25WaWV3ZXIpOiBPYnNlcnZhYmxlPEZbXT4ge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXG4gICAgICBjb2xsZWN0aW9uVmlld2VyLnZpZXdDaGFuZ2UsXG4gICAgICB0aGlzLnRyZWVDb250cm9sLmV4cGFuc2lvbk1vZGVsLm9uQ2hhbmdlLFxuICAgICAgdGhpcy5fZmxhdHRlbmVkRGF0YVxuICAgIF07XG4gICAgcmV0dXJuIG1lcmdlKC4uLmNoYW5nZXMpLnBpcGUobWFwKCgpID0+IHtcbiAgICAgIHRoaXMuX2V4cGFuZGVkRGF0YS5uZXh0KFxuICAgICAgICB0aGlzLl90cmVlRmxhdHRlbmVyLmV4cGFuZEZsYXR0ZW5lZE5vZGVzKHRoaXMuX2ZsYXR0ZW5lZERhdGEudmFsdWUsIHRoaXMudHJlZUNvbnRyb2wpKTtcbiAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZERhdGEudmFsdWU7XG4gICAgfSkpO1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICAvLyBubyBvcFxuICB9XG59XG5cbiJdfQ==