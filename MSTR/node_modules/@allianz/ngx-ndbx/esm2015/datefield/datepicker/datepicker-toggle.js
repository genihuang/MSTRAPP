/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, Input, Optional, Inject, } from '@angular/core';
import { merge, of as observableOf, Subscription } from 'rxjs';
import { NxDatepickerIntl } from './datepicker-intl';
import { NxDatepickerComponent, DATEPICKER_DEFAULT_OPTIONS } from './datepicker.component';
/**
 * Can be used to override the icon of a `nxDatepickerToggle`.
 */
// tslint:disable-next-line:directive-class-suffix
export class NxDatepickerToggleIconComponent {
}
NxDatepickerToggleIconComponent.decorators = [
    { type: Directive, args: [{
                selector: '[nxDatepickerToggleIcon]'
            },] }
];
/**
 * @template D
 */
export class NxDatepickerToggleComponent {
    /**
     * @param {?} _intl
     * @param {?} _changeDetectorRef
     * @param {?} _defaultOptions
     */
    constructor(_intl, _changeDetectorRef, _defaultOptions) {
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._defaultOptions = _defaultOptions;
        this._stateChanges = Subscription.EMPTY;
        this._tabindex = 0;
        if (this._defaultOptions && this._defaultOptions.toggleIconTabindex) {
            this._tabindex = this._defaultOptions.toggleIconTabindex;
        }
    }
    /**
     * Datepicker instance that the button will toggle.
     * @param {?} value
     * @return {?}
     */
    set datepicker(value) {
        this.registerDatepicker(value);
    }
    /**
     * @return {?}
     */
    get datepicker() {
        return this._datepicker;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    registerDatepicker(value) {
        if (value) {
            this._datepicker = value;
            this._datepicker.registerToggle(this);
        }
    }
    /**
     * Whether the toggle button is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.datepicker.disabled : !!this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Sets the tabindex for the toggle button. Default: 0.
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        if (this._tabindex !== value) {
            this._tabindex = value;
        }
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this._tabindex;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.datepicker) {
            this._watchStateChanges();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._watchStateChanges();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _open(event) {
        if (this.datepicker && !this.disabled) {
            this.datepicker.open();
            event.stopPropagation();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _watchStateChanges() {
        /** @type {?} */
        const datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : observableOf();
        /** @type {?} */
        const inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
            this.datepicker._datepickerInput._disabledChange : observableOf();
        /** @type {?} */
        const datepickerToggled = this.datepicker ?
            merge(this.datepicker.openedStream, this.datepicker.closedStream) :
            observableOf();
        this._stateChanges.unsubscribe();
        this._stateChanges = merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
}
NxDatepickerToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-datepicker-toggle',
                template: "<button class=\"nx-datepicker-toggle-button\"\n        [tabindex]=\"tabindex\"\n        type=\"button\"\n        [attr.aria-label]=\"_intl.openCalendarLabel\"\n        [disabled]=\"disabled\"\n        (click)=\"_open($event)\">\n\n  <svg\n    *ngIf=\"!_customIcon\"\n    class=\"default-icon\"\n    viewBox=\"0 0 24 24\"\n    width=\"24px\"\n    height=\"24px\"\n    fill=\"currentColor\"\n    focusable=\"false\">\n    <path d=\"M5.2002,17 L5.2002,15 C5.2002,14.45 5.6502,14 6.2002,14 L8.2002,14 C8.7502,14 9.2002,14.45 9.2002,15 L9.2002,17 C9.2002,17.55 8.7502,18 8.2002,\n            18 L6.2002,18 C5.6502,18 5.2002,17.55 5.2002,17 L5.2002,17 Z M20.3992,20.4 L3.5992,20.4 L3.5992,11.464 L3.5992,9.464 L3.5992,8 L20.3992,8 L20.3992,\n            20.4 Z M21.0002,3 L20.0002,3 L19.0002,3 L19.0002,2 C19.0002,1.447 18.5532,1 18.0002,1 C17.4472,1 17.0002,1.447 17.0002,2 L17.0002,3 L16.4002,3 L7.5992,\n            3 L7.0002,3 L7.0002,2 C7.0002,1.447 6.5532,1 6.0002,1 C5.4472,1 5.0002,1.447 5.0002,2 L5.0002,3 L4.0002,3 L3.0002,3 C2.4502,3 2.0002,3.45 2.0002,4 L2.0002,\n            9.464 L2.0002,11.464 L2.0002,21 C2.0002,21.55 2.4502,22 3.0002,22 L21.0002,22 C21.5502,22 22.0002,21.55 22.0002,21 L22.0002,4 C22.0002,3.45 21.5502,3 21.0002,3 L21.0002,3 Z\" id=\"path-1\"></path>\n  </svg>\n\n  <ng-content select=\"[nxDatepickerToggleIcon]\"></ng-content>\n</button>\n",
                host: {
                    'class': 'nx-datepicker-toggle',
                    '[class.nx-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                    '[class.nx-datepicker-toggle--disabled]': 'disabled'
                },
                exportAs: 'nxDatepickerToggle',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{position:relative;display:inline-block;height:24px;width:24px}:host:active{outline:0}.nx-datepicker-toggle-button{border:none;background-color:transparent;outline:0;cursor:pointer;padding:0}.nx-datepicker-toggle-button::-moz-focus-inner{border:0}.default-icon{display:block}:host(.nx-datepicker-toggle--disabled) .nx-datepicker-toggle-button{cursor:not-allowed}:host-context([data-whatinput=keyboard]) .nx-datepicker-toggle-button:focus{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
            }] }
];
/** @nocollapse */
NxDatepickerToggleComponent.ctorParameters = () => [
    { type: NxDatepickerIntl },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DATEPICKER_DEFAULT_OPTIONS,] }] }
];
NxDatepickerToggleComponent.propDecorators = {
    _customIcon: [{ type: ContentChild, args: [NxDatepickerToggleIconComponent,] }],
    datepicker: [{ type: Input, args: ['for',] }],
    disabled: [{ type: Input }],
    tabindex: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxDatepickerToggleComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    NxDatepickerToggleComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDatepickerToggleComponent.prototype._tabindex;
    /**
     * Custom icon set by the consumer.
     * @type {?}
     */
    NxDatepickerToggleComponent.prototype._customIcon;
    /** @type {?} */
    NxDatepickerToggleComponent.prototype._datepicker;
    /** @type {?} */
    NxDatepickerToggleComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    NxDatepickerToggleComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDatepickerToggleComponent.prototype._defaultOptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci10b2dnbGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9kYXRlZmllbGQvIiwic291cmNlcyI6WyJkYXRlcGlja2VyL2RhdGVwaWNrZXItdG9nZ2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsS0FBSyxFQUlMLFFBQVEsRUFDUixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEtBQUssRUFBSSxFQUFFLElBQUksWUFBWSxFQUFJLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVuRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsMEJBQTBCLEVBQTRCLE1BQU0sd0JBQXdCLENBQUM7Ozs7QUFRckgsa0RBQWtEO0FBQ2xELE1BQU0sT0FBTywrQkFBK0I7OztZQUozQyxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDBCQUEwQjthQUNyQzs7Ozs7QUFpQkQsTUFBTSxPQUFPLDJCQUEyQjs7Ozs7O0lBOEN0QyxZQUFtQixLQUF1QixFQUFVLGtCQUFxQyxFQUMvQixlQUF5QztRQURoRixVQUFLLEdBQUwsS0FBSyxDQUFrQjtRQUFVLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFDL0Isb0JBQWUsR0FBZixlQUFlLENBQTBCO1FBOUMzRixrQkFBYSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFHbkMsY0FBUyxHQUFXLENBQUMsQ0FBQztRQTRDMUIsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsa0JBQWtCLEVBQUU7WUFDbkUsSUFBSSxDQUFDLFNB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LENBQUM7OztZQXJHRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjtnQkFDaEMsbzJDQUFxQztnQkFFckMsSUFBSSxFQUFFO29CQUNKLE9BQU8sRUFBRSxzQkFBc0I7b0JBQy9CLHFDQUFxQyxFQUFFLGlDQUFpQztvQkFDeEUsd0NBQXdDLEVBQUUsVUFBVTtpQkFDckQ7Z0JBQ0QsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O2FBQ2hEOzs7O1lBeEJRLGdCQUFnQjtZQWJ2QixpQkFBaUI7NENBcUZkLFFBQVEsWUFBSSxNQUFNLFNBQUMsMEJBQTBCOzs7MEJBeEMvQyxZQUFZLFNBQUMsK0JBQStCO3lCQUc1QyxLQUFLLFNBQUMsS0FBSzt1QkFpQlgsS0FBSzt1QkFTTCxLQUFLOzs7Ozs7O0lBbkNOLG9EQUEyQzs7Ozs7SUFFM0MsZ0RBQTJCOzs7OztJQUMzQixnREFBOEI7Ozs7O0lBRzlCLGtEQUE0Rjs7SUFVNUYsa0RBQXNDOztJQTZCMUIsNENBQThCOzs7OztJQUFFLHlEQUE2Qzs7Ozs7SUFDdkYsc0RBQWlHIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRGlyZWN0aXZlLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE9wdGlvbmFsLFxuICBJbmplY3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWVyZ2UgLCAgb2YgYXMgb2JzZXJ2YWJsZU9mICwgIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOeERhdGVwaWNrZXJJbnRsIH0gZnJvbSAnLi9kYXRlcGlja2VyLWludGwnO1xuaW1wb3J0IHsgTnhEYXRlcGlja2VyQ29tcG9uZW50LCBEQVRFUElDS0VSX0RFRkFVTFRfT1BUSU9OUywgRGF0ZXBpY2tlckRlZmF1bHRPcHRpb25zIH0gZnJvbSAnLi9kYXRlcGlja2VyLmNvbXBvbmVudCc7XG5cblxuXG4vKiogQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGljb24gb2YgYSBgbnhEYXRlcGlja2VyVG9nZ2xlYC4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tueERhdGVwaWNrZXJUb2dnbGVJY29uXSdcbn0pXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeFxuZXhwb3J0IGNsYXNzIE54RGF0ZXBpY2tlclRvZ2dsZUljb25Db21wb25lbnQge31cblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1kYXRlcGlja2VyLXRvZ2dsZScsXG4gIHRlbXBsYXRlVXJsOiAnZGF0ZXBpY2tlci10b2dnbGUuaHRtbCcsXG4gIHN0eWxlVXJsczogWydkYXRlcGlja2VyLXRvZ2dsZS5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbngtZGF0ZXBpY2tlci10b2dnbGUnLFxuICAgICdbY2xhc3MubngtZGF0ZXBpY2tlci10b2dnbGUtYWN0aXZlXSc6ICdkYXRlcGlja2VyICYmIGRhdGVwaWNrZXIub3BlbmVkJyxcbiAgICAnW2NsYXNzLm54LWRhdGVwaWNrZXItdG9nZ2xlLS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gIH0sXG4gIGV4cG9ydEFzOiAnbnhEYXRlcGlja2VyVG9nZ2xlJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE54RGF0ZXBpY2tlclRvZ2dsZUNvbXBvbmVudDxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfc3RhdGVDaGFuZ2VzID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xuICBwcml2YXRlIF90YWJpbmRleDogbnVtYmVyID0gMDtcblxuICAvKiogQ3VzdG9tIGljb24gc2V0IGJ5IHRoZSBjb25zdW1lci4gKi9cbiAgQENvbnRlbnRDaGlsZChOeERhdGVwaWNrZXJUb2dnbGVJY29uQ29tcG9uZW50KSBfY3VzdG9tSWNvbjogTnhEYXRlcGlja2VyVG9nZ2xlSWNvbkNvbXBvbmVudDtcblxuICAvKiogRGF0ZXBpY2tlciBpbnN0YW5jZSB0aGF0IHRoZSBidXR0b24gd2lsbCB0b2dnbGUuICovXG4gIEBJbnB1dCgnZm9yJylcbiAgc2V0IGRhdGVwaWNrZXIodmFsdWU6IE54RGF0ZXBpY2tlckNvbXBvbmVudDxEPikge1xuICAgIHRoaXMucmVnaXN0ZXJEYXRlcGlja2VyKHZhbHVlKTtcbiAgfVxuICBnZXQgZGF0ZXBpY2tlcigpOiBOeERhdGVwaWNrZXJDb21wb25lbnQ8RD4ge1xuICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VyO1xuICB9XG4gIF9kYXRlcGlja2VyOiBOeERhdGVwaWNrZXJDb21wb25lbnQ8RD47XG5cbiAgcHJpdmF0ZSByZWdpc3RlckRhdGVwaWNrZXIodmFsdWU6IE54RGF0ZXBpY2tlckNvbXBvbmVudDxEPikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGF0ZXBpY2tlciA9IHZhbHVlO1xuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5yZWdpc3RlclRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgdG9nZ2xlIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5kYXRlcGlja2VyLmRpc2FibGVkIDogISF0aGlzLl9kaXNhYmxlZDtcbiAgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICAvKiogU2V0cyB0aGUgdGFiaW5kZXggZm9yIHRoZSB0b2dnbGUgYnV0dG9uLiBEZWZhdWx0OiAwLiAqL1xuICBASW5wdXQoKVxuICBzZXQgdGFiaW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl90YWJpbmRleCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3RhYmluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCB0YWJpbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl90YWJpbmRleDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfaW50bDogTnhEYXRlcGlja2VySW50bCwgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoREFURVBJQ0tFUl9ERUZBVUxUX09QVElPTlMpIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBEYXRlcGlja2VyRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9kZWZhdWx0T3B0aW9ucyAmJiB0aGlzLl9kZWZhdWx0T3B0aW9ucy50b2dnbGVJY29uVGFiaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGFiaW5kZXggPSB0aGlzLl9kZWZhdWx0T3B0aW9ucy50b2dnbGVJY29uVGFiaW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kYXRlcGlja2VyKSB7XG4gICAgICB0aGlzLl93YXRjaFN0YXRlQ2hhbmdlcygpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX3dhdGNoU3RhdGVDaGFuZ2VzKCk7XG4gIH1cblxuICBfb3BlbihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYXRlcGlja2VyICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIub3BlbigpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfd2F0Y2hTdGF0ZUNoYW5nZXMoKSB7XG4gICAgY29uc3QgZGF0ZXBpY2tlckRpc2FibGVkID0gdGhpcy5kYXRlcGlja2VyID8gdGhpcy5kYXRlcGlja2VyLl9kaXNhYmxlZENoYW5nZSA6IG9ic2VydmFibGVPZigpO1xuICAgIGNvbnN0IGlucHV0RGlzYWJsZWQgPSB0aGlzLmRhdGVwaWNrZXIgJiYgdGhpcy5kYXRlcGlja2VyLl9kYXRlcGlja2VySW5wdXQgP1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJJbnB1dC5fZGlzYWJsZWRDaGFuZ2UgOiBvYnNlcnZhYmxlT2YoKTtcbiAgICBjb25zdCBkYXRlcGlja2VyVG9nZ2xlZCA9IHRoaXMuZGF0ZXBpY2tlciA/XG4gICAgICAgIG1lcmdlKHRoaXMuZGF0ZXBpY2tlci5vcGVuZWRTdHJlYW0sIHRoaXMuZGF0ZXBpY2tlci5jbG9zZWRTdHJlYW0pIDpcbiAgICAgICAgb2JzZXJ2YWJsZU9mKCk7XG5cbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLl9zdGF0ZUNoYW5nZXMgPSBtZXJnZShcbiAgICAgIHRoaXMuX2ludGwuY2hhbmdlcyxcbiAgICAgIGRhdGVwaWNrZXJEaXNhYmxlZCxcbiAgICAgIGlucHV0RGlzYWJsZWQsXG4gICAgICBkYXRlcGlja2VyVG9nZ2xlZFxuICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgfVxufVxuIl19