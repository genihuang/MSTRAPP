/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { getFontShorthand } from '@allianz/ngx-ndbx/utils';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectorRef, Directive, ElementRef, HostBinding, Input, Renderer2, } from '@angular/core';
/**
 * \@docs-private
 */
export class NxAutoResizeDirective {
    /**
     * @param {?} _element
     * @param {?} _renderer
     * @param {?} _cdr
     */
    constructor(_element, _renderer, _cdr) {
        this._element = _element;
        this._renderer = _renderer;
        this._cdr = _cdr;
        this._resize = true;
        this.updateInputWidth = this.updateInputWidth.bind(this);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set resize(value) {
        this._resize = coerceBooleanProperty(value);
        if (this._resize) {
            this._addEventListener();
            this.updateInputWidth();
        }
        else {
            this._removeEventListener();
        }
    }
    /**
     * @return {?}
     */
    get resize() {
        return this._resize;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.resize) {
            this._addEventListener();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeEventListener();
    }
    /**
     * @return {?}
     */
    updateInputWidth() {
        /** @type {?} */
        const measureCanvas = this._renderer.createElement('canvas');
        /** @type {?} */
        const ctx = measureCanvas.getContext('2d');
        /** @type {?} */
        const styles = window.getComputedStyle(this._element.nativeElement);
        ctx.font = getFontShorthand(styles);
        /** @type {?} */
        const metrics = ctx.measureText(this._element.nativeElement.value);
        /** @type {?} */
        const padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
        /** @type {?} */
        const border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth);
        // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut
        /** @type {?} */
        const newWidth = metrics.width + padding + border + 16;
        // Limit to own given minimal width
        /** @type {?} */
        const parsed = parseFloat(styles.minWidth);
        this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth);
        // needed when the outer component is onPush
        this._cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    _addEventListener() {
        this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @return {?}
     */
    _removeEventListener() {
        this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);
        this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
    }
    /**
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    sumStyles(left, right) {
        left = parseInt(left, 10);
        right = parseInt(right, 10);
        left = Number.isNaN(left) ? 0 : left;
        right = Number.isNaN(right) ? 0 : right;
        return left + right;
    }
}
NxAutoResizeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxAutoResize]'
            },] }
];
/** @nocollapse */
NxAutoResizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxAutoResizeDirective.propDecorators = {
    width: [{ type: HostBinding, args: ['style.width.px',] }],
    resize: [{ type: Input, args: ['nxAutoResize',] }]
};
if (false) {
    /** @type {?} */
    NxAutoResizeDirective.prototype.width;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._resize;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._element;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NxAutoResizeDirective.prototype._cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1yZXNpemUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJudW1iZXItc3RlcHBlci9hdXRvLXJlc2l6ZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFFTCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixXQUFXLEVBQ1gsS0FBSyxFQUVMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQzs7OztBQU12QixNQUFNLE9BQU8scUJBQXFCOzs7Ozs7SUFtQmhDLFlBQW9CLFFBQW9CLEVBQ3BCLFNBQW9CLEVBQ3BCLElBQXVCO1FBRnZCLGFBQVEsR0FBUixRQUFRLENBQVk7UUFDcEIsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixTQUFJLEdBQUosSUFBSSxDQUFtQjtRQWpCbkMsWUFBTyxHQUFZLElBQUksQ0FBQztRQWtCOUIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0QsQ0FBQzs7Ozs7SUFsQkQsSUFDSSxNQUFNLENBQUMsS0FBYztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNoQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztTQUN6QjthQUFNO1lBQ0wsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7U0FDN0I7SUFDSCxDQUFDOzs7O0lBQ0QsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUMsT0FBTyxD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QUlWLFNBQVM7WUFOVCxpQkFBaUI7OztvQkFlaEIsV0FBVyxTQUFDLGdCQUFnQjtxQkFHNUIsS0FBSyxTQUFDLGNBQWM7Ozs7SUFIckIsc0NBQTZDOzs7OztJQUU3Qyx3Q0FBZ0M7Ozs7O0lBZXBCLHlDQUE0Qjs7Ozs7SUFDNUIsMENBQTRCOzs7OztJQUM1QixxQ0FBK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRGb250U2hvcnRoYW5kIH0gZnJvbSAnQGFsbGlhbnovbmd4LW5kYngvdXRpbHMnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbbnhBdXRvUmVzaXplXSdcbn0pXG5leHBvcnQgY2xhc3MgTnhBdXRvUmVzaXplRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICBASG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoLnB4Jykgd2lkdGg6IG51bWJlcjtcblxuICBwcml2YXRlIF9yZXNpemU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoJ254QXV0b1Jlc2l6ZScpXG4gIHNldCByZXNpemUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXNpemUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9yZXNpemUpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoKTtcbiAgICAgIHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICB9XG4gIGdldCByZXNpemUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgICAgICAgIHByaXZhdGUgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB0aGlzLnVwZGF0ZUlucHV0V2lkdGggPSB0aGlzLnVwZGF0ZUlucHV0V2lkdGguYmluZCh0aGlzKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAodGhpcy5yZXNpemUpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gIH1cblxuICB1cGRhdGVJbnB1dFdpZHRoKCkge1xuICAgIGNvbnN0IG1lYXN1cmVDYW52YXMgPSB0aGlzLl9yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGNvbnN0IGN0eCA9IG1lYXN1cmVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgY3R4LmZvbnQgPSBnZXRGb250U2hvcnRoYW5kKHN0eWxlcyk7XG5cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC52YWx1ZSk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5zdW1TdHlsZXMoc3R5bGVzLnBhZGRpbmdMZWZ0LCBzdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICBjb25zdCBib3JkZXIgPSB0aGlzLnN1bVN0eWxlcyhzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCBzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG4gICAgLy8gdGhlIHBpeGVscyBhcmUgbmVlZGVkLCBiZWNhdXNlIGRlc3BpdGUgdGhlIGNvcnJlY3QgY2FsY3VsYXRpb24gdGhlIGxhc3QgcGl4ZWxzIG9mIGEgbnVtYmVyIGFyZSBhbHdheXMgY3V0XG4gICAgY29uc3QgbmV3V2lkdGggPSBtZXRyaWNzLndpZHRoICsgcGFkZGluZyArIGJvcmRlciArIDE2O1xuXG4gICAgLy8gTGltaXQgdG8gb3duIGdpdmVuIG1pbmltYWwgd2lkdGhcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUZsb2F0KHN0eWxlcy5taW5XaWR0aCk7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KE51bWJlci5pc05hTihwYXJzZWQpID8gMCA6IHBhcnNlZCwgbmV3V2lkdGgpO1xuXG4gICAgLy8gbmVlZGVkIHdoZW4gdGhlIG91dGVyIGNvbXBvbmVudCBpcyBvblB1c2hcbiAgICB0aGlzLl9jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLnVwZGF0ZUlucHV0V2lkdGgsIHRydWUpO1xuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnVwZGF0ZUlucHV0V2lkdGgsIHRydWUpO1xuICB9XG5cbiAgX3JlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy51cGRhdGVJbnB1dFdpZHRoLCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy51cGRhdGVJbnB1dFdpZHRoLCB0cnVlKTtcbiAgfVxuXG4gIHN1bVN0eWxlcyhsZWZ0LCByaWdodCkge1xuICAgIGxlZnQgPSBwYXJzZUludChsZWZ0LCAxMCk7XG4gICAgcmlnaHQgPSBwYXJzZUludChyaWdodCwgMTApO1xuICAgIGxlZnQgPSBOdW1iZXIuaXNOYU4obGVmdCkgPyAwIDogbGVmdDtcbiAgICByaWdodCA9IE51bWJlci5pc05hTihyaWdodCkgPyAwIDogcmlnaHQ7XG4gICAgcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgfVxufVxuIl19