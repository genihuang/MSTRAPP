/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, ElementRef, EventEmitter, HostListener, Input, Output, ViewContainerRef } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { fromEvent, Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import { NxPopoverComponent } from './popover.component';
/** @type {?} */
let nextId = 0;
/** @type {?} */
const fallbacks = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
        offsetX: 0,
        offsetY: 16
    },
    {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
        offsetX: 16,
        offsetY: 0
    },
    {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
        offsetX: -16,
        offsetY: 0
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom',
        offsetX: 0,
        offsetY: -16
    }
];
export class NxPopoverTriggerDirective {
    /**
     * @param {?} overlay
     * @param {?} elementRef
     * @param {?} viewContainerRef
     * @param {?} eventManager
     */
    constructor(overlay, elementRef, viewContainerRef, eventManager) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._destroyed = new Subject();
        this._show = false;
        this._closeable = null;
        /**
         * \@docs-private
         */
        this.id = 'nx-popover-' + nextId++;
        /**
         * An event is emitted if the visibility status of the popover changes.
         */
        this.changeShow = new EventEmitter();
        /**
         * Sets the desired direction to open the popover. E.g., right, left, bottom, top
         */
        this.direction = 'right';
        /**
         * Whether the popover will be opened automatically.
         */
        this.popoverInitialVisible = false;
        /**
         * An event is emitted when the visibility of the popopver changes.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether the popover opens in modal state.
         */
        this.modal = false;
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /**
         * Sets the way to trigger the popover. Options are hover, click, manual
         */
        this.trigger = 'click';
        /**
         * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
         */
        this.scrollStrategy = 'close';
        this._documentClickObservable = fromEvent(document, 'click');
    }
    /**
     * Whether to show or hide the popover.
     * @param {?} value
     * @return {?}
     */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
            this.changeShow.emit(this._show);
        }
    }
    /**
     * @return {?}
     */
    get show() {
        return this._show;
    }
    /**
     * Whether to show a close button. By default a close icon is only shown for trigger type click.
     * @param {?} value
     * @return {?}
     */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    /**
     * @return {?}
     */
    get closeable() {
        return this._closeable;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseEnter() {
        if (this.trigger === 'hover') {
            this.openPopover();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseExit() {
        if (this.trigger === 'hover') {
            this.closePopover();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.popover.id = this.id;
        this.eventManager.addGlobalEventListener('window', 'keyup.esc', (/**
         * @return {?}
         */
        () => {
            this.closePopover();
        }));
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.closePopover();
        }));
        if (this.popoverInitialVisible || this._show) {
            this.openPopover();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.closePopover();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || this._closeable;
    }
    /**
     * Update the popover with the given position strategy.
     * @return {?}
     */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    handleClick() {
        if (this.trigger === 'click') {
            if (this.isOpen) {
                this.closePopover();
            }
            else {
                this.openPopover();
            }
        }
    }
    /**
     * Open the popover instance.
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * Close the popover instance.
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * Toggle the popover instance.
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
    /**
     * @private
     * @return {?}
     */
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            if (!this.modal && this.trigger === 'click') {
                this.waitForClose();
            }
        }
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    /**
     * @private
     * @return {?}
     */
    closePopover() {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this._embeddedViewRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            /** @type {?} */
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            if (this.scrollStrategy === 'reposition') {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
            }
            else {
                overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
            }
            overlayState.scrollStrategy.enable();
            if (this.modal && this.trigger === 'click') {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions((/** @type {?} */ (overlayState.positionStrategy)));
            this._subscribeToDetach();
            if (this.modal) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        }));
    }
    // for modal popovers close the popover on backdrop clicks
    /**
     * @private
     * @return {?}
     */
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.closePopover();
        }));
    }
    // Emit the nxClosed event on the popover component when the overlay detaches
    /**
     * @private
     * @return {?}
     */
    _subscribeToDetach() {
        this.overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.popover.emitClosedEvent();
        }));
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    /**
     * @private
     * @return {?}
     */
    waitForClose() {
        return this._documentClickObservable
            .pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => event.target)), filter((/**
         * @param {?} target
         * @return {?}
         */
        target => !this.elementRef.nativeElement.contains(target))), takeUntil(this.popover.closed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.closePopover();
        }));
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    /**
     * @private
     * @param {?} pair
     * @return {?}
     */
    positionArrow(pair) {
        /** @type {?} */
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        /** @type {?} */
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        /** @type {?} */
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        /** @type {?} */
        const targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            /** @type {?} */
            const direction = 'left';
            /** @type {?} */
            const arrowStyle = {};
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    /**
     * @private
     * @return {?}
     */
    getPosition() {
        /** @type {?} */
        let positions;
        /** @type {?} */
        let offsetX = 0;
        /** @type {?} */
        let offsetY = 0;
        if (this.direction === 'top') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'bottom',
                    originX: 'center',
                    originY: 'top'
                }];
            offsetX = 0;
            offsetY = -20;
        }
        else if (this.direction === 'right') {
            positions = [{
                    overlayX: 'start',
                    overlayY: 'center',
                    originX: 'end',
                    originY: 'center'
                }];
            offsetX = 20;
            offsetY = 0;
        }
        else if (this.direction === 'bottom') {
            positions = [{
                    overlayX: 'center',
                    overlayY: 'top',
                    originX: 'center',
                    originY: 'bottom'
                }];
            offsetX = 0;
            offsetY = 20;
        }
        else if (this.direction === 'left') {
            positions = [{
                    overlayX: 'end',
                    overlayY: 'center',
                    originX: 'start',
                    originY: 'center'
                }];
            offsetX = -20;
            offsetY = 0;
        }
        return this.overlay.position().flexibleConnectedTo(this.elementRef)
            .withPositions([...positions, ...fallbacks])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
    }
}
NxPopoverTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxPopoverTriggerFor]',
                exportAs: 'nxPopoverTrigger',
                host: {
                    '(click)': 'handleClick()',
                    'aria-haspopup': 'true',
                    '[attr.aria-expanded]': 'isOpen',
                    '[attr.aria-describedby]': 'isOpen ? id : null'
                }
            },] }
];
/** @nocollapse */
NxPopoverTriggerDirective.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: EventManager }
];
NxPopoverTriggerDirective.propDecorators = {
    changeShow: [{ type: Output, args: ['nxPopoverShowChange',] }],
    show: [{ type: Input, args: ['nxPopoverShow',] }],
    closeable: [{ type: Input, args: ['nxPopoverCloseable',] }],
    popover: [{ type: Input, args: ['nxPopoverTriggerFor',] }],
    direction: [{ type: Input, args: ['nxPopoverDirection',] }],
    popoverInitialVisible: [{ type: Input, args: ['nxPopoverInitialVisible',] }],
    visibleChange: [{ type: Input, args: ['nxPopoverVisibleChange',] }],
    modal: [{ type: Input, args: ['nxPopoverModal',] }],
    trigger: [{ type: Input, args: ['nxPopoverTrigger',] }],
    scrollStrategy: [{ type: Input, args: ['nxPopoverScrollStrategy',] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseExit: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['touchstart',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlayRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.portal;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._show;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._closeable;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._positionStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype._documentClickObservable;
    /**
     * \@docs-private
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.id;
    /**
     * An event is emitted if the visibility status of the popover changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.changeShow;
    /**
     * Links the trigger with the popover to open.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popover;
    /**
     * Sets the desired direction to open the popover. E.g., right, left, bottom, top
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.direction;
    /**
     * Whether the popover will be opened automatically.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.popoverInitialVisible;
    /**
     * An event is emitted when the visibility of the popopver changes.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.visibleChange;
    /**
     * Whether the popover opens in modal state.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.modal;
    /**
     * Sets the way to trigger the popover. Options are hover, click, manual
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.trigger;
    /**
     * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
     * @type {?}
     */
    NxPopoverTriggerDirective.prototype.scrollStrategy;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.overlay;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    NxPopoverTriggerDirective.prototype.eventManager;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBSUwsT0FBTyxFQUNQLGFBQWEsRUFHZCxNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBRUwsU0FBUyxFQUNULFVBQVUsRUFFVixZQUFZLEVBQ1osWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sZ0JBQWdCLEVBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7SUFLckQsTUFBTSxHQUFHLENBQUM7O01BRVIsU0FBUyxHQUE2QjtJQUMxQztRQUNFLE9BQU8sRUFBRSxPQUFPO1FBQ2hCLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLFFBQVEsRUFBRSxPQUFPO1FBQ2pCLFFBQVEsRUFBRSxLQUFLO1FBQ2YsT0FBTyxFQUFFLENBQUM7UUFDVixPQUFPLEVBQUUsRUFBRTtLQUNaO0lBQ0Q7UUFDRSxPQUFPLEVBQUUsS0FBSztRQUNkLE9BQU8sRUFBRSxLQUFLO1FBQ2QsUUFBUSxFQUFFLEtBQUs7UUFDZixRQUFRLEVBQUUsUUFBUTtRQUNsQixPQUFPLEVBQUUsQ0FBQztRQUNWLE9B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MUIsZUFBZSxFQUFFLE1BQU07b0JBQ3ZCLHNCQUFzQixFQUFFLFFBQVE7b0JBQ2hDLHlCQUF5QixFQUFFLG9CQUFvQjtpQkFDaEQ7YUFDRjs7OztZQTFHQyxPQUFPO1lBU1AsVUFBVTtZQVFWLGdCQUFnQjtZQUVULFlBQVk7Ozt5QkFzR2xCLE1BQU0sU0FBQyxxQkFBcUI7bUJBSTVCLEtBQUssU0FBQyxlQUFlO3dCQW9CckIsS0FBSyxTQUFDLG9CQUFvQjtzQkFhMUIsS0FBSyxTQUFDLHFCQUFxQjt3QkFJM0IsS0FBSyxTQUFDLG9CQUFvQjtvQ0FJMUIsS0FBSyxTQUFDLHlCQUF5Qjs0QkFJL0IsS0FBSyxTQUFDLHdCQUF3QjtvQkFJOUIsS0FBSyxTQUFDLGdCQUFnQjtzQkFPdEIsS0FBSyxTQUFDLGtCQUFrQjs2QkFJeEIsS0FBSyxTQUFDLHlCQUF5QjsyQkFhL0IsWUFBWSxTQUFDLFlBQVk7MEJBUXpCLFlBQVksU0FBQyxZQUFZLGNBQ3pCLFlBQVksU0FBQyxZQUFZOzs7Ozs7O0lBbkcxQiwrQ0FBK0I7Ozs7O0lBQy9CLDJDQUFvQzs7Ozs7SUFDcEMsK0NBQXlDOzs7OztJQUN6QywwQ0FBK0I7Ozs7O0lBQy9CLCtDQUFtQzs7Ozs7SUFDbkMsc0RBQTRDOzs7OztJQUM1QyxxREFBK0M7Ozs7O0lBQy9DLDZEQUF5RDs7Ozs7SUFHekQsdUNBQThCOzs7OztJQUc5QiwrQ0FDdUQ7Ozs7O0lBb0N2RCw0Q0FDNEI7Ozs7O0lBRzVCLDhDQUNzQzs7Ozs7SUFHdEMsMERBQ3VDOzs7OztJQUd2QyxrREFDMEQ7Ozs7O0lBRzFELDBDQUN1Qjs7Ozs7SUFNdkIsNENBQ3NDOzs7OztJQUd0QyxtREFDdUQ7Ozs7O0lBSTNDLDRDQUF3Qjs7Ozs7SUFDeEIsK0NBQThCOzs7OztJQUM5QixxREFBMEM7Ozs7O0lBQzFDLGlEQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBDb25uZWN0ZWRQb3NpdGlvbixcbiAgQ29ubmVjdGlvblBvc2l0aW9uUGFpcixcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICBPdmVybGF5LFxuICBPdmVybGF5Q29uZmlnLFxuICBPdmVybGF5UmVmLFxuICBQb3NpdGlvblN0cmF0ZWd5XG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRXZlbnRNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE54UG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuXG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJEaXJlY3Rpb24gPSAnbGVmdCcgfCAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgUG9wb3ZlclRyaWdnZXJUeXBlID0gJ2NsaWNrJyB8ICdob3ZlcicgfCAnbWFudWFsJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgUG9wb3ZlclRyaWdnZXJTY3JvbGxTdHJhdGVneSA9ICdjbG9zZScgfCAncmVwb3NpdGlvbic7XG5sZXQgbmV4dElkID0gMDtcblxuY29uc3QgZmFsbGJhY2tzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXG4gIHtcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICdib3R0b20nLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IDE2XG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnZW5kJyxcbiAgICBvcmlnaW5ZOiAndG9wJyxcbiAgICBvdmVybGF5WDogJ2VuZCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogLTE2XG4gIH0sXG4gIHtcbiAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICBvdmVybGF5WDogJ2NlbnRlcicsXG4gICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgIG9mZnNldFg6IDAsXG4gICAgb2Zmc2V0WTogMTZcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdlbmQnLFxuICAgIG9yaWdpblk6ICdib3R0b20nLFxuICAgIG92ZXJsYXlYOiAnZW5kJyxcbiAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAxNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdjZW50ZXInLFxuICAgIG9mZnNldFg6IDE2LFxuICAgIG9mZnNldFk6IDBcbiAgfSxcbiAge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICBvZmZzZXRYOiAtMTYsXG4gICAgb2Zmc2V0WTogMFxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICBvZmZzZXRYOiAwLFxuICAgIG9mZnNldFk6IC0xNlxuICB9LFxuICB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAndG9wJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAtMTZcbiAgfVxuXTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW254UG9wb3ZlclRyaWdnZXJGb3JdJyxcbiAgZXhwb3J0QXM6ICdueFBvcG92ZXJUcmlnZ2VyJyxcbiAgaG9zdDoge1xuICAgICcoY2xpY2spJzogJ2hhbmRsZUNsaWNrKCknLFxuICAgICdhcmlhLWhhc3BvcHVwJzogJ3RydWUnLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdpc09wZW4nLFxuICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdpc09wZW4gPyBpZCA6IG51bGwnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhQb3BvdmVyVHJpZ2dlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgcHJpdmF0ZSBvdmVybGF5UmVmOiBPdmVybGF5UmVmO1xuICBwcml2YXRlIHBvcnRhbDogVGVtcGxhdGVQb3J0YWw8YW55PjtcbiAgcHJpdmF0ZSBfZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSBfc2hvdzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9jbG9zZWFibGU6IGJvb2xlYW4gPSBudWxsO1xuICBwcml2YXRlIF9wb3NpdGlvblN0cmF0ZWd5OiBQb3NpdGlvblN0cmF0ZWd5O1xuICBwcml2YXRlIF9lbWJlZGRlZFZpZXdSZWY6IEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuICBwcml2YXRlIF9kb2N1bWVudENsaWNrT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50PjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBpZCA9ICdueC1wb3BvdmVyLScgKyBuZXh0SWQrKztcblxuICAvKiogQW4gZXZlbnQgaXMgZW1pdHRlZCBpZiB0aGUgdmlzaWJpbGl0eSBzdGF0dXMgb2YgdGhlIHBvcG92ZXIgY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgnbnhQb3BvdmVyU2hvd0NoYW5nZScpXG4gIGNoYW5nZVNob3c6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKiogV2hldGhlciB0byBzaG93IG9yIGhpZGUgdGhlIHBvcG92ZXIuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyU2hvdycpXG4gIHNldCBzaG93KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9zaG93ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc2hvdyA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3cpIHtcbiAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGFuZ2VTaG93LmVtaXQodGhpcy5fc2hvdyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gIH1cblxuICAvKiogV2hldGhlciB0byBzaG93IGEgY2xvc2UgYnV0dG9uLiBCeSBkZWZhdWx0IGEgY2xvc2UgaWNvbiBpcyBvbmx5IHNob3duIGZvciB0cmlnZ2VyIHR5cGUgY2xpY2suICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyQ2xvc2VhYmxlJylcbiAgc2V0IGNsb3NlYWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2Nsb3NlYWJsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5wb3BvdmVyKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuc2hvd0Nsb3NlQnV0dG9uID0gdGhpcy5pc0Nsb3NlYWJsZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgY2xvc2VhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZWFibGU7XG4gIH1cblxuICAvKiogTGlua3MgdGhlIHRyaWdnZXIgd2l0aCB0aGUgcG9wb3ZlciB0byBvcGVuLiAqL1xuICBASW5wdXQoJ254UG9wb3ZlclRyaWdnZXJGb3InKVxuICBwb3BvdmVyOiBOeFBvcG92ZXJDb21wb25lbnQ7XG5cbiAgLyoqIFNldHMgdGhlIGRlc2lyZWQgZGlyZWN0aW9uIHRvIG9wZW4gdGhlIHBvcG92ZXIuIEUuZy4sIHJpZ2h0LCBsZWZ0LCBib3R0b20sIHRvcCAqL1xuICBASW5wdXQoJ254UG9wb3ZlckRpcmVjdGlvbicpXG4gIGRpcmVjdGlvbjogUG9wb3ZlckRpcmVjdGlvbiA9ICdyaWdodCc7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgd2lsbCBiZSBvcGVuZWQgYXV0b21hdGljYWxseS4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJJbml0aWFsVmlzaWJsZScpXG4gIHBvcG92ZXJJbml0aWFsVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBBbiBldmVudCBpcyBlbWl0dGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgb2YgdGhlIHBvcG9wdmVyIGNoYW5nZXMuICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyVmlzaWJsZUNoYW5nZScpXG4gIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBvcGVucyBpbiBtb2RhbCBzdGF0ZS4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJNb2RhbCcpXG4gIG1vZGFsOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gSWYgbnhQb3BvdmVyVHJpZ2dlciBlcXVhbHMgdG8gJ2hvdmVyJyB0aGUgcG9wb3ZlciBvcGVucyBvbiBtb3VzZWVudGVyIGFuZCBjbG9zZXMgb24gbW91c2VvdXQuXG4gIC8vIElmIG54UG9wb3ZlclRyaWdnZXIgZXF1YWxzIHRvICdjbGljaycgdGhlIHBvcG92ZXIgb3BlbnMgb24gY2xpY2sgYW5kIGNsb3NlcyBvbiBhIGNsaWNrIG9mIHRoZSBjbG9zZSBpY29uIG9yIHByZXNzaW5nIEVTQyBrZXkuXG4gIC8vIElmIG54UG9wb3ZlclRyaWdnZXIgZXF1YWxzIHRvICdtYW51YWwnIHRoZSBwb3BvdmVyIG9wZW5zIG9ubHkgd2hlbiBwcm9ncmFtYXRpY2FsbHkgcmVxdWVzdGVkLlxuICAvKiogU2V0cyB0aGUgd2F5IHRvIHRyaWdnZXIgdGhlIHBvcG92ZXIuIE9wdGlvbnMgYXJlIGhvdmVyLCBjbGljaywgbWFudWFsICovXG4gIEBJbnB1dCgnbnhQb3BvdmVyVHJpZ2dlcicpXG4gIHRyaWdnZXI6IFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljayc7XG5cbiAgLyoqIFNldHMgdGhlIHNjcm9sbCBzdHJhdGVneS4gJ2Nsb3NlJyBjbG9zZXMgdGhlIHBvcG92ZXIgb24gc2Nyb2xsIHdoaWxlICdyZXBvc2l0aW9uJyBzY3JvbGxzIHRoZSBwb3BvdmVyIHdpdGggdGhlIG9yaWdpbi4gKi9cbiAgQElucHV0KCdueFBvcG92ZXJTY3JvbGxTdHJhdGVneScpXG4gIHNjcm9sbFN0cmF0ZWd5OiBQb3BvdmVyVHJpZ2dlclNjcm9sbFN0cmF0ZWd5ID0gJ2Nsb3NlJztcblxuXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvdmVybGF5OiBPdmVybGF5LFxuICAgICAgICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBldmVudE1hbmFnZXI6IEV2ZW50TWFuYWdlcikge1xuICAgIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKVxuICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5vcGVuUG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBASG9zdExpc3RlbmVyKCd0b3VjaHN0YXJ0JylcbiAgb25Nb3VzZUV4aXQoKSB7XG4gICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnBvcG92ZXIuc2hvd0Nsb3NlQnV0dG9uID0gdGhpcy5pc0Nsb3NlYWJsZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMucG9wb3Zlci5pZCA9IHRoaXMuaWQ7XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCd3aW5kb3cnLCAna2V5dXAuZXNjJywgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB9KTtcblxuICAgIHRoaXMucG9wb3Zlci5jbG9zZUJ1dHRvbkNsaWNrLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucG9wb3ZlckluaXRpYWxWaXNpYmxlIHx8IHRoaXMuX3Nob3cpIHtcbiAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWYgJiYgdGhpcy5jcmVhdGVPdmVybGF5KCkuaGFzQXR0YWNoZWQoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzQ2xvc2VhYmxlKCkge1xuICAgIHJldHVybiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snICYmIHRoaXMuX2Nsb3NlYWJsZSA9PT0gbnVsbCkgfHwgdGhpcy5fY2xvc2VhYmxlO1xuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgcG9wb3ZlciB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kuYXBwbHkoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogT3BlbiB0aGUgcG9wb3ZlciBpbnN0YW5jZS4gKi9cbiAgb3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnNob3cgPSB0cnVlO1xuICB9XG5cbiAgLyoqIENsb3NlIHRoZSBwb3BvdmVyIGluc3RhbmNlLiAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBUb2dnbGUgdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICB9XG5cbiAgcHJpdmF0ZSBvcGVuUG9wb3ZlcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY3JlYXRlT3ZlcmxheSgpLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZiA9IHRoaXMuY3JlYXRlT3ZlcmxheSgpLmF0dGFjaCh0aGlzLnBvcnRhbCk7XG5cbiAgICAgIGlmICghdGhpcy5tb2RhbCAmJiB0aGlzLnRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy53YWl0Rm9yQ2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBkZXRhY2hlcyB0aGUgb3ZlcmxheVxuICAvLyB3ZSBhcmUgbGlzdGVuaW5nIHRvIHRoZSBkZXRhY2htZW50cyBvYnNlcnZhYmxlIHdoaWNoIHdpbGwgdGhlbiBlbWl0IHRoZSBueENsb3NlZCBldmVudFxuICAvLyBvbiB0aGUgcG9wb3ZlciBjb21wb25lbnRcbiAgcHJpdmF0ZSBjbG9zZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMucG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XG4gICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kgPSBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneTtcblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsU3RyYXRlZ3kgPT09ICdyZXBvc2l0aW9uJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kuZW5hYmxlKCk7XG5cbiAgICAgIGlmICh0aGlzLm1vZGFsICYmIHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgICB0aGlzLnN1YnNjcmliZVRvUG9zaXRpb25zKG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVUb0RldGFjaCgpO1xuICAgICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcENsaWNrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWY7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvUG9zaXRpb25zKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICBjb25zdCBwYWlyID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyO1xuICAgICAgdGhpcy5wb3NpdGlvbk92ZXJsYXkocGFpcik7XG4gICAgICB0aGlzLnBvc2l0aW9uQXJyb3cocGFpcik7XG5cbiAgICAgIC8vIFRoZXNlIHBvc2l0aW9uIGNoYW5nZXMgYXJyaXZlIHRvbyBsYXRlLFxuICAgICAgLy8gV2UgaGF2ZSB0byB0cmlnZ2VyIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIG1hbnVhbGx5XG4gICAgICAvLyBhcyBpdCdzIGRldGFjaGVkIGZyb20gYW55IHJlbmRlciBoaWVyYXJjaHlcbiAgICAgIC8vIGFuZCBvbmx5IHVwZGF0ZWQgYnkgdGhlIG92ZXJsYXkgd2hlbiBhdHRhY2hlZC5cbiAgICAgIGlmICh0aGlzLl9lbWJlZGRlZFZpZXdSZWYgJiYgIXRoaXMuX2VtYmVkZGVkVmlld1JlZi5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZvciBtb2RhbCBwb3BvdmVycyBjbG9zZSB0aGUgcG9wb3ZlciBvbiBiYWNrZHJvcCBjbGlja3NcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcENsaWNrKCkge1xuICAgIHRoaXMub3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEVtaXQgdGhlIG54Q2xvc2VkIGV2ZW50IG9uIHRoZSBwb3BvdmVyIGNvbXBvbmVudCB3aGVuIHRoZSBvdmVybGF5IGRldGFjaGVzXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvRGV0YWNoKCkge1xuICAgIHRoaXMub3ZlcmxheVJlZi5kZXRhY2htZW50cygpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnBvcG92ZXIuZW1pdENsb3NlZEV2ZW50KCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdWJzY3JpYmUgdG8gZG9jdW1lbnQgY2xpY2tzIHdoZW4gdHJpZ2dlcj0nY2xpY2snIHRvIGNsb3NlIHRoZSBwb3BvdmVyIG9uIGNsaWNrcyBvbiB0aGUgYmFja2dyb3VuZFxuICBwcml2YXRlIHdhaXRGb3JDbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnRDbGlja09ic2VydmFibGVcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoZXZlbnQgPT4gZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgZmlsdGVyKHRhcmdldCA9PiAhdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLnBvcG92ZXIuY2xvc2VkKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHBvc2l0aW9uT3ZlcmxheShwYWlyOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKSB7XG4gICAgaWYgKHBhaXIub3JpZ2luWCA9PT0gJ2VuZCcgJiYgcGFpci5vdmVybGF5WCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblkgPT09ICdib3R0b20nICYmIHBhaXIub3ZlcmxheVkgPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblggPT09ICdzdGFydCcgJiYgcGFpci5vdmVybGF5WCA9PT0gJ2VuZCcpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblkgPT09ICd0b3AnICYmIHBhaXIub3ZlcmxheVkgPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ3RvcCc7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwb3NpdGlvbkFycm93KHBhaXI6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIpIHtcblxuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRQb3NpdGlvblggPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnRXaWR0aCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50TGVmdE9mZnNldCA9IHRoaXMub3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5wYXJlbnRFbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgY29uc3Qgb3ZlcmxheUVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50Lm9mZnNldExlZnQ7XG5cbiAgICAvLyBjYWxjdWxhdGlvbiBmb3IgeCBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgb3ZlcmxheSBsZWZ0IG9mZnNldCBpcyB0aGUgb25lIHRoaW5nIHRvIGNvbnNpZGVyLlxuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gKHBhcmVudEVsZW1lbnRQb3NpdGlvblggKyBwYXJlbnRFbGVtZW50V2lkdGgpIC0gKHBhcmVudEVsZW1lbnRMZWZ0T2Zmc2V0ICsgb3ZlcmxheUVsZW1lbnRMZWZ0T2Zmc2V0KTtcbiAgICBpZiAocGFpci5vcmlnaW5YID09PSBwYWlyLm92ZXJsYXlYKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICBjb25zdCBhcnJvd1N0eWxlID0ge307XG5cbiAgICAgIGFycm93U3R5bGVbZGlyZWN0aW9uXSA9IHRhcmdldFBvc2l0aW9uICsgJ3B4JztcbiAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1N0eWxlID0gYXJyb3dTdHlsZTtcbiAgICB9XG4gICAgaWYgKChwYWlyLm9yaWdpblkgPT09ICdib3R0b20nIHx8IHBhaXIub3JpZ2luWSA9PT0gJ3RvcCcpICYmIHBhaXIub3ZlcmxheVggPT09ICdjZW50ZXInKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuYXJyb3dTdHlsZSA9IHsgbGVmdDogdGFyZ2V0UG9zaXRpb24gKyAncHgnIH07XG4gICAgfVxuXG4gICAgaWYgKChwYWlyLm9yaWdpblggPT09ICdlbmQnIHx8IHBhaXIub3JpZ2luWCA9PT0gJ3N0YXJ0JykgJiYgcGFpci5vdmVybGF5WSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1N0eWxlID0geyB0b3A6ICc1MCUnIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRQb3NpdGlvbigpOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIGxldCBwb3NpdGlvbnM6IENvbm5lY3RlZFBvc2l0aW9uW107XG4gICAgbGV0IG9mZnNldFggPSAwO1xuICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICBwb3NpdGlvbnMgPSBbe1xuICAgICAgICBvdmVybGF5WDogJ2NlbnRlcicsXG4gICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgIG9yaWdpblk6ICd0b3AnXG4gICAgICB9XTtcbiAgICAgIG9mZnNldFggPSAwO1xuICAgICAgb2Zmc2V0WSA9IC0yMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBwb3NpdGlvbnMgPSBbe1xuICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgICAgb3ZlcmxheVk6ICdjZW50ZXInLFxuICAgICAgICBvcmlnaW5YOiAnZW5kJyxcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcidcbiAgICAgIH1dO1xuICAgICAgb2Zmc2V0WCA9IDIwO1xuICAgICAgb2Zmc2V0WSA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWTogJ2JvdHRvbSdcbiAgICAgIH1dO1xuICAgICAgb2Zmc2V0WCA9IDA7XG4gICAgICBvZmZzZXRZID0gMjA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBwb3NpdGlvbnMgPSBbe1xuICAgICAgICBvdmVybGF5WDogJ2VuZCcsXG4gICAgICAgIG92ZXJsYXlZOiAnY2VudGVyJyxcbiAgICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcidcbiAgICAgIH1dO1xuICAgICAgb2Zmc2V0WCA9IC0yMDtcbiAgICAgIG9mZnNldFkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vdmVybGF5LnBvc2l0aW9uKCkuZmxleGlibGVDb25uZWN0ZWRUbyh0aGlzLmVsZW1lbnRSZWYpXG4gICAgICAud2l0aFBvc2l0aW9ucyhbLi4ucG9zaXRpb25zLCAuLi5mYWxsYmFja3NdKVxuICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WChvZmZzZXRYKVxuICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WShvZmZzZXRZKTtcbiAgfVxufVxuIl19