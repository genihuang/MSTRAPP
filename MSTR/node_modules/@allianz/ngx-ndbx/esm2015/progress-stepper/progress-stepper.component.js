/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CdkStep, CdkStepper } from '@angular/cdk/stepper';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, Input, QueryList, SkipSelf } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { ErrorStateMatcher } from '@allianz/ngx-ndbx/utils';
// tslint:disable:use-input-property-decorator
// We need to reference steps in stepper and stepper in steps. To prevent circular depenedency errors
// Provide both components in a single file. Otherwise we would have to introduce interface/abstract classes
// shared between both implementations.
export class NxStepComponent extends CdkStep {
    /**
     * @param {?} stepper
     * @param {?} _errorStateMatcher
     */
    constructor(stepper, _errorStateMatcher) {
        super(stepper);
        this._errorStateMatcher = _errorStateMatcher;
    }
    /**
     * Custom error state matcher that checks for validity of the step form.
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        /** @type {?} */
        const originalErrorState = this._errorStateMatcher.isErrorState(control, form);
        // Checks for the validity of a step form that is not submitted or touched,
        // e.g when the user directly clicks the "next" button or directly on the step
        /** @type {?} */
        const customErrorState = !!(control && control.invalid && this.interacted);
        return originalErrorState || customErrorState;
    }
}
NxStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-step',
                template: "<ng-template><ng-content></ng-content></ng-template>\n",
                exportAs: 'nxStep',
                providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxStepComponent.ctorParameters = () => [
    { type: NxProgressStepperDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxProgressStepperDirective)),] }] },
    { type: ErrorStateMatcher, decorators: [{ type: SkipSelf }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxStepComponent.prototype._errorStateMatcher;
}
export class NxProgressStepperDirective extends CdkStepper {
    constructor() {
        super(...arguments);
        this._stepHeader = new QueryList();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Mark the component for change detection whenever the content children query changes
        this._steps.changes
            .pipe(takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this._stateChanged();
        }));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasPrevious() {
        return (this.selectedIndex - 1) >= 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasNext() {
        return (this.selectedIndex + 1) < this.count;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get count() {
        return this._steps ? this._steps.length : 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get currentStep() {
        if (this.count === 0 || this.selectedIndex === -1) {
            return null;
        }
        /** @type {?} */
        const steps = this._steps.toArray();
        return steps[this.selectedIndex];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get nextStep() {
        if (this.selectedIndex + 1 >= this._steps.length) {
            return null;
        }
        else {
            return this._steps.toArray()[this.selectedIndex + 1];
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get steps() {
        return this._steps;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get currentLabel() {
        /** @type {?} */
        const step = this.currentStep;
        /** @type {?} */
        const label = step.stepLabel || step.label;
        return `
    ${this.currentStepLabel} ${this.selectedIndex + 1}/${this.count}: ${label}
    `;
    }
}
NxProgressStepperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxProgressStepper]',
                exportAs: 'nxProgressStepper',
            },] }
];
NxProgressStepperDirective.propDecorators = {
    _steps: [{ type: ContentChildren, args: [NxStepComponent,] }],
    currentStepLabel: [{ type: Input }],
    title: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxProgressStepperDirective.prototype._steps;
    /** @type {?} */
    NxProgressStepperDirective.prototype._stepHeader;
    /**
     * Sets the label on the left side showing the current step label. Used for mobile viewports.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.currentStepLabel;
    /**
     * Sets the title to be rendered above the progress bar.
     * @type {?}
     */
    NxProgressStepperDirective.prototype.title;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC9wcm9ncmVzcy1zdGVwcGVyLyIsInNvdXJjZXMiOlsicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsZUFBZSxFQUNmLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxTQUFTLEVBQ1QsUUFBUSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7QUFrQjVELE1BQU0sT0FBTyxlQUFnQixTQUFRLE9BQU87Ozs7O0lBRTFDLFlBQWtFLE9BQW1DLEVBQ2pGLGtCQUFxQztRQUN2RCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFERyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO0lBRXpELENBQUM7Ozs7Ozs7SUFHRCxZQUFZLENBQUMsT0FBMkIsRUFBRSxJQUF3Qzs7Y0FDMUUsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDOzs7O2NBSXhFLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDMUUsT0FBTyxrQkFBa0IsSUFBSSxnQkFBZ0IsQ0FBQztJQUNoRCxDQUFDOzs7WUF2QkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxTQUFTO2dCQUNuQixrRUFBOEM7Z0JBQzlDLFFBQVEsRUFBRSxR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cHBlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBRdWVyeUxpc3QsXG4gIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC91dGlscyc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbi8vIHRzbGludDpkaXNhYmxlOnVzZS1pbnB1dC1wcm9wZXJ0eS1kZWNvcmF0b3JcblxuXG4vLyBXZSBuZWVkIHRvIHJlZmVyZW5jZSBzdGVwcyBpbiBzdGVwcGVyIGFuZCBzdGVwcGVyIGluIHN0ZXBzLiBUbyBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZWRlbmN5IGVycm9yc1xuLy8gUHJvdmlkZSBib3RoIGNvbXBvbmVudHMgaW4gYSBzaW5nbGUgZmlsZS4gT3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gaW50cm9kdWNlIGludGVyZmFjZS9hYnN0cmFjdCBjbGFzc2VzXG4vLyBzaGFyZWQgYmV0d2VlbiBib3RoIGltcGxlbWVudGF0aW9ucy5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtc3RlcCcsXG4gIHRlbXBsYXRlVXJsOiAncHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuaHRtbCcsXG4gIGV4cG9ydEFzOiAnbnhTdGVwJyxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IEVycm9yU3RhdGVNYXRjaGVyLCB1c2VFeGlzdGluZzogTnhTdGVwQ29tcG9uZW50fV0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTnhTdGVwQ29tcG9uZW50IGV4dGVuZHMgQ2RrU3RlcCBpbXBsZW1lbnRzIEVycm9yU3RhdGVNYXRjaGVyIHtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUpKSBzdGVwcGVyOiBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSxcbiAgQFNraXBTZWxmKCkgcHJpdmF0ZSBfZXJyb3JTdGF0ZU1hdGNoZXI6IEVycm9yU3RhdGVNYXRjaGVyKSB7XG4gICAgc3VwZXIoc3RlcHBlcik7XG4gIH1cblxuICAvKiogQ3VzdG9tIGVycm9yIHN0YXRlIG1hdGNoZXIgdGhhdCBjaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBzdGVwIGZvcm0uICovXG4gIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICBjb25zdCBvcmlnaW5hbEVycm9yU3RhdGUgPSB0aGlzLl9lcnJvclN0YXRlTWF0Y2hlci5pc0Vycm9yU3RhdGUoY29udHJvbCwgZm9ybSk7XG5cbiAgICAvLyBDaGVja3MgZm9yIHRoZSB2YWxpZGl0eSBvZiBhIHN0ZXAgZm9ybSB0aGF0IGlzIG5vdCBzdWJtaXR0ZWQgb3IgdG91Y2hlZCxcbiAgICAvLyBlLmcgd2hlbiB0aGUgdXNlciBkaXJlY3RseSBjbGlja3MgdGhlIFwibmV4dFwiIGJ1dHRvbiBvciBkaXJlY3RseSBvbiB0aGUgc3RlcFxuICAgIGNvbnN0IGN1c3RvbUVycm9yU3RhdGUgPSAhIShjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZCAmJiB0aGlzLmludGVyYWN0ZWQpO1xuICAgIHJldHVybiBvcmlnaW5hbEVycm9yU3RhdGUgfHwgY3VzdG9tRXJyb3JTdGF0ZTtcbiAgfVxufVxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW254UHJvZ3Jlc3NTdGVwcGVyXScsXG4gIGV4cG9ydEFzOiAnbnhQcm9ncmVzc1N0ZXBwZXInLFxufSlcbmV4cG9ydCBjbGFzcyBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSBleHRlbmRzIENka1N0ZXBwZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLy8gRG8gbm90IGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSBRdWVyeUxpc3Qgb3IgdGhlIGhhc05leHQoKSBmdW5jdGlvbiBwcm9kdWNlc1xuICAvLyB3cm9uZyByZXN1bHRzIG9uIGluaXRcbiAgQENvbnRlbnRDaGlsZHJlbihOeFN0ZXBDb21wb25lbnQpIF9zdGVwczogUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD47XG4gIF9zdGVwSGVhZGVyOiBRdWVyeUxpc3Q8bnVsbD4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgLyoqIFNldHMgdGhlIGxhYmVsIG9uIHRoZSBsZWZ0IHNpZGUgc2hvd2luZyB0aGUgY3VycmVudCBzdGVwIGxhYmVsLiBVc2VkIGZvciBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKSBjdXJyZW50U3RlcExhYmVsOiBzdHJpbmc7XG4gIC8qKiBTZXRzIHRoZSB0aXRsZSB0byBiZSByZW5kZXJlZCBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgZm9yIGNoYW5nZSBkZXRlY3Rpb24gd2hlbmV2ZXIgdGhlIGNvbnRlbnQgY2hpbGRyZW4gcXVlcnkgY2hhbmdlc1xuICAgIHRoaXMuX3N0ZXBzLmNoYW5nZXNcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlZCgpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzUHJldmlvdXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggLSAxKSA+PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSA8IHRoaXMuY291bnQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzID8gdGhpcy5fc3RlcHMubGVuZ3RoIDogMDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBjdXJyZW50U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuX3N0ZXBzLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gc3RlcHNbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBuZXh0U3RlcCgpOiBOeFN0ZXBDb21wb25lbnQgfCBudWxsIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ICsgMSA+PSB0aGlzLl9zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RlcHMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleCArIDFdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBzdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcHM7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgY3VycmVudExhYmVsKCkge1xuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmN1cnJlbnRTdGVwO1xuICAgIGNvbnN0IGxhYmVsID0gc3RlcC5zdGVwTGFiZWwgfHwgc3RlcC5sYWJlbDtcblxuICAgIHJldHVybiBgXG4gICAgJHt0aGlzLmN1cnJlbnRTdGVwTGFiZWx9ICR7dGhpcy5zZWxlY3RlZEluZGV4ICsgMX0vJHt0aGlzLmNvdW50fTogJHtsYWJlbH1cbiAgICBgO1xuICB9XG59XG5cbiJdfQ==