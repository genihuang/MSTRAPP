/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CdkStepper, CdkStepperNext, CdkStepperPrevious } from '@angular/cdk/stepper';
import { ChangeDetectorRef, Directive } from '@angular/core';
import { NxProgressStepperDirective } from './progress-stepper.component';
// tslint:disable:use-input-property-decorator
export class NxStepperNextDirective extends CdkStepperNext {
    /**
     * @param {?} _stepper
     * @param {?} changeDetectorRef
     */
    constructor(_stepper, changeDetectorRef) {
        super(_stepper);
        this.changeDetectorRef = changeDetectorRef;
        /**
         * \@docs-private
         */
        this.disabled = false;
    }
    /**
     * Implemented to prevent changed after checked error after stepper init.
     * When the stepper initializes the directive is checked first before
     * the stepper can check its content thus it doesn't know about it's children yet
     * so _stepper.hasNext returns false and disables the buttons. In the same CD cycle
     * after the stepper has checked its contents the button needs to be enabled resulting
     * in the error.
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const stepper = (/** @type {?} */ (this._stepper));
        if (this.disabled !== !stepper.hasNext) {
            this.disabled = !stepper.hasNext;
            this.changeDetectorRef.markForCheck();
        }
    }
}
NxStepperNextDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[nxStepperNext]',
                host: {
                    '(click)': '_stepper.next()',
                    '[type]': 'type',
                    '[disabled]': 'disabled'
                },
                inputs: ['type'],
                providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
            },] }
];
/** @nocollapse */
NxStepperNextDirective.ctorParameters = () => [
    { type: CdkStepper },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    NxStepperNextDirective.prototype.disabled;
    /**
     * @type {?}
     * @private
     */
    NxStepperNextDirective.prototype.changeDetectorRef;
}
export class NxStepperPreviousDirective extends CdkStepperPrevious {
    /**
     * @param {?} _stepper
     * @param {?} changeDetectorRef
     */
    constructor(_stepper, changeDetectorRef) {
        super(_stepper);
        this.changeDetectorRef = changeDetectorRef;
    }
}
NxStepperPreviousDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[nxStepperPrevious]',
                host: {
                    '(click)': '_stepper.previous()',
                    '[type]': 'type',
                    '[disabled]': '!_stepper.hasPrevious'
                },
                inputs: ['type'],
                providers: [{ provide: CdkStepper, useExisting: NxProgressStepperDirective }]
            },] }
];
/** @nocollapse */
NxStepperPreviousDirective.ctorParameters = () => [
    { type: CdkStepper },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxStepperPreviousDirective.prototype.changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9ucy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4L3Byb2dyZXNzLXN0ZXBwZXIvIiwic291cmNlcyI6WyJidXR0b25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxTQUFTLEVBQW1CLE1BQU0sZUFBZSxDQUFDO0FBRTlFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLDhCQUE4QixDQUFDOztBQWMxRSxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsY0FBYzs7Ozs7SUFLeEQsWUFBWSxRQUFvQixFQUFVLGlCQUFvQztRQUM1RSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFEd0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjs7OztRQUY5RSxhQUFRLEdBQUcsS0FBSyxDQUFDO0lBSWpCLENBQUM7Ozs7Ozs7Ozs7SUFVRCxTQUFTOztjQUNELE9BQU8sR0FBRyxtQkFBQSxJQUFJLENBQUMsUUFBUSxFQUE4QjtRQUMzRCxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO1lBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN2QztJQUNILENBQUM7OztZQWpDRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsSUFBSSxFQUFFO29CQUNKLFNBQVMsRUFBRSxpQkFBaUI7b0JBQzVCLFFBQVEsRUFBRSxNQUFNO29CQUNoQixZQUFZLEVBQUUsVUFBVTtpQkFDekI7Z0JBQ0QsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDO2dCQUNoQixTQUFTLEVBQUUsQ0FBQyxFQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLDBCQUEwQixFQUFDLENBQUM7YUFDNUU7Ozs7WUFoQlEsVUFBVTtZQUNWLGlCQUFpQjs7Ozs7OztJQW1CeEIsMENBQWlCOzs7OztJQUVpQixtREFBNEM7O0FBK0JoRixNQUFNLE9BQU8sMEJBQTJCLFNBQVEsa0JBQWtCOzs7OztJQUNoRSxZQUFZLFFBQW9CLEVBQVUsaUJBQW9DO1FBQzVFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUR3QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO0lBRTlFLENBQUM7OztZQWJGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxJQUFJLEVBQUU7b0JBQ0osU0FBUyxFQUFFLHFCQUFxQjtvQkFDaEMsUUFBUSxFQUFFLE1BQU07b0JBQ2hCLFlBQVksRUFBRSx1QkFBdUI7aUJBQ3RDO2dCQUNELE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQztnQkFDaEIsU0FBUyxFQUFFLENBQUMsRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSwwQkFBMEIsRUFBQyxDQUFDO2FBQzVFOzs7O1lBcERRLFVBQVU7WUFDVixpQkFBaUI7Ozs7Ozs7SUFxRFUsdURBQTRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrU3RlcHBlciwgQ2RrU3RlcHBlck5leHQsIENka1N0ZXBwZXJQcmV2aW91cyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIERvQ2hlY2ssIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBOeFByb2dyZXNzU3RlcHBlckRpcmVjdGl2ZSB9IGZyb20gJy4vcHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQnO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTp1c2UtaW5wdXQtcHJvcGVydHktZGVjb3JhdG9yXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2J1dHRvbltueFN0ZXBwZXJOZXh0XScsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdfc3RlcHBlci5uZXh0KCknLFxuICAgICdbdHlwZV0nOiAndHlwZScsXG4gICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gIH0sXG4gIGlucHV0czogWyd0eXBlJ10sXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmV9XVxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBwZXJOZXh0RGlyZWN0aXZlIGV4dGVuZHMgQ2RrU3RlcHBlck5leHQgaW1wbGVtZW50cyBEb0NoZWNrIHtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKF9zdGVwcGVyOiBDZGtTdGVwcGVyLCBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKF9zdGVwcGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRlZCB0byBwcmV2ZW50IGNoYW5nZWQgYWZ0ZXIgY2hlY2tlZCBlcnJvciBhZnRlciBzdGVwcGVyIGluaXQuXG4gICAqIFdoZW4gdGhlIHN0ZXBwZXIgaW5pdGlhbGl6ZXMgdGhlIGRpcmVjdGl2ZSBpcyBjaGVja2VkIGZpcnN0IGJlZm9yZVxuICAgKiB0aGUgc3RlcHBlciBjYW4gY2hlY2sgaXRzIGNvbnRlbnQgdGh1cyBpdCBkb2Vzbid0IGtub3cgYWJvdXQgaXQncyBjaGlsZHJlbiB5ZXRcbiAgICogc28gX3N0ZXBwZXIuaGFzTmV4dCByZXR1cm5zIGZhbHNlIGFuZCBkaXNhYmxlcyB0aGUgYnV0dG9ucy4gSW4gdGhlIHNhbWUgQ0QgY3ljbGVcbiAgICogYWZ0ZXIgdGhlIHN0ZXBwZXIgaGFzIGNoZWNrZWQgaXRzIGNvbnRlbnRzIHRoZSBidXR0b24gbmVlZHMgdG8gYmUgZW5hYmxlZCByZXN1bHRpbmdcbiAgICogaW4gdGhlIGVycm9yLlxuICAgKi9cbiAgbmdEb0NoZWNrKCkge1xuICAgIGNvbnN0IHN0ZXBwZXIgPSB0aGlzLl9zdGVwcGVyIGFzIE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlO1xuICAgIGlmICh0aGlzLmRpc2FibGVkICE9PSAhc3RlcHBlci5oYXNOZXh0KSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gIXN0ZXBwZXIuaGFzTmV4dDtcbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2J1dHRvbltueFN0ZXBwZXJQcmV2aW91c10nLFxuICBob3N0OiB7XG4gICAgJyhjbGljayknOiAnX3N0ZXBwZXIucHJldmlvdXMoKScsXG4gICAgJ1t0eXBlXSc6ICd0eXBlJyxcbiAgICAnW2Rpc2FibGVkXSc6ICchX3N0ZXBwZXIuaGFzUHJldmlvdXMnXG4gIH0sXG4gIGlucHV0czogWyd0eXBlJ10sXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmV9XVxufSlcbmV4cG9ydCBjbGFzcyBOeFN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZSBleHRlbmRzIENka1N0ZXBwZXJQcmV2aW91cyB7XG4gIGNvbnN0cnVjdG9yKF9zdGVwcGVyOiBDZGtTdGVwcGVyLCBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKF9zdGVwcGVyKTtcbiAgfVxuXG59XG4iXX0=