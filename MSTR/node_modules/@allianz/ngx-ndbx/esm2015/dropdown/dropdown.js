/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxFormfieldComponent, NxFormfieldControl } from '@allianz/ngx-ndbx/formfield';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, SHIFT, TAB } from '@angular/cdk/keycodes';
import { CdkConnectedOverlay } from '@angular/cdk/overlay';
import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Input, isDevMode, NgZone, Optional, Output, Self, ViewChild, TemplateRef, ContentChild, } from '@angular/core';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { defer, merge, Observable, Subject } from 'rxjs';
import { filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';
import { getNxDropdownNonArrayValueError, getNxDropdownNonFunctionValueError } from './dropdown-errors';
import { NxDropdownControl } from './dropdown.control';
import { NxDropdownGroupComponent } from './group/dropdown-group';
import { NxDropdownItemComponent } from './item/dropdown-item';
import { NxDropdownClosedLabelDirective } from './closed-label.directive';
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
export class NxDropdownSelectChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
if (false) {
    /**
     * Reference to the select that emitted the change event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.source;
    /**
     * Current value of the select that emitted the event.
     * @type {?}
     */
    NxDropdownSelectChange.prototype.value;
}
// used in calculation of scrolltop to correctly show some space to the top of the panel
/** @type {?} */
const itemPadding = 16;
// Max-height: 6 items x 44px + 16px padding before first item
/** @type {?} */
export const SELECT_PANEL_MAX_HEIGHT = 280;
export class NxDropdownComponent extends NxDropdownControl {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?} tabIndex
     * @param {?} formFieldComponent
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        this._panelOpen = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * The scroltop of the panelBody.
         */
        this._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */
        this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        this._optionIds = '';
        this._tabIndex = 0;
        /**
         * \@docs-private
         */
        this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        this._ariaLabel = '';
        this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        this._openedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the select has been closed.
         */
        this._closedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        () => {
            if (this.options) {
                return merge(...this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelectionChanges)));
        }));
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */
        this._positions = [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        (search, itemValue) => {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * `View -> model callback called when select has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * @return {?}
     */
    get tabIndex() { return this.disabled ? -1 : this._tabIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /**
     * Selected value
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /**
     * Whether the dropdown is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * If set to 'negative', the component is displayed with the negative set of styles.
     * @param {?} value
     * @return {?}
     */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /**
     * \@docs-private
     * The currently selected option.
     * @return {?}
     */
    get selected() {
        return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get label() {
        return this.formFieldComponent ? this.formFieldComponent.label : '';
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     * @return {?}
     */
    get compareWith() { return this._compareWith; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value. The dropdown items will use this function to set their
     * visibility state.
     * A boolean should be returned.
     * @return {?}
     */
    get filterFn() { return this._filterFn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set filterFn(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._filterFn = fn;
    }
    /**
     * \@docs-private
     * Whether the select is focused.
     * @return {?}
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.onChange.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.select()));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.deselect()));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._resetOptions();
            this._initializeSelection();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hidden));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._panelOpen && this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => this._scrollActiveOptionIntoView()));
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _resetOptions() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !this.isMultiSelect && this._panelOpen) {
                this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._stateChanges)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    }
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    _setOptionIds() {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.id)).join(' ');
    }
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    _onSelect(option, isUserInput) {
        /** @type {?} */
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
                if (isUserInput) {
                    // In case the user selected the option with their mouse, we
                    // want to restore focus back to the trigger, in order to
                    // prevent the select keyboard controls from clashing with
                    // the ones from `mat-option`.
                    this.focus();
                }
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        }));
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    _setSelectionByValue(value) {
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            (currentValue) => this._selectValue(currentValue)));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    _selectValue(value) {
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    _propagateChanges(fallbackValue) {
        /** @type {?} */
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    _sortValues() {
        if (this.isMultiSelect) {
            /** @type {?} */
            const options = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => options.indexOf(a) - options.indexOf(b)));
            this.stateChanges.next();
        }
    }
    /**
     * Focuses the select element.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    openPanel() {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            () => this.focus()));
        }
    }
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    _calculateScrollTop() {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        this._scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            const offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */
            const activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                // to middle out the text a bit more add half of the height
                // (this is still a few pixels off because the container is a bit larger than the font)
                this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
                this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
        }
    }
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    _scrollActiveOptionIntoView() {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        const activeOptionIndex = this._keyManager.activeItemIndex || 0;
        /** @type {?} */
        const itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);
        this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
    }
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
        if (optionGroups.length) {
            /** @type {?} */
            const optionsArray = options.toArray();
            /** @type {?} */
            const groups = optionGroups.toArray();
            /** @type {?} */
            let groupCounter = 0;
            for (let i = 0; i < optionIndex + 1; i++) {
                if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                    groupCounter++;
                }
            }
            return groupCounter;
        }
        return 0;
    }
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    _getOptionScrollPosition(optionIndex, optionHeight, currentScrollPosition, panelHeight) {
        /** @type {?} */
        let optionOffset = optionIndex * optionHeight + itemPadding;
        if (this.showFilter) {
            /** @type {?} */
            const filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
        }
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    _getItemOffset(item) {
        /** @type {?} */
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top;
    }
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @return {?}
     */
    _getAriaLabel() {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    }
    /**
     * \@docs-private
     * Whether the select has a value.
     * @return {?}
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleClosedKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleOpenKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)) {
            return;
        }
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        const manager = this._keyManager;
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * \@docs-private
     * The value displayed in the trigger.
     * @return {?}
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            /** @type {?} */
            const selectedOptions = this._selectionModel.selected.map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.viewValue));
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    _onAttached() {
        this._changeDetectorRef.markForCheck();
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.panelBody.nativeElement.focus();
            if (this._keyManager.activeItem) {
                this._calculateScrollTop();
            }
            this._changeDetectorRef.markForCheck();
            this.openedChange.emit(true);
            if (this.showFilter) {
                this.filterInput.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _clearFilter() {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
NxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown',
                template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                    { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                ],
                host: {
                    'role': 'button',
                    '[class.nx-dropdown]': 'true',
                    '[class.is-filled]': 'hasValue',
                    '[class.has-focus]': 'focused',
                    '[class.nx-dropdown--negative]': '_negative',
                    '[class.nx-dropdown--disabled]': 'disabled',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-required]': 'required',
                    '[attr.aria-label]': '_getAriaLabel()',
                    '[attr.aria-haspopup]': '"listbox"',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'openPanel()'
                },
                styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
            }] }
];
/** @nocollapse */
NxDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxDropdownComponent.propDecorators = {
    tabIndex: [{ type: Input }],
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input, args: ['nxRequired',] }],
    styles: [{ type: Input, args: ['nxStyle',] }],
    showFilter: [{ type: Input, args: ['nxShowFilter',] }],
    filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
    openedChange: [{ type: Output }],
    _openedStream: [{ type: Output, args: ['opened',] }],
    _closedStream: [{ type: Output, args: ['closed',] }],
    filterChanges: [{ type: Output, args: ['filterInput',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    selectionChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel',] }],
    panelBody: [{ type: ViewChild, args: ['panelBody',] }],
    trigger: [{ type: ViewChild, args: ['trigger',] }],
    filterInput: [{ type: ViewChild, args: ['filterInput',] }],
    overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
    groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
    _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective,] }],
    _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
    compareWith: [{ type: Input }],
    filterFn: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NxDropdownComponent.prototype.readonly;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._selectionModel;
    /**
     * @type {?}
     * @protected
     */
    NxDropdownComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._focused;
    /**
     * Whether or not the overlay panel is open.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._panelOpen;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.errorState;
    /**
     * Holds the value from nxValue.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._value;
    /**
     * The scroltop of the panelBody.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._scrollTop;
    /**
     * The minimal space between the viewport and the overlay
     * @type {?}
     */
    NxDropdownComponent.prototype._overlayViewportMargin;
    /**
     * The last measured value for the trigger's client bounding rect.
     * @type {?}
     */
    NxDropdownComponent.prototype._triggerRect;
    /**
     * Holds the panelWidth after panel was attached.
     * @type {?}
     */
    NxDropdownComponent.prototype._panelWidth;
    /**
     * \@docs-private
     * Emits when internal state changes to inform formfield about it.
     * @type {?}
     */
    NxDropdownComponent.prototype.stateChanges;
    /**
     * The IDs of child options to be passed to the aria-owns attribute.
     * @type {?}
     */
    NxDropdownComponent.prototype._optionIds;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ariaDescribedby;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._tabIndex;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.currentFilter;
    /**
     * Label to describe the component.
     * @type {?}
     */
    NxDropdownComponent.prototype._ariaLabel;
    /**
     * Whether the component is required. This adds an aria-required label to the component.
     * @type {?}
     */
    NxDropdownComponent.prototype.required;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._style;
    /**
     * Whether the dropdown should render in its negative style or not.
     * @type {?}
     */
    NxDropdownComponent.prototype._negative;
    /**
     * Whether the dropdown should be shown with an additional filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.showFilter;
    /**
     * Text displayed as placeholder for the filter.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterPlaceholder;
    /**
     * Event emitted when the select panel has been toggled.
     * @type {?}
     */
    NxDropdownComponent.prototype.openedChange;
    /**
     * Event emitted when the select has been opened.
     * @type {?}
     */
    NxDropdownComponent.prototype._openedStream;
    /**
     * Event emitted when the select has been closed.
     * @type {?}
     */
    NxDropdownComponent.prototype._closedStream;
    /**
     * Event emitted when the user types in the filter input.
     * @type {?}
     */
    NxDropdownComponent.prototype.filterChanges;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.valueChange;
    /**
     * Event emitted when the selected value has been changed.
     * @type {?}
     */
    NxDropdownComponent.prototype.selectionChange;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.optionSelectionChanges;
    /**
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     * @type {?}
     */
    NxDropdownComponent.prototype._positions;
    /**
     * \@docs-private
     * Panel containing the select options.
     * @type {?}
     */
    NxDropdownComponent.prototype.panel;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.panelBody;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.trigger;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.filterInput;
    /**
     * \@docs-private
     * Overlay pane containing the options.
     * @type {?}
     */
    NxDropdownComponent.prototype.overlayDir;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.options;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.groups;
    /** @type {?} */
    NxDropdownComponent.prototype._customClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._defaultClosedDropdownLabel;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._closedDropdownLabel;
    /**
     * Emits whenever the component is destroyed.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._destroy;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._keyManager;
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content
     * ( Default: (value) => value ? value.toString() : null; ).
     * @type {?}
     */
    NxDropdownComponent.prototype.valueFormatter;
    /**
     * Comparison function to specify which option is displayed. Defaults to object equality.
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._compareWith;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._filterFn;
    /**
     * `View -> model callback called when value changes`
     * @type {?}
     */
    NxDropdownComponent.prototype._onChange;
    /**
     * `View -> model callback called when select has been touched`
     * @type {?}
     */
    NxDropdownComponent.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype.formFieldComponent;
    /**
     * \@docs-private
     * @type {?}
     */
    NxDropdownComponent.prototype.ngControl;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentForm;
    /**
     * @type {?}
     * @private
     */
    NxDropdownComponent.prototype._parentFormGroup;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC8iLCJzb3VyY2VzIjpbImRyb3Bkb3duL2Ryb3Bkb3duLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN2RixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzNILE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzNELE9BQU8sRUFFTCxTQUFTLEVBQ1QsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsZUFBZSxFQUVmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBR04sUUFBUSxFQUNSLE1BQU0sRUFFTixJQUFJLEVBQ0osU0FBUyxFQUNULFdBQVcsRUFDWCxZQUFZLEdBQ2IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFxQyxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUcsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwRixPQUFPLEVBQUUs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OztJQVFILHlDQWVHOzs7Ozs7SUFPSCxvQ0FBc0M7Ozs7O0lBR3RDLHdDQUE4Qzs7Ozs7SUFHOUMsc0NBQTBDOzs7OztJQUcxQywwQ0FBa0Q7Ozs7OztJQU1sRCx5Q0FBZ0U7Ozs7O0lBR2hFLHNDQUF5RTs7Ozs7SUFHekUscUNBQWtEOztJQUVsRCx5REFDMkQ7Ozs7O0lBRTNELDBEQUNzRDs7Ozs7SUFNdEQsbURBQStDOzs7Ozs7SUFHL0MsdUNBQWdEOzs7OztJQVVoRCwwQ0FBeUU7Ozs7Ozs7SUFlekUsNkNBRUM7Ozs7OztJQVFELDJDQUF1RDs7Ozs7SUFvQnZELHdDQUVDOzs7OztJQTBCRCx3Q0FBNEM7Ozs7O0lBRzVDLHlDQUF1Qjs7Ozs7SUFRckIsaURBQTZDOzs7OztJQUM3QywwQ0FBK0I7Ozs7O0lBQy9CLHNDQUF1Qjs7Ozs7SUFFdkIsaURBQTREOzs7OztJQUU1RCx3Q0FBK0M7Ozs7O0lBQy9DLDBDQUF1Qzs7Ozs7SUFDdkMsK0NBQXdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTnhGb3JtZmllbGRDb21wb25lbnQsIE54Rm9ybWZpZWxkQ29udHJvbCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2Zvcm1maWVsZCc7XG5pbXBvcnQgeyBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IERPV05fQVJST1csIEVORCwgRU5URVIsIEhPTUUsIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBTUEFDRSwgVVBfQVJST1csIFNISUZULCBUQUIgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgQ2RrQ29ubmVjdGVkT3ZlcmxheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEF0dHJpYnV0ZSxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRG9DaGVjayxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgaXNEZXZNb2RlLFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNlbGYsXG4gIFZpZXdDaGlsZCxcbiAgVGVtcGxhdGVSZWYsXG4gIENvbnRlbnRDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cERpcmVjdGl2ZSwgTmdDb250cm9sLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBkZWZlciwgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBnZXROeERyb3Bkb3duTm9uQXJyYXlWYWx1ZUVycm9yLCBnZXROeERyb3Bkb3duTm9uRnVuY3Rpb25WYWx1ZUVycm9yIH0gZnJvbSAnLi9kcm9wZG93bi1lcnJvcnMnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkNvbnRyb2wgfSBmcm9tICcuL2Ryb3Bkb3duLmNvbnRyb2wnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9ncm91cC9kcm9wZG93bi1ncm91cCc7XG5pbXBvcnQgeyBOeERyb3Bkb3duSXRlbUNoYW5nZSwgTnhEcm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2l0ZW0vZHJvcGRvd24taXRlbSc7XG5pbXBvcnQgeyBOeERyb3Bkb3duQ2xvc2VkTGFiZWxEaXJlY3RpdmUgfSBmcm9tICcuL2Nsb3NlZC1sYWJlbC5kaXJlY3RpdmUnO1xuXG5cbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgdmFsdWUgaGFzIGNoYW5nZWQuICovXG5leHBvcnQgY2xhc3MgTnhEcm9wZG93blNlbGVjdENoYW5nZTxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHNlbGVjdCB0aGF0IGVtaXR0ZWQgdGhlIGNoYW5nZSBldmVudC4gKi9cbiAgICBwdWJsaWMgc291cmNlOiBOeERyb3Bkb3duQ29tcG9uZW50LFxuICAgIC8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBzZWxlY3QgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBwdWJsaWMgdmFsdWU6IFQpIHsgfVxufVxuXG4vLyB1c2VkIGluIGNhbGN1bGF0aW9uIG9mIHNjcm9sbHRvcCB0byBjb3JyZWN0bHkgc2hvdyBzb21lIHNwYWNlIHRvIHRoZSB0b3Agb2YgdGhlIHBhbmVsXG5jb25zdCBpdGVtUGFkZGluZyA9IDE2O1xuXG4vLyBNYXgtaGVpZ2h0OiA2IGl0ZW1zIHggNDRweCArIDE2cHggcGFkZGluZyBiZWZvcmUgZmlyc3QgaXRlbVxuZXhwb3J0IGNvbnN0IFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gMjgwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdueC1kcm9wZG93bicsXG4gIHRlbXBsYXRlVXJsOiAnZHJvcGRvd24uaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBzdHlsZVVybHM6IFsnZHJvcGRvd24uc2NzcyddLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IE54RHJvcGRvd25Db250cm9sLCB1c2VFeGlzdGluZzogTnhEcm9wZG93bkNvbXBvbmVudCB9LFxuICAgIHsgcHJvdmlkZTogTnhGb3JtZmllbGRDb250cm9sLCB1c2VFeGlzdGluZzogTnhEcm9wZG93bkNvbXBvbmVudCB9LFxuICBdLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmlzLWZpbGxlZF0nOiAnaGFzVmFsdWUnLFxuICAgICdbY2xhc3MuaGFzLWZvY3VzXSc6ICdmb2N1c2VkJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duLS1uZWdhdGl2ZV0nOiAnX25lZ2F0aXZlJyxcbiAgICAnW2NsYXNzLm54LWRyb3Bkb3duLS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkYnkgfHwgbnVsbCcsXG4gICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnX2dldEFyaWFMYWJlbCgpJyxcbiAgICAnW2F0dHIuYXJpYS1oYXNwb3B1cF0nOiAnXCJsaXN0Ym94XCInLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4nLFxuICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQgfHwgbnVsbCcsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgJyhjbGljayknOiAnb3BlblBhbmVsKCknXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIE54RHJvcGRvd25Db250cm9sIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBEb0NoZWNrIHtcblxuICAvLyBUaGUgZHJvcGRvd24gY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCByZWFkb25seSBvZiB0aGUgTnhGb3JtZmllbGRDb250cm9sIHNvIHdlIGhhcmRjb2RlIGl0IGhlcmVcbiAgcmVhZG9ubHkgcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9zZWxlY3Rpb25Nb2RlbDogU2VsZWN0aW9uTW9kZWw8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+O1xuXG4gIHByb3RlY3RlZCBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gIHByaXZhdGUgX3BhbmVsT3BlbiA9IGZhbHNlO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGVycm9yU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogSG9sZHMgdGhlIHZhbHVlIGZyb20gbnhWYWx1ZS4gKi9cbiAgcHJpdmF0ZSBfdmFsdWU6IGFueTtcblxuICAvKiogVGhlIHNjcm9sdG9wIG9mIHRoZSBwYW5lbEJvZHkuICovXG4gIHByaXZhdGUgX3Njcm9sbFRvcDogbnVtYmVyID0gMDtcblxuICAvKiogVGhlIG1pbmltYWwgc3BhY2UgYmV0d2VlbiB0aGUgdmlld3BvcnQgYW5kIHRoZSBvdmVybGF5ICovXG4gIF9vdmVybGF5Vmlld3BvcnRNYXJnaW46IG51bWJlciA9IDE2O1xuXG4gIC8qKiBUaGUgbGFzdCBtZWFzdXJlZCB2YWx1ZSBmb3IgdGhlIHRyaWdnZXIncyBjbGllbnQgYm91bmRpbmcgcmVjdC4gKi9cbiAgX3RyaWdnZXJSZWN0OiBDbGllbnRSZWN0O1xuXG4gIC8qKiBIb2xkcyB0aGUgcGFuZWxXaWR0aCBhZnRlciBwYW5lbCB3YXMgYXR0YWNoZWQuICovXG4gIF9wYW5lbFdpZHRoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogRW1pdHMgd2hlbiBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIHRvIGluZm9ybSBmb3JtZmllbGQgYWJvdXQgaXQuXG4gICAqL1xuICByZWFkb25seSBzdGF0ZUNoYW5nZXMgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuICovXG4gIF9vcHRpb25JZHM6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGFyaWFEZXNjcmliZWRieTogc3RyaW5nO1xuXG4gIHByaXZhdGUgX3RhYkluZGV4OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGN1cnJlbnRGaWx0ZXI6IHN0cmluZyA9ICcnO1xuXG5cbiAgQElucHV0KClcbiAgZ2V0IHRhYkluZGV4KCk6IG51bWJlciB7IHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiB0aGlzLl90YWJJbmRleDsgfVxuICBzZXQgdGFiSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgdGFiSW5kZXggdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICB0aGlzLl90YWJJbmRleCA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IDA7XG4gIH1cblxuICAvKiogTGFiZWwgdG8gZGVzY3JpYmUgdGhlIGNvbXBvbmVudC4gKi9cbiAgQElucHV0KCdueEFyaWFMYWJlbCcpIF9hcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBTZWxlY3RlZCB2YWx1ZSAqL1xuICBASW5wdXQoJ254VmFsdWUnKVxuICBnZXQgdmFsdWUoKTogYW55IHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZTogYW55KSB7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy53cml0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9vbkNoYW5nZShuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGRyb3Bkb3duIGlzIGRpc2FibGVkLiAqL1xuICBASW5wdXQoJ254RGlzYWJsZWQnKVxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWU7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlcXVpcmVkLiBUaGlzIGFkZHMgYW4gYXJpYS1yZXF1aXJlZCBsYWJlbCB0byB0aGUgY29tcG9uZW50LiAqL1xuICBASW5wdXQoJ254UmVxdWlyZWQnKSByZXF1aXJlZDogYm9vbGVhbjtcblxuICBwcml2YXRlIF9zdHlsZTogc3RyaW5nID0gJyc7XG4gIC8qKiBXaGV0aGVyIHRoZSBkcm9wZG93biBzaG91bGQgcmVuZGVyIGluIGl0cyBuZWdhdGl2ZSBzdHlsZSBvciBub3QuICovXG4gIF9uZWdhdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBJZiBzZXQgdG8gJ25lZ2F0aXZlJywgdGhlIGNvbXBvbmVudCBpcyBkaXNwbGF5ZWQgd2l0aCB0aGUgbmVnYXRpdmUgc2V0IG9mIHN0eWxlcy4gKi9cbiAgQElucHV0KCdueFN0eWxlJylcbiAgc2V0IHN0eWxlcyh2YWx1ZTogc3RyaW5nKSB7XG5cbiAgICBpZiAodGhpcy5fc3R5bGUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3R5bGUgPSB2YWx1ZTtcbiAgICB0aGlzLl9uZWdhdGl2ZSA9ICEhdGhpcy5fc3R5bGUubWF0Y2goL25lZ2F0aXZlLyk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIHNob3duIHdpdGggYW4gYWRkaXRpb25hbCBmaWx0ZXIgaW5wdXQuICovXG4gIEBJbnB1dCgnbnhTaG93RmlsdGVyJykgc2hvd0ZpbHRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUZXh0IGRpc3BsYXllZCBhcyBwbGFjZWhvbGRlciBmb3IgdGhlIGZpbHRlci4gKi9cbiAgQElucHV0KCdueEZpbHRlclBsYWNlaG9sZGVyJykgZmlsdGVyUGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBwYW5lbCBoYXMgYmVlbiB0b2dnbGVkLiAqL1xuICBAT3V0cHV0KCkgcmVhZG9ubHkgb3BlbmVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgnb3BlbmVkJykgcmVhZG9ubHkgX29wZW5lZFN0cmVhbTogT2JzZXJ2YWJsZTx2b2lkPiA9XG4gICAgdGhpcy5vcGVuZWRDaGFuZ2UucGlwZShmaWx0ZXIobyA9PiBvKSwgbWFwKCgpID0+IHsgfSkpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBjbG9zZWQuICovXG4gIEBPdXRwdXQoJ2Nsb3NlZCcpIHJlYWRvbmx5IF9jbG9zZWRTdHJlYW06IE9ic2VydmFibGU8dm9pZD4gPVxuICAgIHRoaXMub3BlbmVkQ2hhbmdlLnBpcGUoZmlsdGVyKG8gPT4gIW8pLCBtYXAoKCkgPT4geyB9KSk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdXNlciB0eXBlcyBpbiB0aGUgZmlsdGVyIGlucHV0LiAqL1xuICBAT3V0cHV0KCdmaWx0ZXJJbnB1dCcpIHJlYWRvbmx5IGZpbHRlckNoYW5nZXM6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzZWxlY3QgY2hhbmdlcy4gVGhpcyBpcyBoZXJlIHByaW1hcmlseVxuICAgKiB0byBmYWNpbGl0YXRlIHRoZSB0d28td2F5IGJpbmRpbmcgZm9yIHRoZSBgdmFsdWVgIGlucHV0LlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqL1xuICBAT3V0cHV0KCdueFZhbHVlQ2hhbmdlJykgcmVhZG9ubHkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPE54RHJvcGRvd25TZWxlY3RDaGFuZ2U+ID1cbiAgICBuZXcgRXZlbnRFbWl0dGVyPE54RHJvcGRvd25TZWxlY3RDaGFuZ2U+KCk7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgcmVhZG9ubHkgb3B0aW9uU2VsZWN0aW9uQ2hhbmdlczogT2JzZXJ2YWJsZTxOeERyb3Bkb3duSXRlbUNoYW5nZT4gPSBkZWZlcjxPYnNlcnZhYmxlPE54RHJvcGRvd25JdGVtQ2hhbmdlPj4oKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtZXJnZSguLi50aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24ub25TZWxlY3Rpb25DaGFuZ2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbmdab25lLm9uU3RhYmxlXG4gICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgIC5waXBlKHRha2UoMSksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLm9wdGlvblNlbGVjdGlvbkNoYW5nZXMpKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgcG9zaXRpb24gY29uZmlnIGVuc3VyZXMgdGhhdCB0aGUgdG9wIFwic3RhcnRcIiBjb3JuZXIgb2YgdGhlIG92ZXJsYXlcbiAgICogaXMgYWxpZ25lZCB3aXRoIHdpdGggdGhlIHRvcCBcInN0YXJ0XCIgb2YgdGhlIG9yaWdpbiBieSBkZWZhdWx0IChvdmVybGFwcGluZ1xuICAgKiB0aGUgdHJpZ2dlciBjb21wbGV0ZWx5KS4gSWYgdGhlIHBhbmVsIGNhbm5vdCBmaXQgYmVsb3cgdGhlIHRyaWdnZXIsIGl0XG4gICAqIHdpbGwgZmFsbCBiYWNrIHRvIGEgcG9zaXRpb24gYWJvdmUgdGhlIHRyaWdnZXIuXG4gICAqL1xuICBfcG9zaXRpb25zID0gW3tcbiAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgIG9yaWdpblk6ICd0b3AnLFxuICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgIG92ZXJsYXlZOiAndG9wJ1xuICB9LCB7XG4gICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICBvdmVybGF5WTogJ2NlbnRlcidcbiAgfSwge1xuICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgb3ZlcmxheVk6ICdib3R0b20nXG4gIH1dO1xuXG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogUGFuZWwgY29udGFpbmluZyB0aGUgc2VsZWN0IG9wdGlvbnMuXG4gICAqL1xuICBAVmlld0NoaWxkKCdwYW5lbCcpIHBhbmVsOiBFbGVtZW50UmVmO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsQm9keScpIHBhbmVsQm9keTogRWxlbWVudFJlZjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKCd0cmlnZ2VyJykgdHJpZ2dlcjogRWxlbWVudFJlZjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKCdmaWx0ZXJJbnB1dCcpIGZpbHRlcklucHV0OiBFbGVtZW50UmVmO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIE92ZXJsYXkgcGFuZSBjb250YWluaW5nIHRoZSBvcHRpb25zLlxuICAgKi9cbiAgQFZpZXdDaGlsZChDZGtDb25uZWN0ZWRPdmVybGF5KSBvdmVybGF5RGlyOiBDZGtDb25uZWN0ZWRPdmVybGF5O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTnhEcm9wZG93bkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSkgb3B0aW9ucztcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAQ29udGVudENoaWxkcmVuKE54RHJvcGRvd25Hcm91cENvbXBvbmVudCkgZ3JvdXBzO1xuXG4gIEBDb250ZW50Q2hpbGQoTnhEcm9wZG93bkNsb3NlZExhYmVsRGlyZWN0aXZlKVxuICBfY3VzdG9tQ2xvc2VkRHJvcGRvd25MYWJlbDogTnhEcm9wZG93bkNsb3NlZExhYmVsRGlyZWN0aXZlO1xuXG4gIEBWaWV3Q2hpbGQoJ2RlZmF1bHRDbG9zZWREcm9wZG93bkxhYmVsJylcbiAgcHJpdmF0ZSBfZGVmYXVsdENsb3NlZERyb3Bkb3duTGFiZWw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGNsb3NlZERyb3Bkb3duTGFiZWwoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZERyb3Bkb3duTGFiZWw7XG4gIH1cbiAgcHJpdmF0ZSBfY2xvc2VkRHJvcGRvd25MYWJlbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogRW1pdHMgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkKCk6IE54RHJvcGRvd25JdGVtQ29tcG9uZW50IHwgTnhEcm9wZG93bkl0ZW1Db21wb25lbnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXNNdWx0aVNlbGVjdCA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF07XG4gIH1cblxuICBwcml2YXRlIF9rZXlNYW5hZ2VyOiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeERyb3Bkb3duSXRlbUNvbXBvbmVudD47XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IHBhbmVsT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICB9XG4gIHNldCBwYW5lbE9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9wYW5lbE9wZW4gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHZhbHVlIGludG8gYSBzdHJpbmcuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgZGlzcGxheWluZyBhbmQgZmlsdGVyaW5nIHRoZSBjb250ZW50XG4gICAqICggRGVmYXVsdDogKHZhbHVlKSA9PiB2YWx1ZSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsOyApLlxuICAgKi9cbiAgQElucHV0KCdueFZhbHVlRm9ybWF0dGVyJykgdmFsdWVGb3JtYXR0ZXIgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmZvcm1GaWVsZENvbXBvbmVudCA/IHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50LmxhYmVsIDogJyc7XG4gIH1cblxuICAvKiogQ29tcGFyaXNvbiBmdW5jdGlvbiB0byBzcGVjaWZ5IHdoaWNoIG9wdGlvbiBpcyBkaXNwbGF5ZWQuIERlZmF1bHRzIHRvIG9iamVjdCBlcXVhbGl0eS4gKi9cbiAgcHJpdmF0ZSBfY29tcGFyZVdpdGggPSAobzE6IGFueSwgbzI6IGFueSkgPT4gbzEgPT09IG8yO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjb21wYXJlIHRoZSBvcHRpb24gdmFsdWVzIHdpdGggdGhlIHNlbGVjdGVkIHZhbHVlcy4gVGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIGlzIGEgdmFsdWUgZnJvbSBhbiBvcHRpb24uIFRoZSBzZWNvbmQgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3Rpb24uIEEgYm9vbGVhblxuICAgKiBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgY29tcGFyZVdpdGgoKSB7IHJldHVybiB0aGlzLl9jb21wYXJlV2l0aDsgfVxuICBzZXQgY29tcGFyZVdpdGgoZm46IChvMTogc3RyaW5nLCBvMjogc3RyaW5nKSA9PiBib29sZWFuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZ2V0TnhEcm9wZG93bk5vbkZ1bmN0aW9uVmFsdWVFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLl9jb21wYXJlV2l0aCA9IGZuO1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgLy8gQSBkaWZmZXJlbnQgY29tcGFyYXRvciBtZWFucyB0aGUgc2VsZWN0aW9uIGNvdWxkIGNoYW5nZS5cbiAgICAgIHRoaXMuX2luaXRpYWxpemVTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9maWx0ZXJGbiA9IChzZWFyY2g6IHN0cmluZywgaXRlbVZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gaXRlbVZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBiZSB1c2VkIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGUgc2VhcmNoIGZpbHRlci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSB1c2VyIGlucHV0LFxuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBkcm9wZG93biBpdGVtIHZhbHVlLiBUaGUgZHJvcGRvd24gaXRlbXMgd2lsbCB1c2UgdGhpcyBmdW5jdGlvbiB0byBzZXQgdGhlaXJcbiAgICogdmlzaWJpbGl0eSBzdGF0ZS5cbiAgICogQSBib29sZWFuIHNob3VsZCBiZSByZXR1cm5lZC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBmaWx0ZXJGbigpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlckZuOyB9XG4gIHNldCBmaWx0ZXJGbihmbjogKHNlYXJjaDogc3RyaW5nLCBpdGVtVmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGdldE54RHJvcGRvd25Ob25GdW5jdGlvblZhbHVlRXJyb3IoKTtcbiAgICB9XG4gICAgdGhpcy5fZmlsdGVyRm4gPSBmbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBmb2N1c2VkLlxuICAgKi9cbiAgZ2V0IGZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQgfHwgdGhpcy5wYW5lbE9wZW47XG4gIH1cblxuICAvKiogYFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlc2AgKi9cbiAgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAvKiogYFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gc2VsZWN0IGhhcyBiZWVuIHRvdWNoZWRgICovXG4gIF9vblRvdWNoZWQgPSAoKSA9PiB7IH07XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgZ2V0IGVsZW1lbnRSZWYoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBAQXR0cmlidXRlKCd0YWJpbmRleCcpIHRhYkluZGV4OiBzdHJpbmcsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb3JtRmllbGRDb21wb25lbnQ6IE54Rm9ybWZpZWxkQ29tcG9uZW50LFxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgQFNlbGYoKSBAT3B0aW9uYWwoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50Rm9ybTogTmdGb3JtLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLm5nQ29udHJvbCkge1xuICAgICAgLy8gTm90ZTogd2UgcHJvdmlkZSB0aGUgdmFsdWUgYWNjZXNzb3IgdGhyb3VnaCBoZXJlLCBpbnN0ZWFkIG9mXG4gICAgICAvLyB0aGUgYHByb3ZpZGVyc2AgdG8gYXZvaWQgcnVubmluZyBpbnRvIGEgY2lyY3VsYXIgaW1wb3J0LlxuICAgICAgdGhpcy5uZ0NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy50YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4LCAxMCkgfHwgMDtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgIHRoaXMudXBkYXRlRXJyb3JTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsPE54RHJvcGRvd25JdGVtQ29tcG9uZW50Pih0aGlzLmlzTXVsdGlTZWxlY3QpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuX2Nsb3NlZERyb3Bkb3duTGFiZWwgPVxuICAgICAgdGhpcy5fY3VzdG9tQ2xvc2VkRHJvcGRvd25MYWJlbCAmJiB0aGlzLl9jdXN0b21DbG9zZWREcm9wZG93bkxhYmVsLnRlbXBsYXRlUmVmIHx8IHRoaXMuX2RlZmF1bHRDbG9zZWREcm9wZG93bkxhYmVsO1xuICAgIHRoaXMuX2luaXRLZXlNYW5hZ2VyKCk7XG5cbiAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5vbkNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmFkZGVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5zZWxlY3QoKSk7XG4gICAgICBldmVudC5yZW1vdmVkLmZvckVhY2gob3B0aW9uID0+IG9wdGlvbi5kZXNlbGVjdCgpKTtcbiAgICB9KTtcblxuICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKG51bGwpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9yZXNldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoY29udHJvbCAmJiBjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCAoZm9ybSAmJiBmb3JtLnN1Ym1pdHRlZCkpKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHVwZGF0ZUVycm9yU3RhdGUoKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMubmdDb250cm9sID8gdGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCA6IG51bGw7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgaWYgKG5ld1N0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgdGhpcy5lcnJvclN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdXAgYSBrZXkgbWFuYWdlciB0byBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBwcml2YXRlIF9pbml0S2V5TWFuYWdlcigpIHtcbiAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE54RHJvcGRvd25JdGVtQ29tcG9uZW50Pih0aGlzLm9wdGlvbnMpXG4gICAgICAud2l0aFR5cGVBaGVhZCgpXG4gICAgICAud2l0aFdyYXAoKVxuICAgICAgLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKClcbiAgICAgIC53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKCdsdHInKVxuICAgICAgLnNraXBQcmVkaWNhdGUoaXRlbSA9PiBpdGVtLl9oaWRkZW4pO1xuXG4gICAgdGhpcy5fa2V5TWFuYWdlci50YWJPdXQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSB0cmlnZ2VyIGJlZm9yZSBjbG9zaW5nLiBFbnN1cmVzIHRoYXQgdGhlIGZvY3VzXG4gICAgICAvLyBwb3NpdGlvbiB3b24ndCBiZSBsb3N0IGlmIHRoZSB1c2VyIGdvdCBmb2N1cyBpbnRvIHRoZSBvdmVybGF5LlxuICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9rZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wYW5lbE9wZW4gJiYgdGhpcy5wYW5lbCkge1xuICAgICAgICAvLyBEZWxheSB0aGUgYXV0byBzY3JvbGxpbmcgdW50aWwgYWxsIGl0ZW1zIGhhdmUgc2V0dGxlZCBvdGhlcndpc2UgdGhlIGl0ZW0gY29udGFpbmVycyBtaWdodFxuICAgICAgICAvLyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZVxuICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgIC5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BhbmVsT3BlbiAmJiAhdGhpcy5pc011bHRpU2VsZWN0ICYmIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSkge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9yZXNldE9wdGlvbnMoKTogdm9pZCB7XG4gICAgY29uc3QgY2hhbmdlZE9yRGVzdHJveWVkID0gbWVyZ2UodGhpcy5vcHRpb25zLmNoYW5nZXMsIHRoaXMuX2Rlc3Ryb3kpO1xuXG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKGNoYW5nZWRPckRlc3Ryb3llZCkpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICB0aGlzLl9vblNlbGVjdChldmVudC5pdGVtLCBldmVudC5pc1VzZXJJbnB1dCk7XG5cbiAgICAgIGlmIChldmVudC5pc1VzZXJJbnB1dCAmJiAhdGhpcy5pc011bHRpU2VsZWN0ICYmIHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgb3B0aW9ucyBhbmQgcmVhY3QgYWNjb3JkaW5nbHkuXG4gICAgLy8gSGFuZGxlcyBjYXNlcyBsaWtlIHRoZSBsYWJlbHMgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbnMgY2hhbmdpbmcuXG4gICAgbWVyZ2UoLi4udGhpcy5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLl9zdGF0ZUNoYW5nZXMpKVxuICAgICAgLnBpcGUodGFrZVVudGlsKGNoYW5nZWRPckRlc3Ryb3llZCkpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgLy8gZGVmZXIgaXQgZm9yIHRoZSBuZXh0IGN5Y2xlIHRvIG5vdCBydW4gaW4gY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgICAvLyB0aGUgY29tYmluYXRpb24gb2YgZHJvcGRvd24taXRlbSBub3RpZnlpbmcgcGFyZW50IGFuZCB3aGVuIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gdHJpZXMgdG8gZmV0Y2ggdGhlIHRyaWdnZXJWYWx1ZSBmcm9tIHRoZSBjaGlsZCB0aHJvd3MgdGhlc2UgZXJyb3JzXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuX3NldE9wdGlvbklkcygpO1xuICB9XG5cbiAgLyoqIFJlY29yZHMgb3B0aW9uIElEcyB0byBwYXNzIHRvIHRoZSBhcmlhLW93bnMgcHJvcGVydHkuICovXG4gIHByaXZhdGUgX3NldE9wdGlvbklkcygpIHtcbiAgICB0aGlzLl9vcHRpb25JZHMgPSB0aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uaWQpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8qKiBJbnZva2VkIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWQuICovXG4gIHByaXZhdGUgX29uU2VsZWN0KG9wdGlvbjogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQsIGlzVXNlcklucHV0OiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3Qgd2FzU2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbik7XG5cbiAgICBpZiAob3B0aW9uLnZhbHVlID09IG51bGwgJiYgIXRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgb3B0aW9uLmRlc2VsZWN0KCk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcyhvcHRpb24udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPyB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3B0aW9uKSA6IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KG9wdGlvbik7XG5cbiAgICAgIGlmIChpc1VzZXJJbnB1dCkge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0ob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgICB0aGlzLl9zb3J0VmFsdWVzKCk7XG5cbiAgICAgICAgaWYgKGlzVXNlcklucHV0KSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSB0aGUgdXNlciBzZWxlY3RlZCB0aGUgb3B0aW9uIHdpdGggdGhlaXIgbW91c2UsIHdlXG4gICAgICAgICAgLy8gd2FudCB0byByZXN0b3JlIGZvY3VzIGJhY2sgdG8gdGhlIHRyaWdnZXIsIGluIG9yZGVyIHRvXG4gICAgICAgICAgLy8gcHJldmVudCB0aGUgc2VsZWN0IGtleWJvYXJkIGNvbnRyb2xzIGZyb20gY2xhc2hpbmcgd2l0aFxuICAgICAgICAgIC8vIHRoZSBvbmVzIGZyb20gYG1hdC1vcHRpb25gLlxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3YXNTZWxlY3RlZCAhPT0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZChvcHRpb24pKSB7XG4gICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZVNlbGVjdGlvbigpOiB2b2lkIHtcbiAgICAvLyBEZWZlciBzZXR0aW5nIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCB0aGUgXCJFeHByZXNzaW9uXG4gICAgLy8gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWRcIiBlcnJvcnMgZnJvbSBBbmd1bGFyLlxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh0aGlzLm5nQ29udHJvbCA/IHRoaXMubmdDb250cm9sLnZhbHVlIDogdGhpcy5fdmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGVkIG9wdGlvbiBiYXNlZCBvbiBhIHZhbHVlLiBJZiBubyBvcHRpb24gY2FuIGJlXG4gICAqIGZvdW5kIHdpdGggdGhlIGRlc2lnbmF0ZWQgdmFsdWUsIHRoZSBzZWxlY3QgdHJpZ2dlciBpcyBjbGVhcmVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZTogYW55IHwgYW55W10pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0ICYmIHZhbHVlKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IGdldE54RHJvcGRvd25Ob25BcnJheVZhbHVlRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgIHZhbHVlLmZvckVhY2goKGN1cnJlbnRWYWx1ZTogYW55KSA9PiB0aGlzLl9zZWxlY3RWYWx1ZShjdXJyZW50VmFsdWUpKTtcbiAgICAgIHRoaXMuX3NvcnRWYWx1ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLl9zZWxlY3RWYWx1ZSh2YWx1ZSk7XG4gICAgICAvLyBTaGlmdCBmb2N1cyB0byB0aGUgYWN0aXZlIGl0ZW0uIE5vdGUgdGhhdCB3ZSBzaG91bGRuJ3QgZG8gdGhpcyBpbiBtdWx0aXBsZVxuICAgICAgLy8gbW9kZSwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IHdoYXQgb3B0aW9uIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCBsYXN0LlxuICAgICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuZCBzZWxlY3RzIGFuZCBvcHRpb24gYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgKiBAcmV0dXJucyBPcHRpb24gdGhhdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIF9zZWxlY3RWYWx1ZSh2YWx1ZTogYW55KTogTnhEcm9wZG93bkl0ZW1Db21wb25lbnQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZCgob3B0aW9uOiBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJlYXQgbnVsbCBhcyBhIHNwZWNpYWwgcmVzZXQgdmFsdWUuXG4gICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgIT0gbnVsbCAmJiB0aGlzLl9jb21wYXJlV2l0aChvcHRpb24udmFsdWUsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgIC8vIE5vdGlmeSBkZXZlbG9wZXJzIG9mIGVycm9ycyBpbiB0aGVpciBjb21wYXJhdG9yLlxuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdChjb3JyZXNwb25kaW5nT3B0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlc3BvbmRpbmdPcHRpb247XG4gIH1cblxuICAvKiogRW1pdHMgY2hhbmdlIGV2ZW50IHRvIHNldCB0aGUgbW9kZWwgdmFsdWUuICovXG4gIHByaXZhdGUgX3Byb3BhZ2F0ZUNoYW5nZXMoZmFsbGJhY2tWYWx1ZT86IGFueSk6IHZvaWQge1xuICAgIGxldCB2YWx1ZVRvRW1pdDogYW55ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmlzTXVsdGlTZWxlY3QpIHtcbiAgICAgIHZhbHVlVG9FbWl0ID0gKHRoaXMuc2VsZWN0ZWQgYXMgTnhEcm9wZG93bkl0ZW1Db21wb25lbnRbXSkubWFwKG9wdGlvbiA9PiBvcHRpb24udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQgPyAodGhpcy5zZWxlY3RlZCBhcyBOeERyb3Bkb3duSXRlbUNvbXBvbmVudCkudmFsdWUgOiBmYWxsYmFja1ZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVUb0VtaXQ7XG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlVG9FbWl0KTtcbiAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZVRvRW1pdCk7XG4gICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChuZXcgTnhEcm9wZG93blNlbGVjdENoYW5nZSh0aGlzLCB2YWx1ZVRvRW1pdCkpO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqIFNvcnRzIHRoZSBzZWxlY3RlZCB2YWx1ZXMgaW4gdGhlIHNlbGVjdGVkIGJhc2VkIG9uIHRoZWlyIG9yZGVyIGluIHRoZSBwYW5lbC4gKi9cbiAgcHJpdmF0ZSBfc29ydFZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5pc011bHRpU2VsZWN0KSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnRvQXJyYXkoKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaW5kZXhPZihhKSAtIG9wdGlvbnMuaW5kZXhPZihiKSk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEZvY3VzZXMgdGhlIHNlbGVjdCBlbGVtZW50LiAqL1xuICBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKiBPcGVucyB0aGUgcGFuZWwgb2YgdGhlIGRyb3Bkb3duLiAqL1xuICBvcGVuUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl90cmlnZ2VyUmVjdCA9IHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2tleU1hbmFnZXIud2l0aEhvcml6b250YWxPcmllbnRhdGlvbihudWxsKTtcbiAgICB0aGlzLl9oaWdobGlnaHRDb3JyZWN0T3B0aW9uKCk7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBwYW5lbCBvZiB0aGUgZHJvcGRvd24uICovXG4gIGNsb3NlUGFuZWwoKSB7XG4gICAgaWYgKHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLndpdGhIb3Jpem9udGFsT3JpZW50YXRpb24oJ2x0cicpO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMub3BlbmVkQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgLy8gZGVmZXIgdGhlIGZvY3VzIGlmIHRoZSBkcm9wZG93biB0cmlnZ2VycyBhY3Rpb25zIHRoYXQgZGV0YWNoXG4gICAgICAvLyBhIHRlbXBsYXRlL3ZpZXcgZnJvbSB0aGUgRE9NIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZvY3VzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBpbml0YWwgc2Nyb2xsVG9wIHdoZW4gdGhlIGRyb3Bkb3duIG9wZW5zXG4gIC8vIHNjcm9sbHMgdGhlIHNlbGVjdGVkIGl0ZW0gdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgaWYgcG9zc2libGVcbiAgcHJpdmF0ZSBfY2FsY3VsYXRlU2Nyb2xsVG9wKCkge1xuICAgIC8vIHJlc2V0IHRoZSBzY3JvbGx0b3AgdG8gbWFrZSBjYWxjdWxhdGlvbiBlYXNpZXJcbiAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy5fc2Nyb2xsVG9wID0gMDtcbiAgICBpZiAoIXRoaXMuZW1wdHkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2dldEl0ZW1PZmZzZXQodGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKTtcbiAgICAgIGNvbnN0IHBhbmVsSGVpZ2h0ID0gdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBwYW5lbFJlY3QgPSB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgbWlkZGxlT2ZQYW5lbCA9IHBhbmVsUmVjdC50b3AgKyBwYW5lbEhlaWdodCAvIDI7XG4gICAgICBjb25zdCBhY3RpdmVJdGVtUmVjdCA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5jb250YWluZXJFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAob2Zmc2V0ID4gbWlkZGxlT2ZQYW5lbCkge1xuICAgICAgICAvLyBiZWNhdXNlIHdlIHJlc2V0IHRoZSBzY3JvbGxUb3AgdG8gMCBhdCB0aGUgdG9wIHdlIGNhbiBzaW1wbHkgdGFrZSB0aGUgbWlkZGxlT2ZQYW5lbCB3aGljaCBpcyBvdXJcbiAgICAgICAgLy8gdGFyZ2V0IHBvc2l0aW9uIGZvciB0aGUgaXRlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgb2Zmc2V0ICh3aGljaCBpcyBub3cgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydClcbiAgICAgICAgLy8gdG8gbWlkZGxlIG91dCB0aGUgdGV4dCBhIGJpdCBtb3JlIGFkZCBoYWxmIG9mIHRoZSBoZWlnaHRcbiAgICAgICAgLy8gKHRoaXMgaXMgc3RpbGwgYSBmZXcgcGl4ZWxzIG9mZiBiZWNhdXNlIHRoZSBjb250YWluZXIgaXMgYSBiaXQgbGFyZ2VyIHRoYW4gdGhlIGZvbnQpXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IG9mZnNldCAtIG1pZGRsZU9mUGFuZWwgKyAoYWN0aXZlSXRlbVJlY3QuaGVpZ2h0IC0gaXRlbVBhZGRpbmcpIC8gMjtcbiAgICAgICAgdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFNjcm9sbHMgdGhlIGFjdGl2ZSBvcHRpb24gaW50byB2aWV3LiAqL1xuICBwcml2YXRlIF9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGFuZWxPcGVuIHx8ICF0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlT3B0aW9uSW5kZXggPSB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCB8fCAwO1xuICAgIGNvbnN0IGl0ZW1SZWN0ID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtLmNvbnRhaW5lckVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbihhY3RpdmVPcHRpb25JbmRleCwgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5ncm91cHMpO1xuXG4gICAgdGhpcy5wYW5lbEJvZHkubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9nZXRPcHRpb25TY3JvbGxQb3NpdGlvbihcbiAgICAgIGFjdGl2ZU9wdGlvbkluZGV4ICsgbGFiZWxDb3VudCxcbiAgICAgIGl0ZW1SZWN0LmhlaWdodCxcbiAgICAgIHRoaXMucGFuZWxCb2R5Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFRcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfY291bnRHcm91cExhYmVsc0JlZm9yZU9wdGlvbihvcHRpb25JbmRleDogbnVtYmVyLCBvcHRpb25zOiBRdWVyeUxpc3Q8TnhEcm9wZG93bkl0ZW1Db21wb25lbnQ+LFxuICAgIG9wdGlvbkdyb3VwczogUXVlcnlMaXN0PE54RHJvcGRvd25Hcm91cENvbXBvbmVudD4pOiBudW1iZXIge1xuXG4gICAgaWYgKG9wdGlvbkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IG9wdGlvbnMudG9BcnJheSgpO1xuICAgICAgY29uc3QgZ3JvdXBzID0gb3B0aW9uR3JvdXBzLnRvQXJyYXkoKTtcbiAgICAgIGxldCBncm91cENvdW50ZXIgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbkluZGV4ICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChvcHRpb25zQXJyYXlbaV0uZ3JvdXAgJiYgb3B0aW9uc0FycmF5W2ldLmdyb3VwID09PSBncm91cHNbZ3JvdXBDb3VudGVyXSkge1xuICAgICAgICAgIGdyb3VwQ291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cENvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPcHRpb25TY3JvbGxQb3NpdGlvbihvcHRpb25JbmRleDogbnVtYmVyLCBvcHRpb25IZWlnaHQ6IG51bWJlcixcbiAgICBjdXJyZW50U2Nyb2xsUG9zaXRpb246IG51bWJlciwgcGFuZWxIZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IG9wdGlvbk9mZnNldCA9IG9wdGlvbkluZGV4ICogb3B0aW9uSGVpZ2h0ICsgaXRlbVBhZGRpbmc7XG5cbiAgICBpZiAodGhpcy5zaG93RmlsdGVyKSB7XG4gICAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm54LWRyb3Bkb3duX19maWx0ZXInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICBvcHRpb25PZmZzZXQgPSBvcHRpb25JbmRleCAqIG9wdGlvbkhlaWdodCArIGZpbHRlckhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uT2Zmc2V0IDwgY3VycmVudFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25PZmZzZXQgKyBvcHRpb25IZWlnaHQgPiBjdXJyZW50U2Nyb2xsUG9zaXRpb24gKyBwYW5lbEhlaWdodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG9wdGlvbk9mZnNldCAtIHBhbmVsSGVpZ2h0ICsgb3B0aW9uSGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFNjcm9sbFBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0SXRlbU9mZnNldChpdGVtKSB7XG4gICAgY29uc3QgaXRlbVJlY3QgPSBpdGVtLmNvbnRhaW5lckVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiBpdGVtUmVjdC50b3A7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBGb3JtZmllbGQgSW1wbGVtZW50YXRpb25cbiAgICovXG4gIHNldERlc2NyaWJlZEJ5SWRzKGlkczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICB0aGlzLmFyaWFEZXNjcmliZWRieSA9IGlkcy5qb2luKCcgJyk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzZXRBcmlhTGFiZWwodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2FyaWFMYWJlbCA9IHZhbHVlO1xuICB9XG5cbiAgX2dldEFyaWFMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJpYUxhYmVsIHx8ICh0aGlzLmZvcm1GaWVsZENvbXBvbmVudCA/IHRoaXMuZm9ybUZpZWxkQ29tcG9uZW50LmxhYmVsIDogbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3QgaGFzIGEgdmFsdWUuXG4gICAqL1xuICBnZXQgZW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLl9zZWxlY3Rpb25Nb2RlbCB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmhhc1ZhbHVlKCk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgc2hvdWxkTGFiZWxGbG9hdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c2VkIHx8ICF0aGlzLmVtcHR5O1xuICB9XG4gIC8qKiBFbmQgRm9ybWZpZWxkICovXG5cbiAgLyoqIENvbnRyb2xWYWx1ZUFjY2Vzc29yICovXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QncyB2YWx1ZS4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoZSBtb2RlbC5cbiAgICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX29uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICB9XG4gIC8qKiBFbmQgQ29udHJvbFZhbHVlQWNjZXNzb3IgKi9cblxuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5faGFuZGxlT3BlbktleWRvd24oZXZlbnQpIDogdGhpcy5faGFuZGxlQ2xvc2VkS2V5ZG93bihldmVudCk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVDbG9zZWRLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgY29uc3QgaXNBcnJvd0tleSA9IGtleUNvZGUgPT09IERPV05fQVJST1cgfHwga2V5Q29kZSA9PT0gVVBfQVJST1cgfHxcbiAgICAgIGtleUNvZGUgPT09IExFRlRfQVJST1cgfHwga2V5Q29kZSA9PT0gUklHSFRfQVJST1c7XG4gICAgY29uc3QgaXNPcGVuS2V5ID0ga2V5Q29kZSA9PT0gRU5URVIgfHwga2V5Q29kZSA9PT0gU1BBQ0U7XG5cbiAgICAvLyBPcGVuIHRoZSBzZWxlY3Qgb24gQUxUICsgYXJyb3cga2V5IHRvIG1hdGNoIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAgICBpZiAoaXNPcGVuS2V5IHx8ICgodGhpcy5pc011bHRpU2VsZWN0IHx8IGV2ZW50LmFsdEtleSkgJiYgaXNBcnJvd0tleSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTXVsdGlTZWxlY3QgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPcGVuS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIC8vIGFsbCBldmVudHMgb3RoZXIgdGhhbiB0aGUgbGlzdGVkIG9uZXMgc2hvdWxkIGJlIGlnbm9yZWQgb3IgaGFuZGxlZCBpbiBfb25GaWx0ZXIoKVxuICAgIGlmICghKFtET1dOX0FSUk9XLCBVUF9BUlJPVywgSE9NRSwgRU5ELCBFTlRFUiwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFNISUZULCBTUEFDRSwgVEFCXS5pbmRleE9mKGtleUNvZGUpID49IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Fycm93S2V5ID0ga2V5Q29kZSA9PT0gRE9XTl9BUlJPVyB8fCBrZXlDb2RlID09PSBVUF9BUlJPVztcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcy5fa2V5TWFuYWdlcjtcblxuICAgIGNvbnN0IGFsbEhpZGRlbiA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5faGlkZGVuKS5ldmVyeShvcHRpb24gPT4gQm9vbGVhbihvcHRpb24pKTtcblxuICAgIGlmIChrZXlDb2RlID09PSBIT01FIHx8IGtleUNvZGUgPT09IEVORCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGtleUNvZGUgPT09IEhPTUUgPyBtYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpIDogbWFuYWdlci5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJvd0tleSAmJiBldmVudC5hbHRLZXkpIHtcbiAgICAgIC8vIENsb3NlIHRoZSBzZWxlY3Qgb24gQUxUICsgYXJyb3cga2V5IHRvIG1hdGNoIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEVOVEVSICYmIG1hbmFnZXIuYWN0aXZlSXRlbSAmJiAhYWxsSGlkZGVuKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBFTlRFUiAmJiBhbGxIaWRkZW4pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2hvd0ZpbHRlciAmJiBrZXlDb2RlID09PSBTUEFDRSAmJiBtYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtYW5hZ2VyLmFjdGl2ZUl0ZW0uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBUQUIpIHtcbiAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEluZGV4ID0gbWFuYWdlci5hY3RpdmVJdGVtSW5kZXg7XG4gICAgICBtYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG5cbiAgICAgIGlmICh0aGlzLmlzTXVsdGlTZWxlY3QgJiYgaXNBcnJvd0tleSAmJiBldmVudC5zaGlmdEtleSAmJiBtYW5hZ2VyLmFjdGl2ZUl0ZW0gJiZcbiAgICAgICAgbWFuYWdlci5hY3RpdmVJdGVtSW5kZXggIT09IHByZXZpb3VzbHlGb2N1c2VkSW5kZXgpIHtcbiAgICAgICAgbWFuYWdlci5hY3RpdmVJdGVtLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGZvcm1hdFZhbHVlKHZhbHVlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZUZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICAvKiogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW4gdGhlIGZpbHRlciBpbnB1dCAqL1xuICBfb25GaWx0ZXIoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY3VycmVudEZpbHRlciA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB0aGlzLmZpbHRlckNoYW5nZXMubmV4dChldmVudC50YXJnZXQudmFsdWUpO1xuICAgIGNvbnN0IGFsbEhpZGRlbiA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5faGlkZGVuKS5ldmVyeShvcHRpb24gPT4gQm9vbGVhbihvcHRpb24pKTtcbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogVGhlIHZhbHVlIGRpc3BsYXllZCBpbiB0aGUgdHJpZ2dlci5cbiAgICovXG4gIGdldCB0cmlnZ2VyVmFsdWUoKTogc3RyaW5nIHtcblxuICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNNdWx0aVNlbGVjdCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWQubWFwKG9wdGlvbiA9PiBvcHRpb24udmlld1ZhbHVlKTtcblxuICAgICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0udmlld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2hsaWdodHMgdGhlIHNlbGVjdGVkIGl0ZW0uIElmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZCwgaXQgd2lsbCBoaWdobGlnaHRcbiAgICogdGhlIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICovXG4gIHByaXZhdGUgX2hpZ2hsaWdodENvcnJlY3RPcHRpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2tleU1hbmFnZXIpIHtcbiAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0odGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiB0aGUgb3ZlcmxheSBwYW5lbCBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICovXG4gIF9vbkF0dGFjaGVkKCk6IHZvaWQge1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIHRoaXMub3ZlcmxheURpci5wb3NpdGlvbkNoYW5nZS5waXBlKHRha2UoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnBhbmVsQm9keS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICBpZiAodGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNjcm9sbFRvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB0aGlzLm9wZW5lZENoYW5nZS5lbWl0KHRydWUpO1xuICAgICAgaWYgKHRoaXMuc2hvd0ZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlcklucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9vbkZvY3VzKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSB0b3VjaGVkIGNhbGxiYWNrIG9ubHkgaWYgdGhlIHBhbmVsIGlzIGNsb3NlZC4gT3RoZXJ3aXNlLCB0aGUgdHJpZ2dlciB3aWxsXG4gICAqIFwiYmx1clwiIHRvIHRoZSBwYW5lbCB3aGVuIGl0IG9wZW5zLCBjYXVzaW5nIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAqL1xuICBfb25CbHVyKCkge1xuICAgIHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmZpbHRlcklucHV0ICYmIHRoaXMuc2hvd0ZpbHRlcikge1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucGFuZWxPcGVuKSB7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBpc0ZpbHRlckVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaWx0ZXIubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgX2NsZWFyRmlsdGVyKCkge1xuICAgIHRoaXMuZmlsdGVySW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIHRoaXMuY3VycmVudEZpbHRlciA9ICcnO1xuICAgIHRoaXMuZmlsdGVyQ2hhbmdlcy5uZXh0KCcnKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlIGRldGVybWluZXMgdGhlIGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgIHRvIGJlIHNldCBvbiB0aGUgaG9zdC4gKi9cbiAgX2dldEFyaWFBY3RpdmVEZXNjZW5kYW50KCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLnBhbmVsT3BlbiAmJiB0aGlzLl9rZXlNYW5hZ2VyICYmIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbS5pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl19