/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, forwardRef, Input, Output, ViewChild, Optional, HostListener, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { ToggleButton } from './toggle-button';
import { NxCircleToggleGroupComponent } from '../circle-toggle-group/circle-toggle-group.component';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NxMobileToggleButtonComponent } from '../mobile-toggle-button/mobile-toggle-button.component';
export class ToggleChangeEvent {
    /**
     * @param {?} button
     * @param {?} value
     */
    constructor(button, value) {
        this.button = button;
        this.value = value;
    }
}
if (false) {
    /**
     * A toggle button
     * @type {?}
     */
    ToggleChangeEvent.prototype.button;
    /**
     * The value of the toggle button that is sent with the event.
     * @type {?}
     */
    ToggleChangeEvent.prototype.value;
}
/** @type {?} */
let nextId = 0;
export class NxCircleToggleComponent extends ToggleButton {
    /**
     * @param {?} toggleGroup
     * @param {?} _checkedDispatcher
     * @param {?} _changeDetectorRef
     */
    constructor(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
        super();
        this.toggleGroup = toggleGroup;
        this._checkedDispatcher = _checkedDispatcher;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `toggle-button-${nextId++}`;
        /**
         * \@docs-private
         */
        this.inGroup = false;
        this._name = null;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         */
        this.checkedChange = new EventEmitter();
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         */
        this.selectionChange = new EventEmitter();
        this._checked = false;
        this._value = null;
        this._iconName = null;
        this._svg = null;
        this._svgChecked = null;
        this._label = null;
        this._hint = null;
        this._hover = false;
        /**
         * touched is set to true on touch devices.
         */
        this._touched = false;
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} checked
         * @return {?}
         */
        (checked) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        if (this.toggleGroup) {
            this.name = this.toggleGroup.name;
        }
    }
    /**
     * Id of the circle toggle.
     *
     * If not set, the circle toggle gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Name that is used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the circle toggle is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.checked !== newValue) {
            this._checked = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * The value that is used in the model.
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this._value = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Id of the icon that should be displayed.
     * @param {?} name
     * @return {?}
     */
    set iconName(name) {
        this._iconName = name;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get iconName() {
        return this._iconName;
    }
    /**
     * SVG that is displayed if the circle toggle is unchecked.
     * @param {?} src
     * @return {?}
     */
    set svg(src) {
        this._svg = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svg() {
        return this._svg;
    }
    /**
     * SVG that is displayed if the circle toggle is checked.
     * @param {?} src
     * @return {?}
     */
    set svgChecked(src) {
        this._svgChecked = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svgChecked() {
        return this._svgChecked;
    }
    /**
     * Label displayed below the circle.
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        this._label = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * Additional hint displayed below the label.
     * @param {?} value
     * @return {?}
     */
    set hint(value) {
        this._hint = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get hint() {
        return this._hint;
    }
    /**
     * Whether the circle toggle uses the negative set of styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the circle toggle has a responsive behavior.
     * @param {?} value
     * @return {?}
     */
    set responsive(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.responsive !== newValue) {
            this._responsive = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get responsive() {
        return this._responsive;
    }
    /**
     * Whether the circle toggle is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseEnter() {
        if (!this._touched) {
            this._hover = true;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseLeave() {
        if (!this._touched) {
            this._hover = false;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onTouchStart() {
        this._touched = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.toggleGroup) {
            this.attachListenerForGroup();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.toggleGroup) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.inGroup = true;
                this.negative = this.toggleGroup.negative;
                this.disabled = this.toggleGroup.disabled;
                this.responsive = this.toggleGroup.responsive;
                this.id = this.toggleGroup.id + `-button-${nextId++}`;
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // function returned by the listener
        this._removeUniqueSelectionListener();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    attachListenerForGroup() {
        this._removeUniqueSelectionListener =
            this._checkedDispatcher.listen((/**
             * @param {?} groupId
             * @param {?} buttonId
             * @return {?}
             */
            (groupId, buttonId) => {
                if (this.id !== buttonId && groupId === this.toggleGroup.id) {
                    this.checked = false;
                }
            }));
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    writeValue(newValue) {
        this.checked = newValue;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        if ((this.toggleGroup && this.checked) || this.disabled) {
            return;
        }
        else {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
            if (this.toggleGroup) {
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        }
    }
    /**
     * \@docs-private
     *
     * method called by the group if the internal value of the group is changed programatically,
     * does not trigger change emission
     * @return {?}
     */
    setGroupSelection() {
        // propagate changes only if the value in the group is different than the button checked value
        if (!this.checked) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgButton() {
        return !!this.svg && !!this.svgChecked;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgUrl() {
        /** @type {?} */
        let useFilledSvg = this.checked || (!this.disabled && this._hover);
        if (this.negative) {
            useFilledSvg = !useFilledSvg;
        }
        return useFilledSvg ? this.svgChecked : this.svg;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get type() {
        return this.toggleGroup ? 'radio' : 'checkbox';
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    handleEnterKey(event) {
        if (!this.toggleGroup) {
            this.toggle(event);
        }
    }
}
NxCircleToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-circle-toggle',
                template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\">\n    </nx-mobile-toggle-button>\n</label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: ToggleButton,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent))
                    },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.nx-toggle-circle]': 'true',
                    '[class.in-group]': 'inGroup',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-responsive]': 'responsive'
                },
                styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
            }] }
];
/** @nocollapse */
NxCircleToggleComponent.ctorParameters = () => [
    { type: NxCircleToggleGroupComponent, decorators: [{ type: Optional }] },
    { type: UniqueSelectionDispatcher },
    { type: ChangeDetectorRef }
];
NxCircleToggleComponent.propDecorators = {
    name: [{ type: Input }],
    checkedChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    iconName: [{ type: Input, args: ['icon',] }],
    svg: [{ type: Input }],
    svgChecked: [{ type: Input }],
    label: [{ type: Input }],
    hint: [{ type: Input }],
    negative: [{ type: Input }],
    responsive: [{ type: Input }],
    disabled: [{ type: Input }],
    toggleButton: [{ type: ViewChild, args: [NxMobileToggleButtonComponent,] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._id;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.inGroup;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._name;
    /**
     * An event that is emitted when the checked state fo the circle toggle changes.
     * @type {?}
     */
    NxCircleToggleComponent.prototype.checkedChange;
    /**
     * An event that is emitted when the checked state of the circle toggle changes.
     * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
     * @type {?}
     */
    NxCircleToggleComponent.prototype.selectionChange;
    /** @type {?} */
    NxCircleToggleComponent.prototype._checked;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._iconName;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._svg;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._svgChecked;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._label;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._hint;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._responsive;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._disabled;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.toggleButton;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._hover;
    /**
     * touched is set to true on touch devices.
     * @type {?}
     */
    NxCircleToggleComponent.prototype._touched;
    /** @type {?} */
    NxCircleToggleComponent.prototype._removeUniqueSelectionListener;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype.onTouchedCallback;
    /**
     * \@docs-private
     * @type {?}
     */
    NxCircleToggleComponent.prototype.toggleGroup;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._checkedDispatcher;
    /**
     * @type {?}
     * @private
     */
    NxCircleToggleComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2lyY2xlLXRvZ2dsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxsaWFuei9uZ3gtbmRieC8iLCJzb3VyY2VzIjpbImNpcmNsZS10b2dnbGUvY2lyY2xlLXRvZ2dsZS9jaXJjbGUtdG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBb0MsWUFBWSxFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUMvSCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFckUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLHNEQUFzRCxDQUFDO0FBQ3BHLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBRXZHLE1BQU0sT0FBTyxpQkFBaUI7Ozs7O0lBTzVCLFlBQVksTUFBTSxFQUFFLEtBQUs7UUFDdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztDQUNGOzs7Ozs7SUFUQyxtQ0FBcUI7Ozs7O0lBR3JCLGtDQUFjOzs7SUFRWixNQUFNLEdBQUcsQ0FBQztBQXlCZCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsWUFBWTs7Ozs7O0lBb052RCxZQUFZLG9CQUFvQixDQUFvQixXQUF5QyxFQUNuRixrQkFBNkMsRUFBVSxrQkFBcUM7UUFDcEcsS0FBSyxFQUFFLENBQUM7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RXZELG1EQUFxRDs7Ozs7SUFDckQsb0RBQXNDOzs7OztJQUVMLDhDQUE0RDs7Ozs7SUFDM0YscURBQXFEOzs7OztJQUFFLHFEQUE2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQsIE9wdGlvbmFsLCBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCwgSG9zdExpc3RlbmVyLCBDaGFuZ2VEZXRlY3RvclJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcblxuaW1wb3J0IHsgVG9nZ2xlQnV0dG9uIH0gZnJvbSAnLi90b2dnbGUtYnV0dG9uJztcbmltcG9ydCB7IE54Q2lyY2xlVG9nZ2xlR3JvdXBDb21wb25lbnQgfSBmcm9tICcuLi9jaXJjbGUtdG9nZ2xlLWdyb3VwL2NpcmNsZS10b2dnbGUtZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBOeE1vYmlsZVRvZ2dsZUJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4uL21vYmlsZS10b2dnbGUtYnV0dG9uL21vYmlsZS10b2dnbGUtYnV0dG9uLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBjbGFzcyBUb2dnbGVDaGFuZ2VFdmVudCB7XG4gIC8qKiBBIHRvZ2dsZSBidXR0b24gKi9cbiAgYnV0dG9uOiBUb2dnbGVCdXR0b247XG5cbiAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgdG9nZ2xlIGJ1dHRvbiB0aGF0IGlzIHNlbnQgd2l0aCB0aGUgZXZlbnQuICovXG4gIHZhbHVlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYnV0dG9uLCB2YWx1ZSkge1xuICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5sZXQgbmV4dElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbngtY2lyY2xlLXRvZ2dsZScsXG4gIHRlbXBsYXRlVXJsOiAnY2lyY2xlLXRvZ2dsZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWydjaXJjbGUtdG9nZ2xlLmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBUb2dnbGVCdXR0b24sXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOeENpcmNsZVRvZ2dsZUNvbXBvbmVudClcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnhDaXJjbGVUb2dnbGVDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm54LXRvZ2dsZS1jaXJjbGVdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuaW4tZ3JvdXBdJzogJ2luR3JvdXAnLFxuICAgICdbY2xhc3MuaXMtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAnW2NsYXNzLmlzLXJlc3BvbnNpdmVdJzogJ3Jlc3BvbnNpdmUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTnhDaXJjbGVUb2dnbGVDb21wb25lbnQgZXh0ZW5kcyBUb2dnbGVCdXR0b24gaW1wbGVtZW50c1xuT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICBwcml2YXRlIF9pZDogc3RyaW5nID0gYHRvZ2dsZS1idXR0b24tJHtuZXh0SWQrK31gO1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGluR3JvdXA6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogSWQgb2YgdGhlIGNpcmNsZSB0b2dnbGUuXG4gICAqXG4gICAqIElmIG5vdCBzZXQsIHRoZSBjaXJjbGUgdG9nZ2xlIGdldHMgYW4gaW5jcmVtZW50ZWQgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICovXG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICBwcml2YXRlIF9uYW1lOiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBOYW1lIHRoYXQgaXMgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS4gKi9cbiAgQElucHV0KClcbiAgc2V0IG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGZvIHRoZSBjaXJjbGUgdG9nZ2xlIGNoYW5nZXMuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgY2hlY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgb2YgdGhlIGNpcmNsZSB0b2dnbGUgY2hhbmdlcy5cbiAgICogVGhlIGV2ZW50IG9iamVjdCBjb250YWlucyB0aGUgY2lyY2xlIHRvZ2dsZSBpdHNlbGYgYW5kIGl0cyB2YWx1ZSAoc2VlIFRvZ2dsZUNoYW5nZUV2ZW50KS5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBzZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZUNoYW5nZUV2ZW50PigpO1xuXG4gIF9jaGVja2VkOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgdG9nZ2xlIGlzIGNoZWNrZWQuICovXG4gIEBJbnB1dCgpXG4gIHNldCBjaGVja2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9jaGVja2VkID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNoZWNrZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gIH1cblxuICBwcml2YXRlIF92YWx1ZTogc3RyaW5nID0gbnVsbDtcblxuICAvKiogVGhlIHZhbHVlIHRoYXQgaXMgdXNlZCBpbiB0aGUgbW9kZWwuICovXG4gIEBJbnB1dCgpXG4gIHNldCB2YWx1ZShuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgdmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9pY29uTmFtZTogc3RyaW5nID0gbnVsbDtcbiAgLyoqIElkIG9mIHRoZSBpY29uIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZC4gKi9cbiAgQElucHV0KCdpY29uJylcbiAgc2V0IGljb25OYW1lKG5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuX2ljb25OYW1lID0gbmFtZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgaWNvbk5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWNvbk5hbWU7XG4gIH1cblxuICBwcml2YXRlIF9zdmc6IHN0cmluZyA9IG51bGw7XG5cbiAgLyoqIFNWRyB0aGF0IGlzIGRpc3BsYXllZCBpZiB0aGUgY2lyY2xlIHRvZ2dsZSBpcyB1bmNoZWNrZWQuICovXG4gIEBJbnB1dCgpXG4gIHNldCBzdmcoc3JjOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9zdmcgPSBzcmM7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbiAgZ2V0IHN2ZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdmc7XG4gIH1cblxuICBwcml2YXRlIF9zdmdDaGVja2VkOiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBTVkcgdGhhdCBpcyBkaXNwbGF5ZWQgaWYgdGhlIGNpcmNsZSB0b2dnbGUgaXMgY2hlY2tlZC4gKi9cbiAgQElucHV0KClcbiAgc2V0IHN2Z0NoZWNrZWQoc3JjOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9zdmdDaGVja2VkID0gc3JjO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG4gIGdldCBzdmdDaGVja2VkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z0NoZWNrZWQ7XG4gIH1cblxuICBwcml2YXRlIF9sYWJlbDogc3RyaW5nID0gbnVsbDtcblxuICAvKiogTGFiZWwgZGlzcGxheWVkIGJlbG93IHRoZSBjaXJjbGUuICovXG4gIEBJbnB1dCgpXG4gIHNldCBsYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fbGFiZWwgPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbGFiZWw7XG4gIH1cblxuICBwcml2YXRlIF9oaW50OiBzdHJpbmcgPSBudWxsO1xuXG4gIC8qKiBBZGRpdGlvbmFsIGhpbnQgZGlzcGxheWVkIGJlbG93IHRoZSBsYWJlbC4gKi9cbiAgQElucHV0KClcbiAgc2V0IGhpbnQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2hpbnQgPSB2YWx1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuICBnZXQgaGludCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9oaW50O1xuICB9XG5cbiAgcHJpdmF0ZSBfbmVnYXRpdmU7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNpcmNsZSB0b2dnbGUgdXNlcyB0aGUgbmVnYXRpdmUgc2V0IG9mIHN0eWxpbmcuICovXG4gIEBJbnB1dCgpXG4gIHNldCBuZWdhdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX25lZ2F0aXZlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmVnYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25lZ2F0aXZlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzcG9uc2l2ZTtcblxuICAvKiogV2hldGhlciB0aGUgY2lyY2xlIHRvZ2dsZSBoYXMgYSByZXNwb25zaXZlIGJlaGF2aW9yLiAqL1xuICBASW5wdXQoKVxuICBzZXQgcmVzcG9uc2l2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5yZXNwb25zaXZlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlc3BvbnNpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNpdmU7XG4gIH1cblxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0aGUgY2lyY2xlIHRvZ2dsZSBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLmRpc2FibGVkICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKE54TW9iaWxlVG9nZ2xlQnV0dG9uQ29tcG9uZW50KVxuICB0b2dnbGVCdXR0b246IE54TW9iaWxlVG9nZ2xlQnV0dG9uQ29tcG9uZW50O1xuXG4gIHByaXZhdGUgX2hvdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIHRvdWNoZWQgaXMgc2V0IHRvIHRydWUgb24gdG91Y2ggZGV2aWNlcy4gKi9cbiAgX3RvdWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJykgb25Nb3VzZUVudGVyKCkge1xuICAgIGlmICghdGhpcy5fdG91Y2hlZCkge1xuICAgICAgdGhpcy5faG92ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbk1vdXNlTGVhdmUoKSB7XG4gICAgaWYgKCF0aGlzLl90b3VjaGVkKSB7XG4gICAgICB0aGlzLl9ob3ZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBIb3N0TGlzdGVuZXIoJ3RvdWNoc3RhcnQnKSBvblRvdWNoU3RhcnQoKSB7XG4gICAgdGhpcy5fdG91Y2hlZCA9IHRydWU7XG4gIH1cblxuICBfcmVtb3ZlVW5pcXVlU2VsZWN0aW9uTGlzdGVuZXI6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrID0gKGNoZWNrZWQ6IGJvb2xlYW4pID0+IHsgfTtcbiAgcHJpdmF0ZSBvblRvdWNoZWRDYWxsYmFjayA9ICgpID0+IHsgfTtcblxuICBjb25zdHJ1Y3RvcigvKiogQGRvY3MtcHJpdmF0ZSAqLyBAT3B0aW9uYWwoKSBwdWJsaWMgdG9nZ2xlR3JvdXA6IE54Q2lyY2xlVG9nZ2xlR3JvdXBDb21wb25lbnQsXG4gICAgcHJpdmF0ZSBfY2hlY2tlZERpc3BhdGNoZXI6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodGhpcy50b2dnbGVHcm91cCkge1xuICAgICAgdGhpcy5uYW1lID0gdGhpcy50b2dnbGVHcm91cC5uYW1lO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLnRvZ2dsZUdyb3VwKSB7XG4gICAgICB0aGlzLmF0dGFjaExpc3RlbmVyRm9yR3JvdXAoKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlR3JvdXApIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmluR3JvdXAgPSB0cnVlO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdGhpcy50b2dnbGVHcm91cC5uZWdhdGl2ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMudG9nZ2xlR3JvdXAuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRoaXMudG9nZ2xlR3JvdXAucmVzcG9uc2l2ZTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMudG9nZ2xlR3JvdXAuaWQgKyBgLWJ1dHRvbi0ke25leHRJZCsrfWA7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvLyBmdW5jdGlvbiByZXR1cm5lZCBieSB0aGUgbGlzdGVuZXJcbiAgICB0aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgYXR0YWNoTGlzdGVuZXJGb3JHcm91cCgpIHtcbiAgICB0aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lciA9XG4gICAgICB0aGlzLl9jaGVja2VkRGlzcGF0Y2hlci5saXN0ZW4oKGdyb3VwSWQ6IHN0cmluZywgYnV0dG9uSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGhpcy5pZCAhPT0gYnV0dG9uSWQgJiYgZ3JvdXBJZCA9PT0gdGhpcy50b2dnbGVHcm91cC5pZCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUobmV3VmFsdWUpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrZWQgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgfVxuXG4gIHNldERpc2FibGVkU3RhdGU/KGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHRvZ2dsZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAoKHRoaXMudG9nZ2xlR3JvdXAgJiYgdGhpcy5jaGVja2VkKSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5jaGVja2VkKTtcbiAgICAgIHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KG5ldyBUb2dnbGVDaGFuZ2VFdmVudCh0aGlzLCB0aGlzLnZhbHVlKSk7XG4gICAgICBpZiAodGhpcy50b2dnbGVHcm91cCkge1xuICAgICAgICB0aGlzLl9jaGVja2VkRGlzcGF0Y2hlci5ub3RpZnkodGhpcy50b2dnbGVHcm91cC5pZCwgdGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICpcbiAgICogbWV0aG9kIGNhbGxlZCBieSB0aGUgZ3JvdXAgaWYgdGhlIGludGVybmFsIHZhbHVlIG9mIHRoZSBncm91cCBpcyBjaGFuZ2VkIHByb2dyYW1hdGljYWxseSxcbiAgICogZG9lcyBub3QgdHJpZ2dlciBjaGFuZ2UgZW1pc3Npb25cbiAgICovXG4gIHNldEdyb3VwU2VsZWN0aW9uKCkge1xuICAgIC8vIHByb3BhZ2F0ZSBjaGFuZ2VzIG9ubHkgaWYgdGhlIHZhbHVlIGluIHRoZSBncm91cCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgYnV0dG9uIGNoZWNrZWQgdmFsdWVcbiAgICBpZiAoIXRoaXMuY2hlY2tlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLmNoZWNrZWQpO1xuICAgICAgdGhpcy5fY2hlY2tlZERpc3BhdGNoZXIubm90aWZ5KHRoaXMudG9nZ2xlR3JvdXAuaWQsIHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBzdmdCdXR0b24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5zdmcgJiYgISF0aGlzLnN2Z0NoZWNrZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgc3ZnVXJsKCk6IHN0cmluZyB7XG4gICAgbGV0IHVzZUZpbGxlZFN2ZyA9IHRoaXMuY2hlY2tlZCB8fCAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5faG92ZXIpO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlKSB7XG4gICAgICB1c2VGaWxsZWRTdmcgPSAhdXNlRmlsbGVkU3ZnO1xuICAgIH1cbiAgICByZXR1cm4gdXNlRmlsbGVkU3ZnID8gdGhpcy5zdmdDaGVja2VkIDogdGhpcy5zdmc7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVHcm91cCA/ICdyYWRpbycgOiAnY2hlY2tib3gnO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgaGFuZGxlRW50ZXJLZXkoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudG9nZ2xlR3JvdXApIHtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==