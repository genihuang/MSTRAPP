/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { mapClassNames } from '@allianz/ngx-ndbx/utils';
import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, forwardRef, Input, QueryList, Renderer2, ViewChild, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject, merge } from 'rxjs';
import { filter, startWith, takeUntil } from 'rxjs/operators';
import { NxRadioToggleButtonBaseComponent } from './radio-toggle-button-base.component';
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MAPPING = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
export class NxRadioToggleComponent {
    /**
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     */
    constructor(renderer, _changeDetectorRef) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleId = (nextId++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
    }
    /**
     * Sets the component to the disabled state.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Sets the name used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToToggleButtonsChange();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge(...this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.onChecked)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this._selection = change.value;
            this.onChangeCallback(this._selection);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToToggleButtonsChange() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        (toggles) => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    () => toggle.select()));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    }
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._selection = value;
        /** @type {?} */
        const correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.value === this._selection));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /**
     * Sets the modifiers for the component.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        /** @type {?} */
        const modifierClasses = mapClassNames(value, [], MAPPING);
        modifierClasses.split(' ')
            .forEach((/**
         * @param {?} className
         * @return {?}
         */
        className => this.renderer.addClass(this.toggleContainer.nativeElement, className)));
    }
    /**
     * \@docs-private
     * @param {?} selection
     * @return {?}
     */
    set selection(selection) {
        this._selection = selection;
        this.onChangeCallback(selection);
    }
    /**
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
}
NxRadioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle',
                template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioToggleComponent)),
                        multi: true
                    }
                ],
                styles: [".nx-radio-toggle{display:flex;height:100%}.nx-radio-toggle:focus+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}.nx-radio-toggle:hover+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#075994}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxRadioToggleComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    toggleContainer: [{ type: ViewChild, args: ['toggleContainer',] }],
    name: [{ type: Input, args: ['nxName',] }],
    toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
    writeValue: [{ type: Input, args: ['nxSelection',] }],
    style: [{ type: Input, args: ['nxStyle',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._toggleId;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._selection;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._destroyed;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._disabled;
    /** @type {?} */
    NxRadioToggleComponent.prototype._disableChange;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.toggleContainer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._name;
    /**
     * \@docs-private
     * @type {?}
     */
    NxRadioToggleComponent.prototype.toggleButtons;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NxRadioToggleComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGxpYW56L25neC1uZGJ4LyIsInNvdXJjZXMiOlsicmFkaW8tdG9nZ2xlL3JhZGlvLXRvZ2dsZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN4RCxPQUFPLEVBR0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFVBQVUsRUFDVixLQUFLLEVBRUwsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQU8sTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRSxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQzs7SUFHcEYsTUFBTSxHQUFHLENBQUM7O01BRVIsT0FBTyxHQUFHO0lBQ2QsVUFBVSxFQUFFLDJCQUEyQjtJQUN2QyxPQUFPLEVBQUUsd0JBQXdCO0NBQ2xDO0FBZUQsTUFBTSxPQUFPLHNCQUFzQjs7Ozs7SUFvRGpDLFlBQW9CLFFBQW1CLEVBQVUsa0JBQXFDO1FBQWxFLGFBQVEsR0FBUixRQUFRLENBQVc7UUFBVSx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBbEQ5RSxjQUFTLEdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBSTFDLGVBQVUsR0FBa0IsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUUxQyxj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QUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxFQUFDLENBQUM7SUFDakcsQ0FBQzs7Ozs7O0lBR0QsSUFBSSxTQUFTLENBQUMsU0FBYztRQUMxQixJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztRQUM1QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkMsQ0FBQzs7OztJQUVELElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDOzs7WUF6SkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxpQkFBaUI7Z0JBQzNCLG1KQUEwQztnQkFDMUMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBRS9DLFNBQVMsRUFBRTtvQkFDVDt3QkFDRSxPQUFPLEVBQUUsaUJBQWlCO3dCQUMxQixXQUFXLEVBQUUsVUFBVTs7O3dCQUFDLEdBQUcsRUFBRSxDQUFDLHNCQUFzQixFQUFDO3dCQUNyRCxLQUFLLEVBQUUsSUFBSTtxQkFDWjtpQkFDRjs7YUFDRjs7OztZQTlCQyxTQUFTO1lBRVQsaUJBQWlCOzs7dUJBMkNoQixLQUFLLFNBQUMsWUFBWTs4QkFhbEIsU0FBUyxTQUFDLGlCQUFpQjttQkFNM0IsS0FBSyxTQUFDLFFBQVE7NEJBWWQsZUFBZSxTQUFDLGdDQUFnQzt5QkE0RGhELEtBQUssU0FBQyxhQUFhO29CQW9CbkIsS0FBSyxTQUFDLFNBQVM7Ozs7Ozs7SUEzSGhCLDJDQUFrRDs7Ozs7SUFFbEQsNENBQXdCOzs7OztJQUV4Qiw0Q0FBa0Q7Ozs7O0lBRWxELDJDQUFtQzs7SUFHbkMsZ0RBQXFDOzs7OztJQWdCckMsaURBQ29DOzs7OztJQUVwQyx1Q0FBc0I7Ozs7O0lBZXRCLCtDQUM2RTs7Ozs7SUFFN0UsbURBQXNDOzs7OztJQUV0QyxrREFBZ0Q7Ozs7O0lBRXBDLDBDQUEyQjs7Ozs7SUFBRSxvREFBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgbWFwQ2xhc3NOYW1lcyB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L3V0aWxzJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgZm9yd2FyZFJlZixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBzdGFydFdpdGgsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOeFJhZGlvVG9nZ2xlQnV0dG9uQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vcmFkaW8tdG9nZ2xlLWJ1dHRvbi1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOeFJhZGlvVG9nZ2xlQnV0dG9uQ2hhbmdlLCBOeFJhZGlvVG9nZ2xlQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpby10b2dnbGUtYnV0dG9uLmNvbXBvbmVudCc7XG5cbmxldCBuZXh0SWQgPSAwO1xuXG5jb25zdCBNQVBQSU5HID0ge1xuICAnbmVnYXRpdmUnOiAnbngtcmFkaW8tdG9nZ2xlLS1uZWdhdGl2ZScsXG4gICdzbWFsbCc6ICdueC1yYWRpby10b2dnbGUtLXNtYWxsJyxcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXJhZGlvLXRvZ2dsZScsXG4gIHRlbXBsYXRlVXJsOiAncmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHN0eWxlVXJsczogWydyYWRpby10b2dnbGUuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOeFJhZGlvVG9nZ2xlQ29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlXG4gICAgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIE54UmFkaW9Ub2dnbGVDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcblxuICBwcml2YXRlIF90b2dnbGVJZDogc3RyaW5nID0gKG5leHRJZCsrKS50b1N0cmluZygpO1xuXG4gIHByaXZhdGUgX3NlbGVjdGlvbjogYW55O1xuXG4gIHByaXZhdGUgX2Rlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBlbWl0cyB0byBzaWduYWwgY2hpbGRyZW4gdG8gcnVuIGNoYW5nZSBkZXRlY3Rpb25cbiAgX2Rpc2FibGVDaGFuZ2UgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLiovXG4gIEBJbnB1dCgnbnhEaXNhYmxlZCcpXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvZXJjZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9kaXNhYmxlZCAhPT0gY29lcmNlZCkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VkO1xuICAgICAgdGhpcy5fZGlzYWJsZUNoYW5nZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3RvZ2dsZUNvbnRhaW5lcicpXG4gIHByaXZhdGUgdG9nZ2xlQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gIHByaXZhdGUgX25hbWU6IHN0cmluZztcblxuICAvKiogU2V0cyB0aGUgbmFtZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LiAqL1xuICBASW5wdXQoJ254TmFtZScpXG4gIHNldCBuYW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5fbmFtZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgfVxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihOeFJhZGlvVG9nZ2xlQnV0dG9uQmFzZUNvbXBvbmVudClcbiAgdG9nZ2xlQnV0dG9uczogUXVlcnlMaXN0PE54UmFkaW9Ub2dnbGVCdXR0b25CYXNlQ29tcG9uZW50PiA9IG5ldyBRdWVyeUxpc3QoKTtcblxuICBwcml2YXRlIG9uVG91Y2hlZENhbGxiYWNrID0gKCkgPT4geyB9O1xuXG4gIHByaXZhdGUgb25DaGFuZ2VDYWxsYmFjayA9IChvcHRpb246IGFueSkgPT4geyB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVUb1RvZ2dsZUJ1dHRvbnNDaGFuZ2UoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBjaGFuZ2VkT3JEZXN0cm95ZWQgPSBtZXJnZSh0aGlzLnRvZ2dsZUJ1dHRvbnMuY2hhbmdlcywgdGhpcy5fZGVzdHJveWVkKTtcblxuICAgIG1lcmdlKC4uLnRoaXMudG9nZ2xlQnV0dG9ucy5tYXAoKGJ1dHRvbjogYW55KSA9PiBidXR0b24ub25DaGVja2VkKSlcbiAgICAgIC5waXBlKHRha2VVbnRpbChjaGFuZ2VkT3JEZXN0cm95ZWQpKVxuICAgICAgLnN1YnNjcmliZSgoY2hhbmdlOiBOeFJhZGlvVG9nZ2xlQnV0dG9uQ2hhbmdlKSA9PiB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IGNoYW5nZS52YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMuX3NlbGVjdGlvbik7XG4gICAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fZGlzYWJsZUNoYW5nZS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgc3Vic2NyaWJlVG9Ub2dnbGVCdXR0b25zQ2hhbmdlKCk6IHZvaWQge1xuICAgIHRoaXMudG9nZ2xlQnV0dG9ucy5jaGFuZ2VzXG4gICAgICAucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKHRoaXMudG9nZ2xlQnV0dG9ucyksXG4gICAgICAgIGZpbHRlcih0b2dnbGVzID0+IHRvZ2dsZXMubGVuZ3RoID4gMCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpXG4gICAgICApLnN1YnNjcmliZSgodG9nZ2xlcykgPT4ge1xuICAgICAgICB0b2dnbGVzLmZvckVhY2godG9nZ2xlID0+IHtcbiAgICAgICAgICB0b2dnbGUucmVzZXRDbGFzc2VzKCk7XG4gICAgICAgICAgaWYgKHRvZ2dsZS52YWx1ZSA9PT0gdGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGVkZ2UgY2FzZSB0aGF0IHRoZSBidXR0b24gd2l0aCB0aGUgdmFsdWUgb2YgdGhpcy5zZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIGRpZG4ndCBleGlzdCB5ZXQgYnV0IHdhcyBhZGRlZCBhZnRlcndhcmRzIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0b2dnbGUuc2VsZWN0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZXMuZmlyc3Quc2V0Rmlyc3RCdXR0b24oKTtcbiAgICAgICAgdG9nZ2xlcy5sYXN0LnNldExhc3RCdXR0b24oKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZUNhbGxiYWNrOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZUNhbGxiYWNrO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkQ2FsbGJhY2s6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWRDYWxsYmFjaztcbiAgfVxuXG4gIC8qKiBQcmVzZWxlY3RzIHRoZSByZXNwZWN0aXZlIG9wdGlvbnMuICovXG4gIEBJbnB1dCgnbnhTZWxlY3Rpb24nKVxuICB3cml0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICBjb25zdCBjb3JyZXNwb25kaW5nQnV0dG9uID1cbiAgICAgIHRoaXMudG9nZ2xlQnV0dG9ucy5maW5kKChidXR0b246IE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQpID0+IGJ1dHRvbi52YWx1ZSA9PT0gdGhpcy5fc2VsZWN0aW9uKTtcbiAgICBpZiAoY29ycmVzcG9uZGluZ0J1dHRvbikge1xuICAgICAgKGNvcnJlc3BvbmRpbmdCdXR0b24gYXMgTnhSYWRpb1RvZ2dsZUJ1dHRvbkNvbXBvbmVudCkuc2VsZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG54LXJhZGlvLXRvZ2dsZS0ke3RoaXMuX3RvZ2dsZUlkfWA7XG4gIH1cblxuICAvKiogU2V0cyB0aGUgbW9kaWZpZXJzIGZvciB0aGUgY29tcG9uZW50LiAqL1xuICBASW5wdXQoJ254U3R5bGUnKVxuICBzZXQgc3R5bGUodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1vZGlmaWVyQ2xhc3NlcyA9IG1hcENsYXNzTmFtZXModmFsdWUsIFtdLCBNQVBQSU5HKTtcbiAgICBtb2RpZmllckNsYXNzZXMuc3BsaXQoJyAnKVxuICAgICAgLmZvckVhY2goY2xhc3NOYW1lID0+IHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy50b2dnbGVDb250YWluZXIubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKSk7XG4gIH1cblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzZXQgc2VsZWN0aW9uKHNlbGVjdGlvbjogYW55KSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayhzZWxlY3Rpb24pO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGlvbigpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb247XG4gIH1cbn1cbiJdfQ==