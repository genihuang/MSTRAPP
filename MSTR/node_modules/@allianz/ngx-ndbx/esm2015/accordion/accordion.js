/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input } from '@angular/core';
import { CdkAccordion } from '@angular/cdk/accordion';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
/** @type {?} */
const DEFAULT_TYPE = 'regular';
export class NxAccordionDirective extends CdkAccordion {
    constructor() {
        super(...arguments);
        this._style = 'regular';
        this._negative = null;
    }
    /**
     * Value for the styling that should be chosen.
     * Default value: 'regular'
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        value = value ? value : DEFAULT_TYPE;
        const [newValue] = value.match(/regular|light/) || [DEFAULT_TYPE];
        this._style = (/** @type {?} */ (newValue));
    }
    /**
     * @return {?}
     */
    get style() {
        return this._style;
    }
    /**
     * Whether the negative set of styles should be used.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
}
NxAccordionDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'nx-accordion',
                host: {
                    '[class.nx-accordion]': 'true',
                    'role': 'presentation'
                }
            },] }
];
NxAccordionDirective.propDecorators = {
    style: [{ type: Input, args: ['nxStyle',] }],
    negative: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._style;
    /**
     * @type {?}
     * @private
     */
    NxAccordionDirective.prototype._negative;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJhY2NvcmRpb24vYWNjb3JkaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7O01BR3hELFlBQVksR0FBbUIsU0FBUztBQVU5QyxNQUFNLE9BQU8sb0JBQXFCLFNBQVEsWUFBWTtJQVJ0RDs7UUFVVSxXQUFNLEdBQW1CLFNBQVMsQ0FBQztRQWlCbkMsY0FBUyxHQUFZLElBQUksQ0FBQztJQVVwQyxDQUFDOzs7Ozs7O0lBckJDLElBQ0ksS0FBSyxDQUFDLEtBQXFCO1FBQzdCLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO2NBRS9CLENBQUMsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUNqRSxJQUFJLENBQUMsTUFBTSxHQUFHLG1CQUFBLFFBQVEsRUFBa0IsQ0FBQztJQUMzQyxDQUFDOzs7O0lBQ0QsSUFBSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7Ozs7OztJQUtELElBQ0ksUUFBUSxDQUFDLEtBQWM7UUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRCxDQUFDOzs7O0lBQ0QsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7OztZQXBDRixTQUFTLFNBQUM7O2dCQUVULFFBQVEsRUFBRSxjQUFjO2dCQUN4QixJQUFJLEVBQUU7b0JBQ0osc0JBQXNCLEVBQUUsTUFBTTtvQkFDOUIsTUFBTSxFQUFFLGNBQWM7aUJBQ3ZCO2FBQ0Y7OztvQkFTRSxLQUFLLFNBQUMsU0FBUzt1QkFjZixLQUFLOzs7Ozs7O0lBcEJOLHNDQUEyQzs7Ozs7SUFpQjNDLHlDQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENka0FjY29yZGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hY2NvcmRpb24nO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IEFjY29yZGlvblN0eWxlIH0gZnJvbSAnLi9leHBhbnNpb24tcGFuZWwnO1xuXG5jb25zdCBERUZBVUxUX1RZUEU6IEFjY29yZGlvblN0eWxlID0gJ3JlZ3VsYXInO1xuXG5ARGlyZWN0aXZlKHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1zZWxlY3RvclxuICBzZWxlY3RvcjogJ254LWFjY29yZGlvbicsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm54LWFjY29yZGlvbl0nOiAndHJ1ZScsXG4gICAgJ3JvbGUnOiAncHJlc2VudGF0aW9uJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE54QWNjb3JkaW9uRGlyZWN0aXZlIGV4dGVuZHMgQ2RrQWNjb3JkaW9uIHtcblxuICBwcml2YXRlIF9zdHlsZTogQWNjb3JkaW9uU3R5bGUgPSAncmVndWxhcic7XG5cbiAgLyoqXG4gICAqIFZhbHVlIGZvciB0aGUgc3R5bGluZyB0aGF0IHNob3VsZCBiZSBjaG9zZW4uXG4gICAqIERlZmF1bHQgdmFsdWU6ICdyZWd1bGFyJ1xuICAgKi9cbiAgQElucHV0KCdueFN0eWxlJylcbiAgc2V0IHN0eWxlKHZhbHVlOiBBY2NvcmRpb25TdHlsZSkge1xuICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IERFRkFVTFRfVFlQRTtcblxuICAgIGNvbnN0IFtuZXdWYWx1ZV0gPSB2YWx1ZS5tYXRjaCgvcmVndWxhcnxsaWdodC8pIHx8IFtERUZBVUxUX1RZUEVdO1xuICAgIHRoaXMuX3N0eWxlID0gbmV3VmFsdWUgYXMgQWNjb3JkaW9uU3R5bGU7XG4gIH1cbiAgZ2V0IHN0eWxlKCk6IEFjY29yZGlvblN0eWxlIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gIH1cblxuICBwcml2YXRlIF9uZWdhdGl2ZTogYm9vbGVhbiA9IG51bGw7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG5lZ2F0aXZlIHNldCBvZiBzdHlsZXMgc2hvdWxkIGJlIHVzZWQuICovXG4gIEBJbnB1dCgpXG4gIHNldCBuZWdhdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX25lZ2F0aXZlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBnZXQgbmVnYXRpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25lZ2F0aXZlO1xuICB9XG59XG4iXX0=