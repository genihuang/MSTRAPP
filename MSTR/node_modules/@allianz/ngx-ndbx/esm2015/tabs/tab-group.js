/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NxTabGroupBase } from './tab-group-base';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, EventEmitter, HostListener, Input, Output, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { merge, Subscription } from 'rxjs';
import { NxAccordionDirective } from '@allianz/ngx-ndbx/accordion';
import { NxExpansionPanelComponent } from '@allianz/ngx-ndbx/accordion';
import { NxTabComponent } from './tab';
import { NxTabBodyComponent } from './tab-body';
import { NxTabHeaderComponent } from './tab-header';
export class NxTabChangeEvent {
}
if (false) {
    /**
     * The index of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.index;
    /**
     * The component instance of the selected or focused tab.
     * @type {?}
     */
    NxTabChangeEvent.prototype.tab;
}
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MOBILE_BREAKPOINT = 480;
export class NxTabGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._groupId = nextId++;
    }
    /**
     * Sets the selected tab.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /**
     * Whether the negative set of styling should be used.
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab should be immediately selected on focus.
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /**
     * Whether the tabs should to accordion on mobile viewports.
     * @return {?}
     */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._switchAppearance(window.innerWidth);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                /** @type {?} */
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                (tab, index) => tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._stateChanges)))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _createChangeEvent(index) {
        /** @type {?} */
        const event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    handleClick(index) {
        this.selectedIndex = this.tabHeader.focusIndex = index;
    }
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    getTabIndex(tab, idx) {
        return this.selectedIndex === idx ? 0 : -1;
    }
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this._switchAppearance(event.target.innerWidth);
    }
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    _switchAppearance(viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._showDesktopVersion();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _showMobileVersion() {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _showDesktopVersion() {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-group',
                template: "\n  <nx-tab-header *ngIf=\"!_showAccordion\"\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabel\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      {{tab.label}}\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(!_showAccordion && selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [content]=\"tab.content\"\n      [active]=\"!_showAccordion && selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n\n  <nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n    <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\">\n      <nx-expansion-panel-header>\n        <nx-expansion-panel-title>{{tab.label}}</nx-expansion-panel-title>\n      </nx-expansion-panel-header>\n      <ng-template [cdkPortalOutlet]=\"tab.content\"></ng-template>\n    </nx-expansion-panel>\n  </nx-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative'
                },
                providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                styles: [":host{display:block}.nx-tab-header__item{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px;outline:0}.nx-tab-header__item::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}"]
            }] }
];
/** @nocollapse */
NxTabGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabGroupComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
    tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
    tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],
    panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
    accordion: [{ type: ViewChild, args: [NxAccordionDirective,] }],
    selectedIndex: [{ type: Input }],
    negative: [{ type: Input }],
    autoselect: [{ type: Input }],
    mobileAccordion: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    selectedTabChange: [{ type: Output }],
    focusChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._groupId;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._negative;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._indexToSelect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._autoselect;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._mobileAccordion;
    /** @type {?} */
    NxTabGroupComponent.prototype._showAccordion;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabs;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabBodyChildren;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.tabHeader;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.panels;
    /**
     * \@docs-private
     * @type {?}
     */
    NxTabGroupComponent.prototype.accordion;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedIndexChange;
    /**
     * An event emitted when the selected tab has changed.
     * @type {?}
     */
    NxTabGroupComponent.prototype.selectedTabChange;
    /**
     * An event emitted when focus has changed within a tab group.
     *
     * **Note:** is not supported in mobile view.
     * @type {?}
     */
    NxTabGroupComponent.prototype.focusChange;
    /**
     * Subscription to tabs being added/removed.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabsSubscription;
    /**
     * Subscription to changes in the tab labels.
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._tabLabelSubscription;
    /**
     * @type {?}
     * @private
     */
    NxTabGroupComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWdyb3VwLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsbGlhbnovbmd4LW5kYngvIiwic291cmNlcyI6WyJ0YWJzL3RhYi1ncm91cC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3BGLE9BQU8sRUFHTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsWUFBWSxFQUNaLFlBQVksRUFDWixLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUViLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ25FLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDdkMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUdwRCxNQUFNLE9BQU8sZ0JBQWdCO0NBTTVCOzs7Ozs7SUFKQyxpQ0FBYzs7Ozs7SUFHZCwrQkFBb0I7OztJQUdsQixNQUFNLEdBQVcsQ0FBQzs7TUFDaEIsaUJBQWlCLEdBQUcsR0FBRztBQVk3QixNQUFNLE9BQU8sbUJBQW1COzs7O0lBaUY5QixZQUFvQixrQkFBcUM7UUFBckMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQWhGakQsbUJBQWMsR0FBa0IsSUFBSSxDQUFDO1FBRXJDLGNBQVMsR0FBWSxLQUFLLENBQUM7UUFDM0IsbUJBQWMs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dXJjZXNDb250ZW50IjpbImltcG9ydCB7IE54VGFiR3JvdXBCYXNlIH0gZnJvbSAnLi90YWItZ3JvdXAtYmFzZSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVmlld0NoaWxkLFxuICBWaWV3Q2hpbGRyZW4sXG4gIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1lcmdlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTnhBY2NvcmRpb25EaXJlY3RpdmUgfSBmcm9tICdAYWxsaWFuei9uZ3gtbmRieC9hY2NvcmRpb24nO1xuaW1wb3J0IHsgTnhFeHBhbnNpb25QYW5lbENvbXBvbmVudCB9IGZyb20gJ0BhbGxpYW56L25neC1uZGJ4L2FjY29yZGlvbic7XG5pbXBvcnQgeyBOeFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiJztcbmltcG9ydCB7IE54VGFiQm9keUNvbXBvbmVudCB9IGZyb20gJy4vdGFiLWJvZHknO1xuaW1wb3J0IHsgTnhUYWJIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL3RhYi1oZWFkZXInO1xuXG5cbmV4cG9ydCBjbGFzcyBOeFRhYkNoYW5nZUV2ZW50IHtcbiAgLyoqIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgb3IgZm9jdXNlZCB0YWIuICovXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqIFRoZSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgdGhlIHNlbGVjdGVkIG9yIGZvY3VzZWQgdGFiLiAqL1xuICB0YWI6IE54VGFiQ29tcG9uZW50O1xufVxuXG5sZXQgbmV4dElkOiBudW1iZXIgPSAwO1xuY29uc3QgTU9CSUxFX0JSRUFLUE9JTlQgPSA0ODA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ254LXRhYi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAndGFiLWdyb3VwLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi90YWItZ3JvdXAuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuaXMtbmVnYXRpdmVdJzogJ25lZ2F0aXZlJ1xuICB9LFxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogTnhUYWJHcm91cEJhc2UsIHVzZUV4aXN0aW5nOiBOeFRhYkdyb3VwQ29tcG9uZW50fV1cbn0pXG5leHBvcnQgY2xhc3MgTnhUYWJHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE54VGFiR3JvdXBCYXNlLCBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCB7XG4gIHByaXZhdGUgX3NlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9ncm91cElkOiBudW1iZXI7XG4gIHByaXZhdGUgX25lZ2F0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2luZGV4VG9TZWxlY3Q6IG51bWJlciB8IG51bGwgPSAwO1xuICBwcml2YXRlIF9hdXRvc2VsZWN0OiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfbW9iaWxlQWNjb3JkaW9uOiBib29sZWFuID0gdHJ1ZTtcbiAgX3Nob3dBY2NvcmRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAQ29udGVudENoaWxkcmVuKE54VGFiQ29tcG9uZW50KSB0YWJzOiBRdWVyeUxpc3Q8TnhUYWJDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGRyZW4oTnhUYWJCb2R5Q29tcG9uZW50KSB0YWJCb2R5Q2hpbGRyZW46IFF1ZXJ5TGlzdDxOeFRhYkJvZHlDb21wb25lbnQ+O1xuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIEBWaWV3Q2hpbGQoJ3RhYkhlYWRlcicpIHRhYkhlYWRlcjogTnhUYWJIZWFkZXJDb21wb25lbnQ7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQFZpZXdDaGlsZHJlbihOeEV4cGFuc2lvblBhbmVsQ29tcG9uZW50KSBwYW5lbHM6IFF1ZXJ5TGlzdDxOeEV4cGFuc2lvblBhbmVsQ29tcG9uZW50PjtcblxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBAVmlld0NoaWxkKE54QWNjb3JkaW9uRGlyZWN0aXZlKSBhY2NvcmRpb246IE54QWNjb3JkaW9uRGlyZWN0aXZlO1xuXG4gIC8qKiBTZXRzIHRoZSBzZWxlY3RlZCB0YWIuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZEluZGV4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7XG4gIH1cbiAgc2V0IHNlbGVjdGVkSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2luZGV4VG9TZWxlY3QgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgbnVsbCk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgbmVnYXRpdmUgc2V0IG9mIHN0eWxpbmcgc2hvdWxkIGJlIHVzZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBuZWdhdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmVnYXRpdmU7XG4gIH1cbiAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9uZWdhdGl2ZSkge1xuICAgICAgdGhpcy5fbmVnYXRpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSB0YWIgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IHNlbGVjdGVkIG9uIGZvY3VzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYXV0b3NlbGVjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b3NlbGVjdDtcbiAgfVxuICBzZXQgYXV0b3NlbGVjdCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2F1dG9zZWxlY3QgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHRhYnMgc2hvdWxkIHRvIGFjY29yZGlvbiBvbiBtb2JpbGUgdmlld3BvcnRzLiAqL1xuICBASW5wdXQoKVxuICBnZXQgbW9iaWxlQWNjb3JkaW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9tb2JpbGVBY2NvcmRpb247XG4gIH1cbiAgc2V0IG1vYmlsZUFjY29yZGlvbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX21vYmlsZUFjY29yZGlvbiA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICAvKiogQW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCB0YWIgaGFzIGNoYW5nZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzZWxlY3RlZEluZGV4Q2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIHRhYiBoYXMgY2hhbmdlZC4gKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkVGFiQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnhUYWJDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiBmb2N1cyBoYXMgY2hhbmdlZCB3aXRoaW4gYSB0YWIgZ3JvdXAuXG4gICAqXG4gICAqICoqTm90ZToqKiBpcyBub3Qgc3VwcG9ydGVkIGluIG1vYmlsZSB2aWV3LlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IGZvY3VzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnhUYWJDaGFuZ2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE54VGFiQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgIC8qKiBTdWJzY3JpcHRpb24gdG8gdGFicyBiZWluZyBhZGRlZC9yZW1vdmVkLiAqL1xuICAgcHJpdmF0ZSBfdGFic1N1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICAgLyoqIFN1YnNjcmlwdGlvbiB0byBjaGFuZ2VzIGluIHRoZSB0YWIgbGFiZWxzLiAqL1xuICAgcHJpdmF0ZSBfdGFiTGFiZWxTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy5fZ3JvdXBJZCA9IG5leHRJZCsrO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fc3dpdGNoQXBwZWFyYW5jZSh3aW5kb3cuaW5uZXJXaWR0aCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5fc3Vic2NyaWJlVG9UYWJMYWJlbHMoKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBhbW91bnQgb2YgdGFicywgaW4gb3JkZXIgdG8gYmVcbiAgICAvLyBhYmxlIHRvIHJlLXJlbmRlciB0aGUgY29udGVudCBhcyBuZXcgdGFicyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICB0aGlzLl90YWJzU3Vic2NyaXB0aW9uID0gdGhpcy50YWJzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4VG9TZWxlY3QgPSB0aGlzLl9jbGFtcFRhYkluZGV4KHRoaXMuX2luZGV4VG9TZWxlY3QpO1xuICAgICAgLy8gTWFpbnRhaW4gdGhlIHByZXZpb3VzbHktc2VsZWN0ZWQgdGFiIGlmIGEgbmV3IHRhYiBpcyBhZGRlZCBvciByZW1vdmVkIGFuZCB0aGVyZSBpcyBub1xuICAgICAgLy8gZXhwbGljaXQgY2hhbmdlIHRoYXQgc2VsZWN0cyBhIGRpZmZlcmVudCB0YWIuXG4gICAgICBpZiAoaW5kZXhUb1NlbGVjdCA9PT0gdGhpcy5fc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzLnRvQXJyYXkoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGFic1tpXS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gQXNzaWduIGJvdGggdG8gdGhlIGBfaW5kZXhUb1NlbGVjdGAgYW5kIGBfc2VsZWN0ZWRJbmRleGAgc28gd2UgZG9uJ3QgZmlyZSBhIGNoYW5nZWRcbiAgICAgICAgICAgIC8vIGV2ZW50LCBvdGhlcndpc2UgdGhlIGNvbnN1bWVyIG1heSBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBpbiBzb21lIGVkZ2UgY2FzZXMgbGlrZVxuICAgICAgICAgICAgLy8gYWRkaW5nIGEgdGFiIHdpdGhpbiB0aGUgYHNlbGVjdGVkSW5kZXhDaGFuZ2VgIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IHRoaXMuX3NlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgKiBBZnRlciB0aGUgY29udGVudCBpcyBjaGVja2VkLCB0aGlzIGNvbXBvbmVudCBrbm93cyB3aGF0IHRhYnMgaGF2ZSBiZWVuIGRlZmluZWRcbiAgICAqIGFuZCB3aGF0IHRoZSBzZWxlY3RlZCBpbmRleCBzaG91bGQgYmUuXG4gICAgKi9cbiAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgIC8vIERvbid0IGNsYW1wIHRoZSBgaW5kZXhUb1NlbGVjdGAgaW1tZWRpYXRlbHkgaW4gdGhlIHNldHRlciBiZWNhdXNlIGl0IGNhbiBoYXBwZW4gdGhhdFxuICAgIC8vIHRoZSBhbW91bnQgb2YgdGFicyBjaGFuZ2VzIGJlZm9yZSB0aGUgYWN0dWFsIGNoYW5nZSBkZXRlY3Rpb24gcnVucy5cbiAgICBjb25zdCBpbmRleFRvU2VsZWN0ID0gdGhpcy5faW5kZXhUb1NlbGVjdCA9IHRoaXMuX2NsYW1wVGFiSW5kZXgodGhpcy5faW5kZXhUb1NlbGVjdCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzZWxlY3RlZCBpbmRleCwgZW1pdCBhIGNoYW5nZSBldmVudC4gU2hvdWxkIG5vdCB0cmlnZ2VyIGlmXG4gICAgLy8gdGhlIHNlbGVjdGVkIGluZGV4IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT09IGluZGV4VG9TZWxlY3QpIHtcbiAgICAgIGNvbnN0IGlzRmlyc3RSdW4gPSB0aGlzLl9zZWxlY3RlZEluZGV4ID09IG51bGw7XG5cbiAgICAgIGlmICghaXNGaXJzdFJ1bikge1xuICAgICAgICB0aGlzLnNlbGVjdGVkVGFiQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXhUb1NlbGVjdCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGFuZ2luZyB0aGVzZSB2YWx1ZXMgYWZ0ZXIgY2hhbmdlIGRldGVjdGlvbiBoYXMgcnVuXG4gICAgICAvLyBzaW5jZSB0aGUgY2hlY2tlZCBjb250ZW50IG1heSBjb250YWluIHJlZmVyZW5jZXMgdG8gdGhlbS5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRhYnMuZm9yRWFjaCgodGFiLCBpbmRleCkgPT4gdGFiLmlzQWN0aXZlID0gaW5kZXggPT09IGluZGV4VG9TZWxlY3QpO1xuXG4gICAgICAgIGlmICghaXNGaXJzdFJ1bikge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleENoYW5nZS5lbWl0KGluZGV4VG9TZWxlY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCAhPT0gaW5kZXhUb1NlbGVjdCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IGluZGV4VG9TZWxlY3Q7XG4gICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl90YWJzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gICAvKipcbiAgICogU3Vic2NyaWJlcyB0byBjaGFuZ2VzIGluIHRoZSB0YWIgbGFiZWxzLiBUaGlzIGlzIG5lZWRlZCwgYmVjYXVzZSB0aGUgQElucHV0IGZvciB0aGUgbGFiZWwgaXNcbiAgICogb24gdGhlIE54VGFiIGNvbXBvbmVudCwgd2hlcmVhcyB0aGUgZGF0YSBiaW5kaW5nIGlzIGluc2lkZSB0aGUgTnhUYWJHcm91cC4gSW4gb3JkZXIgZm9yIHRoZVxuICAgKiBiaW5kaW5nIHRvIGJlIHVwZGF0ZWQsIHdlIG5lZWQgdG8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gaXQgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvblxuICAgKiBtYW51YWxseS5cbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvVGFiTGFiZWxzKCkge1xuICAgIGlmICh0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbiA9IG1lcmdlKC4uLnRoaXMudGFicy5tYXAodGFiID0+IHRhYi5fc3RhdGVDaGFuZ2VzKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCkpO1xuICB9XG5cbiAgLyoqIENsYW1wcyB0aGUgZ2l2ZW4gaW5kZXggdG8gdGhlIGJvdW5kcyBvZiAwIGFuZCB0aGUgdGFicyBsZW5ndGguICovXG4gIHByaXZhdGUgX2NsYW1wVGFiSW5kZXgoaW5kZXg6IG51bWJlciB8IG51bGwpOiBudW1iZXIge1xuICAgIC8vIE5vdGUgdGhlIGB8fCAwYCwgd2hpY2ggZW5zdXJlcyB0aGF0IHZhbHVlcyBsaWtlIE5hTiBjYW4ndCBnZXQgdGhyb3VnaFxuICAgIC8vIGFuZCB3aGljaCB3b3VsZCBvdGhlcndpc2UgdGhyb3cgdGhlIGNvbXBvbmVudCBpbnRvIGFuIGluZmluaXRlIGxvb3BcbiAgICAvLyAoc2luY2UgTWF0aC5tYXgoTmFOLCAwKSA9PT0gTmFOKS5cbiAgICByZXR1cm4gTWF0aC5taW4odGhpcy50YWJzLmxlbmd0aCAtIDEsIE1hdGgubWF4KGluZGV4IHx8IDAsIDApKTtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGZvY3VzQ2hhbmdlZChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5mb2N1c0NoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4KSk7XG4gIH1cblxuICBwcml2YXRlIF9jcmVhdGVDaGFuZ2VFdmVudChpbmRleDogbnVtYmVyKTogTnhUYWJDaGFuZ2VFdmVudCB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTnhUYWJDaGFuZ2VFdmVudDtcbiAgICBldmVudC5pbmRleCA9IGluZGV4O1xuICAgIGlmICh0aGlzLnRhYnMgJiYgdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgZXZlbnQudGFiID0gdGhpcy50YWJzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGhhbmRsZUNsaWNrKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhYkhlYWRlci5mb2N1c0luZGV4ID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiBSZXR1cm5zIHRoZSB0YWJpbmRleCBmb3IgYSB0YWIgbGFiZWxcbiAgICovXG4gIGdldFRhYkluZGV4KHRhYjogTnhUYWJDb21wb25lbnQsIGlkeDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaWR4ID8gMCA6IC0xO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnQgKi9cbiAgX2dldFRhYkxhYmVsSWQoaTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYG54LXRhYi1sYWJlbC0ke3RoaXMuX2dyb3VwSWR9LSR7aX1gO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGNvbnRlbnQgZWxlbWVudCAqL1xuICBfZ2V0VGFiQ29udGVudElkKGk6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBueC10YWItY29udGVudC0ke3RoaXMuX2dyb3VwSWR9LSR7aX1gO1xuICB9XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pXG4gIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgdGhpcy5fc3dpdGNoQXBwZWFyYW5jZShldmVudC50YXJnZXQuaW5uZXJXaWR0aCk7XG4gIH1cblxuICBwcml2YXRlIF9zd2l0Y2hBcHBlYXJhbmNlKHZpZXdQb3J0V2lkdGgpIHtcbiAgICBpZiAoIXRoaXMuX21vYmlsZUFjY29yZGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmlld1BvcnRXaWR0aCA8PSBNT0JJTEVfQlJFQUtQT0lOVCAmJiAhdGhpcy5fc2hvd0FjY29yZGlvbikge1xuICAgICAgdGhpcy5fc2hvd01vYmlsZVZlcnNpb24oKTtcbiAgICB9IGVsc2UgaWYgKHZpZXdQb3J0V2lkdGggPiBNT0JJTEVfQlJFQUtQT0lOVCAmJiB0aGlzLl9zaG93QWNjb3JkaW9uKSB7XG4gICAgICB0aGlzLl9zaG93RGVza3RvcFZlcnNpb24oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zaG93TW9iaWxlVmVyc2lvbigpIHtcbiAgICB0aGlzLl9zaG93QWNjb3JkaW9uID0gdHJ1ZTtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Nob3dEZXNrdG9wVmVyc2lvbigpIHtcbiAgICB0aGlzLl9zaG93QWNjb3JkaW9uID0gZmFsc2U7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogRW11bGF0ZSB0aGUgdGFiIGNoYW5nZSBldmVudCB3aGVuIGFuIGFjY29yZGlvbiBwYW5lbCBpcyBvcGVuZWQgaW5cbiAgICogbW9iaWxlIHZpZXdwb3J0cy5cbiAgICovXG4gIF9wYW5lbE9wZW5lZChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gIH1cbn1cbiJdfQ==