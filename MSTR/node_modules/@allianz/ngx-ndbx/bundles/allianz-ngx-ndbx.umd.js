(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@allianz/ngx-ndbx/base'), require('@angular/platform-browser'), require('@allianz/ngx-ndbx/checkbox'), require('@angular/cdk/observers'), require('@angular/cdk/bidi'), require('@allianz/ngx-ndbx/natural-language-form'), require('@angular/cdk/overlay'), require('@allianz/ngx-ndbx/popover'), require('@allianz/ngx-ndbx/dropdown'), require('@allianz/ngx-ndbx/grid'), require('@allianz/ngx-ndbx/autocomplete'), require('@allianz/ngx-ndbx/formfield'), require('@allianz/ngx-ndbx/button'), require('@allianz/ngx-ndbx/input'), require('@allianz/ngx-ndbx/core'), require('decimal.js'), require('@angular/forms'), require('@angular/cdk/table'), require('@angular/cdk/scrolling'), require('@angular/cdk/collections'), require('@angular/cdk/accordion'), require('@angular/animations'), require('@allianz/ngx-ndbx/icon'), require('rxjs/operators'), require('@angular/cdk/portal'), require('rxjs'), require('@allianz/ngx-ndbx/accordion'), require('@angular/cdk/a11y'), require('@angular/cdk/keycodes'), require('@allianz/ngx-ndbx/utils'), require('@angular/cdk/coercion'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx', ['exports', '@allianz/ngx-ndbx/base', '@angular/platform-browser', '@allianz/ngx-ndbx/checkbox', '@angular/cdk/observers', '@angular/cdk/bidi', '@allianz/ngx-ndbx/natural-language-form', '@angular/cdk/overlay', '@allianz/ngx-ndbx/popover', '@allianz/ngx-ndbx/dropdown', '@allianz/ngx-ndbx/grid', '@allianz/ngx-ndbx/autocomplete', '@allianz/ngx-ndbx/formfield', '@allianz/ngx-ndbx/button', '@allianz/ngx-ndbx/input', '@allianz/ngx-ndbx/core', 'decimal.js', '@angular/forms', '@angular/cdk/table', '@angular/cdk/scrolling', '@angular/cdk/collections', '@angular/cdk/accordion', '@angular/animations', '@allianz/ngx-ndbx/icon', 'rxjs/operators', '@angular/cdk/portal', 'rxjs', '@allianz/ngx-ndbx/accordion', '@angular/cdk/a11y', '@angular/cdk/keycodes', '@allianz/ngx-ndbx/utils', '@angular/cdk/coercion', '@angular/core', '@angular/common'], factory) :
    (factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = {}),global.allianz['ngx-ndbx'].base,global.ng.platformBrowser,global.allianz['ngx-ndbx'].checkbox,global.ng.cdk.observers,global.ng.cdk.bidi,global.allianz['ngx-ndbx']['natural-language-form'],global.ng.cdk.overlay,global.allianz['ngx-ndbx'].popover,global.allianz['ngx-ndbx'].dropdown,global.allianz['ngx-ndbx'].grid,global.allianz['ngx-ndbx'].autocomplete,global.allianz['ngx-ndbx'].formfield,global.allianz['ngx-ndbx'].button,global.allianz['ngx-ndbx'].input,global.allianz['ngx-ndbx'].core,global.decimal_js,global.ng.forms,global.ng.cdk.table,global.ng.cdk.scrolling,global.ng.cdk.collections,global.ng.cdk.accordion,global.ng.animations,global.allianz['ngx-ndbx'].icon,global.rxjs.operators,global.ng.cdk.portal,global.rxjs,global.allianz['ngx-ndbx'].accordion,global.ng.cdk.a11y,global.ng.cdk.keycodes,global.allianz['ngx-ndbx'].utils,global.ng.cdk.coercion,global.ng.core,global.ng.common));
}(this, (function (exports,base,platformBrowser,checkbox,observers,bidi,naturalLanguageForm,overlay,popover,dropdown,grid,autocomplete,formfield,button,input,core,decimal_js,forms,table,scrolling,collections,accordion,animations,icon,operators,portal,rxjs,accordion$1,a11y,keycodes,utils,coercion,core$1,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NdbxModule = /** @class */ (function () {
        function NdbxModule() {
        }
        /**
         * @return {?}
         */
        NdbxModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: NdbxModule
                };
            };
        NdbxModule.decorators = [
            { type: core$1.NgModule, args: [{},] }
        ];
        return NdbxModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE = 'medium';
    /** @type {?} */
    var DEFAULT_TYPE = 'primary';
    /** @type {?} */
    var NX_BUTTON_HOST_BINDINGS = {
        '[class.nx-button--primary]': 'type === "primary"',
        '[class.nx-button--secondary]': 'type === "secondary"',
        '[class.nx-button--tertiary]': 'type === "tertiary"',
        '[class.nx-button--cta]': 'type === "cta"',
        '[class.nx-button--emphasis]': 'type === "emphasis"',
        '[class.nx-button--large]': 'size === "large"',
        '[class.nx-button--medium]': 'size === "medium"',
        '[class.nx-button--small-medium]': 'size === "small-medium"',
        '[class.nx-button--small]': 'size === "small"',
        '[class.nx-button--block]': 'block',
        '[class.nx-button--negative]': 'negative',
    };
    /**
     * \@docs-private
     */
    var /**
     * \@docs-private
     */ NxButtonBase = /** @class */ (function () {
        function NxButtonBase(_changeDetectorRef, _elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE;
            /**
             * \@docs-private
             */
            this.size = DEFAULT_SIZE;
            /**
             * \@docs-private
             */
            this.negative = false;
            /**
             * \@docs-private
             */
            this.block = false;
        }
        Object.defineProperty(NxButtonBase.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/primary|secondary|tertiary|cta|emphasis/) || [DEFAULT_TYPE], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = ( /** @type {?} */(type));
                var _c = __read(this._classNames.match(/small-medium|small|medium|large/) || [DEFAULT_SIZE], 1), _d = _c[0], size = _d === void 0 ? null : _d;
                this.size = ( /** @type {?} */(size));
                this.negative = /negative/.test(this._classNames);
                this.block = /block/.test(this._classNames);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxButtonBase.prototype, "elementRef", {
            /**
             * @docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             */
            get: /**
             * \@docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             * @return {?}
             */ function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        return NxButtonBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxButtonComponent = /** @class */ (function (_super) {
        __extends(NxButtonComponent, _super);
        function NxButtonComponent(changeDetectorRef, elementRef) {
            return _super.call(this, changeDetectorRef, elementRef) || this;
        }
        NxButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                        // tslint:disable-next-line:component-selector
                        selector: 'button[nxButton]',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: NX_BUTTON_HOST_BINDINGS,
                        inputs: ['classNames:nxButton'],
                        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
                    }] }
        ];
        /** @nocollapse */
        NxButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: core$1.ElementRef }
            ];
        };
        return NxButtonComponent;
    }(NxButtonBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxIconButtonComponent = /** @class */ (function (_super) {
        __extends(NxIconButtonComponent, _super);
        function NxIconButtonComponent(changeDetectorRef, elementRef) {
            return _super.call(this, changeDetectorRef, elementRef) || this;
        }
        NxIconButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'button[nxIconButton]',
                        template: "<span class=\"nx-button__content-wrapper\">\n  <ng-content></ng-content>\n</span>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: NX_BUTTON_HOST_BINDINGS,
                        inputs: ['classNames:nxIconButton'],
                        styles: [":host{border:2px solid transparent;border-radius:4px;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;line-height:24px;margin:0 0 24px;padding:10px 30px;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s,box-shadow .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;min-height:48px}:host:disabled{cursor:not-allowed}:host:focus{outline:transparent solid 2px}:host::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]).nx-button--negative:focus,:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-button--primary){color:#fff;background-color:#007ab3}:host(.nx-button--primary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--primary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--primary):disabled{background-color:rgba(0,122,179,.4);border-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--primary.nx-button--negative){background-color:#fff;border-color:#fff;color:#006192}:host(.nx-button--primary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--primary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--primary.nx-button--negative):disabled{background-color:rgba(255,255,255,.4);border-color:transparent;color:rgba(65,65,65,.3)}:host(.nx-button--secondary){background-color:transparent;border-color:#007ab3;color:#006192}:host(.nx-button--secondary):hover:not(:disabled):not(:active){background-color:#075994;border-color:#075994;color:#fff}:host(.nx-button--secondary):active{background-color:#003781;border-color:#003781;box-shadow:none;color:#fff}:host(.nx-button--secondary):disabled{background-color:transparent;border-color:rgba(0,122,179,.4);color:rgba(0,97,146,.4)}:host(.nx-button--secondary.nx-button--negative){color:#fff;border-color:#fff}:host(.nx-button--secondary.nx-button--negative):hover:not(:disabled):not(:active){background-color:#d9d9d9;border-color:#d9d9d9;color:#006192}:host(.nx-button--secondary.nx-button--negative):active{background-color:#c2c2c2;border-color:#c2c2c2;color:#006192}:host(.nx-button--secondary.nx-button--negative):disabled{background-color:transparent;border-color:rgba(255,255,255,.4);color:rgba(255,255,255,.4)}:host(.nx-button--tertiary){background-color:transparent;color:#006192}:host(.nx-button--tertiary):hover{background-color:#ececec}:host(.nx-button--tertiary):active{background-color:#d9d9d9;box-shadow:none}:host(.nx-button--tertiary):disabled{background-color:transparent;color:rgba(0,97,146,.4)}:host(.nx-button--tertiary.nx-button--negative){color:#fff}:host(.nx-button--tertiary.nx-button--negative):hover{background-color:#d9d9d9;color:#006192}:host(.nx-button--tertiary.nx-button--negative):active{background-color:#c2c2c2;color:#006192}:host(.nx-button--tertiary.nx-button--negative):disabled{background-color:transparent;color:rgba(255,255,255,.4)}:host(.nx-button--large){font-size:20px;min-height:72px;padding:22px 46px;line-height:24px}@media (max-width:703px){:host{display:block;width:100%}:host(.nx-button--large){padding:22px 30px}}:host(.nx-button--small-medium){display:inline-block;font-size:16px;padding:6px 22px;text-transform:none;line-height:24px;min-height:40px;width:auto}:host(.nx-button--small){display:inline-block;font-size:14px;padding:6px 14px;text-transform:none;line-height:16px;min-height:32px;width:auto}:host(.nx-button--cta){background-color:#3da556;color:#fff}:host(.nx-button--cta):hover{background-color:#348357}:host(.nx-button--cta):active{background-color:#276442}:host(.nx-button--cta):disabled{background-color:rgba(61,165,86,.4)}:host(.nx-button--emphasis){background-color:#f86200;color:#fff}:host(.nx-button--emphasis):hover{background-color:#e15200}:host(.nx-button--emphasis):active{background-color:#c15500}:host(.nx-button--emphasis):disabled{background-color:rgba(248,98,0,.4)}@media (min-width:704px){:host(.nx-button--block){display:block;width:100%}}:host .nx-button__content-wrapper{display:flex;align-items:center;justify-content:center}:host([nxiconbutton]){padding:0;font-size:24px;flex:0 0 auto}:host([nxiconbutton]).nx-button--small{width:32px;font-size:16px}:host([nxiconbutton]).nx-button--small-medium{width:40px}:host([nxiconbutton]).nx-button--medium{width:48px}:host([nxiconbutton]).nx-button--large{width:72px}"]
                    }] }
        ];
        /** @nocollapse */
        NxIconButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: core$1.ElementRef }
            ];
        };
        return NxIconButtonComponent;
    }(NxButtonBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxButtonModule = /** @class */ (function () {
        function NxButtonModule() {
        }
        NxButtonModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxButtonComponent, NxIconButtonComponent],
                        exports: [NxButtonComponent, NxIconButtonComponent]
                    },] }
        ];
        return NxButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    var NxCheckboxChangeEvent = /** @class */ (function () {
        function NxCheckboxChangeEvent(checked, value, checkbox$$1) {
            this.checked = checked;
            this.value = value;
            this.checkbox = checkbox$$1;
        }
        return NxCheckboxChangeEvent;
    }());
    var NxCheckboxGroupComponent = /** @class */ (function () {
        function NxCheckboxGroupComponent(_changeDetectorRef, ngControl) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._stateChanges = new rxjs.Subject();
            this.selectionChange = new core$1.EventEmitter();
            this._id = "nx-checkbox-group-" + nextId++;
            this._disabled = false;
            this._negative = false;
            this._onChange = ( /**
             * @return {?}
             */function () { });
            this._onTouched = ( /**
             * @return {?}
             */function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /** Sets the Id of the checkbox group. */
            set: /**
             * Sets the Id of the checkbox group.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            /** Sets the name of the checkboxes inside the nx-checkbox-group. */
            set: /**
             * Sets the name of the checkboxes inside the nx-checkbox-group.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Disables all checkboxes inside the nx-checkbox-group. */
            set: /**
             * Disables all checkboxes inside the nx-checkbox-group.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                if (this._label) {
                    this._label.disabled = this._disabled;
                }
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Set the negative styles for all the checkboxes inside the nx-checkbox-group */
            set: /**
             * Set the negative styles for all the checkboxes inside the nx-checkbox-group
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */ function () {
                return this._labelSize;
            },
            /** Sets the label size of the checkboxes inside the group */
            set: /**
             * Sets the label size of the checkboxes inside the group
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._labelSize = value;
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxGroupComponent.prototype, "required", {
            /** Whether the nx-checkbox-group are required. */
            get: /**
             * Whether the nx-checkbox-group are required.
             * @return {?}
             */ function () {
                return this._required;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._required = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.ngControl) {
                    this._value = this._checkboxes.filter(( /**
                     * @param {?} checkbox
                     * @return {?}
                     */function (checkbox$$1) { return checkbox$$1.checked; })).map(( /**
                     * @param {?} cb
                     * @return {?}
                     */function (cb) { return cb.value; }));
                    // Defer setting the value in order to avoid the "Expression
                    // has changed after it was checked" errors from Angular.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        _this._onChange(_this._value);
                    }));
                }
                this._updateSelectedCheckboxFromValue();
                this._checkboxes.changes.subscribe(( /**
                 * @return {?}
                 */function () {
                    _this._value = _this._checkboxes.filter(( /**
                     * @param {?} checkbox
                     * @return {?}
                     */function (checkbox$$1) { return checkbox$$1.checked; })).map(( /**
                     * @param {?} cb
                     * @return {?}
                     */function (cb) { return cb.value; }));
                    if (_this.ngControl) {
                        _this.ngControl.control.setValue(_this._value);
                    }
                    _this._updateSelectedCheckboxFromValue();
                }));
            };
        /**
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._stateChanges.complete();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this._value) {
                    this._value = value;
                }
                this._updateSelectedCheckboxFromValue();
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /**
         * @private
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype._updateSelectedCheckboxFromValue = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._checkboxes !== null) {
                    if (this._value) {
                        this._checkboxes.map(( /**
                         * @param {?} checkbox
                         * @return {?}
                         */function (checkbox$$1) {
                            if (_this._value.indexOf(checkbox$$1.value) !== -1) {
                                checkbox$$1.checked = true;
                            }
                        }));
                    }
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxGroupComponent.prototype.change = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                value = this._checkboxes.filter(( /**
                 * @param {?} checkbox
                 * @return {?}
                 */function (checkbox$$1) { return checkbox$$1.checked; })).map(( /**
                 * @param {?} cb
                 * @return {?}
                 */function (cb) { return cb.value; }));
                this._onChange(value);
                if (this._onTouched) {
                    this._onTouched();
                }
                this.selectionChange.emit(new NxCheckboxChangeEvent(value.checked, value.value, value));
            };
        NxCheckboxGroupComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-checkbox-group',
                        template: "<div>\n  <div class=\"nx-checkbox-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-checkbox-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-checkbox-group]': 'true',
                            '[class.nx-checkbox-group--negative]': 'negative',
                            '[attr.id]': 'id',
                            '[attr.required]': 'required',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.aria-labelledby]': 'this._label?.id  || null',
                            '[attr.role]': '"group"',
                        },
                        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}:host.nx-checkbox-group--negative ::ng-deep nx-error,:host.nx-checkbox-group--negative ::ng-deep nx-icon.nx-error__icon,:host.nx-checkbox-group--negative ::ng-deep nx-label{color:#fff}"]
                    }] }
        ];
        /** @nocollapse */
        NxCheckboxGroupComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: forms.NgControl, decorators: [{ type: core$1.Optional }, { type: core$1.Self }] }
            ];
        };
        NxCheckboxGroupComponent.propDecorators = {
            _checkboxes: [{ type: core$1.ContentChildren, args: [core$1.forwardRef(( /**
                                     * @return {?}
                                     */function () { return NxCheckboxComponent; })), { descendants: true },] }],
            _label: [{ type: core$1.ContentChild, args: [core$1.forwardRef(( /**
                                     * @return {?}
                                     */function () { return base.NxLabelComponent; })), {},] }],
            selectionChange: [{ type: core$1.Output }],
            id: [{ type: core$1.Input }],
            name: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            labelSize: [{ type: core$1.Input }],
            required: [{ type: core$1.Input }]
        };
        return NxCheckboxGroupComponent;
    }());
    var NxCheckboxComponent = /** @class */ (function () {
        function NxCheckboxComponent(_changeDetectorRef, checkboxGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this.checkboxGroup = checkboxGroup;
            this._id = (nextId++).toString();
            this._disabled = false;
            this._negative = false;
            this._labelSize = 'small';
            this._checked = false;
            this._name = null;
            this._indeterminate = false;
            /**
             * An event emitted when the indeterminate value has changed
             */
            this.indeterminateChange = new core$1.EventEmitter(false);
            /**
             * An event emitted when the checked value has changed.
             *
             * Emits the boolean checked value of the changed checkbox.
             */
            this.checkedChange = new core$1.EventEmitter(false);
            /**
             * An event emitted when the checked value has changed.
             *
             * Emits a NxCheckboxChangeEvent.
             */
            this.checkboxChange = new core$1.EventEmitter();
            this.onChangeCallback = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxCheckboxComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "nx-checkbox-" + this._id;
            },
            /**
             * Id of the checkbox.
             *
             * If not set, the checkbox gets an incremented value by default.
             */
            set: /**
             * Id of the checkbox.
             *
             * If not set, the checkbox gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._id) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return (this.checkboxGroup && this.checkboxGroup.name) ? this.checkboxGroup.name : this._name;
            },
            /** Name of the checkbox. */
            set: /**
             * Name of the checkbox.
             * @param {?} name
             * @return {?}
             */ function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return (this.checkboxGroup && this.checkboxGroup.disabled) ? this.checkboxGroup.disabled : this._disabled;
            },
            /** Whether the checkbox is disabled. */
            set: /**
             * Whether the checkbox is disabled.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */ function () {
                return (this.checkboxGroup && this.checkboxGroup.labelSize) ? this.checkboxGroup.labelSize : this._labelSize;
            },
            /**
             * Sets the label size of the checkbox. Default value: small
             */
            set: /**
             * Sets the label size of the checkbox. Default value: small
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._labelSize = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return (this.checkboxGroup && this.checkboxGroup.negative) ? this.checkboxGroup.negative : this._negative;
            },
            /**
             * Whether the checkbox has negative styling.
             */
            set: /**
             * Whether the checkbox has negative styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._negative) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this._checked;
            },
            /** Whether the checkbox is checked. */
            set: /**
             * Whether the checkbox is checked.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._checked) {
                    if (this._indeterminate) {
                        this._setIndeterminate(false);
                    }
                    this._setChecked(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "indeterminate", {
            get: /**
             * @return {?}
             */ function () {
                return this._indeterminate;
            },
            /** Whether the checkbox is indeterminated. */
            set: /**
             * Whether the checkbox is indeterminated.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._indeterminate !== newValue) {
                    if (this._checked) {
                        this._setChecked(false);
                    }
                    this._setIndeterminate(newValue);
                }
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "required", {
            /** Whether the checkbox is required. */
            get: /**
             * Whether the checkbox is required.
             * @return {?}
             */ function () {
                return this._required;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._required = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxComponent.prototype, "value", {
            /** Sets the value of the checkbox. Default value is the checked status. */
            get: /**
             * Sets the value of the checkbox. Default value is the checked status.
             * @return {?}
             */ function () {
                return this._value ? this._value : this.checked.toString();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCheckboxComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return !!(this.checkboxGroup && this.checkboxGroup.ngControl && this.checkboxGroup.ngControl.invalid
                    && this.checkboxGroup.ngControl.touched);
            };
        /**
         * @return {?}
         */
        NxCheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.checkboxGroup) {
                    this.name = this.checkboxGroup.name;
                    // when relevant properties of the parent like name and disabled change
                    // we need to let change detection know that the template needs an update
                    this._parentChangeSubscription = this.checkboxGroup._stateChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._changeDetectorRef.markForCheck();
                    }));
                }
            };
        /**
         * @return {?}
         */
        NxCheckboxComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._parentChangeSubscription) {
                    this._parentChangeSubscription.unsubscribe();
                }
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype._setIndeterminate = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._indeterminate = value;
                this.indeterminateChange.emit(this._indeterminate);
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype._setChecked = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._checked = value;
                this._changeDetectorRef.markForCheck();
            };
        /** Toggles the checked state of the checkbox. */
        /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */
        NxCheckboxComponent.prototype.toggle = /**
         * Toggles the checked state of the checkbox.
         * @return {?}
         */
            function () {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
                if (this.checkboxGroup !== null) {
                    this.checkboxGroup.change(this);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxCheckboxComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === null) {
                    value = false;
                }
                if (value !== this.checked) {
                    this.checked = value;
                }
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxCheckboxComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxCheckboxComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCheckboxComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCheckboxComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.onTouchedCallback();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCheckboxComponent.prototype._onInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // stop the propagation of the native click on the checkbox input so that a click is not triggered twice
                event.stopPropagation();
                if (!this.disabled) {
                    this.toggle();
                    this.checkedChange.emit(this._checked);
                    this.checkboxChange.emit(this._createChangeEvent(this._checked));
                }
            };
        /**@docs-private */
        /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */
        NxCheckboxComponent.prototype._createChangeEvent = /**
         * \@docs-private
         * @private
         * @param {?} checkedValue
         * @return {?}
         */
            function (checkedValue) {
                /** @type {?} */
                var event = new NxCheckboxChangeEvent(checkedValue, this.value, this);
                event.checked = checkedValue;
                event.value = this.value;
                event.checkbox = this;
                return event;
            };
        NxCheckboxComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-checkbox',
                        template: "<input\n  type=\"checkbox\"\n  [id]=\"id\"\n  [name]=\"name\"\n  [checked]=\"checked\"\n  [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  [attr.aria-labelledby]=\"id + '-label'\"\n  (click)=\"_onInputClick($event)\"\n  class=\"nx-checkbox__input\"\n  [value]=\"value\"\n>\n\n<label [id]=\"id + '-label'\" [attr.for]=\"id\" class=\"nx-checkbox__label\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"checked\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n        <div *ngIf=\"indeterminate\" class=\"nx-checkbox__indeterminate-indicator\"></div>\n    </span>\n    <div class=\"nx-checkbox__label-text\">\n        <ng-content></ng-content>\n    </div>\n</label>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-checkbox]': 'true',
                            '[class.disabled]': 'disabled',
                            '[class.nx-checkbox--label-large]': 'labelSize === "large"',
                            '[class.nx-checkbox--negative]': 'negative',
                            '[attr.required]': 'required',
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.aria-invalid]': '_controlInvalid() || null',
                        },
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxCheckboxComponent; })),
                                multi: true
                            }
                        ],
                        styles: [":host{display:block;position:relative;margin-bottom:16px}:host.has-error .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control,:host.ng-invalid .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#dc3149;border-color:#dc3149}:host.has-error .nx-checkbox__control,:host.ng-invalid .nx-checkbox__control{border-color:#dc3149}:host.has-error .nx-checkbox__indeterminate-indicator,:host.ng-invalid .nx-checkbox__indeterminate-indicator{background-color:#dc3149}.nx-checkbox__input{opacity:0;position:absolute}.nx-checkbox__label{font-size:16px;line-height:24px;cursor:pointer;display:flex}:host(.nx-checkbox--label-large) .nx-checkbox__label{font-size:20px;line-height:28px;letter-spacing:.2px}.nx-checkbox__label-text{padding:0;margin-left:12px}.nx-checkbox__control{background-color:#fff;border:2px solid #767676;border-radius:4px;color:#fff;font-size:20px;height:24px;width:24px;min-width:24px;display:flex;justify-content:center;align-items:center;z-index:0;cursor:pointer}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-radius:4px}.nx-checkbox__indeterminate-indicator{background-color:#007ab3;height:2px;width:10px}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{background-color:#007ab3;border-color:#007ab3}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#ececec;border-color:#c2c2c2;cursor:not-allowed}.nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label{cursor:not-allowed;color:#c2c2c2}.nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#c2c2c2}:host(.nx-checkbox--negative) .nx-checkbox__control{border-color:#fff;background-color:transparent}:host(.nx-checkbox--negative) .nx-checkbox__label{color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{color:#000;background-color:#fff;border-color:#fff}:host(.nx-checkbox--negative) .nx-checkbox__input:checked:disabled+.nx-checkbox__label .nx-checkbox__control{color:rgba(255,255,255,.4);border-color:transparent;background-color:rgba(194,194,194,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label{color:rgba(255,255,255,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__control{background-color:rgba(153,153,153,.4);border-color:rgba(217,217,217,.4)}:host(.nx-checkbox--negative) .nx-checkbox__input:disabled+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:rgba(217,217,217,.4)}@media screen and (-ms-high-contrast:active){.nx-checkbox__input:focus+.nx-checkbox__label{color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control::after{background-color:#fff}.nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{border-color:#fff}.nx-checkbox__input:checked+.nx-checkbox__label .nx-checkbox__control{border-color:#ff0;color:#ff0}.nx-checkbox__input:focus:checked+.nx-checkbox__label .nx-checkbox__control{background-color:none;border-color:#fff;color:#fff}.nx-checkbox__label{color:#ff0}.nx-checkbox__input:indeterminate+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#ff0}.nx-checkbox__input:indeterminate:focus+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#fff}}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#075994}:host:not(.nx-checkbox--negative):not(.ng-invalid):not(.has-error):hover .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#075994}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__control{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled]):checked+.nx-checkbox__label .nx-checkbox__indeterminate-indicator{background-color:#003781}:host:not(.nx-checkbox--negative):active .nx-checkbox__input:not([disabled])+.nx-checkbox__label .nx-checkbox__control{border-color:#003781}:host-context([data-whatinput=keyboard]) .nx-checkbox__input:focus+.nx-checkbox__label .nx-checkbox__control{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxCheckboxComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: NxCheckboxGroupComponent, decorators: [{ type: core$1.Optional }] }
            ];
        };
        NxCheckboxComponent.propDecorators = {
            id: [{ type: core$1.Input }],
            name: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            labelSize: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            checked: [{ type: core$1.Input }],
            indeterminate: [{ type: core$1.Input }],
            required: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }],
            indeterminateChange: [{ type: core$1.Output }],
            checkedChange: [{ type: core$1.Output }],
            checkboxChange: [{ type: core$1.Output }]
        };
        return NxCheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCheckboxModule = /** @class */ (function () {
        function NxCheckboxModule() {
        }
        NxCheckboxModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [
                            NxCheckboxComponent,
                            NxCheckboxGroupComponent,
                        ],
                        exports: [
                            NxCheckboxComponent,
                            NxCheckboxGroupComponent,
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule,
                            base.NxLabelModule
                        ]
                    },] }
        ];
        return NxCheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The change event object emitted by the radio group and radio button.
     */
    var /**
     * The change event object emitted by the radio group and radio button.
     */ NxRadioChange = /** @class */ (function () {
        /** The NxRadioComponent that emits the change event. NxRadioChange object can be instantiated with source radio component and a value. */
        function NxRadioChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxRadioChange;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$1 = 0;
    var NxRadioGroupComponent = /** @class */ (function () {
        function NxRadioGroupComponent(_changeDetectorRef, ngControl, _parentForm, _parentFormGroup) {
            this._changeDetectorRef = _changeDetectorRef;
            this.ngControl = ngControl;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            // emits when the internal state changes on properties which are relevant
            // for the radio buttons so that they can mark themself for check
            this._stateChanges = new rxjs.Subject();
            this._id = "nx-radio-group-" + nextId$1++;
            this._disabled = false;
            this._negative = false;
            this._required = false;
            /**
             * An event is dispatched on each group value change.
             */
            this.groupValueChange = new core$1.EventEmitter();
            this._name = "nx-radio-group-" + nextId$1++;
            this._value = null;
            // The currently selected radio button; should match _value
            this._selected = null;
            this._onChange = ( /**
             * @return {?}
             */function () { });
            this._onTouched = ( /**
             * @return {?}
             */function () { });
            if (this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                this.ngControl.valueAccessor = this;
            }
        }
        Object.defineProperty(NxRadioGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /** Sets the Id of the radio group. */
            set: /**
             * Sets the Id of the radio group.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether every radio button in this group should be disabled. */
            set: /**
             * Whether every radio button in this group should be disabled.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                // inform childs about the change where CD should be triggered
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the radio group should have negative styling. */
            set: /**
             * Whether the radio group should have negative styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "required", {
            get: /**
             * @return {?}
             */ function () {
                return this._required;
            },
            /** Sets if at least an option should be selected. */
            set: /**
             * Sets if at least an option should be selected.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._required = coercion.coerceBooleanProperty(value);
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /** Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null). */
            set: 
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /**
             * Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._name = value;
                this._stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioGroupComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () { return this._value; },
            /** Sets the value of the selected radion button in this group (Default: null). */
            set: /**
             * Sets the value of the selected radion button in this group (Default: null).
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (this._value !== newValue) {
                    // Set this before proceeding to ensure no circular loop occurs with selection.
                    this._value = newValue;
                    this._updateSelectedRadioFromValue();
                    this._checkSelectedRadioButton();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._updateSelectedRadioFromValue();
                this._checkSelectedRadioButton();
            };
        /**
         * @return {?}
         */
        NxRadioGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._stateChanges.complete();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRadioGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxRadioGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxRadioGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /** @docs-private this is meant to be called by the radio buttons in this group */
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group
         * @param {?} value
         * @return {?}
         */
        NxRadioGroupComponent.prototype.change = /**
         * \@docs-private this is meant to be called by the radio buttons in this group
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
                this._onChange(value);
                this.groupValueChange.emit(new NxRadioChange(this._selected, this._value));
            };
        /** @docs-private this is meant to be called by the radio buttons in this group. */
        /**
         * \@docs-private this is meant to be called by the radio buttons in this group.
         * @return {?}
         */
        NxRadioGroupComponent.prototype.touch = /**
         * \@docs-private this is meant to be called by the radio buttons in this group.
         * @return {?}
         */
            function () {
                if (this._onTouched) {
                    this._onTouched();
                }
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @private
         * @return {?}
         */
        NxRadioGroupComponent.prototype._updateSelectedRadioFromValue = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                // If the value already matches the selected radio, do nothing.
                /** @type {?} */
                var isAlreadySelected = this._selected != null && this._selected.value === this._value;
                if (this._radios != null && !isAlreadySelected) {
                    this._selected = null;
                    this._radios.forEach(( /**
                     * @param {?} radio
                     * @return {?}
                     */function (radio) {
                        radio.checked = _this.value === radio.value;
                        if (radio.checked) {
                            _this._selected = radio;
                        }
                    }));
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxRadioGroupComponent.prototype._checkSelectedRadioButton = /**
         * @private
         * @return {?}
         */
            function () {
                if (this._selected && !this._selected.checked) {
                    this._selected.checked = true;
                }
            };
        NxRadioGroupComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-group',
                        template: "<div>\n  <div class=\"nx-radio-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            'role': 'radiogroup',
                            '[attr.id]': 'id',
                            '[attr.required]': 'required',
                            '[class.nx-radio-group--negative]': 'negative',
                            '[attr.aria-labelledby]': 'this._label?.id  || null'
                        },
                        styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioGroupComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: forms.NgControl, decorators: [{ type: core$1.Optional }, { type: core$1.Self }] },
                { type: forms.NgForm, decorators: [{ type: core$1.Optional }] },
                { type: forms.FormGroupDirective, decorators: [{ type: core$1.Optional }] }
            ];
        };
        NxRadioGroupComponent.propDecorators = {
            _label: [{ type: core$1.ContentChild, args: [core$1.forwardRef(( /**
                                     * @return {?}
                                     */function () { return base.NxLabelComponent; })), {},] }],
            id: [{ type: core$1.Input, args: ['id',] }],
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            negative: [{ type: core$1.Input }],
            required: [{ type: core$1.Input }],
            groupValueChange: [{ type: core$1.Output, args: ['nxGroupValueChange',] }],
            _radios: [{ type: core$1.ContentChildren, args: [core$1.forwardRef(( /**
                                     * @return {?}
                                     */function () { return NxRadioComponent; })), { descendants: true },] }],
            name: [{ type: core$1.Input }],
            value: [{ type: core$1.Input, args: ['nxValue',] }]
        };
        return NxRadioGroupComponent;
    }());
    var NxRadioComponent = /** @class */ (function () {
        function NxRadioComponent(radioGroup, _changeDetectorRef) {
            this.radioGroup = radioGroup;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-radio-" + nextId$1++;
            this._name = null;
            this._labelSize = 'big';
            this._negative = false;
            /**
             * An event is dispatched on each value change.
             */
            this.valueChange = new core$1.EventEmitter();
            this._value = null;
            this._checked = false;
            this._disabled = false;
            this._required = false;
            this.onChangeCallback = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxRadioComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /** Sets the id of the radio component. */
            set: /**
             * Sets the id of the radio component.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._id !== value) {
                    this._id = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "inputId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.id + "-input";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "labelId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.id + "-label";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return (this.radioGroup && this.radioGroup.name) ? this.radioGroup.name : this._name;
            },
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /** Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null). */
            set: 
            // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
            /**
             * Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null).
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */ function () {
                return this._labelSize;
            },
            /** Sets the label size of the radio button.
             * The default value is `big`.
            */
            set: /**
             * Sets the label size of the radio button.
             * The default value is `big`.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._labelSize !== value) {
                    this._labelSize = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this.radioGroup ? this.radioGroup.negative : this._negative;
            },
            /**
             * Whether the negative set of styles should be used.
             *
             * If the radio button is placed in a radio group, the negative value
             * is overwritten by the group's negative value.
             */
            set: /**
             * Whether the negative set of styles should be used.
             *
             * If the radio button is placed in a radio group, the negative value
             * is overwritten by the group's negative value.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** Sets the value of the form control element (Default: null). */
            set: /**
             * Sets the value of the form control element (Default: null).
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._value) {
                    this._value = value;
                    this.onChangeCallback(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "checked", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._checked;
            },
            /** Whether the radio component is selected. */
            set: /**
             * Whether the radio component is selected.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._checked !== value) {
                    this._checked = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "disabled", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._disabled || (this.radioGroup && this.radioGroup.disabled);
            },
            /** Whether the radio button should be disabled or not. */
            set: /**
             * Whether the radio button should be disabled or not.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioComponent.prototype, "required", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._required || (this.radioGroup && this.radioGroup.required);
            },
            /** Sets if at least a radio button should be selected. */
            set: /**
             * Sets if at least a radio button should be selected.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._required = value;
                // needed when the outer component is set to onPush because it is a native property
                // on the host element
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.radioGroup) {
                    this.name = this.radioGroup.name;
                    // when relevant properties of the parent like name and disabled change
                    // we need to let change detection know that the template needs an update
                    this._parentChangeSubscription = this.radioGroup._stateChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._changeDetectorRef.markForCheck();
                    }));
                    if (this.radioGroup.value === this._value) {
                        this._checked = true;
                    }
                }
            };
        /**
         * @return {?}
         */
        NxRadioComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._parentChangeSubscription) {
                    this._parentChangeSubscription.unsubscribe();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRadioComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === this._value) {
                    this._checked = true;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxRadioComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxRadioComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.onTouchedCallback();
                if (this.radioGroup) {
                    this.radioGroup.touch();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxRadioComponent.prototype._onInputChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this._checked = true;
                this.valueChange.emit(new NxRadioChange(this, this._value));
                this.onChangeCallback(this.value);
                if (this.radioGroup && this.value !== this.radioGroup.value) {
                    this.radioGroup.change(this.value);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxRadioComponent.prototype._onInputClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // make sure click event propagation on the visually hidden input
                // are stopped to prevent multiple events bubbling up.
                event.stopPropagation();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioComponent.prototype._controlInvalid = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var form = this.radioGroup && (this.radioGroup._parentFormGroup || this.radioGroup._parentForm);
                return !!(this.radioGroup && this.radioGroup.ngControl && this.radioGroup.ngControl.invalid
                    && (this.radioGroup.ngControl.touched || (form && form.submitted)));
            };
        NxRadioComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio',
                        template: "<input\n  type=\"radio\"\n  [id]=\"inputId\"\n  [attr.name]=\"name\"\n  [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  (change)=\"_onInputChange($event)\"\n  (click)=\"_onInputClick($event)\"\n  [checked]=\"checked\"\n  [attr.aria-labelledby]=\"labelId\"\n  class=\"nx-radio__input\">\n<label [id]=\"labelId\" [attr.for]=\"inputId\" class=\"nx-radio__label\">\n    <div class=\"nx-radio__circle\">\n      <div class=\"nx-radio__dot\"></div>\n    </div>\n    <span class=\"nx-radio__label--text\"><ng-content></ng-content></span>\n</label>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[attr.required]': 'required',
                            '[class.nx-radio-button--small-label]': 'labelSize === "small"',
                            '[class.nx-radio-button--big-label]': 'labelSize === "big"',
                            '[class.nx-radio--negative]': 'negative',
                            '[class.has-error]': '_controlInvalid() || null',
                            '[attr.aria-invalid]': '_controlInvalid() || null'
                        },
                        styles: [":host{display:block;position:relative}:host.has-error .nx-radio__circle,:host.ng-invalid .nx-radio__circle{border-color:#dc3149}:host.has-error .nx-radio__input:checked+.nx-radio__label .nx-radio__dot,:host.ng-invalid .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#dc3149}.nx-radio__input{opacity:0;position:absolute}:host(.nx-radio-button--small-label) .nx-radio__label{font-size:16px;line-height:24px}:host(.nx-radio-button--big-label) .nx-radio__label{font-size:20px;line-height:28px}:host.nx-radio--negative .nx-radio__label--text{color:#fff}:host.nx-radio--negative .nx-radio__circle{border-color:#fff}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background:#fff}:host.nx-radio--negative .nx-radio__input:disabled+.nx-radio__label{opacity:.4}.nx-radio__label{color:#414141;cursor:pointer;display:inline-flex;position:relative;align-items:center}.nx-radio__circle{border:2px solid #007ab3;border-radius:50%;width:24px;min-width:24px;height:24px;margin-right:12px;position:relative;display:flex;justify-content:center;align-items:center}.nx-radio__dot{width:8px;height:8px;background-color:transparent;border-radius:50%;transition:background-color .2s}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#007ab3}.nx-radio__input:disabled+.nx-radio__label{cursor:not-allowed;color:#c2c2c2}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:#c2c2c2}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:#c2c2c2}:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#003781}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#003781}@media screen and (-ms-high-contrast:active){.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:windowText}.nx-radio__input:focus+.nx-radio__label{color:highlightText}.nx-radio__input:focus+.nx-radio__label .nx-radio__dot{background-color:highlightText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioComponent.ctorParameters = function () {
            return [
                { type: NxRadioGroupComponent, decorators: [{ type: core$1.Optional }] },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxRadioComponent.propDecorators = {
            id: [{ type: core$1.Input, args: ['id',] }],
            name: [{ type: core$1.Input, args: ['name',] }],
            labelSize: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            valueChange: [{ type: core$1.Output, args: ['nxValueChange',] }],
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            checked: [{ type: core$1.Input, args: ['nxChecked',] }],
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            required: [{ type: core$1.Input }]
        };
        return NxRadioComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioModule = /** @class */ (function () {
        function NxRadioModule() {
        }
        NxRadioModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxRadioComponent, NxRadioGroupComponent],
                        exports: [NxRadioComponent, NxRadioGroupComponent],
                        imports: [
                            icon.NxIconModule
                        ]
                    },] }
        ];
        return NxRadioModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$1 = 'normal';
    var NxCopytextComponent = /** @class */ (function () {
        function NxCopytextComponent() {
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE$1;
            /**
             * \@docs-private
             */
            this.negative = false;
        }
        Object.defineProperty(NxCopytextComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            /**
             * Sets the type and whether the negative set of styling should be used.
             *
             * You can combine the values of type NxCopytextType and 'negative'.
             *
             * Default type: 'normal'
             */
            set: /**
             * Sets the type and whether the negative set of styling should be used.
             *
             * You can combine the values of type NxCopytextType and 'negative'.
             *
             * Default type: 'normal'
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/small|medium|normal|large/) || [DEFAULT_TYPE$1], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = ( /** @type {?} */(type));
                this.negative = !!this._classNames.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        NxCopytextComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'p[nxCopytext]',
                        template: "<ng-content></ng-content>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-copy]': 'true',
                            '[class.nx-copy--small]': 'type === "small"',
                            '[class.nx-copy--medium]': 'type === "medium"',
                            '[class.nx-copy--normal]': 'type === "normal"',
                            '[class.nx-copy--large]': 'type === "large"',
                            '[class.nx-copy--negative]': 'negative',
                        },
                        styles: [":host{margin:0 0 32px;font-size:16px;font-size:var(--body-03-font-size,16px);line-height:24px;line-height:var(--body-03-line-height,24px);font-weight:400;font-weight:var(--body-03-font-weight,400);letter-spacing:0;letter-spacing:var(--body-03-letter-spacing,0)}:host.nx-copy.nx-copy{font-weight:400}:host(.nx-copy--negative){color:#fff}:host(.nx-copy--small){font-size:12px;font-size:var(--body-05-font-size,12px);line-height:16px;line-height:var(--body-05-line-height,16px);font-weight:600;font-weight:var(--body-05-font-weight,600);letter-spacing:.5px;letter-spacing:var(--body-05-letter-spacing,.5px)}:host(.nx-copy--medium){font-size:14px;font-size:var(--body-04-font-size,14px);line-height:20px;line-height:var(--body-04-line-height,20px);font-weight:600;font-weight:var(--body-04-font-weight,600);letter-spacing:.2px;letter-spacing:var(--body-04-letter-spacing,.2px)}:host(.nx-copy--large){font-size:18px;font-size:var(--body-02-font-size,18px);line-height:24px;line-height:var(--body-02-line-height,24px);font-weight:400;font-weight:var(--body-02-font-weight,400);letter-spacing:.2px;letter-spacing:var(--body-02-letter-spacing,.2px)}"]
                    }] }
        ];
        NxCopytextComponent.propDecorators = {
            classNames: [{ type: core$1.Input, args: ['nxCopytext',] }]
        };
        return NxCopytextComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCopytextModule = /** @class */ (function () {
        function NxCopytextModule() {
        }
        NxCopytextModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxCopytextComponent],
                        exports: [NxCopytextComponent]
                    },] }
        ];
        return NxCopytextModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$2 = 'section';
    var NxHeadlineComponent = /** @class */ (function () {
        function NxHeadlineComponent() {
            /**
             * \@docs-private
             */
            this.type = DEFAULT_TYPE$2;
            /**
             * \@docs-private
             */
            this.negative = false;
        }
        Object.defineProperty(NxHeadlineComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            /** Changes the type of the headline which affects the visual appearance.
             * You can combine a HeadlineType and 'negative'. */
            set: /**
             * Changes the type of the headline which affects the visual appearance.
             * You can combine a HeadlineType and 'negative'.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                /** @type {?} */
                var typeRegex = /page-bold-caps|page|section|subsection-large|subsection-medium|subsection-small|subsection-xsmall/;
                var _a = __read(this._classNames.match(typeRegex) || [DEFAULT_TYPE$2], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = ( /** @type {?} */(type));
                this.negative = !!this._classNames.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        NxHeadlineComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: '[nxHeadline]',
                        template: "<ng-content></ng-content>",
                        host: {
                            '[class.nx-heading--page]': 'type === "page"',
                            '[class.nx-heading--page-bold-caps]': 'type === "page-bold-caps"',
                            '[class.nx-heading--section]': 'type === "section"',
                            '[class.nx-heading--subsection-large]': 'type === "subsection-large"',
                            '[class.nx-heading--subsection-medium]': 'type === "subsection-medium"',
                            '[class.nx-heading--subsection-small]': 'type === "subsection-small"',
                            '[class.nx-heading--subsection-xsmall]': 'type === "subsection-xsmall"',
                            '[class.nx-heading--negative]': 'negative',
                        },
                        styles: [":host{margin:0}:host ::ng-deep nx-link,:host ::ng-deep nx-link a,:host a{color:#006192;font-size:inherit;font-weight:600;letter-spacing:inherit;text-decoration:none}:host(.nx-heading--page-bold-caps){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);font-weight:700;text-transform:uppercase;margin-bottom:8px}@media (max-width:703px){:host(.nx-heading--page-bold-caps){font-size:40px;font-size:var(--heading-01-small-font-size,40px);line-height:48px;line-height:var(--heading-01-small-line-height,48px)}}:host(.nx-heading--page){font-size:54px;font-size:var(--heading-01-font-size,54px);line-height:60px;line-height:var(--heading-01-line-height,60px);font-weight:300;font-weight:var(--heading-01-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-01-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--page){font-size:40px;font-size:var(--heading-01-small-font-size,40px);line-height:48px;line-height:var(--heading-01-small-line-height,48px)}}:host(.nx-heading--section){font-size:40px;font-size:var(--heading-02-font-size,40px);line-height:48px;line-height:var(--heading-02-line-height,48px);font-weight:300;font-weight:var(--heading-02-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-02-letter-spacing,.3px);margin-bottom:48px}@media (max-width:703px){:host(.nx-heading--section){font-size:35px;font-size:var(--heading-02-small-font-size,35px);line-height:40px;line-height:var(--heading-02-small-line-height,40px)}}:host(.nx-heading--subsection-large){font-size:30px;font-size:var(--heading-03-font-size,30px);line-height:36px;line-height:var(--heading-03-line-height,36px);font-weight:300;font-weight:var(--heading-03-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-03-letter-spacing,.3px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-large){font-size:26px;font-size:var(--heading-03-small-font-size,26px);line-height:32px;line-height:var(--heading-03-small-line-height,32px)}}:host(.nx-heading--subsection-medium){font-size:26px;font-size:var(--heading-04-font-size,26px);line-height:32px;line-height:var(--heading-04-line-height,32px);font-weight:300;font-weight:var(--heading-04-font-weight,300);letter-spacing:.3px;letter-spacing:var(--heading-04-letter-spacing,.3px);margin-bottom:40px}@media (max-width:703px){:host(.nx-heading--subsection-medium){font-size:24px;font-size:var(--heading-04-small-font-size,24px);line-height:32px;line-height:var(--heading-04-small-line-height,32px)}}:host(.nx-heading--subsection-small){font-size:24px;font-size:var(--heading-05-font-size,24px);line-height:32px;line-height:var(--heading-05-line-height,32px);font-weight:600;font-weight:var(--heading-05-font-weight,600);letter-spacing:.2px;letter-spacing:var(--heading-05-letter-spacing,.2px);margin-bottom:32px}@media (max-width:703px){:host(.nx-heading--subsection-small){font-size:20px;font-size:var(--heading-05-small-font-size,20px);line-height:28px;line-height:var(--heading-05-small-line-height,28px)}}:host(.nx-heading--subsection-xsmall){font-size:20px;font-size:var(--heading-06-font-size,20px);line-height:28px;line-height:var(--heading-06-line-height,28px);font-weight:300;font-weight:var(--heading-06-font-weight,300);letter-spacing:.2px;letter-spacing:var(--heading-06-letter-spacing,.2px);margin-bottom:24px}@media (max-width:703px){:host(.nx-heading--subsection-xsmall){font-size:18px;font-size:var(--heading-06-small-font-size,18px);line-height:28px;line-height:var(--heading-06-small-line-height,28px)}}:host(.nx-heading--negative){color:#fff}:host(.nx-heading--negative) ::ng-deep a{color:#fff}"]
                    }] }
        ];
        NxHeadlineComponent.propDecorators = {
            classNames: [{ type: core$1.Input, args: ['nxHeadline',] }]
        };
        return NxHeadlineComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxHeadlineModule = /** @class */ (function () {
        function NxHeadlineModule() {
        }
        NxHeadlineModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxHeadlineComponent],
                        exports: [NxHeadlineComponent]
                    },] }
        ];
        return NxHeadlineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAPPING = {
        'black': 'nx-link--black',
        'negative': 'nx-link--negative',
        'text': 'nx-link--text',
        'block': 'nx-link--block',
        'icon-right': 'nx-link--icon-right'
    };
    /** @type {?} */
    var DEFAULT_CLASSES = ['nx-link'];
    var NxLinkComponent = /** @class */ (function (_super) {
        __extends(NxLinkComponent, _super);
        function NxLinkComponent(_elementRef, _renderer) {
            var _this = _super.call(this, MAPPING, DEFAULT_CLASSES, _elementRef, _renderer) || this;
            _this._renderer = _renderer;
            return _this;
        }
        /**
         * @return {?}
         */
        NxLinkComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // Add a specific link class that the css gets more specific than the nx-icon css
                /** @type {?} */
                var icons = this.elementRef.nativeElement.querySelectorAll('nx-icon');
                for (var i = 0; i < icons.length; i++) {
                    this._renderer.addClass(icons[i], 'nx-link__icon');
                }
            };
        Object.defineProperty(NxLinkComponent.prototype, "elementRef", {
            /**
             * @docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             */
            get: /**
             * \@docs-private
             * getter used for the modal component as a quickfix
             * since button got changed from directive to component the reference used by the ngOpenModelOnClick directive
             * for nxButtons is a reference to component instance instead of an element reference. As a workaround we need a
             * way to reach the elementRef of the component until the modal gets refactored.
             * @return {?}
             */ function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        NxLinkComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-link',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        template: '<ng-content></ng-content>',
                        inputs: ['classNames: nxStyle'],
                        styles: [":host{display:inline-block;color:#006192;cursor:pointer;font-size:16px;font-weight:600;letter-spacing:1px;position:relative;text-decoration:none;transition:color .2s,box-shadow .2s;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:24px}:host:hover{color:#008ed6}:host::ng-deep a:active{color:#003781}:host::ng-deep a{display:flex}:host-context([data-whatinput=keyboard])::ng-deep a:focus{border-radius:4px;outline:0;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-link--negative){color:#fff}:host(.nx-link--negative):hover{color:#c2c2c2}:host(.nx-link--negative)::ng-deep a:active{color:#999}:host(.nx-link--negative)::ng-deep a[aria-disabled],:host(.nx-link--negative)::ng-deep a[disabled]{color:rgba(255,255,255,.4)}:host(.nx-link--black){color:#414141}:host(.nx-link--black):hover{color:#999}:host(.nx-link--black)::ng-deep a:active{color:#5b5b5b}:host(.nx-link--black)::ng-deep a[aria-disabled],:host(.nx-link--black)::ng-deep a[disabled]{color:#c2c2c2}.nx-link--text{font-weight:700;text-transform:none;letter-spacing:normal;border-radius:4px}:host::ng-deep .c-icon,:host::ng-deep nx-icon.nx-link__icon{line-height:24px;font-size:24px;margin:0 8px 0 0}:host::ng-deep .c-icon::before,:host::ng-deep nx-icon.nx-link__icon::before{line-height:inherit;font-size:inherit;width:24px;height:24px}:host(.nx-link--icon-right)::ng-deep .c-icon,:host(.nx-link--icon-right)::ng-deep nx-icon.nx-link__icon{order:2;margin:0 0 0 8px}:host::ng-deep a[aria-disabled],:host::ng-deep a[disabled]{cursor:not-allowed;color:rgba(0,97,146,.4)}:host::ng-deep a[aria-disabled]:active,:host::ng-deep a[disabled]:active{color:#006192}:host::ng-deep a[aria-disabled]:focus,:host::ng-deep a[disabled]:focus{outline:0;box-shadow:none}"]
                    }] }
        ];
        /** @nocollapse */
        NxLinkComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: core$1.Renderer2 }
            ];
        };
        NxLinkComponent.propDecorators = {
            icon: [{ type: core$1.ContentChild, args: [icon.NxIconComponent,] }]
        };
        return NxLinkComponent;
    }(core.MappedStyles));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxLinkModule = /** @class */ (function () {
        function NxLinkModule() {
        }
        NxLinkModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxLinkComponent],
                        exports: [NxLinkComponent]
                    },] }
        ];
        return NxLinkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var /**
     * \@docs-private
     * @abstract
     */ ToggleButton = /** @class */ (function () {
        function ToggleButton() {
        }
        return ToggleButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$2 = 0;
    var NxCircleToggleGroupComponent = /** @class */ (function () {
        function NxCircleToggleGroupComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-circle-toggle-group-" + nextId$2++;
            this._destroyed = new rxjs.Subject();
            /**
             * An event emitted when the selection changes. Outputs the value of the currently selected button.
             */
            this.valueChange = new core$1.EventEmitter();
            this._name = "toggle-group-" + nextId$2++;
            this._negative = false;
            this._responsive = true;
            this.onChangeCallback = ( /**
             * @param {?} value
             * @return {?}
             */function (value) { });
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle group.
             *
             * If not set, the circle toggle group gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._name = value;
                this.updateToggleButtonsNames();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether the circle toggle group is disabled. */
            set: /**
             * Whether the circle toggle group is disabled.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
                if (this.buttons) {
                    this.buttons.forEach(( /**
                     * @param {?} button
                     * @return {?}
                     */function (button$$1) { return button$$1.disabled = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the circle toggle group uses the negative styling. */
            set: /**
             * Whether the circle toggle group uses the negative styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                }
                if (this.buttons) {
                    this.buttons.forEach(( /**
                     * @param {?} button
                     * @return {?}
                     */function (button$$1) { return button$$1.negative = value; }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** The value of the selected circle toggle in the circle toggle group. */
            set: /**
             * The value of the selected circle toggle in the circle toggle group.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.writeValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */ function () {
                return this._responsive;
            },
            /** Whether the circle toggle group has a responsive behavior. */
            set: /**
             * Whether the circle toggle group has a responsive behavior.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.responsive) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this.value !== value) {
                    this._value = value;
                    this.notifySelectedChild(value);
                }
            };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._destroyed.next();
                this._destroyed.complete();
            };
        /**
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscribeToSelectionChanges();
                // react if a content child is deleted, added etc.
                this.buttons.changes
                    .pipe(operators.startWith(this.buttons), operators.filter(( /**
             * @param {?} toggles
             * @return {?}
             */function (toggles) { return toggles.length > 0; })), operators.tap(( /**
                 * @param {?} toggles
                 * @return {?}
                 */function (toggles) {
                    return Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        toggles.forEach(( /**
                         * @param {?} toggle
                         * @return {?}
                         */function (toggle) { return toggle.toggleButton.resetClasses(); }));
                        _this.buttons.first.toggleButton.setFirstButton();
                        _this.buttons.last.toggleButton.setLastButton();
                    }));
                })), operators.takeUntil(this._destroyed))
                    .subscribe(( /**
             * @return {?}
             */function () { return _this.subscribeToSelectionChanges(); }));
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.subscribeToSelectionChanges = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var changedOrDestroyed = rxjs.merge(this.buttons.changes, this._destroyed);
                rxjs.merge.apply(void 0, __spread(this.buttons.map(( /**
                 * @param {?} button
                 * @return {?}
                 */function (button$$1) { return button$$1.selectionChange; })))).pipe(operators.takeUntil(changedOrDestroyed))
                    .subscribe(( /**
             * @param {?} change
             * @return {?}
             */function (change) {
                    _this.onChangeCallback(change.value);
                    _this.valueChange.emit(change.value);
                }));
            };
        /**
         * @docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         */
        /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.notifySelectedChild = /**
         * \@docs-private
         * inform the selected button if the group selection is set programattically at the beginning
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                if (this.buttons) {
                    /** @type {?} */
                    var selected = this.buttons.find(( /**
                     * @param {?} button
                     * @return {?}
                     */function (button$$1) { return button$$1.value === newValue; }));
                    if (selected) {
                        selected.setGroupSelection();
                    }
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.updateToggleButtonsNames = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.buttons) {
                    this.buttons.forEach(( /**
                     * @param {?} button
                     * @return {?}
                     */function (button$$1) { return button$$1.name = _this.name; }));
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleGroupComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "selectedButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.buttons ? this.buttons.find(( /**
                 * @param {?} button
                 * @return {?}
                 */function (button$$1) { return button$$1.checked; })) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleGroupComponent.prototype, "buttons", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        NxCircleToggleGroupComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-circle-toggle-group',
                        template: "<ng-content></ng-content>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxCircleToggleGroupComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.is-responsive]': 'responsive',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                            '[attr.aria-labelledby]': 'name',
                            '[attr.name]': 'name',
                            '[attr.id]': 'id',
                            '[class.nx-circle-toggle-group]': 'true',
                            'role': 'radiogroup'
                        },
                        styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleGroupComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxCircleToggleGroupComponent.propDecorators = {
            _buttons: [{ type: core$1.ContentChildren, args: [ToggleButton,] }],
            valueChange: [{ type: core$1.Output }],
            name: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }],
            responsive: [{ type: core$1.Input }]
        };
        return NxCircleToggleGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxMobileToggleButtonComponent = /** @class */ (function () {
        function NxMobileToggleButtonComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.checked = false;
            this.negative = false;
            this.disabled = false;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.isFirst = true;
                this._changeDetectorRef.markForCheck();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.isLast = true;
                this._changeDetectorRef.markForCheck();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMobileToggleButtonComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.isFirst = false;
                this.isLast = false;
                this._changeDetectorRef.markForCheck();
            };
        NxMobileToggleButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-mobile-toggle-button',
                        template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<span class=\"nx-toggle-button__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-first]': 'isFirst',
                            '[class.is-last]': 'isLast',
                            '[class.is-flipped]': 'checked'
                        },
                        styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;font-weight:nx-font-weights(light);line-height:20px;font-size:14px}.nx-toggle-button__label-text{padding-top:0;padding-right:4px;font-weight:600;color:#007ab3}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff}:host(.is-flipped.nx-toggle-button__mobile-check){opacity:1}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background:#007ab3}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}"]
                    }] }
        ];
        /** @nocollapse */
        NxMobileToggleButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxMobileToggleButtonComponent.propDecorators = {
            checked: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            hint: [{ type: core$1.Input }],
            label: [{ type: core$1.Input }]
        };
        return NxMobileToggleButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ToggleChangeEvent = /** @class */ (function () {
        function ToggleChangeEvent(button$$1, value) {
            this.button = button$$1;
            this.value = value;
        }
        return ToggleChangeEvent;
    }());
    /** @type {?} */
    var nextId$3 = 0;
    var NxCircleToggleComponent = /** @class */ (function (_super) {
        __extends(NxCircleToggleComponent, _super);
        function NxCircleToggleComponent(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
            var _this = _super.call(this) || this;
            _this.toggleGroup = toggleGroup;
            _this._checkedDispatcher = _checkedDispatcher;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._id = "toggle-button-" + nextId$3++;
            /**
             * \@docs-private
             */
            _this.inGroup = false;
            _this._name = null;
            /**
             * An event that is emitted when the checked state fo the circle toggle changes.
             */
            _this.checkedChange = new core$1.EventEmitter();
            /**
             * An event that is emitted when the checked state of the circle toggle changes.
             * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
             */
            _this.selectionChange = new core$1.EventEmitter();
            _this._checked = false;
            _this._value = null;
            _this._iconName = null;
            _this._svg = null;
            _this._svgChecked = null;
            _this._label = null;
            _this._hint = null;
            _this._hover = false;
            /**
             * touched is set to true on touch devices.
             */
            _this._touched = false;
            _this._removeUniqueSelectionListener = ( /**
             * @return {?}
             */function () { });
            _this.onChangeCallback = ( /**
             * @param {?} checked
             * @return {?}
             */function (checked) { });
            _this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            if (_this.toggleGroup) {
                _this.name = _this.toggleGroup.name;
            }
            return _this;
        }
        Object.defineProperty(NxCircleToggleComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             */
            set: /**
             * Id of the circle toggle.
             *
             * If not set, the circle toggle gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            /** Name that is used for accessibility. */
            set: /**
             * Name that is used for accessibility.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this._checked;
            },
            /** Whether the circle toggle is checked. */
            set: /**
             * Whether the circle toggle is checked.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.checked !== newValue) {
                    this._checked = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** The value that is used in the model. */
            set: /**
             * The value that is used in the model.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this._value = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "iconName", {
            get: /**
             * @return {?}
             */ function () {
                return this._iconName;
            },
            /** Id of the icon that should be displayed. */
            set: /**
             * Id of the icon that should be displayed.
             * @param {?} name
             * @return {?}
             */ function (name) {
                this._iconName = name;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svg", {
            get: /**
             * @return {?}
             */ function () {
                return this._svg;
            },
            /** SVG that is displayed if the circle toggle is unchecked. */
            set: /**
             * SVG that is displayed if the circle toggle is unchecked.
             * @param {?} src
             * @return {?}
             */ function (src) {
                this._svg = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgChecked", {
            get: /**
             * @return {?}
             */ function () {
                return this._svgChecked;
            },
            /** SVG that is displayed if the circle toggle is checked. */
            set: /**
             * SVG that is displayed if the circle toggle is checked.
             * @param {?} src
             * @return {?}
             */ function (src) {
                this._svgChecked = src;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this._label;
            },
            /** Label displayed below the circle. */
            set: /**
             * Label displayed below the circle.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._label = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "hint", {
            get: /**
             * @return {?}
             */ function () {
                return this._hint;
            },
            /** Additional hint displayed below the label. */
            set: /**
             * Additional hint displayed below the label.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._hint = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the circle toggle uses the negative set of styling. */
            set: /**
             * Whether the circle toggle uses the negative set of styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.negative !== newValue) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */ function () {
                return this._responsive;
            },
            /** Whether the circle toggle has a responsive behavior. */
            set: /**
             * Whether the circle toggle has a responsive behavior.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.responsive !== newValue) {
                    this._responsive = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether the circle toggle is disabled. */
            set: /**
             * Whether the circle toggle is disabled.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this.disabled !== newValue) {
                    this._disabled = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseEnter = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (!this._touched) {
                    this._hover = true;
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onMouseLeave = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (!this._touched) {
                    this._hover = false;
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.onTouchStart = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._touched = true;
            };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.toggleGroup) {
                    this.attachListenerForGroup();
                }
            };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.toggleGroup) {
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        _this.inGroup = true;
                        _this.negative = _this.toggleGroup.negative;
                        _this.disabled = _this.toggleGroup.disabled;
                        _this.responsive = _this.toggleGroup.responsive;
                        _this.id = _this.toggleGroup.id + ("-button-" + nextId$3++);
                    }));
                }
            };
        /**
         * @return {?}
         */
        NxCircleToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // function returned by the listener
                this._removeUniqueSelectionListener();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCircleToggleComponent.prototype.attachListenerForGroup = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                var _this = this;
                this._removeUniqueSelectionListener =
                    this._checkedDispatcher.listen(( /**
                     * @param {?} groupId
                     * @param {?} buttonId
                     * @return {?}
                     */function (groupId, buttonId) {
                        if (_this.id !== buttonId && groupId === _this.toggleGroup.id) {
                            _this.checked = false;
                        }
                    }));
            };
        /**
         * @param {?} newValue
         * @return {?}
         */
        NxCircleToggleComponent.prototype.writeValue = /**
         * @param {?} newValue
         * @return {?}
         */
            function (newValue) {
                this.checked = newValue;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxCircleToggleComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.toggle = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                event.stopPropagation();
                if ((this.toggleGroup && this.checked) || this.disabled) {
                    return;
                }
                else {
                    this.checked = !this.checked;
                    this.onChangeCallback(this.checked);
                    this.checkedChange.emit(this.checked);
                    this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
                    if (this.toggleGroup) {
                        this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
                    }
                }
            };
        /**
         * @docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         */
        /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
        NxCircleToggleComponent.prototype.setGroupSelection = /**
         * \@docs-private
         *
         * method called by the group if the internal value of the group is changed programatically,
         * does not trigger change emission
         * @return {?}
         */
            function () {
                // propagate changes only if the value in the group is different than the button checked value
                if (!this.checked) {
                    this.checked = !this.checked;
                    this.onChangeCallback(this.checked);
                    this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
                }
            };
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return !!this.svg && !!this.svgChecked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "svgUrl", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                /** @type {?} */
                var useFilledSvg = this.checked || (!this.disabled && this._hover);
                if (this.negative) {
                    useFilledSvg = !useFilledSvg;
                }
                return useFilledSvg ? this.svgChecked : this.svg;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCircleToggleComponent.prototype, "type", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.toggleGroup ? 'radio' : 'checkbox';
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxCircleToggleComponent.prototype.handleEnterKey = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.toggleGroup) {
                    this.toggle(event);
                }
            };
        NxCircleToggleComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-circle-toggle',
                        template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\">\n    </nx-mobile-toggle-button>\n</label>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: ToggleButton,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxCircleToggleComponent; }))
                            },
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxCircleToggleComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-toggle-circle]': 'true',
                            '[class.in-group]': 'inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-responsive]': 'responsive'
                        },
                        styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
                    }] }
        ];
        /** @nocollapse */
        NxCircleToggleComponent.ctorParameters = function () {
            return [
                { type: NxCircleToggleGroupComponent, decorators: [{ type: core$1.Optional }] },
                { type: collections.UniqueSelectionDispatcher },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxCircleToggleComponent.propDecorators = {
            name: [{ type: core$1.Input }],
            checkedChange: [{ type: core$1.Output }],
            selectionChange: [{ type: core$1.Output }],
            checked: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }],
            iconName: [{ type: core$1.Input, args: ['icon',] }],
            svg: [{ type: core$1.Input }],
            svgChecked: [{ type: core$1.Input }],
            label: [{ type: core$1.Input }],
            hint: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            responsive: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            toggleButton: [{ type: core$1.ViewChild, args: [NxMobileToggleButtonComponent,] }],
            onMouseEnter: [{ type: core$1.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core$1.HostListener, args: ['mouseleave',] }],
            onTouchStart: [{ type: core$1.HostListener, args: ['touchstart',] }]
        };
        return NxCircleToggleComponent;
    }(ToggleButton));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxIconToggleButtonComponent = /** @class */ (function () {
        function NxIconToggleButtonComponent() {
            this.inGroup = true;
        }
        NxIconToggleButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-icon-toggle-button',
                        template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-circle-button]': 'true',
                            '[class.is-flipped]': 'checked',
                            '[class.has-checkmark]': '!inGroup',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-negative]': 'negative',
                            '[class.is-touched]': 'touched'
                        },
                        styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer}:host .nx-toggle-circle__label-text{position:relative;display:inline-block;padding-top:12px;line-height:24px;font-size:16px;max-width:16rem;z-index:1;color:#414141}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-text{color:#fff}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border:2px solid #007ab3;display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s}:host .nx-toggle-circle__check-icon{background-color:#3da556;border-radius:50%;border:2px solid #fff;color:#fff;font-size:24px;width:32px;height:32px;margin-left:12px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__label-hint{color:#414141;display:inline-block;line-height:24px;font-size:16px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-hint{color:#fff}}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__label-hint{font-weight:300}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background:#007ab3}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;background:#006192}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;background:#007ab3}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}"]
                    }] }
        ];
        NxIconToggleButtonComponent.propDecorators = {
            inGroup: [{ type: core$1.Input }],
            hint: [{ type: core$1.Input }],
            label: [{ type: core$1.Input }],
            checked: [{ type: core$1.Input }],
            icon: [{ type: core$1.Input }],
            svgUrl: [{ type: core$1.Input, args: ['svg',] }],
            disabled: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            touched: [{ type: core$1.Input }]
        };
        return NxIconToggleButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCircleToggleModule = /** @class */ (function () {
        function NxCircleToggleModule() {
        }
        NxCircleToggleModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [
                            NxCircleToggleGroupComponent,
                            NxCircleToggleComponent,
                            NxIconToggleButtonComponent,
                            NxMobileToggleButtonComponent
                        ],
                        exports: [
                            NxCircleToggleGroupComponent,
                            NxIconToggleButtonComponent,
                            NxCircleToggleComponent,
                            NxMobileToggleButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ]
                    },] }
        ];
        return NxCircleToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$3 = 'normal';
    var NxListComponent = /** @class */ (function () {
        function NxListComponent() {
            /**
             * \@docs-private
             */
            this.negative = false;
            /**
             * \@docs-private
             */
            this.orderedCircle = false;
        }
        Object.defineProperty(NxListComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            /**
             * Sets the visual appearance of the list. You can combine different values:
             *
             * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
             * on modifiers. Defaults to normal.
             *
             * negative: Display the list with a negative set of styling.
             *
             * ordered-circle: Display the list item numbers in a color filled circle.
             */
            set: /**
             * Sets the visual appearance of the list. You can combine different values:
             *
             * xsmall | small | normal: The listed input values are expanded to the underlying BEM conform styles based
             * on modifiers. Defaults to normal.
             *
             * negative: Display the list with a negative set of styling.
             *
             * ordered-circle: Display the list item numbers in a color filled circle.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                var _a = __read(this._classNames.match(/xsmall|small|normal/) || [DEFAULT_TYPE$3], 1), _b = _a[0], type = _b === void 0 ? null : _b;
                this.type = ( /** @type {?} */(type));
                this.negative = !!this._classNames.match(/negative/);
                this.orderedCircle = !!this._classNames.match(/ordered-circle/);
            },
            enumerable: true,
            configurable: true
        });
        NxListComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'ul[nxList], ol[nxList]',
                        template: '<ng-content></ng-content>',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-list--xsmall]': 'type === "xsmall"',
                            '[class.nx-list--small]': 'type === "small"',
                            '[class.nx-list--normal]': 'type === "normal"',
                            '[class.nx-list--negative]': 'negative',
                            '[class.nx-list--ordered-circle]': 'orderedCircle',
                        },
                        styles: [":host{color:#414141;list-style:none;margin-bottom:32px;padding:0;counter-reset:list}:host(.nx-list--normal){font-size:18px;line-height:24px;letter-spacing:.2px}:host(.nx-list--small){font-size:16px;line-height:24px}:host(.nx-list--xsmall){font-size:14px;line-height:20px;letter-spacing:.2px}:host(.nx-list--xsmall):not(ol)::ng-deep li:not([nxlisticon])::before{top:6px}:host(.nx-list--xsmall) ::ng-deep .nx-list__icon{top:-2px}:host(ol.nx-list--xsmall.nx-list--ordered-circle) ::ng-deep li:not([nxlisticon])::before{top:-2px}:host(ol.nx-list--xsmall.nx-list--ordered-circle) ::ng-deep li:not([nxlisticon])::after{top:-2px}:host(.nx-list--negative){color:#fff}:host(.nx-list--negative) ::ng-deep .nx-list__icon{color:#fff}:host ::ng-deep .nx-list__icon{position:absolute;left:0;top:0;font-size:24px;color:#5a5360}:host ::ng-deep li{margin-bottom:16px;padding-left:36px;position:relative}:host(ul) ::ng-deep>li:not([nxlisticon]):before{background-color:#5a5360;border-radius:50%;content:\"\";display:inline-block;height:8px;width:8px;margin-right:16px;position:absolute;left:8px;top:8px}:host(ol) ::ng-deep>li:not([nxlisticon]):before{counter-increment:list;content:counter(list);position:absolute;font-size:inherit;font-weight:700;display:inline-block;width:24px;text-align:center;left:3px}:host ::ng-deep li>::ng-deep ol,:host ::ng-deep li>::ng-deep ul{margin-bottom:16px;margin-top:16px}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):before{width:24px;font-size:16px;line-height:24px;color:#fff;font-weight:400;left:0;z-index:2}:host(ol.nx-list--ordered-circle) ::ng-deep>li:not([nxlisticon]):after{border-radius:50%;width:24px;height:24px;background-color:#5a5360;left:0;top:0;content:'';position:absolute}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):after{background-color:#fff}:host(ol.nx-list--ordered-circle.nx-list--negative)::ng-deep>li:not([nxlisticon]):before{color:#5a5360}:host(ul.nx-list--negative) ::ng-deep>li:not([nxlisticon]):before{background-color:#fff}"]
                    }] }
        ];
        NxListComponent.propDecorators = {
            classNames: [{ type: core$1.Input, args: ['nxList',] }]
        };
        return NxListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxListIconComponent = /** @class */ (function () {
        function NxListIconComponent() {
        }
        NxListIconComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'li[nxListIcon]',
                        template: "\n    <span class=\"nx-list__icon\">\n      <nx-icon [name]='name'></nx-icon>\n    </span>\n    <ng-content></ng-content>"
                    }] }
        ];
        NxListIconComponent.propDecorators = {
            viewRefPrefix: [{ type: core$1.ViewChild, args: ['viewRefPrefix', { read: core$1.ViewContainerRef },] }],
            name: [{ type: core$1.Input, args: ['nxListIcon',] }]
        };
        return NxListIconComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxListModule = /** @class */ (function () {
        function NxListModule() {
        }
        NxListModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxListComponent, NxListIconComponent],
                        imports: [icon.NxIconModule],
                        exports: [NxListComponent, NxListIconComponent],
                        bootstrap: [icon.NxIconComponent]
                    },] }
        ];
        return NxListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$4 = 0;
    /**
     * \@docs-private
     */
    var NxRadioToggleButtonBaseComponent = /** @class */ (function () {
        function NxRadioToggleButtonBaseComponent(renderer) {
            this.renderer = renderer;
            /**
             * \@docs-private
             */
            this.toggleButtonId = 'nx-radio-toggle-button-' + nextId$4++;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.triggerInputClick = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this.toggleInput.nativeElement.click();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setFirstButton = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.setLastButton = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleButtonBaseComponent.prototype.resetClasses = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                utils.removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
            };
        NxRadioToggleButtonBaseComponent.propDecorators = {
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            labelContainer: [{ type: core$1.ViewChild, args: ['toggleButtonLabelContainer',] }],
            toggleInput: [{ type: core$1.ViewChild, args: ['toggleInput',] }]
        };
        return NxRadioToggleButtonBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$5 = 0;
    /** @type {?} */
    var MAPPING$1 = {
        'negative': 'nx-radio-toggle--negative',
        'small': 'nx-radio-toggle--small',
    };
    var NxRadioToggleComponent = /** @class */ (function () {
        function NxRadioToggleComponent(renderer, _changeDetectorRef) {
            this.renderer = renderer;
            this._changeDetectorRef = _changeDetectorRef;
            this._toggleId = (nextId$5++).toString();
            this._destroyed = new rxjs.Subject();
            this._disabled = false;
            // emits to signal children to run change detection
            this._disableChange = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.toggleButtons = new core$1.QueryList();
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            this.onChangeCallback = ( /**
             * @param {?} option
             * @return {?}
             */function (option) { });
        }
        Object.defineProperty(NxRadioToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Sets the component to the disabled state.*/
            set: /**
             * Sets the component to the disabled state.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var coerced = coercion.coerceBooleanProperty(value);
                if (this._disabled !== coerced) {
                    this._disabled = coerced;
                    this._disableChange.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            /** Sets the name used for accessibility. */
            set: /**
             * Sets the name used for accessibility.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._name !== value) {
                    this._name = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.subscribeToToggleButtonsChange();
            };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var changedOrDestroyed = rxjs.merge(this.toggleButtons.changes, this._destroyed);
                rxjs.merge.apply(void 0, __spread(this.toggleButtons.map(( /**
                 * @param {?} button
                 * @return {?}
                 */function (button$$1) { return button$$1.onChecked; })))).pipe(operators.takeUntil(changedOrDestroyed))
                    .subscribe(( /**
             * @param {?} change
             * @return {?}
             */function (change) {
                    _this._selection = change.value;
                    _this.onChangeCallback(_this._selection);
                }));
            };
        /**
         * @return {?}
         */
        NxRadioToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._destroyed.next();
                this._destroyed.complete();
                this._disableChange.complete();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioToggleComponent.prototype.subscribeToToggleButtonsChange = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                var _this = this;
                this.toggleButtons.changes
                    .pipe(operators.startWith(this.toggleButtons), operators.filter(( /**
             * @param {?} toggles
             * @return {?}
             */function (toggles) { return toggles.length > 0; })), operators.takeUntil(this._destroyed)).subscribe(( /**
                 * @param {?} toggles
                 * @return {?}
                 */function (toggles) {
                    toggles.forEach(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (toggle) {
                        toggle.resetClasses();
                        if (toggle.value === _this.selection) {
                            // We need to defer the selection for the edge case that the button with the value of this.selection
                            // didn't exist yet but was added afterwards to prevent changed after checked errors
                            setTimeout(( /**
                             * @return {?}
                             */function () { return toggle.select(); }));
                        }
                    }));
                    toggles.first.setFirstButton();
                    toggles.last.setLastButton();
                }));
            };
        /**
         * @param {?} onChangeCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnChange = /**
         * @param {?} onChangeCallback
         * @return {?}
         */
            function (onChangeCallback) {
                this.onChangeCallback = onChangeCallback;
            };
        /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
        NxRadioToggleComponent.prototype.registerOnTouched = /**
         * @param {?} onTouchedCallback
         * @return {?}
         */
            function (onTouchedCallback) {
                this.onTouchedCallback = onTouchedCallback;
            };
        /** Preselects the respective options. */
        /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
        NxRadioToggleComponent.prototype.writeValue = /**
         * Preselects the respective options.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                this._selection = value;
                /** @type {?} */
                var correspondingButton = this.toggleButtons.find(( /**
                 * @param {?} button
                 * @return {?}
                 */function (button$$1) { return button$$1.value === _this._selection; }));
                if (correspondingButton) {
                    (( /** @type {?} */(correspondingButton))).select();
                }
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioToggleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        Object.defineProperty(NxRadioToggleComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return "nx-radio-toggle-" + this._toggleId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "style", {
            /** Sets the modifiers for the component. */
            set: /**
             * Sets the modifiers for the component.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                /** @type {?} */
                var modifierClasses = utils.mapClassNames(value, [], MAPPING$1);
                modifierClasses.split(' ')
                    .forEach(( /**
             * @param {?} className
             * @return {?}
             */function (className) { return _this.renderer.addClass(_this.toggleContainer.nativeElement, className); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleComponent.prototype, "selection", {
            get: /**
             * @return {?}
             */ function () {
                return this._selection;
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} selection
             * @return {?}
             */ function (selection) {
                this._selection = selection;
                this.onChangeCallback(selection);
            },
            enumerable: true,
            configurable: true
        });
        NxRadioToggleComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-toggle',
                        template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioToggleComponent; })),
                                multi: true
                            }
                        ],
                        styles: [".nx-radio-toggle{display:flex;height:100%}.nx-radio-toggle:focus+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}.nx-radio-toggle:hover+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#075994}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleComponent.ctorParameters = function () {
            return [
                { type: core$1.Renderer2 },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxRadioToggleComponent.propDecorators = {
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            toggleContainer: [{ type: core$1.ViewChild, args: ['toggleContainer',] }],
            name: [{ type: core$1.Input, args: ['nxName',] }],
            toggleButtons: [{ type: core$1.ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
            writeValue: [{ type: core$1.Input, args: ['nxSelection',] }],
            style: [{ type: core$1.Input, args: ['nxStyle',] }]
        };
        return NxRadioToggleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var /**
     * \@docs-private
     */ NxRadioToggleButtonChange = /** @class */ (function () {
        function NxRadioToggleButtonChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxRadioToggleButtonChange;
    }());
    var NxRadioToggleButtonComponent = /** @class */ (function (_super) {
        __extends(NxRadioToggleButtonComponent, _super);
        function NxRadioToggleButtonComponent(radioToggle, renderer, _changeDetectorRef, _toggleDispatcher) {
            var _this = _super.call(this, renderer) || this;
            _this.radioToggle = radioToggle;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._toggleDispatcher = _toggleDispatcher;
            /**
             * \@docs-private
             */
            // emits when the button is checked to notify the group
            _this.onChecked = new rxjs.Subject();
            _this._destroyed = new rxjs.Subject();
            _this._disabled = false;
            _this._selected = false;
            /**
             * Unregister function for _expansionDispatcher.
             */
            _this._removeUniqueSelectionListener = ( /**
             * @return {?}
             */function () { });
            _this._removeUniqueSelectionListener = _this._toggleDispatcher.listen(( /**
             * @param {?} id
             * @param {?} radioToggleId
             * @return {?}
             */function (id, radioToggleId) {
                if (_this.radioToggle && _this.radioToggle.id === radioToggleId && _this.id !== id) {
                    _this._selected = false;
                    // need to let change detector know in case that the select() function was called on another button
                    _this._changeDetectorRef.markForCheck();
                }
            }));
            _this.radioToggle._disableChange.pipe(operators.takeUntil(_this._destroyed)).subscribe(( /**
             * @return {?}
             */function () {
                _this._changeDetectorRef.markForCheck();
            }));
            return _this;
        }
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled || (this.radioToggle && this.radioToggle.disabled);
            },
            /** @docs-private */
            set: /**
             * \@docs-private
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            /** Sets the checked state and notify siblings and the parent group about the change */
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            set: /**
             * Sets the checked state and notify siblings and the parent group about the change
             * @param {?} value
             * @return {?}
             */ 
            // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
            // To select a button without firing the event use the select() function
            function (value) {
                if (this._selected !== value) {
                    this._selected = value;
                    if (this._selected) {
                        this._notifySiblings();
                        this._emitCheckedEvent();
                    }
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._removeUniqueSelectionListener();
                this._destroyed.next();
                this._destroyed.complete();
            };
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "toggleId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.radioToggle.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioToggleButtonComponent.prototype, "id", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.toggleButtonId;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._notifySiblings = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var toggleId = this.radioToggle ? this.radioToggle.id : this.id;
                this._toggleDispatcher.notify(this.id, toggleId);
            };
        /**
         * @private
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype._emitCheckedEvent = /**
         * @private
         * @return {?}
         */
            function () {
                this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
            };
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        // Does NOT emit the onChecked event. Useful when you need to set initial
        // state. Used by the parent to set checked states on initialization and during
        // writeValue() changes.
        /**
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.select =
            // Does NOT emit the onChecked event. Useful when you need to set initial
            // state. Used by the parent to set checked states on initialization and during
            // writeValue() changes.
            /**
             * @return {?}
             */
            function () {
                if (!this._selected) {
                    this._selected = true;
                    this._notifySiblings();
                }
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @return {?}
         */
        NxRadioToggleButtonComponent.prototype.onKeyupSpace = /**
         * @return {?}
         */
            function () {
                this._selected = false;
                this._notifySiblings();
            };
        NxRadioToggleButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-toggle-button',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                        providers: [
                            {
                                provide: NxRadioToggleButtonBaseComponent, useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioToggleButtonComponent; }))
                            }
                        ],
                        styles: [":host{display:flex;position:relative;flex-direction:row}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;border-color:#003781;color:#fff}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#b2d7e8;border-color:#b2d7e8;color:#fff;cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;border-color:#007ab3;color:#fff;cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#ff0;cursor:default;border-color:inherit}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{background-color:#000}}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;min-height:16px;padding:6px;text-transform:none;line-height:16px}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{line-height:24px;padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-radius:0 4px 4px 0;border-width:2px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}}.nx-radio-toggle__label-container{padding:10px 30px;border:2px solid #007ab3;border-radius:0;border-width:2px 0 2px 2px;color:#007ab3;cursor:pointer;flex-grow:1;font-size:16px;font-weight:600;line-height:24px;text-align:center;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#075994;border-color:#075994;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#d9d9d9}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioToggleButtonComponent.ctorParameters = function () {
            return [
                { type: NxRadioToggleComponent, decorators: [{ type: core$1.Inject, args: [core$1.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NxRadioToggleComponent; })),] }] },
                { type: core$1.Renderer2 },
                { type: core$1.ChangeDetectorRef },
                { type: collections.UniqueSelectionDispatcher }
            ];
        };
        NxRadioToggleButtonComponent.propDecorators = {
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            selected: [{ type: core$1.Input, args: ['nxSelected',] }],
            onKeyupSpace: [{ type: core$1.HostListener, args: ['keyup.space',] }]
        };
        return NxRadioToggleButtonComponent;
    }(NxRadioToggleButtonBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioToggleModule = /** @class */ (function () {
        function NxRadioToggleModule() {
        }
        NxRadioToggleModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                        imports: [common.CommonModule, forms.FormsModule, icon.NxIconModule]
                    },] }
        ];
        return NxRadioToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$6 = 0;
    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */
    var NxCheckboxCircleComponent = /** @class */ (function () {
        function NxCheckboxCircleComponent() {
            this._id = (nextId$6++).toString();
            /**
             * An event emitted when the checked value has changed.
             */
            this.checkedChange = new core$1.EventEmitter(false);
            this.onChangeCallback = ( /**
             * @param {?} checked
             * @return {?}
             */function (checked) { });
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            console.warn('`nx-checkbox-circle` is deprecated. Use `nx-circle-toggle` instead.');
        }
        Object.defineProperty(NxCheckboxCircleComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "nx-checkbox-circle-" + this._id;
            },
            /**
             * Id of the checkbox.
             * If not set, the checkbox gets an incremented value by default.
             */
            set: /**
             * Id of the checkbox.
             * If not set, the checkbox gets an incremented value by default.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._id) {
                    this._id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        NxCheckboxCircleComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.checked = value;
                this.checkedChange.emit(value);
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxCheckboxCircleComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxCheckboxCircleComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxCheckboxCircleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxCheckboxCircleComponent.prototype.toggle = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.writeValue(!this.checked);
                this.onChangeCallback(this.checked);
            };
        Object.defineProperty(NxCheckboxCircleComponent.prototype, "svgButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return !!this.svg && !!this.svgChecked;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCheckboxCircleComponent.prototype, "svgUrl", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.checked ? this.svgChecked : this.svg;
            },
            enumerable: true,
            configurable: true
        });
        NxCheckboxCircleComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-checkbox-circle',
                        template: "<input [id]=\"id\" class=\"nx-checkbox-circle__input\" [name]=\"name\" [attr.aria-labelledby]=\"id + '-label'\"\n    type=\"checkbox\" [checked]=\"checked\" (click)=\"toggle()\">\n<label class=\"nx-checkbox-circle__label\" [for]=\"id\"\n  [id]=\"id + '-label'\">\n  <span class=\"nx-checkbox-circle__check-icon\">\n    <nx-icon name=\"check-circle\"></nx-icon>\n  </span>\n  <span class=\"nx-checkbox-circle__icon\">\n    <nx-icon *ngIf=\"iconName\" [name]=\"iconName\"></nx-icon>\n    <img *ngIf=\"svgButton\" class=\"nx-checkbox-circle__icon-image\" [src]=\"svgUrl\"\n    />\n  </span>\n  <span class=\"nx-checkbox-circle__label-text\">\n    {{label}}\n  </span>\n</label>\n",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxCheckboxCircleComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.is-checked]': 'checked'
                        },
                        styles: [":host{display:inline-block;margin-right:65px;vertical-align:top;position:relative}.nx-checkbox-circle__icon-image{height:100%}.nx-checkbox-circle__label-text{display:inline-block;max-width:16rem}.nx-checkbox-circle__input{opacity:0;position:absolute}.nx-checkbox-circle__check-icon{background-color:#f5f5f5;border-radius:50%;color:#3da556;display:block;font-size:31px;text-align:center;line-height:1;width:32px;height:32px;margin-left:1.6rem;padding:0;position:absolute;top:0;left:50%;opacity:0;transition:opacity .3s;z-index:1}@media (max-width:703px){:host{margin-right:48px}.nx-checkbox-circle__check-icon{width:28px;height:28px;font-size:27px;left:45%}}:host(.is-checked) .nx-checkbox-circle__check-icon{opacity:1;transition:opacity .3s}.nx-checkbox-circle__icon{border:2px solid #007ab3;border-radius:50%;content:\"\";display:block;height:8rem;width:8rem;left:50%;margin-left:-4rem;position:absolute;top:5px;transition:background-color .2s,border-color .2s,box-shadow .2s}.nx-checkbox-circle__icon nx-icon{border-radius:50%;color:#007ab3;display:block;font-size:4.8rem;position:absolute;text-align:center;margin:1.4rem;z-index:1}.nx-checkbox-circle__icon:hover{border-color:#006192;cursor:pointer}.nx-checkbox-circle__icon:hover nx-icon{color:#006192}:host(.is-checked) .nx-checkbox-circle__icon{background-color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.is-checked) .nx-checkbox-circle__icon{color:#000}}:host(.is-checked) .nx-checkbox-circle__icon:hover{background-color:#006192;border-color:#006192}:host(.is-checked) .nx-checkbox-circle__icon nx-icon{color:#fff}.nx-checkbox-circle__label{display:inline-block;font-size:16px;font-weight:600;line-height:20px;margin-right:8px;padding:9.5rem 0 0;position:relative;text-align:center}@media (max-width:703px){.nx-checkbox-circle__icon{width:6.4rem;height:6.4rem;margin-left:-3.2rem}.nx-checkbox-circle__icon nx-icon{margin:1.1rem;font-size:4rem}.nx-checkbox-circle__label{margin-right:6px;padding:8rem 0 0;font-size:14px;line-height:16px}}.nx-checkbox-circle__text{display:block;position:absolute;text-align:center;left:0;top:5px;font-size:22px;line-height:8rem;width:8rem;height:8rem;color:#007ab3;border-radius:50%;border:2px solid #007ab3;z-index:0;cursor:pointer}.nx-checkbox-circle__text:hover{color:#006192;border-color:#006192}@media (max-width:703px){.nx-checkbox-circle__text{font-size:18px;line-height:6.4rem;width:6.4rem;height:6.4rem}}:host-context([data-whatinput=keyboard]) .nx-checkbox-circle__input:focus+.nx-checkbox-circle__label ::ng-deep .nx-checkbox-circle__icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxCheckboxCircleComponent.ctorParameters = function () { return []; };
        NxCheckboxCircleComponent.propDecorators = {
            id: [{ type: core$1.Input }],
            name: [{ type: core$1.Input }],
            checkedChange: [{ type: core$1.Output }],
            checked: [{ type: core$1.Input }],
            iconName: [{ type: core$1.Input, args: ['nxIcon',] }],
            svg: [{ type: core$1.Input, args: ['nxSvg',] }],
            svgChecked: [{ type: core$1.Input, args: ['nxSvgChecked',] }],
            label: [{ type: core$1.Input, args: ['nxLabel',] }]
        };
        return NxCheckboxCircleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCheckboxCircleModule = /** @class */ (function () {
        function NxCheckboxCircleModule() {
        }
        NxCheckboxCircleModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxCheckboxCircleComponent],
                        exports: [NxCheckboxCircleComponent],
                        imports: [
                            icon.NxIconModule,
                            common.CommonModule
                        ]
                    },] }
        ];
        return NxCheckboxCircleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$1 = 'small';
    var NxSpinnerComponent = /** @class */ (function () {
        function NxSpinnerComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._size = DEFAULT_SIZE$1;
            this._negative = false;
        }
        Object.defineProperty(NxSpinnerComponent.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            /** Sets the size of the spinner. Default is 'small'. */
            set: /**
             * Sets the size of the spinner. Default is 'small'.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._size) {
                    this._size = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSpinnerComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the spinner should use a negative styling. */
            set: /**
             * Whether the spinner should use a negative styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._negative) {
                    this._negative = coercion.coerceBooleanProperty(value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        NxSpinnerComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-spinner',
                        template: "<div class=\"nx-spinner__spin-block\">\n  <div class=\"nx-spinner__edge-left\"></div>\n  <div class=\"nx-spinner__edge-right\"></div>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-spinner--small]': 'size === "small"',
                            '[class.nx-spinner--medium]': 'size === "medium"',
                            '[class.nx-spinner--large]': 'size === "large"',
                            '[class.nx-spinner--negative]': 'negative',
                            '[attr.role]': '"status"',
                            '[attr.aria-busy]': '"true"',
                            '[attr.aria-live]': '"assertive"',
                        },
                        styles: ["@-webkit-keyframes spin{0%{-webkit-transform:rotate(45deg);transform:rotate(45deg)}100%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}}@keyframes spin{0%{-webkit-transform:rotate(45deg);transform:rotate(45deg)}100%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}}:host{position:relative;display:block}:host(.nx-spinner--small){width:16px;height:16px}:host(.nx-spinner--medium){width:24px;height:24px}:host(.nx-spinner--large){width:40px;height:40px}.nx-spinner__spin-block{width:100%;height:100%;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-style:solid;border-radius:50%;border-color:#007ab3 #ececec #ececec;-webkit-animation-name:spin;animation-name:spin;-webkit-animation-duration:.8s;animation-duration:.8s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}:host(.nx-spinner--small) .nx-spinner__spin-block{border-width:calc(1.6px)}:host(.nx-spinner--medium) .nx-spinner__spin-block{border-width:calc(2.4px)}:host(.nx-spinner--large) .nx-spinner__spin-block{border-width:calc(4px)}.nx-spinner__edge-left,.nx-spinner__edge-right{width:12%;height:12%;border-radius:50%;background-color:#007ab3;position:absolute;top:4%}.nx-spinner__edge-left{left:4%}.nx-spinner__edge-right{right:4%}:host(.nx-spinner--negative) .nx-spinner__spin-block{border-color:#fff rgba(250,247,239,.35) rgba(250,247,239,.35)}:host(.nx-spinner--negative) .nx-spinner__edge-left,:host(.nx-spinner--negative) .nx-spinner__edge-right{background-color:#fff}"]
                    }] }
        ];
        /** @nocollapse */
        NxSpinnerComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxSpinnerComponent.propDecorators = {
            size: [{ type: core$1.Input, args: ['nxSize',] }],
            negative: [{ type: core$1.Input }]
        };
        return NxSpinnerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSpinnerModule = /** @class */ (function () {
        function NxSpinnerModule() {
        }
        NxSpinnerModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [
                            NxSpinnerComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            NxSpinnerComponent
                        ],
                        bootstrap: [],
                        providers: []
                    },] }
        ];
        return NxSpinnerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxModalService = /** @class */ (function () {
        function NxModalService() {
            this.subject = new rxjs.Subject();
            this.close$ = this.subject.asObservable();
        }
        /**
         * @return {?}
         */
        NxModalService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.subject.next();
            };
        NxModalService.decorators = [
            { type: core$1.Injectable }
        ];
        return NxModalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var fadeIn = animations.animation([
        animations.style({ opacity: 0 }),
        animations.animate('300ms', animations.style({ opacity: 1 }))
    ]);
    /** @type {?} */
    var fadeOut = animations.animation(animations.animate('300ms', animations.style({ opacity: 0 })));
    /** @type {?} */
    var scaleUp = animations.animation([
        animations.style({ transform: 'scale(1)', opacity: 1 }),
        animations.animate('250ms', animations.style({ transform: 'scale(1.3)', opacity: 0 }))
    ]);
    /** @type {?} */
    var scaleDown = animations.animation([
        animations.style({ transform: 'scale(1.3)', opacity: 0 }),
        animations.animate('250ms', animations.style({ transform: 'scale(1)', opacity: 1 }))
    ]);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Container for the action buttons in a modal. Has a fixed position at the bottom of the modal on scroll.
     */
    var NxModalActionsDirective = /** @class */ (function () {
        function NxModalActionsDirective() {
        }
        NxModalActionsDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[nxModalActions]',
                        host: {
                            '[class.nx-modal__actions]': 'true'
                        }
                    },] }
        ];
        return NxModalActionsDirective;
    }());
    /**
     * Scrollable container for the content of a modal.
     */
    var NxModalContentDirective = /** @class */ (function () {
        function NxModalContentDirective() {
        }
        NxModalContentDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[nxModalContent]',
                        host: {
                            '[class.nx-modal__content]': 'true'
                        }
                    },] }
        ];
        return NxModalContentDirective;
    }());
    var NxModalComponent = /** @class */ (function () {
        function NxModalComponent(modalService, eventManager, _changeDetectorRef) {
            this.modalService = modalService;
            this.eventManager = eventManager;
            this._changeDetectorRef = _changeDetectorRef;
            this._closeButtonLabel = 'Close dialog';
            /**
             * Whether the modal view should close when the user hits the escape key.
             * Default is true.
             */
            this.hideOnEsc = true;
            /**
             * Whether the modal view should close when the user clicks on the backdrop.
             * Default is true.
             */
            this.hideOnClickOutside = true;
            /**
             * Whether the modal view should have a close icon in the upper right corner.
             * Default is true.
             */
            this.showCloseIcon = true;
            /**
             * An event emitted when the user clicks on the backdrop or uses the built-in close button.
             * This event can be applied in conjunction with the custom open state handling
             * of a modal to close it when requested by the user.
             */
            this.closeEvent = new core$1.EventEmitter();
            this.closeSubscription = rxjs.Subscription.EMPTY;
        }
        Object.defineProperty(NxModalComponent.prototype, "closeButtonLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._closeButtonLabel;
            },
            /** Sets the 'aria-label' of the modal close button needed for accessibility.
             *
             * Default value is 'Close dialog'.
             */
            set: /**
             * Sets the 'aria-label' of the modal close button needed for accessibility.
             *
             * Default value is 'Close dialog'.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._closeButtonLabel) {
                    this._closeButtonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxModalComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.closeSubscription = this.modalService.close$.subscribe(( /**
                 * @return {?}
                 */function () { return _this.closeEvent.emit(); }));
                this.eventManager.addGlobalEventListener('window', 'keyup.esc', ( /**
                 * @return {?}
                 */function () {
                    if (_this.hideOnEsc) {
                        _this.modalService.close();
                    }
                }));
            };
        /**
         * @return {?}
         */
        NxModalComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.closeSubscription.unsubscribe();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxModalComponent.prototype.clickOutsideModal = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this.hideOnClickOutside) {
                    this.modalService.close();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxModalComponent.prototype.closeButtonClick = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.modalService.close();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} evt
         * @return {?}
         */
        NxModalComponent.prototype.cancelClick = /**
         * \@docs-private
         * @param {?} evt
         * @return {?}
         */
            function (evt) {
                evt.stopPropagation();
            };
        NxModalComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-modal',
                        template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n  <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n    <div class=\"nx-modal__position\">\n      <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n\n        <button\n          (click)=\"closeButtonClick()\"\n          *ngIf=\"showCloseIcon\"\n          [attr.aria-label]=\"closeButtonLabel\"\n          class=\"nx-modal__close\"\n          type=\"button\">\n          <nx-icon name=\"close\"></nx-icon>\n        </button>\n\n        <div class=\"nx-modal__content-wrapper\">\n          <ng-container *ngIf=\"body else projectContent\">\n            <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n          </ng-container>\n\n          <ng-template #projectContent>\n            <ng-content></ng-content>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('fadeInOut', [
                                animations.transition(':enter', [
                                    animations.useAnimation(fadeIn),
                                    animations.query('@scaleUpDown', [
                                        animations.animateChild()
                                    ])
                                ]),
                                animations.transition(':leave', [
                                    animations.query('@scaleUpDown', [
                                        animations.animateChild()
                                    ]),
                                    animations.useAnimation(fadeOut)
                                ])
                            ]),
                            animations.trigger('scaleUpDown', [
                                animations.transition(':enter', animations.useAnimation(scaleDown)),
                                animations.transition(':leave', animations.useAnimation(scaleUp))
                            ])
                        ],
                        host: {
                            '[@fadeInOut]': '',
                            '[class.nx-modal--fixed-width]': 'size === "fixed"'
                        },
                        styles: [".nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:100;align-items:center;justify-content:center;transition:opacity .3s}.nx-modal__backdrop{background-color:rgba(0,0,0,.35);height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;background:#fff;box-shadow:0 8px 24px rgba(65,65,65,.35)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width:703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;color:#414141;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:0;padding:0}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-modal__close:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}@media (max-width:703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid #d9d9d9;display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;background:#fff;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 72px - 48px)}@media (max-width:703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 72px - 48px)}}"]
                    }] }
        ];
        /** @nocollapse */
        NxModalComponent.ctorParameters = function () {
            return [
                { type: NxModalService },
                { type: platformBrowser.EventManager },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxModalComponent.propDecorators = {
            closeButtonLabel: [{ type: core$1.Input }],
            body: [{ type: core$1.Input, args: ['nxBody',] }],
            hideOnEsc: [{ type: core$1.Input, args: ['nxHideOnEsc',] }],
            hideOnClickOutside: [{ type: core$1.Input, args: ['nxHideOnClickOutside',] }],
            showCloseIcon: [{ type: core$1.Input, args: ['nxShowCloseIcon',] }],
            size: [{ type: core$1.Input, args: ['nxSize',] }],
            closeEvent: [{ type: core$1.Output, args: ['nxClose',] }]
        };
        return NxModalComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxOpenModalOnClickDirective = /** @class */ (function () {
        function NxOpenModalOnClickDirective(templateRef, viewContainer, modalService) {
            var _this = this;
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.modalService = modalService;
            /**
             * \@docs-private
             */
            this.clickHandler = ( /**
             * @param {?} event
             * @return {?}
             */function (event) {
                _this.viewContainer.clear();
                // instantiate the template onto which this directive is applied
                /** @type {?} */
                var viewRef = _this.viewContainer.createEmbeddedView(_this.templateRef);
                // we need to mark the viewRef explicitly if the modal is used inside another
                // component that is using onPush change detection
                viewRef.markForCheck();
                event.preventDefault();
                event.stopPropagation();
            });
        }
        /**
         * @return {?}
         */
        NxOpenModalOnClickDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscription = this.modalService.close$.subscribe(( /**
                 * @return {?}
                 */function () { return _this.viewContainer.clear(); }));
            };
        /**
         * @return {?}
         */
        NxOpenModalOnClickDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.elements.forEach(( /**
                 * @param {?} el
                 * @return {?}
                 */function (el) {
                    if (el.removeEventListener) {
                        el.removeEventListener('click', _this.clickHandler);
                    }
                }));
                this.subscription.unsubscribe();
            };
        Object.defineProperty(NxOpenModalOnClickDirective.prototype, "nxOpenModalOnClick", {
            /**
             * One or multiple template reference variables pointing to elements
             * which should trigger opening the modal on click.
             *
             * Value: A single template reference variable or an array of template reference variables.
             */
            set: /**
             * One or multiple template reference variables pointing to elements
             * which should trigger opening the modal on click.
             *
             * Value: A single template reference variable or an array of template reference variables.
             * @param {?} elements
             * @return {?}
             */ function (elements) {
                var _this = this;
                // also support the case where only one element is passed, check for the length property to be sure elements is an array
                if (elements.length) {
                    this.elements = elements;
                }
                else {
                    this.elements = [elements];
                }
                // add a click event listener to any element passed as property to this directive
                this.elements.forEach(( /**
                 * @param {?} el
                 * @return {?}
                 */function (el) {
                    if (el.addEventListener) {
                        el.addEventListener('click', _this.clickHandler);
                        // workaround until refactoring: if the reference is a component
                        // reference the component has to implement a getter to its own elementRef
                    }
                    else if (el.elementRef) {
                        el.elementRef.nativeElement.addEventListener('click', _this.clickHandler);
                    }
                    else {
                        console.warn("nxOpenModalOnClick: Given Element doesn't appear to be an ElementRef.", el);
                    }
                }));
            },
            enumerable: true,
            configurable: true
        });
        NxOpenModalOnClickDirective.decorators = [
            { type: core$1.Directive, args: [{ selector: '[nxOpenModalOnClick]' },] }
        ];
        /** @nocollapse */
        NxOpenModalOnClickDirective.ctorParameters = function () {
            return [
                { type: core$1.TemplateRef },
                { type: core$1.ViewContainerRef },
                { type: NxModalService }
            ];
        };
        NxOpenModalOnClickDirective.propDecorators = {
            nxOpenModalOnClick: [{ type: core$1.Input }]
        };
        return NxOpenModalOnClickDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxModalModule = /** @class */ (function () {
        function NxModalModule() {
        }
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention
        // define the modal service on root level as an application wide singleton,
        // assuming that we only display one modal at a time, which seems quite reasonable
        // this is static and named "forRoot" by convention
        /**
         * @return {?}
         */
        NxModalModule.forRoot =
            // define the modal service on root level as an application wide singleton,
            // assuming that we only display one modal at a time, which seems quite reasonable
            // this is static and named "forRoot" by convention
            /**
             * @return {?}
             */
            function () {
                return {
                    ngModule: NxModalModule,
                    providers: [NxModalService]
                };
            };
        NxModalModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [common.CommonModule, a11y.A11yModule, icon.NxIconModule],
                        declarations: [
                            NxModalComponent,
                            NxOpenModalOnClickDirective,
                            NxModalActionsDirective,
                            NxModalContentDirective
                        ],
                        exports: [
                            NxModalComponent,
                            NxOpenModalOnClickDirective,
                            NxModalActionsDirective,
                            NxModalContentDirective
                        ],
                    },] }
        ];
        return NxModalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$7 = 0;
    var NxSwitcherComponent = /** @class */ (function () {
        function NxSwitcherComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-switcher-" + nextId$7++;
            this._labelPosition = 'right';
            this._name = null;
            this._checked = false;
            this._big = false;
            this._labelSize = 'large';
            this._negative = false;
            this._disabled = false;
            /**
             * An event is dispatched each time the switcher value is changed
             */
            this.checkedChange = new core$1.EventEmitter();
            this.onChangeCallback = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxSwitcherComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            /** Sets the id of the switcher */
            set: /**
             * Sets the id of the switcher
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "labelPosition", {
            get: /**
             * @return {?}
             */ function () {
                return this._labelPosition;
            },
            /** Specifies the placement of the label */
            set: /**
             * Specifies the placement of the label
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._labelPosition = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            /** Sets the label text of the switcher */
            set: /**
             * Sets the label text of the switcher
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._name = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this._checked;
            },
            /** Whether the switcher is checked (on) or unchecked (off) */
            set: /**
             * Whether the switcher is checked (on) or unchecked (off)
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._checked = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "big", {
            get: /**
             * @return {?}
             */ function () {
                return this._big;
            },
            /** Whether the big switcher is used */
            set: /**
             * Whether the big switcher is used
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._big = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "labelSize", {
            get: /**
             * @return {?}
             */ function () {
                return this._labelSize;
            },
            /** Sets the size of the label */
            set: /**
             * Sets the size of the label
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._labelSize = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the style for a dark background is used */
            set: /**
             * Whether the style for a dark background is used
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._negative = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxSwitcherComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether the switcher is in the disabled state */
            set: /**
             * Whether the switcher is in the disabled state
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                this._disabled = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Allows to toggle between the states */
        /**
         * Allows to toggle between the states
         * @return {?}
         */
        NxSwitcherComponent.prototype.toggle = /**
         * Allows to toggle between the states
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.checked = !this.checked;
                    this.onChangeCallback(this.checked);
                    this.checkedChange.emit(this.checked);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxSwitcherComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === null) {
                    value = false;
                }
                if (value !== this.checked) {
                    this.checked = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxSwitcherComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxSwitcherComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxSwitcherComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxSwitcherComponent.prototype.touch = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.onTouchedCallback();
            };
        NxSwitcherComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-switcher',
                        template: "<input type=\"checkbox\" [id]=\"id\" [attr.name]=\"name\" [disabled]=\"disabled\" [checked]=\"checked\" (click)=\"toggle()\" (blur)=\"touch()\"\n  role=\"switch\"\n  [attr.aria-checked]=\"checked\"\n  class=\"nx-switcher__input\">\n<label [attr.for]=\"id\" class=\"nx-switcher__label\">\n    <div class=\"nx-switcher__toggle\">\n      <div class=\"nx-switcher__dot\">\n        <nx-icon *ngIf=\"big\" name=\"check\"></nx-icon>\n      </div>\n    </div>\n  <ng-content></ng-content>\n</label>\n\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxSwitcherComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            /* the host id should be set to null, otherwise nx-switcher and its <input> get the same id
                                and on label click the input click is not triggered (double id problem) */
                            '[attr.id]': 'null',
                            '[class.is-negative]': 'negative',
                            '[class.is-checked]': 'checked',
                            '[class.is-big]': 'big',
                            '[class.nx-switcher--small-label]': 'labelSize === "small"',
                            '[class.is-disabled]': 'disabled',
                            '[class.is-swapped]': 'labelPosition === "left"'
                        },
                        styles: [":host{position:relative;display:flex}:host(.is-swapped) .nx-switcher__label{flex-direction:row-reverse}:host(.is-swapped) .nx-switcher__label .nx-switcher__toggle{margin-left:12px}.nx-switcher__input{opacity:0;position:absolute}.nx-switcher__label{font-size:20px;font-size:var(--body-01-font-size,20px);line-height:28px;line-height:var(--body-01-line-height,28px);font-weight:400;font-weight:var(--body-01-font-weight,400);letter-spacing:.2px;letter-spacing:var(--body-01-letter-spacing,.2px);white-space:nowrap;cursor:pointer;display:flex;position:relative;align-items:center}.nx-switcher__toggle{position:relative;display:inline-block;width:48px;height:24px;background-color:#767676;border-radius:16px;transition:background-color .2s}@media screen and (-ms-high-contrast:active){.nx-switcher__label{color:#ff0}.nx-switcher__toggle{background-color:#c2c2c2;color:#ff0}}:host(:not(.is-swapped)) .nx-switcher__toggle{margin-right:12px}.nx-switcher__dot{position:absolute;height:20px;width:20px;left:2px;bottom:2px;background-color:#fff;border-radius:16px;-webkit-transform:translate(0);transform:translate(0);transition:transform .2s;transition:transform .2s,-webkit-transform .2s}:host(.is-checked) .nx-switcher__dot{-webkit-transform:translate(24px);transform:translate(24px)}:host(.is-checked) .nx-switcher__toggle{background-color:#007ab3;background-color:var(--interaction-primary,#007ab3)}@media screen and (-ms-high-contrast:active){:host(.is-checked) .nx-switcher__toggle{background-color:#ff0;color:#ff0}.nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{color:#fff}}:host(.is-checked.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host(.is-big) .nx-switcher__toggle{width:56px;height:32px}:host(.is-big) .nx-switcher__dot{height:28px;width:28px}:host(.is-big) nx-icon{position:absolute;top:2px;left:2px;font-size:24px;opacity:0;color:#007ab3;color:var(--interaction-primary,#007ab3)}:host(.is-big).is-checked nx-icon{opacity:1;transition:opacity .2s}:host(.nx-switcher--small-label) .nx-switcher__label{font-size:16px;font-size:var(--body-03-font-size,16px);line-height:24px;line-height:var(--body-03-line-height,24px);font-weight:400;font-weight:var(--body-03-font-weight,400);letter-spacing:0;letter-spacing:var(--body-03-letter-spacing,0)}:host(.is-negative) .nx-switcher__label{color:#fff}:host(.is-negative) .nx-switcher__dot{background-color:#fff}:host(.is-negative) .nx-switcher__toggle{background-color:rgba(255,255,255,.4)}:host-context([data-whatinput=keyboard]) .nx-switcher__input:focus+.nx-switcher__label .nx-switcher__toggle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.is-disabled) .nx-switcher__toggle{background-color:#c2c2c2;background-color:var(--disabled-01,#c2c2c2)}:host(.is-disabled) .nx-switcher__dot{background-color:#fff;opacity:.4}:host(.is-disabled) .nx-switcher__label{cursor:not-allowed;color:#c2c2c2;color:var(--disabled-01,#c2c2c2)}:host(.is-disabled) nx-icon{color:#c2c2c2;color:var(--disabled-01,#c2c2c2)}"]
                    }] }
        ];
        /** @nocollapse */
        NxSwitcherComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxSwitcherComponent.propDecorators = {
            id: [{ type: core$1.Input }],
            labelPosition: [{ type: core$1.Input }],
            name: [{ type: core$1.Input }],
            checked: [{ type: core$1.Input }],
            big: [{ type: core$1.Input, args: ['nxBig',] }],
            labelSize: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input, args: ['nxNegative',] }],
            disabled: [{ type: core$1.Input }],
            checkedChange: [{ type: core$1.Output, args: ['checkedChange',] }]
        };
        return NxSwitcherComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxSwitcherModule = /** @class */ (function () {
        function NxSwitcherModule() {
        }
        NxSwitcherModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxSwitcherComponent],
                        exports: [NxSwitcherComponent],
                        imports: [common.CommonModule, icon.NxIconModule]
                    },] }
        ];
        return NxSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$8 = 0;
    /** @type {?} */
    var fallbacks = [
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        },
        {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
            offsetX: 0,
            offsetY: 16
        },
        {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
            offsetX: 16,
            offsetY: 0
        },
        {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
            offsetX: -16,
            offsetY: 0
        },
        {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
            offsetX: 0,
            offsetY: -16
        }
    ];
    var NxPopoverTriggerDirective = /** @class */ (function () {
        function NxPopoverTriggerDirective(overlay$$1, elementRef, viewContainerRef, eventManager) {
            this.overlay = overlay$$1;
            this.elementRef = elementRef;
            this.viewContainerRef = viewContainerRef;
            this.eventManager = eventManager;
            this._destroyed = new rxjs.Subject();
            this._show = false;
            this._closeable = null;
            /**
             * \@docs-private
             */
            this.id = 'nx-popover-' + nextId$8++;
            /**
             * An event is emitted if the visibility status of the popover changes.
             */
            this.changeShow = new core$1.EventEmitter();
            /**
             * Sets the desired direction to open the popover. E.g., right, left, bottom, top
             */
            this.direction = 'right';
            /**
             * Whether the popover will be opened automatically.
             */
            this.popoverInitialVisible = false;
            /**
             * An event is emitted when the visibility of the popopver changes.
             */
            this.visibleChange = new core$1.EventEmitter();
            /**
             * Whether the popover opens in modal state.
             */
            this.modal = false;
            // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
            // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
            // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
            /**
             * Sets the way to trigger the popover. Options are hover, click, manual
             */
            this.trigger = 'click';
            /**
             * Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin.
             */
            this.scrollStrategy = 'close';
            this._documentClickObservable = rxjs.fromEvent(document, 'click');
        }
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "show", {
            get: /**
             * @return {?}
             */ function () {
                return this._show;
            },
            /** Whether to show or hide the popover. */
            set: /**
             * Whether to show or hide the popover.
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = coercion.coerceBooleanProperty(value);
                if (this._show !== value) {
                    this._show = value;
                    if (this._show) {
                        this.openPopover();
                    }
                    else {
                        this.closePopover();
                    }
                    this.changeShow.emit(this._show);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "closeable", {
            get: /**
             * @return {?}
             */ function () {
                return this._closeable;
            },
            /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
            set: /**
             * Whether to show a close button. By default a close icon is only shown for trigger type click.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._closeable = coercion.coerceBooleanProperty(value);
                if (this.popover) {
                    this.popover.showCloseButton = this.isCloseable();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.onMouseEnter = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this.trigger === 'hover') {
                    this.openPopover();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.onMouseExit = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this.trigger === 'hover') {
                    this.closePopover();
                }
            };
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.popover.showCloseButton = this.isCloseable();
            };
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.popover.id = this.id;
                this.eventManager.addGlobalEventListener('window', 'keyup.esc', ( /**
                 * @return {?}
                 */function () {
                    _this.closePopover();
                }));
                this.popover.closeButtonClick.pipe(operators.takeUntil(this._destroyed)).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.closePopover();
                }));
                if (this.popoverInitialVisible || this._show) {
                    this.openPopover();
                }
            };
        /**
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.closePopover();
                this._destroyed.next();
                this._destroyed.complete();
            };
        Object.defineProperty(NxPopoverTriggerDirective.prototype, "isOpen", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.overlayRef && this.createOverlay().hasAttached();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.isCloseable = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return (this.trigger === 'click' && this._closeable === null) || this._closeable;
            };
        /** Update the popover with the given position strategy. */
        /**
         * Update the popover with the given position strategy.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.updatePosition = /**
         * Update the popover with the given position strategy.
         * @return {?}
         */
            function () {
                if (this._positionStrategy) {
                    this._positionStrategy.apply();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.handleClick = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this.trigger === 'click') {
                    if (this.isOpen) {
                        this.closePopover();
                    }
                    else {
                        this.openPopover();
                    }
                }
            };
        /** Open the popover instance. */
        /**
         * Open the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.open = /**
         * Open the popover instance.
         * @return {?}
         */
            function () {
                this.show = true;
            };
        /** Close the popover instance. */
        /**
         * Close the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.close = /**
         * Close the popover instance.
         * @return {?}
         */
            function () {
                this.show = false;
            };
        /** Toggle the popover instance. */
        /**
         * Toggle the popover instance.
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.toggle = /**
         * Toggle the popover instance.
         * @return {?}
         */
            function () {
                this.show = !this.show;
            };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.openPopover = /**
         * @private
         * @return {?}
         */
            function () {
                if (!this.createOverlay().hasAttached()) {
                    this._embeddedViewRef = this.createOverlay().attach(this.portal);
                    if (!this.modal && this.trigger === 'click') {
                        this.waitForClose();
                    }
                }
            };
        // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component
        // detaches the overlay
        // we are listening to the detachments observable which will then emit the nxClosed event
        // on the popover component
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.closePopover =
            // detaches the overlay
            // we are listening to the detachments observable which will then emit the nxClosed event
            // on the popover component
            /**
             * @private
             * @return {?}
             */
            function () {
                if (this.overlayRef) {
                    this.overlayRef.detach();
                    this._embeddedViewRef = null;
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.createOverlay = /**
         * @private
         * @return {?}
         */
            function () {
                if (!this.overlayRef) {
                    this.portal = new portal.TemplatePortal(this.popover.templateRef, this.viewContainerRef);
                    /** @type {?} */
                    var overlayState = new overlay.OverlayConfig();
                    overlayState.positionStrategy = this.getPosition();
                    this._positionStrategy = overlayState.positionStrategy;
                    if (this.scrollStrategy === 'reposition') {
                        overlayState.scrollStrategy = this.overlay.scrollStrategies.reposition();
                    }
                    else {
                        overlayState.scrollStrategy = this.overlay.scrollStrategies.close();
                    }
                    overlayState.scrollStrategy.enable();
                    if (this.modal && this.trigger === 'click') {
                        overlayState.hasBackdrop = true;
                    }
                    this.overlayRef = this.overlay.create(overlayState);
                    this.subscribeToPositions(( /** @type {?} */(overlayState.positionStrategy)));
                    this._subscribeToDetach();
                    if (this.modal) {
                        this._subscribeToBackdropClick();
                    }
                }
                return this.overlayRef;
            };
        /**
         * @private
         * @param {?} position
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.subscribeToPositions = /**
         * @private
         * @param {?} position
         * @return {?}
         */
            function (position) {
                var _this = this;
                position.positionChanges.pipe(operators.takeUntil(this._destroyed)).subscribe(( /**
                 * @param {?} change
                 * @return {?}
                 */function (change) {
                    /** @type {?} */
                    var pair = change.connectionPair;
                    _this.positionOverlay(pair);
                    _this.positionArrow(pair);
                    // These position changes arrive too late,
                    // We have to trigger the change detection manually
                    // as it's detached from any render hierarchy
                    // and only updated by the overlay when attached.
                    if (_this._embeddedViewRef && !_this._embeddedViewRef.destroyed) {
                        _this._embeddedViewRef.detectChanges();
                    }
                }));
            };
        // for modal popovers close the popover on backdrop clicks
        // for modal popovers close the popover on backdrop clicks
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._subscribeToBackdropClick =
            // for modal popovers close the popover on backdrop clicks
            /**
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                this.overlayRef.backdropClick().pipe(operators.takeUntil(this._destroyed)).subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    _this.closePopover();
                }));
            };
        // Emit the nxClosed event on the popover component when the overlay detaches
        // Emit the nxClosed event on the popover component when the overlay detaches
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype._subscribeToDetach =
            // Emit the nxClosed event on the popover component when the overlay detaches
            /**
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                this.overlayRef.detachments().pipe(operators.takeUntil(this._destroyed)).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.popover.emitClosedEvent();
                }));
            };
        // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
        // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.waitForClose =
            // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
            /**
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                return this._documentClickObservable
                    .pipe(operators.map(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return event.target; })), operators.filter(( /**
                 * @param {?} target
                 * @return {?}
                 */function (target) { return !_this.elementRef.nativeElement.contains(target); })), operators.takeUntil(this.popover.closed))
                    .subscribe(( /**
             * @return {?}
             */function () {
                    _this.closePopover();
                }));
            };
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.positionOverlay = /**
         * @private
         * @param {?} pair
         * @return {?}
         */
            function (pair) {
                if (pair.originX === 'end' && pair.overlayX === 'start') {
                    this.popover.direction = 'right';
                }
                else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
                    this.popover.direction = 'bottom';
                }
                else if (pair.originX === 'start' && pair.overlayX === 'end') {
                    this.popover.direction = 'left';
                }
                else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
                    this.popover.direction = 'top';
                }
            };
        /**
         * @private
         * @param {?} pair
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.positionArrow = /**
         * @private
         * @param {?} pair
         * @return {?}
         */
            function (pair) {
                /** @type {?} */
                var parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
                /** @type {?} */
                var parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
                /** @type {?} */
                var parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
                /** @type {?} */
                var overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
                // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
                /** @type {?} */
                var targetPosition = (parentElementPositionX + parentElementWidth) - (parentElementLeftOffset + overlayElementLeftOffset);
                if (pair.originX === pair.overlayX) {
                    /** @type {?} */
                    var direction = 'left';
                    /** @type {?} */
                    var arrowStyle = {};
                    arrowStyle[direction] = targetPosition + 'px';
                    this.popover.arrowStyle = arrowStyle;
                }
                if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
                    this.popover.arrowStyle = { left: targetPosition + 'px' };
                }
                if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
                    this.popover.arrowStyle = { top: '50%' };
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxPopoverTriggerDirective.prototype.getPosition = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var positions;
                /** @type {?} */
                var offsetX = 0;
                /** @type {?} */
                var offsetY = 0;
                if (this.direction === 'top') {
                    positions = [{
                            overlayX: 'center',
                            overlayY: 'bottom',
                            originX: 'center',
                            originY: 'top'
                        }];
                    offsetX = 0;
                    offsetY = -20;
                }
                else if (this.direction === 'right') {
                    positions = [{
                            overlayX: 'start',
                            overlayY: 'center',
                            originX: 'end',
                            originY: 'center'
                        }];
                    offsetX = 20;
                    offsetY = 0;
                }
                else if (this.direction === 'bottom') {
                    positions = [{
                            overlayX: 'center',
                            overlayY: 'top',
                            originX: 'center',
                            originY: 'bottom'
                        }];
                    offsetX = 0;
                    offsetY = 20;
                }
                else if (this.direction === 'left') {
                    positions = [{
                            overlayX: 'end',
                            overlayY: 'center',
                            originX: 'start',
                            originY: 'center'
                        }];
                    offsetX = -20;
                    offsetY = 0;
                }
                return this.overlay.position().flexibleConnectedTo(this.elementRef)
                    .withPositions(__spread(positions, fallbacks))
                    .withDefaultOffsetX(offsetX)
                    .withDefaultOffsetY(offsetY);
            };
        NxPopoverTriggerDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[nxPopoverTriggerFor]',
                        exportAs: 'nxPopoverTrigger',
                        host: {
                            '(click)': 'handleClick()',
                            'aria-haspopup': 'true',
                            '[attr.aria-expanded]': 'isOpen',
                            '[attr.aria-describedby]': 'isOpen ? id : null'
                        }
                    },] }
        ];
        /** @nocollapse */
        NxPopoverTriggerDirective.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core$1.ElementRef },
                { type: core$1.ViewContainerRef },
                { type: platformBrowser.EventManager }
            ];
        };
        NxPopoverTriggerDirective.propDecorators = {
            changeShow: [{ type: core$1.Output, args: ['nxPopoverShowChange',] }],
            show: [{ type: core$1.Input, args: ['nxPopoverShow',] }],
            closeable: [{ type: core$1.Input, args: ['nxPopoverCloseable',] }],
            popover: [{ type: core$1.Input, args: ['nxPopoverTriggerFor',] }],
            direction: [{ type: core$1.Input, args: ['nxPopoverDirection',] }],
            popoverInitialVisible: [{ type: core$1.Input, args: ['nxPopoverInitialVisible',] }],
            visibleChange: [{ type: core$1.Input, args: ['nxPopoverVisibleChange',] }],
            modal: [{ type: core$1.Input, args: ['nxPopoverModal',] }],
            trigger: [{ type: core$1.Input, args: ['nxPopoverTrigger',] }],
            scrollStrategy: [{ type: core$1.Input, args: ['nxPopoverScrollStrategy',] }],
            onMouseEnter: [{ type: core$1.HostListener, args: ['mouseenter',] }],
            onMouseExit: [{ type: core$1.HostListener, args: ['mouseleave',] }, { type: core$1.HostListener, args: ['touchstart',] }]
        };
        return NxPopoverTriggerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Popover content that will be rendered lazily
     * after the popover is opened for the first time.
     */
    var NxPopoverContentDirective = /** @class */ (function () {
        function NxPopoverContentDirective(_template) {
            this._template = _template;
        }
        NxPopoverContentDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'ng-template[nxPopoverContent]'
                    },] }
        ];
        /** @nocollapse */
        NxPopoverContentDirective.ctorParameters = function () {
            return [
                { type: core$1.TemplateRef }
            ];
        };
        return NxPopoverContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPopoverComponent = /** @class */ (function () {
        function NxPopoverComponent() {
            /**
             * Event emitted when the popover is closed.
             */
            this.closed = new core$1.EventEmitter();
            /**
             * \@docs-private
             */
            this.closeButtonClick = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.showCloseButton = false;
            /**
             * \@docs-private
             */
            this.arrowStyle = {};
        }
        /**
         * @return {?}
         */
        NxPopoverComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.closed.complete();
            };
        // emit to notify the popover trigger directive that the close button was clicked
        /** @docs-private */
        // emit to notify the popover trigger directive that the close button was clicked
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverComponent.prototype.emitButtonClick =
            // emit to notify the popover trigger directive that the close button was clicked
            /**
             * \@docs-private
             * @return {?}
             */
            function () {
                this.closeButtonClick.next();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPopoverComponent.prototype.emitClosedEvent = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.closed.emit();
            };
        Object.defineProperty(NxPopoverComponent.prototype, "classList", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                if (this.direction) {
                    return ["nx-popover--" + this.direction];
                }
            },
            enumerable: true,
            configurable: true
        });
        NxPopoverComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-popover',
                        template: "<ng-template>\n  <div [ngClass]=\"classList\" role=\"tooltip\" aria-hidden=\"false\">\n    <div class=\"nx-popover__content\">\n        <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\">\n          </div>\n      <span aria-hidden=\"true\" class=\"nx-popover__close-icon\" (click)=\"emitButtonClick()\"\n            *ngIf=\"showCloseButton\">\n        <nx-icon name=\"close\"></nx-icon>\n      </span>\n      <span [id]=\"id\">\n        <ng-content></ng-content>\n        <ng-container [ngTemplateOutlet]=\"_lazyContent?._template\"></ng-container>\n      </span>\n    </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxPopover',
                        styles: [".nx-popover__content{background-color:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;display:inline-block;font-size:16px}.nx-popover__close-icon{position:absolute;top:4px;right:4px;cursor:pointer;font-size:16px;line-height:16px}[data-whatintent=mouse] .nx-popover__content:focus{outline:0}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;-webkit-transform:translate(-50%,0);transform:translate(-50%,0);border-top:1px solid #d9d9d9;border-left:1px solid #d9d9d9}.nx-popover--top .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(225deg);transform:translate(-50%,0) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px #fff,-2px -2px 4px rgba(65,65,65,.5)}.nx-popover--right .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(-45deg);transform:translate(0,-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{-webkit-transform:translate(-50%,0) rotate(45deg);transform:translate(-50%,0) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{-webkit-transform:translate(0,-50%) rotate(135deg);transform:translate(0,-50%) rotate(135deg);right:-5px}"]
                    }] }
        ];
        /** @nocollapse */
        NxPopoverComponent.ctorParameters = function () { return []; };
        NxPopoverComponent.propDecorators = {
            templateRef: [{ type: core$1.ViewChild, args: [core$1.TemplateRef,] }],
            _lazyContent: [{ type: core$1.ContentChild, args: [NxPopoverContentDirective,] }],
            closed: [{ type: core$1.Output, args: ['nxClosed',] }]
        };
        return NxPopoverComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPopoverModule = /** @class */ (function () {
        function NxPopoverModule() {
        }
        NxPopoverModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxPopoverTriggerDirective,
                            NxPopoverComponent,
                            NxPopoverContentDirective
                        ],
                        exports: [
                            NxPopoverTriggerDirective,
                            NxPopoverComponent,
                            NxPopoverContentDirective
                        ]
                    },] }
        ];
        return NxPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTagComponent = /** @class */ (function () {
        function NxTagComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * An event is dispatched each time when the tag is clicked.
             */
            this.clicked = new core$1.EventEmitter();
            /**
             * An event is dispatched each time when the tag is removed.
             */
            this.removed = new core$1.EventEmitter();
        }
        Object.defineProperty(NxTagComponent.prototype, "removable", {
            get: /**
             * @return {?}
             */ function () {
                return this._removable;
            },
            /** Whether the tag is removeable. */
            set: /**
             * Whether the tag is removeable.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._removable = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTagComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** Sets the value of the tag. */
            set: /**
             * Sets the value of the tag.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._value !== value) {
                    this._value = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        // Emit the removed event that the parent can remove the value
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        // Emit the removed event that the parent can remove the value
        NxTagComponent.prototype.removeClickHandler = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            // Emit the removed event that the parent can remove the value
            function (event) {
                event.stopPropagation();
                this.removed.emit(this.value);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxTagComponent.prototype.removeKeyHandler = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.removable && (event.keyCode === keycodes.DELETE || event.keyCode === keycodes.BACKSPACE)) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.removed.emit(this.value);
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxTagComponent.prototype.tagClickHandler = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.clicked.emit(this.value);
            };
        NxTagComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tag',
                        template: "{{ value }}\n<span role=\"link\" aria-label=\"close\" class=\"nx-tag__close\" *ngIf=\"removable\"\n    (click)=\"removeClickHandler($event)\">\n    <nx-icon class=\"nx-tag__close-icon\" name=\"close\"></nx-icon>\n</span>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '(click)': 'tagClickHandler()',
                            '(keydown)': 'removeKeyHandler($event)',
                            '[attr.tabIndex]': '0'
                        },
                        styles: [":host{height:auto;max-width:100%;font-size:14px;color:#767676;padding:6px 14px;line-height:16px;letter-spacing:1px;font-weight:600;display:flex;align-items:center;border:2px solid #d9d9d9;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .2s,box-shadow .2s;cursor:pointer}:host:hover{border-color:#c2c2c2;color:#5b5b5b;background-color:#ececec}:host:focus{outline:transparent solid 2px}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}.nx-tag__close-icon{outline:0;width:16px;height:16px;display:block;font-size:16px;line-height:14px}.nx-tag__close{margin-left:8px}:host-context(.nx-taglist--keyword){padding:14px 22px}"]
                    }] }
        ];
        /** @nocollapse */
        NxTagComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxTagComponent.propDecorators = {
            removable: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }],
            clicked: [{ type: core$1.Output }],
            removed: [{ type: core$1.Output }]
        };
        return NxTagComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTaglistComponent = /** @class */ (function () {
        function NxTaglistComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * An event is dispatched each time when the list of tags changed.
             */
            this.tagsChange = new core$1.EventEmitter();
            /**
             * An event is dispatched each time when a tag is clicked.
             */
            this.tagClickEvent = new core$1.EventEmitter();
            this._tags = [];
            this._allowTagDeletion = true;
            this._isKeywordList = false;
            this._labelProperty = 'nxTaglistLabel';
            this._valueFormatterFn = ( /**
             * @param {?} value
             * @return {?}
             */function (value) { return value; });
            this._onChange = ( /**
             * @return {?}
             */function () { });
            this._onTouched = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxTaglistComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */ function () {
                return this._tags;
            },
            /** Sets the list of tags. */
            set: /**
             * Sets the list of tags.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "allowTagDeletion", {
            get: /**
             * @return {?}
             */ function () {
                return this._allowTagDeletion;
            },
            /** Whether the tags can be removed from the list. */
            set: /**
             * Whether the tags can be removed from the list.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._allowTagDeletion = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "isKeywordList", {
            get: /**
             * @return {?}
             */ function () {
                return this._isKeywordList;
            },
            /** Whether the tags can be styled as keywords. */
            set: /**
             * Whether the tags can be styled as keywords.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._isKeywordList = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "labelProp", {
            get: /**
             * @return {?}
             */ function () {
                return this._labelProperty;
            },
            /** Sets the label property, in case tags represent objects. */
            set: /**
             * Sets the label property, in case tags represent objects.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._labelProperty !== value) {
                    this._labelProperty = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "labelledby", {
            get: /**
             * @return {?}
             */ function () {
                return this._ariaLabelledBy;
            },
            /** Sets the label property to improve accessibility. */
            set: /**
             * Sets the label property to improve accessibility.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._ariaLabelledBy !== value) {
                    this._ariaLabelledBy = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTaglistComponent.prototype, "valueFormatter", {
            get: /**
             * @return {?}
             */ function () {
                return this._valueFormatterFn;
            },
            /** Sets the customization function for tag value.  */
            set: /**
             * Sets the customization function for tag value.
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                this._valueFormatterFn = fn;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter */
        /**
         * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        NxTaglistComponent.prototype.delete = /**
         * Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
            function (index, value) {
                if (this.allowTagDeletion) {
                    this.tags = __spread(this.tags.slice(0, index), this.tags.slice(index + 1));
                    this._onChange(this.tags);
                    this.tagsChange.emit(this.tags);
                }
            };
        /** Allows to add a tag. Takes tag object as an input */
        /**
         * Allows to add a tag. Takes tag object as an input
         * @param {?} tag
         * @return {?}
         */
        NxTaglistComponent.prototype.addTag = /**
         * Allows to add a tag. Takes tag object as an input
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                var _this = this;
                if (!tag) {
                    return;
                }
                // make sure tag is either string or has the configured label prop and is not yet in the list
                if ((typeof tag === 'string' && this.tags.indexOf(tag) === -1) ||
                    (tag[this.labelProp] && this.tags.filter(( /**
                     * @param {?} t
                     * @return {?}
                     */function (t) { return t[_this.labelProp] === tag[_this.labelProp]; })).length < 1)) {
                    this.tags = __spread(this.tags, [tag]);
                    this._onChange(this.tags);
                    this.tagsChange.emit(this.tags);
                }
            };
        /** Allows to clear the tag list. */
        /**
         * Allows to clear the tag list.
         * @return {?}
         */
        NxTaglistComponent.prototype.clearTags = /**
         * Allows to clear the tag list.
         * @return {?}
         */
            function () {
                this.tags = [];
                this._onChange(this.tags);
                this.tagsChange.emit(this.tags);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} tags
         * @return {?}
         */
        NxTaglistComponent.prototype.writeValue = /**
         * \@docs-private
         * @param {?} tags
         * @return {?}
         */
            function (tags) {
                this.tags = tags;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxTaglistComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxTaglistComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} tag
         * @return {?}
         */
        NxTaglistComponent.prototype.renderTag = /**
         * \@docs-private
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                /** @type {?} */
                var tagStr = typeof tag === 'string' ? tag : tag[this.labelProp];
                return this.valueFormatter(tagStr);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        NxTaglistComponent.prototype.tagClick = /**
         * \@docs-private
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
            function (index, value) {
                this.tagClickEvent.emit(this.tags[index]);
            };
        NxTaglistComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-taglist',
                        template: "  <ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n      <nx-tag [value]=\"renderTag(tag)\" [removable]=\"allowTagDeletion\" (clicked)=\"tagClick(i, $event)\" (removed)=\"delete(i, $event)\"></nx-tag>\n  </li>\n  </ul>\n  <ng-content *ngIf=\"tags.length < 1\"></ng-content>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxTaglistComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-taglist--keyword]': 'isKeywordList',
                            '[attr.aria-labelledby]': 'labelledby || null'
                        },
                        styles: [":host{position:relative;min-height:32px;margin-bottom:32px;display:flex;justify-content:space-between}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}@media (max-width:703px){.nx-taglist--keyword{justify-content:center}}"]
                    }] }
        ];
        /** @nocollapse */
        NxTaglistComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxTaglistComponent.propDecorators = {
            tagsChange: [{ type: core$1.Output, args: ['nxTagsChange',] }],
            tagClickEvent: [{ type: core$1.Output, args: ['nxTagClick',] }],
            tags: [{ type: core$1.Input, args: ['nxTags',] }],
            allowTagDeletion: [{ type: core$1.Input, args: ['nxAllowTagDeletion',] }],
            isKeywordList: [{ type: core$1.Input, args: ['nxIsKeywordList',] }],
            labelProp: [{ type: core$1.Input, args: ['nxLabelProperty',] }],
            labelledby: [{ type: core$1.Input, args: ['aria-labelledby',] }],
            valueFormatter: [{ type: core$1.Input, args: ['nxValueFormatter',] }]
        };
        return NxTaglistComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTaglistModule = /** @class */ (function () {
        function NxTaglistModule() {
        }
        NxTaglistModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxTaglistComponent, NxTagComponent],
                        exports: [NxTaglistComponent, NxTagComponent],
                        imports: [common.CommonModule, icon.NxIconModule]
                    },] }
        ];
        return NxTaglistModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxImageDirective = /** @class */ (function () {
        function NxImageDirective() {
            console.warn('Directive nxImg which was used together with nxFigure ' +
                'is now deprecated and not required anymore. Please remove it from your ' +
                'tag. Check the documentation for more details.');
        }
        NxImageDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'img[nxImg]'
                    },] }
        ];
        /** @nocollapse */
        NxImageDirective.ctorParameters = function () { return []; };
        return NxImageDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$2 = 'auto';
    var NxFigureComponent = /** @class */ (function () {
        function NxFigureComponent() {
        }
        Object.defineProperty(NxFigureComponent.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            /**
             * Sets the type of the visual appearance of the image.
             * The default value  is 'auto'.
             */
            set: /**
             * Sets the type of the visual appearance of the image.
             * The default value  is 'auto'.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                this._classNames = value;
                /** @type {?} */
                var sizeRegex = /^(auto|1by1|1dot8by1|1dot2by1|1by1dot1|2dot6by1)$/;
                var _a = __read(this._classNames.match(sizeRegex) || [DEFAULT_SIZE$2], 1), _b = _a[0], size = _b === void 0 ? null : _b;
                this.size = ( /** @type {?} */(size));
                this.rounded = !!this._classNames.match(/rounded/);
            },
            enumerable: true,
            configurable: true
        });
        NxFigureComponent.decorators = [
            { type: core$1.Component, args: [{
                        // tslint:disable-next-line:component-selector
                        selector: 'figure[nxFigure]',
                        template: '<ng-content></ng-content>',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.nx-image--auto]': 'size === "auto" && !rounded',
                            '[class.nx-image--1by1]': 'size === "1by1"',
                            '[class.nx-image--1dot8by1]': 'size === "1dot8by1"',
                            '[class.nx-image--1dot2by1]': 'size === "1dot2by1"',
                            '[class.nx-image--1by1dot1]': 'size === "1by1dot1"',
                            '[class.nx-image--2dot6by1]': 'size === "2dot6by1"',
                            '[class.nx-image--rounded]': 'rounded'
                        },
                        styles: [":host{display:block;position:relative;line-height:0}:host ::ng-deep img{display:block;font-family:\"object-fit: cover;\";-o-object-fit:cover;object-fit:cover;height:100%;width:100%}:host(.nx-image--auto) ::ng-deep img{height:auto}:host(:not(.nx-image--auto)) ::ng-deep img{position:absolute;top:0;left:0}:host(.nx-image--rounded){padding-top:100%}:host(.nx-image--rounded) ::ng-deep img{border-radius:50%;bottom:0;left:0;position:absolute;right:0;top:0}:host(.nx-image--1by1){padding-top:100%}:host(.nx-image--1dot8by1){padding-top:55.55556%}:host(.nx-image--1dot2by1){padding-top:83.33333%}:host(.nx-image--1by1dot1){padding-top:110%}:host(.nx-image--2dot6by1){padding-top:38.46154%}:host(.nx-image--1by1dot4){padding-top:140%}"]
                    }] }
        ];
        NxFigureComponent.propDecorators = {
            classNames: [{ type: core$1.Input, args: ['nxFigure',] }]
        };
        return NxFigureComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxImageModule = /** @class */ (function () {
        function NxImageModule() {
        }
        NxImageModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxFigureComponent, NxImageDirective],
                        exports: [NxFigureComponent, NxImageDirective]
                    },] }
        ];
        return NxImageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$9 = 0;
    /**
     * @abstract
     */
    var NxRadioCircleButton = /** @class */ (function () {
        function NxRadioCircleButton(radioCircle) {
            this.radioCircle = radioCircle;
            /**
             * \@docs-private
             */
            this.id = ++nextId$9;
        }
        /**
         * @return {?}
         */
        NxRadioCircleButton.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                if (!this.label) {
                    console.warn("nx-radio-circle-icon-button/nx-radio-circle-svg-button: required field 'nxLabel' is not set");
                }
            };
        Object.defineProperty(NxRadioCircleButton.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this.radioCircle.selectedButton === this || null;
            },
            /** Whether the item is preselected. */
            set: /**
             * Whether the item is preselected.
             * @param {?} checked
             * @return {?}
             */ function (checked) {
                if (checked) {
                    this.radioCircle.selectedButton = this;
                }
                else {
                    if (this.checked) {
                        this.radioCircle.selectedButton = null;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioCircleButton.prototype, "circleButtonId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.radioCircle.radioCircleId + '-' + this.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioCircleButton.prototype, "radioCircleId", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.radioCircle.radioCircleId;
            },
            enumerable: true,
            configurable: true
        });
        NxRadioCircleButton.propDecorators = {
            label: [{ type: core$1.Input, args: ['nxLabel',] }],
            hint: [{ type: core$1.Input, args: ['nxHint',] }],
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            labelElement: [{ type: core$1.ViewChild, args: ['labelElement',] }],
            checked: [{ type: core$1.Input, args: ['nxSelected',] }]
        };
        return NxRadioCircleButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$a = 0;
    /**
     * @deprecated Use `nx-circle-toggle-group` instead
     * \@deletion-target 8.0.0
     */
    var NxRadioCircleComponent = /** @class */ (function () {
        function NxRadioCircleComponent(renderer) {
            this.renderer = renderer;
            this._id = nextId$a++;
            this._responsive = true;
            /**
             * An event emitted when the selection changes.
             */
            this.valueChange = new core$1.EventEmitter();
            /**
             * Whether the radio circle is disabled.
             */
            this.disabled = false;
            this.onTouchedCallback = ( /**
             * @param {?} option
             * @return {?}
             */function (option) {
            });
            this.onChangeCallback = ( /**
             * @param {?} option
             * @return {?}
             */function (option) {
            });
            console.warn('`nx-radio-circle` is deprecated. Use `nx-circle-toggle-group` instead.');
        }
        Object.defineProperty(NxRadioCircleComponent.prototype, "responsiveToggle", {
            /**
             * Whether the toggle behavior is disabled.
             *
             * @deprecated Use `nxResponsive` instead
             * @deletion-target 7.0.0
             */
            set: /**
             * Whether the toggle behavior is disabled.
             *
             * @deprecated Use `nxResponsive` instead
             * \@deletion-target 7.0.0
             * @param {?} value
             * @return {?}
             */ function (value) {
                console.warn('`nxResponsiveToggle` is deprecated. Use `nxResponsive` instead.');
                this.responsive = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioCircleComponent.prototype, "responsive", {
            get: /**
             * @return {?}
             */ function () {
                return this._responsive;
            },
            /**
             * Whether the radio circle should have a responsive behavior.
             *
             * On false the circles will stay even on mobile viewports.
             * Default: true.
             */
            set: /**
             * Whether the radio circle should have a responsive behavior.
             *
             * On false the circles will stay even on mobile viewports.
             * Default: true.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.responsive) {
                    this._responsive = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioCircleComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectedButton ? this._selectedButton.value : null;
            },
            /** Sets the value of the radio circle. */
            set: /**
             * Sets the value of the radio circle.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.writeValue(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @docs-private
         * @deprecated Use `responsive` getter
         * @deletion-target 7.0.0
         */
        /**
         * \@docs-private
         * @deprecated Use `responsive` getter
         * \@deletion-target 7.0.0
         * @return {?}
         */
        NxRadioCircleComponent.prototype.getResposiveToggle = /**
         * \@docs-private
         * @deprecated Use `responsive` getter
         * \@deletion-target 7.0.0
         * @return {?}
         */
            function () {
                console.warn('The method `getResponsiveToggle is deprecated. Use the `responsive` getter instead');
                return this._responsive;
            };
        Object.defineProperty(NxRadioCircleComponent.prototype, "radioCircleId", {
            /** The id of the radio circle. */
            get: /**
             * The id of the radio circle.
             * @return {?}
             */ function () {
                return "radio-circle-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxRadioCircleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.renderer.addClass(this._buttons.first.labelElement.nativeElement, "nx-radio-circle__label--first");
                this.renderer.addClass(this._buttons.last.labelElement.nativeElement, "nx-radio-circle__label--last");
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRadioCircleComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this._buttons) {
                    this._selectedButton = this._buttons.find(( /**
                     * @param {?} button
                     * @return {?}
                     */function (button$$1) { return button$$1.value === value; }));
                }
            };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRadioCircleComponent.prototype.registerOnChange = /**
         * @param {?} callback
         * @return {?}
         */
            function (callback) {
                this.onChangeCallback = callback;
            };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRadioCircleComponent.prototype.registerOnTouched = /**
         * @param {?} callback
         * @return {?}
         */
            function (callback) {
                this.onTouchedCallback = callback;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRadioCircleComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        Object.defineProperty(NxRadioCircleComponent.prototype, "selectedButton", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._selectedButton;
            },
            set: /**
             * @param {?} button
             * @return {?}
             */ function (button$$1) {
                if (this.disabled) {
                    return;
                }
                this._selectedButton = button$$1;
                this.onChangeCallback(this.value);
                this.valueChange.emit(this.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRadioCircleComponent.prototype, "buttons", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        NxRadioCircleComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-circle',
                        template: "<div [id]=\"radioCircleId\" class=\"nx-radio-circle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n  <ng-content></ng-content>\n</div>\n",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioCircleComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.is-responsive]': 'responsive',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                        },
                        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioCircleComponent.ctorParameters = function () {
            return [
                { type: core$1.Renderer2 }
            ];
        };
        NxRadioCircleComponent.propDecorators = {
            _buttons: [{ type: core$1.ContentChildren, args: [NxRadioCircleButton,] }],
            valueChange: [{ type: core$1.Output, args: ['nxValueChange',] }],
            name: [{ type: core$1.Input, args: ['nxName',] }],
            disabled: [{ type: core$1.Input, args: ['disabled',] }],
            responsiveToggle: [{ type: core$1.Input, args: ['nxResponsiveToggle',] }],
            responsive: [{ type: core$1.Input, args: ['nxResponsive',] }],
            value: [{ type: core$1.Input, args: ['nxValue',] }]
        };
        return NxRadioCircleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */
    var NxRadioCircleIconButtonComponent = /** @class */ (function (_super) {
        __extends(NxRadioCircleIconButtonComponent, _super);
        function NxRadioCircleIconButtonComponent(radioCircle) {
            var _this = _super.call(this, radioCircle) || this;
            _this.radioCircle = radioCircle;
            console.warn('`nx-radio-circle-icon-button` is deprecated. Use `nx-circle-toggle` instead.');
            return _this;
        }
        NxRadioCircleIconButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-circle-icon-button',
                        template: "<input [id]=\"circleButtonId\" class=\"nx-radio-circle__input\" name=\"circle-icon\" type=\"radio\" [checked]=\"checked\"\n       (click)=\"checked = true\">\n<label #labelElement [for]=\"circleButtonId\" class=\"nx-radio-circle__label\" [class.nx-radio-circle--checked]=\"checked\">\n  <div class=\"nx-radio-circle__circle\">\n    <nx-icon class=\"nx-radio-circle__label--icon\" [name]=\"icon\"></nx-icon>    \n  </div>\n  <nx-icon class=\"nx-radio-circle__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n  <span class=\"nx-radio-circle__label-text\">{{label}}</span>\n  <span *ngIf=\"hint\" class=\"nx-radio-circle__label-info\">{{hint}}</span>\n</label>\n",
                        providers: [
                            {
                                provide: NxRadioCircleButton, useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioCircleIconButtonComponent; }))
                            }
                        ],
                        host: {
                            '[class.is-disabled]': 'radioCircle.disabled',
                            '[attr.aria-disabled]': 'radioCircle.disabled'
                        },
                        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioCircleIconButtonComponent.ctorParameters = function () {
            return [
                { type: NxRadioCircleComponent, decorators: [{ type: core$1.Inject, args: [core$1.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NxRadioCircleComponent; })),] }] }
            ];
        };
        NxRadioCircleIconButtonComponent.propDecorators = {
            icon: [{ type: core$1.Input, args: ['nxIcon',] }]
        };
        return NxRadioCircleIconButtonComponent;
    }(NxRadioCircleButton));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @deprecated Use `nx-circle-toggle` instead
     * \@deletion-target 8.0.0
     */
    var NxRadioCircleSvgButtonComponent = /** @class */ (function (_super) {
        __extends(NxRadioCircleSvgButtonComponent, _super);
        function NxRadioCircleSvgButtonComponent(radioCircle) {
            var _this = _super.call(this, radioCircle) || this;
            _this._hover = false;
            console.warn('`nx-radio-circle-svg-button` is deprecated. Use `nx-circle-toggle` instead.');
            return _this;
        }
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioCircleSvgButtonComponent.prototype.onMouseEnter = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._hover = true;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxRadioCircleSvgButtonComponent.prototype.onMouseLeave = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._hover = false;
            };
        /**
         * @return {?}
         */
        NxRadioCircleSvgButtonComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (!this.svg) {
                    console.warn("nx-radio-circle-svg-button: required field 'nxSvg' is not set");
                }
                if (!this.svgChecked) {
                    console.warn("nx-radio-circle-svg-button: required field 'nxSvgChecked' is not set");
                }
            };
        Object.defineProperty(NxRadioCircleSvgButtonComponent.prototype, "svgUrl", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return (this.checked || this._hover) ? this.svgChecked : this.svg;
            },
            enumerable: true,
            configurable: true
        });
        NxRadioCircleSvgButtonComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-radio-circle-svg-button',
                        template: "<input [id]=\"circleButtonId\" class=\"nx-radio-circle__input\" type=\"radio\" [checked]=\"checked\"\n       (click)=\"checked = true\">\n<label #labelElement [for]=\"circleButtonId\" class=\"nx-radio-circle__label\" [class.nx-radio-circle--checked]=\"checked\">\n    <div class=\"nx-radio-circle__circle\">\n      <img [src]=\"svgUrl\" class=\"nx-radio-circle__label--icon\"/>\n    </div>\n  <nx-icon class=\"nx-radio-circle__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n  <span class=\"nx-radio-circle__label-text\">{{label}}</span>\n  <span *ngIf=\"hint\" class=\"nx-radio-circle__label-info\">{{hint}}</span>\n</label>\n",
                        providers: [
                            {
                                provide: NxRadioCircleButton, useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRadioCircleSvgButtonComponent; }))
                            }
                        ],
                        styles: [":host{display:block;position:relative}@media (max-width:703px){:host-context(.is-responsive) .nx-radio-circle{flex-direction:column}:host-context(.is-responsive) .nx-radio-circle__label{flex-direction:row;border:2px solid #007ab3;border-top-width:0;font-size:16px;padding:8px 40px 8px 15px}:host-context(.is-responsive) .nx-radio-circle__label--first{border-top-width:2px;border-radius:5px 5px 0 0}:host-context(.is-responsive) .nx-radio-circle__label--last{border-radius:0 0 5px 5px}:host-context(.is-responsive) .nx-radio-circle__circle{display:none}:host-context(.is-responsive) .nx-radio-circle__label-info{color:#007ab3;margin-left:10px;margin-top:0;line-height:16px;font-size:14px}:host-context(.is-responsive) .nx-radio-circle__mobile-check{display:inline-block;opacity:0;line-height:1;margin-right:10px}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__mobile-check{opacity:1}:host-context(.is-responsive) .nx-radio-circle--checked{background-color:#007ab3;color:#fff}:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-info,:host-context(.is-responsive) .nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-icon-button,:host(:not(.is-responsive)) ::ng-deep nx-radio-circle-svg-button{flex:1 0 auto;min-width:33.3%}}.nx-radio-circle{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}.nx-radio-circle__input{opacity:0;position:absolute}.nx-radio-circle__label{cursor:pointer;display:flex;flex-direction:column;justify-content:center;text-align:center;align-items:center;font-size:16px;font-weight:600;padding:0;position:relative;transition:background-color .2s,border-color .2s,color .2s;vertical-align:middle}@media (min-width:704px){:host:hover .nx-radio-circle__circle{background-color:#006192;border-color:transparent;box-shadow:none;color:#fff}.nx-radio-circle__label{line-height:8rem;min-height:8rem;min-width:8rem;max-width:8rem;padding:0}}.nx-radio-circle__label-text{line-height:20px;z-index:1;color:#414141}@media (max-width:703px){.nx-radio-circle__label-text{color:#007ab3}}.nx-radio-circle__input:focus+.nx-radio-circle__label{color:#fff}.nx-radio-circle__input:focus+.nx-radio-circle__label:after{background-color:#006192;border-color:transparent}.nx-radio-circle__mobile-check{font-size:24px;display:none;z-index:1}.nx-radio-circle--checked .nx-radio-circle__circle{color:#fff;background-color:#007ab3}.nx-radio-circle--checked{color:#fff}.nx-radio-circle--checked:hover{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-text{color:#fff}.nx-radio-circle--checked .nx-radio-circle__circle{background-color:#ff0;border-color:#ff0}.nx-radio-circle--checked,.nx-radio-circle--checked .nx-radio-circle__label-text{color:#000}.nx-radio-circle--checked .nx-radio-circle__label-text{color:#fff}}.nx-radio-circle__circle{display:flex;justify-content:center;align-items:center;border-radius:50%;min-width:8rem;min-height:8rem;max-width:8rem;max-height:8rem;width:8rem;height:8rem;border:2px solid #007ab3;margin-bottom:1.5rem;color:#007ab3}:host.is-disabled *{color:#c2c2c2}:host.is-disabled .nx-radio-circle__circle{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__circle{background-color:#c2c2c2;border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label--icon{color:#fff!important}@media (max-width:703px){:host.is-disabled .nx-radio-circle__label{border:2px solid #c2c2c2}:host.is-disabled .nx-radio-circle__label-info{color:#c2c2c2}:host.is-disabled .nx-icon--check:before{color:#fff}:host.is-disabled .nx-radio-circle--checked{background-color:#c2c2c2}:host.is-disabled .nx-radio-circle--checked .nx-radio-circle__label-info{color:#fff}}:host.is-disabled:hover{cursor:not-allowed}:host.is-disabled:hover .nx-radio-circle__circle{background-color:transparent;cursor:not-allowed}.nx-radio-circle__label--icon{pointer-events:none;z-index:1;display:flex;text-align:center;align-items:center;justify-content:center;font-size:4rem;font-weight:400;position:relative}.nx-radio-circle__label--icon.nx-icon--auto{font-size:4rem}.nx-radio-circle__label-info{color:#fff;display:inline-block;font-weight:300;line-height:22px;font-size:18px;margin-top:4px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){.nx-radio-circle__label-info{color:#fff}}.nx-radio-circle__label-info:before{content:'(';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info{color:#767676;display:block;width:16rem}.nx-radio-circle__label-info:before{content:''}}.nx-radio-circle__label-info:after{content:')';display:inline-block}@media (min-width:704px){.nx-radio-circle__label-info:after{content:''}}:host-context([data-whatinput=keyboard]) .nx-radio-circle__input:focus+.nx-radio-circle__label .nx-radio-circle__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxRadioCircleSvgButtonComponent.ctorParameters = function () {
            return [
                { type: NxRadioCircleComponent, decorators: [{ type: core$1.Inject, args: [core$1.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NxRadioCircleComponent; })),] }] }
            ];
        };
        NxRadioCircleSvgButtonComponent.propDecorators = {
            svg: [{ type: core$1.Input, args: ['nxSvg',] }],
            svgChecked: [{ type: core$1.Input, args: ['nxSvgChecked',] }],
            onMouseEnter: [{ type: core$1.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core$1.HostListener, args: ['mouseleave',] }]
        };
        return NxRadioCircleSvgButtonComponent;
    }(NxRadioCircleButton));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRadioCircleModule = /** @class */ (function () {
        function NxRadioCircleModule() {
        }
        NxRadioCircleModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxRadioCircleComponent, NxRadioCircleIconButtonComponent, NxRadioCircleSvgButtonComponent],
                        exports: [NxRadioCircleComponent, NxRadioCircleIconButtonComponent, NxRadioCircleSvgButtonComponent],
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ]
                    },] }
        ];
        return NxRadioCircleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxVideoComponent = /** @class */ (function () {
        function NxVideoComponent(sanitizer, _changeDetectorRef) {
            this.sanitizer = sanitizer;
            this._changeDetectorRef = _changeDetectorRef;
            this._videoId = null;
            this._altText = '';
            this._playButtonAriaLabel = '';
            this._previewImageSrc = null;
            this._showPlayerControls = true;
            this._allowFullScreen = true;
            this._interfaceLanguage = null;
            /**
             * \@docs-private
             */
            this.showPlayer = false;
        }
        Object.defineProperty(NxVideoComponent.prototype, "videoId", {
            get: /**
             * @return {?}
             */ function () {
                return this._videoId;
            },
            /** Sets the id of the YouTube video. */
            set: /**
             * Sets the id of the YouTube video.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._videoId !== value) {
                    this._videoId = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "altText", {
            get: /**
             * @return {?}
             */ function () {
                return this._altText;
            },
            /** Sets the value of the alt attribute for the preview image. */
            set: /**
             * Sets the value of the alt attribute for the preview image.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._altText !== value) {
                    this._altText = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "nxPlayButtonAriaLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._playButtonAriaLabel;
            },
            /** Sets the value of the aria-label attribute on the play button (Default: Play Video). */
            set: /**
             * Sets the value of the aria-label attribute on the play button (Default: Play Video).
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._playButtonAriaLabel !== value) {
                    this._playButtonAriaLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "previewImageSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._previewImageSrc;
            },
            /** Sets the preview image. If this is not provided, an image from YouTube will be used as default. */
            set: /**
             * Sets the preview image. If this is not provided, an image from YouTube will be used as default.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._previewImageSrc !== value) {
                    this._previewImageSrc = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "showPlayerControls", {
            get: /**
             * @return {?}
             */ function () {
                return this._showPlayerControls;
            },
            /** Sets player controls. If set to false, player controls are not available. */
            set: /**
             * Sets player controls. If set to false, player controls are not available.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._showPlayerControls = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "allowFullScreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._allowFullScreen;
            },
            /** Sets fullscreen option. If set to false, fullscreen option is not available. */
            set: /**
             * Sets fullscreen option. If set to false, fullscreen option is not available.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._allowFullScreen = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "interfaceLanguage", {
            get: /**
             * @return {?}
             */ function () {
                return this._interfaceLanguage;
            },
            /** Sets interface language. Can be used to override the interface language determined by YouTube. */
            set: /**
             * Sets interface language. Can be used to override the interface language determined by YouTube.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._interfaceLanguage !== value) {
                    this._interfaceLanguage = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxVideoComponent.prototype.select = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.showPlayer = true;
                this._changeDetectorRef.markForCheck();
            };
        Object.defineProperty(NxVideoComponent.prototype, "videoSrc", {
            /** Returns the safe resource URL of the YouTube video, given video id.  */
            get: /**
             * Returns the safe resource URL of the YouTube video, given video id.
             * @return {?}
             */ function () {
                /** @type {?} */
                var url = "https://www.youtube.com/embed/" + this.videoId + "?rel=0&showinfo=0&autoplay=1";
                if (!this.showPlayerControls) {
                    url += '&controls=0';
                }
                if (!this.allowFullScreen) {
                    url += '&fs=0';
                }
                if (this.interfaceLanguage) {
                    url += "&hl=" + this.interfaceLanguage;
                }
                return this.sanitizer.bypassSecurityTrustResourceUrl(url);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "imgSrc", {
            /** Returns the preview image source URL, given video id. */
            get: /**
             * Returns the preview image source URL, given video id.
             * @return {?}
             */ function () {
                return this.previewImageSrc ? this.previewImageSrc : "https://img.youtube.com/vi/" + this.videoId + "/sddefault.jpg";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxVideoComponent.prototype, "playButtonAriaLabel", {
            /** Returns the labels for the control buttons. */
            get: /**
             * Returns the labels for the control buttons.
             * @return {?}
             */ function () {
                /** @type {?} */
                var defaultLabel = this.altText ? this.altText + " - Play Video" : 'Play Video';
                return this.nxPlayButtonAriaLabel ? this.nxPlayButtonAriaLabel : defaultLabel;
            },
            enumerable: true,
            configurable: true
        });
        NxVideoComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-video',
                        template: "<div class=\"nx-video\">\n  <div class=\"nx-video__iframe\">\n\n    <div *ngIf=\"!showPlayer\">\n\n      <button class=\"nx-video__play-button\"\n              (click)=\"select()\"\n              [attr.aria-label]=\"playButtonAriaLabel\"\n              (keydown.enter)=\"select()\">\n      </button>\n      <img [src]=\"imgSrc\" class=\"nx-video__thumbnail\"\n           [alt]=\"altText\"\n           (click)=\"select()\"\n           (keydown.enter)=\"select()\">\n\n    </div>\n    <div *ngIf=\"videoId && showPlayer\">\n      <iframe title=\"video\" class=\"nx-video__iframe\" [attr.allowfullscreen]=\"allowFullScreen\" [src]=\"videoSrc\"></iframe>\n    </div>\n\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [".nx-video{position:relative;padding-bottom:56.25%;overflow:hidden;width:100%;height:auto}.nx-video__iframe{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.nx-video__thumbnail{position:absolute;cursor:pointer;width:100%;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);opacity:.7}.nx-video__play-button{border:none;background:url(play-button.svg) center no-repeat;cursor:pointer;position:absolute;width:88px;height:56px;z-index:1}.nx-video__play-button::-moz-focus-inner{border:0}.nx-video__play-button,.nx-video__play-button:before{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}"]
                    }] }
        ];
        /** @nocollapse */
        NxVideoComponent.ctorParameters = function () {
            return [
                { type: platformBrowser.DomSanitizer },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxVideoComponent.propDecorators = {
            videoId: [{ type: core$1.Input, args: ['nxVideoId',] }],
            altText: [{ type: core$1.Input, args: ['nxAltText',] }],
            nxPlayButtonAriaLabel: [{ type: core$1.Input, args: ['nxPlayButtonAriaLabel',] }],
            previewImageSrc: [{ type: core$1.Input, args: ['nxPreviewImageSrc',] }],
            showPlayerControls: [{ type: core$1.Input, args: ['nxShowPlayerControls',] }],
            allowFullScreen: [{ type: core$1.Input, args: ['nxAllowFullScreen',] }],
            interfaceLanguage: [{ type: core$1.Input, args: ['nxInterfaceLanguage',] }]
        };
        return NxVideoComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxVideoModule = /** @class */ (function () {
        function NxVideoModule() {
        }
        NxVideoModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxVideoComponent],
                        exports: [NxVideoComponent],
                        imports: [common.CommonModule]
                    },] }
        ];
        return NxVideoModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * \@docs-private
     * @return {?}
     */
    function getNxDropdownNonArrayValueError() {
        return Error('Value must be an array in multiselect mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     * @return {?}
     */
    function getNxDropdownNonFunctionValueError() {
        return Error('`compareWith` must be a function.');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var NxDropdownControl = /** @class */ (function (_super) {
        __extends(NxDropdownControl, _super);
        function NxDropdownControl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Whether the dropdown should allow multi selection and additional checkboxes are shown.
             *
             * Note: Please make sure the value you bind is an array. If not an error is thrown!
             */
            _this.isMultiSelect = false;
            return _this;
        }
        NxDropdownControl.propDecorators = {
            isMultiSelect: [{ type: core$1.Input, args: ['nxIsMultiselect',] }]
        };
        return NxDropdownControl;
    }(formfield.NxFormfieldControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownGroupComponent = /** @class */ (function () {
        function NxDropdownGroupComponent() {
        }
        NxDropdownGroupComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-dropdown-group',
                        template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background-color:rgba(236,236,236,.5)}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-style:italic;padding:24px 32px 16px;font-weight:700;font-size:12px;line-height:16px}"]
                    }] }
        ];
        NxDropdownGroupComponent.propDecorators = {
            label: [{ type: core$1.Input, args: ['nxLabel',] }]
        };
        return NxDropdownGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownItemChange = /** @class */ (function () {
        function NxDropdownItemChange(item, isUserInput) {
            if (isUserInput === void 0) {
                isUserInput = false;
            }
            this.item = item;
            this.isUserInput = isUserInput;
        }
        return NxDropdownItemChange;
    }());
    /**
     * the unique id counter
     * @type {?}
     */
    var nextId$b = 0;
    var NxDropdownItemComponent = /** @class */ (function () {
        function NxDropdownItemComponent(_dropdown, group, _changeDetectorRef, _elementRef) {
            var _this = this;
            this._dropdown = _dropdown;
            this.group = group;
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            this._hidden = false;
            this._mostRecentViewValue = '';
            this._id = "nx-dropdown-item-" + nextId$b++;
            this._selected = false;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            /**
             * Event emitted when the option is selected or deselected.
             */
            // tslint:disable-next-line:no-output-on-prefix
            this.onSelectionChange = new core$1.EventEmitter();
            /**
             * Emits when the state of the option changes and any parents have to be notified.
             */
            this._stateChanges = new rxjs.Subject();
            (( /** @type {?} */(this._dropdown))).filterChanges.pipe(operators.takeUntil(this._destroy)).subscribe(( /**
             * @param {?} value
             * @return {?}
             */function (value) {
                _this._showOrHideByFilter(value);
            }));
            // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
            (( /** @type {?} */(this._dropdown)))._closedStream.pipe(operators.takeUntil(this._destroy)).subscribe(( /**
             * @return {?}
             */function () {
                _this._hidden = false;
            }));
        }
        Object.defineProperty(NxDropdownItemComponent.prototype, "id", {
            /** The unique ID of the option. */
            get: /**
             * The unique ID of the option.
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "selected", {
            /** Whether the item is selected. */
            get: /**
             * Whether the item is selected.
             * @return {?}
             */ function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "active", {
            /** Whether the item is active. */
            get: /**
             * Whether the item is active.
             * @return {?}
             */ function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "multiselect", {
            /**
             * @docs-private
             * Whether the parent dropdown is in multiselect mode.
             */
            get: /**
             * \@docs-private
             * Whether the parent dropdown is in multiselect mode.
             * @return {?}
             */ function () {
                return this._dropdown && this._dropdown.isMultiSelect;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                // Since the parent dropdown component could be using the item's label to display the selected values
                // and it doesn't have a way of knowing if the item's label has changed
                // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
                // relatively cheap, however we still limit them only to selected options in order to avoid
                // hitting the DOM too often.
                if (this._selected) {
                    /** @type {?} */
                    var viewValue = this.viewValue;
                    if (viewValue !== this._mostRecentViewValue) {
                        this._mostRecentViewValue = viewValue;
                        this._stateChanges.next();
                    }
                }
            };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._stateChanges.complete();
                this._destroy.next();
                this._destroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
                event.preventDefault();
                event.stopPropagation();
                this._selectViaInteraction();
            };
        /**
        * `Selects the option while indicating the selection came from the user. Used to
        * determine if the select's view -> model callback should be invoked.`
        */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxDropdownItemComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
            function () {
                this._selected = this.multiselect ? !this._selected : true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent(true);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.show = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._hidden = false;
                this._changeDetectorRef.markForCheck();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.hide = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._hidden = true;
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @private
         * @param {?} search
         * @return {?}
         */
        NxDropdownItemComponent.prototype._showOrHideByFilter = /**
         * @private
         * @param {?} search
         * @return {?}
         */
            function (search) {
                /** @type {?} */
                var constraint = (( /** @type {?} */(this._dropdown))).filterFn(search, this.viewValue);
                this._hidden = constraint ? false : true;
                this._changeDetectorRef.markForCheck();
            };
        Object.defineProperty(NxDropdownItemComponent.prototype, "_formattedValue", {
            get: /**
             * @return {?}
             */ function () {
                return (( /** @type {?} */(this._dropdown))).valueFormatter(this.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownItemComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return (this._elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.select = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (!this._selected) {
                    this._selected = true;
                    this._changeDetectorRef.markForCheck();
                    this._emitSelectionChangeEvent();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.deselect = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this._selected) {
                    this._selected = false;
                    this._changeDetectorRef.markForCheck();
                    this._emitSelectionChangeEvent();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.focus = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxDropdownItemComponent.prototype._emitSelectionChangeEvent = /**
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
            function (isUserInput) {
                if (isUserInput === void 0) {
                    isUserInput = false;
                }
                this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._active = true;
                this._changeDetectorRef.markForCheck();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._active = false;
                this._changeDetectorRef.markForCheck();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownItemComponent.prototype.getLabel = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.value;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NxDropdownItemComponent.prototype._isContentEmpty = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.children.length === 0 && !element.textContent.trim();
            };
        /**
         * @return {?}
         */
        NxDropdownItemComponent.prototype._onLabelChange = /**
         * @return {?}
         */
            function () {
                // trigger change detection when the label content changes for the case that ng-content was empty before.
                // this is also important when the label comes in deferred, e.g. by a delayed observable,
                // then first the default label derived from the value is shown
                // and after the value from the async observable is ready we need to trigger change detection that the derived label
                // gets hidden again.
                // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
                // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
                this._changeDetectorRef.detectChanges();
            };
        NxDropdownItemComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-dropdown-item',
                        template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[id]': 'id',
                            'role': 'option',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[class.nx-hidden]': '_hidden',
                            '[class.nx-dropdown-item--active]': 'active',
                            '[class.nx-selected]': 'selected',
                            '[class.nx-multiselect]': 'multiselect',
                            '(click)': '_onClick($event)'
                        },
                        styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-multiselect) ::ng-deep .nx-checkbox__label{height:28px;display:flex;align-items:center}:host(.nx-dropdown-item--active),:host:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active),:host:hover{color:highlightText}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}.nx-dropdown-results__option-checkicon{opacity:0;width:16px;height:16px;margin-right:8px}.nx-dropdown-results__option-checkicon nx-icon{font-size:16px}:host-context([data-whatinput=keyboard]).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownItemComponent.ctorParameters = function () {
            return [
                { type: NxDropdownControl, decorators: [{ type: core$1.Inject, args: [NxDropdownControl,] }] },
                { type: NxDropdownGroupComponent, decorators: [{ type: core$1.Optional }] },
                { type: core$1.ChangeDetectorRef },
                { type: core$1.ElementRef }
            ];
        };
        NxDropdownItemComponent.propDecorators = {
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            onSelectionChange: [{ type: core$1.Output }],
            containerElement: [{ type: core$1.ViewChild, args: ['container',] }]
        };
        return NxDropdownItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // This Directive solely purpose is to mark given ng-template and project it into the required destination.
    var NxDropdownClosedLabelDirective = /** @class */ (function () {
        function NxDropdownClosedLabelDirective(templateRef) {
            this.templateRef = templateRef;
        }
        NxDropdownClosedLabelDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[nxClosedLabel]'
                    },] }
        ];
        /** @nocollapse */
        NxDropdownClosedLabelDirective.ctorParameters = function () {
            return [
                { type: core$1.TemplateRef }
            ];
        };
        return NxDropdownClosedLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */
    var /**
     * Change event object that is emitted when the select value has changed.
     * @template T
     */ NxDropdownSelectChange = /** @class */ (function () {
        function NxDropdownSelectChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return NxDropdownSelectChange;
    }());
    // used in calculation of scrolltop to correctly show some space to the top of the panel
    /** @type {?} */
    var itemPadding = 16;
    // Max-height: 6 items x 44px + 16px padding before first item
    /** @type {?} */
    var SELECT_PANEL_MAX_HEIGHT = 280;
    var NxDropdownComponent = /** @class */ (function (_super) {
        __extends(NxDropdownComponent, _super);
        function NxDropdownComponent(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
            var _this = _super.call(this) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._elementRef = _elementRef;
            _this._ngZone = _ngZone;
            _this.formFieldComponent = formFieldComponent;
            _this.ngControl = ngControl;
            _this._parentForm = _parentForm;
            _this._parentFormGroup = _parentFormGroup;
            // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
            _this.readonly = false;
            _this._disabled = false;
            _this._focused = false;
            /**
             * Whether or not the overlay panel is open.
             */
            _this._panelOpen = false;
            /**
             * \@docs-private
             */
            _this.errorState = false;
            /**
             * The scroltop of the panelBody.
             */
            _this._scrollTop = 0;
            /**
             * The minimal space between the viewport and the overlay
             */
            _this._overlayViewportMargin = 16;
            /**
             * \@docs-private
             * Emits when internal state changes to inform formfield about it.
             */
            _this.stateChanges = new rxjs.Subject();
            /**
             * The IDs of child options to be passed to the aria-owns attribute.
             */
            _this._optionIds = '';
            _this._tabIndex = 0;
            /**
             * \@docs-private
             */
            _this.currentFilter = '';
            /**
             * Label to describe the component.
             */
            _this._ariaLabel = '';
            _this._style = '';
            /**
             * Whether the dropdown should render in its negative style or not.
             */
            _this._negative = false;
            /**
             * Whether the dropdown should be shown with an additional filter input.
             */
            _this.showFilter = false;
            /**
             * Text displayed as placeholder for the filter.
             */
            _this.filterPlaceholder = '';
            /**
             * Event emitted when the select panel has been toggled.
             */
            _this.openedChange = new core$1.EventEmitter();
            /**
             * Event emitted when the select has been opened.
             */
            _this._openedStream = _this.openedChange.pipe(operators.filter(( /**
             * @param {?} o
             * @return {?}
             */function (o) { return o; })), operators.map(( /**
             * @return {?}
             */function () { })));
            /**
             * Event emitted when the select has been closed.
             */
            _this._closedStream = _this.openedChange.pipe(operators.filter(( /**
             * @param {?} o
             * @return {?}
             */function (o) { return !o; })), operators.map(( /**
             * @return {?}
             */function () { })));
            /**
             * Event emitted when the user types in the filter input.
             */
            _this.filterChanges = new rxjs.Subject();
            /**
             * Event that emits whenever the raw value of the select changes. This is here primarily
             * to facilitate the two-way binding for the `value` input.
             * \@docs-private
             */
            _this.valueChange = new core$1.EventEmitter();
            /**
             * Event emitted when the selected value has been changed.
             */
            _this.selectionChange = new core$1.EventEmitter();
            /**
             * \@docs-private
             */
            _this.optionSelectionChanges = rxjs.defer(( /**
             * @return {?}
             */function () {
                if (_this.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.options.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.onSelectionChange; }))));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(( /**
             * @return {?}
             */function () { return _this.optionSelectionChanges; })));
            }));
            /**
             * This position config ensures that the top "start" corner of the overlay
             * is aligned with with the top "start" of the origin by default (overlapping
             * the trigger completely). If the panel cannot fit below the trigger, it
             * will fall back to a position above the trigger.
             */
            _this._positions = [{
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'top'
                }, {
                    originX: 'start',
                    originY: 'center',
                    overlayX: 'start',
                    overlayY: 'center'
                }, {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'bottom'
                }];
            /**
             * Emits whenever the component is destroyed.
             */
            _this._destroy = new rxjs.Subject();
            /**
             * Function that transforms the value into a string.
             * This function is used for displaying and filtering the content
             * ( Default: (value) => value ? value.toString() : null; ).
             */
            _this.valueFormatter = ( /**
             * @param {?} value
             * @return {?}
             */function (value) {
                return value == null ? '' : value.toString();
            });
            /**
             * Comparison function to specify which option is displayed. Defaults to object equality.
             */
            _this._compareWith = ( /**
             * @param {?} o1
             * @param {?} o2
             * @return {?}
             */function (o1, o2) { return o1 === o2; });
            _this._filterFn = ( /**
             * @param {?} search
             * @param {?} itemValue
             * @return {?}
             */function (search, itemValue) {
                return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
            });
            /**
             * `View -> model callback called when value changes`
             */
            _this._onChange = ( /**
             * @return {?}
             */function () { });
            /**
             * `View -> model callback called when select has been touched`
             */
            _this._onTouched = ( /**
             * @return {?}
             */function () { });
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            _this.tabIndex = parseInt(tabIndex, 10) || 0;
            return _this;
        }
        Object.defineProperty(NxDropdownComponent.prototype, "tabIndex", {
            get: /**
             * @return {?}
             */ function () { return this.disabled ? -1 : this._tabIndex; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // If the specified tabIndex value is null or undefined, fall back to the default value.
                this._tabIndex = value != null ? value : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "value", {
            /** Selected value */
            get: /**
             * Selected value
             * @return {?}
             */ function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (newValue !== this._value) {
                    this.writeValue(newValue);
                    this._value = newValue;
                    this._onChange(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "disabled", {
            /** Whether the dropdown is disabled. */
            get: /**
             * Whether the dropdown is disabled.
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "styles", {
            /** If set to 'negative', the component is displayed with the negative set of styles. */
            set: /**
             * If set to 'negative', the component is displayed with the negative set of styles.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._style === value) {
                    return;
                }
                this._style = value;
                this._negative = !!this._style.match(/negative/);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "closedDropdownLabel", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._closedDropdownLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "selected", {
            /**
             * @docs-private
             * The currently selected option.
             */
            get: /**
             * \@docs-private
             * The currently selected option.
             * @return {?}
             */ function () {
                return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "panelOpen", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._panelOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._panelOpen = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "label", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.formFieldComponent ? this.formFieldComponent.label : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "compareWith", {
            /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             */
            get: /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             * @return {?}
             */ function () { return this._compareWith; },
            set: /**
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._compareWith = fn;
                if (this._selectionModel) {
                    // A different comparator means the selection could change.
                    this._initializeSelection();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "filterFn", {
            /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             */
            get: /**
             * Function to be used when the user types into the search filter. The first argument is the user input,
             * the second argument is the dropdown item value. The dropdown items will use this function to set their
             * visibility state.
             * A boolean should be returned.
             * @return {?}
             */ function () { return this._filterFn; },
            set: /**
             * @param {?} fn
             * @return {?}
             */ function (fn) {
                if (typeof fn !== 'function') {
                    throw getNxDropdownNonFunctionValueError();
                }
                this._filterFn = fn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "focused", {
            /**
             * @docs-private
             * Whether the select is focused.
             */
            get: /**
             * \@docs-private
             * Whether the select is focused.
             * @return {?}
             */ function () {
                return this._focused || this.panelOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this.ngControl) {
                    this.updateErrorState();
                }
            };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._selectionModel = new collections.SelectionModel(this.isMultiSelect);
            };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._closedDropdownLabel =
                    this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
                this._initKeyManager();
                this._selectionModel.onChange.pipe(operators.takeUntil(this._destroy)).subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    event.added.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.select(); }));
                    event.removed.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.deselect(); }));
                }));
                this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this._resetOptions();
                    _this._initializeSelection();
                }));
            };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._destroy.next();
                this._destroy.complete();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        NxDropdownComponent.prototype.isErrorState = /**
         * \@docs-private
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
            function (control, form) {
                return !!(control && control.invalid && (control.touched || (form && form.submitted)));
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var oldState = this.errorState;
                /** @type {?} */
                var parent = this._parentFormGroup || this._parentForm;
                /** @type {?} */
                var control = this.ngControl ? ( /** @type {?} */(this.ngControl.control)) : null;
                /** @type {?} */
                var newState = this.isErrorState(control, parent);
                if (newState !== oldState) {
                    this.errorState = newState;
                    this.stateChanges.next();
                }
            };
        /** Sets up a key manager to listen to keyboard events on the overlay panel. */
        /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initKeyManager = /**
         * Sets up a key manager to listen to keyboard events on the overlay panel.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this._keyManager = new a11y.ActiveDescendantKeyManager(this.options)
                    .withTypeAhead()
                    .withWrap()
                    .withVerticalOrientation()
                    .withHorizontalOrientation('ltr')
                    .skipPredicate(( /**
             * @param {?} item
             * @return {?}
             */function (item) { return item._hidden; }));
                this._keyManager.tabOut.pipe(operators.takeUntil(this._destroy)).subscribe(( /**
                 * @return {?}
                 */function () {
                    // Restore focus to the trigger before closing. Ensures that the focus
                    // position won't be lost if the user got focus into the overlay.
                    _this.closePanel();
                }));
                this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe(( /**
                 * @return {?}
                 */function () {
                    if (_this._panelOpen && _this.panel) {
                        // Delay the auto scrolling until all items have settled otherwise the item containers might
                        // not exist yet
                        _this._ngZone.onStable
                            .asObservable()
                            .pipe(operators.take(1)).subscribe(( /**
                     * @return {?}
                     */function () { return _this._scrollActiveOptionIntoView(); }));
                    }
                    else if (!_this._panelOpen && !_this.isMultiSelect && _this._keyManager.activeItem) {
                        _this._keyManager.activeItem._selectViaInteraction();
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._resetOptions = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var changedOrDestroyed = rxjs.merge(this.options.changes, this._destroy);
                this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed)).subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    _this._onSelect(event.item, event.isUserInput);
                    if (event.isUserInput && !_this.isMultiSelect && _this._panelOpen) {
                        _this.closePanel();
                    }
                }));
                // Listen to changes in the internal state of the options and react accordingly.
                // Handles cases like the labels of the selected options changing.
                rxjs.merge.apply(void 0, __spread(this.options.map(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return option._stateChanges; })))).pipe(operators.takeUntil(changedOrDestroyed))
                    .subscribe(( /**
             * @return {?}
             */function () {
                    // defer it for the next cycle to not run in changed after checked errors
                    // the combination of dropdown-item notifying parent and when the parent
                    // tries to fetch the triggerValue from the child throws these errors
                    setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this._changeDetectorRef.markForCheck();
                        _this.stateChanges.next();
                    }));
                }));
                this._setOptionIds();
            };
        /** Records option IDs to pass to the aria-owns property. */
        /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._setOptionIds = /**
         * Records option IDs to pass to the aria-owns property.
         * @private
         * @return {?}
         */
            function () {
                this._optionIds = this.options.map(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return option.id; })).join(' ');
            };
        /** Invoked when an option is clicked. */
        /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
        NxDropdownComponent.prototype._onSelect = /**
         * Invoked when an option is clicked.
         * @private
         * @param {?} option
         * @param {?} isUserInput
         * @return {?}
         */
            function (option, isUserInput) {
                /** @type {?} */
                var wasSelected = this._selectionModel.isSelected(option);
                if (option.value == null && !this.isMultiSelect) {
                    option.deselect();
                    this._selectionModel.clear();
                    this._propagateChanges(option.value);
                }
                else {
                    option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
                    if (isUserInput) {
                        this._keyManager.setActiveItem(option);
                    }
                    if (this.isMultiSelect) {
                        this._sortValues();
                        if (isUserInput) {
                            // In case the user selected the option with their mouse, we
                            // want to restore focus back to the trigger, in order to
                            // prevent the select keyboard controls from clashing with
                            // the ones from `mat-option`.
                            this.focus();
                        }
                    }
                }
                if (wasSelected !== this._selectionModel.isSelected(option)) {
                    this._propagateChanges();
                }
                this.stateChanges.next();
            };
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._initializeSelection = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                // Defer setting the value in order to avoid the "Expression
                // has changed after it was checked" errors from Angular.
                Promise.resolve().then(( /**
                 * @return {?}
                 */function () {
                    _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
                }));
            };
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         */
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype._setSelectionByValue = /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                if (this.isMultiSelect && value) {
                    if (!Array.isArray(value)) {
                        throw getNxDropdownNonArrayValueError();
                    }
                    this._selectionModel.clear();
                    value.forEach(( /**
                     * @param {?} currentValue
                     * @return {?}
                     */function (currentValue) { return _this._selectValue(currentValue); }));
                    this._sortValues();
                }
                else {
                    this._selectionModel.clear();
                    /** @type {?} */
                    var correspondingOption = this._selectValue(value);
                    // Shift focus to the active item. Note that we shouldn't do this in multiple
                    // mode, because we don't know what option the user interacted with last.
                    if (correspondingOption) {
                        this._keyManager.setActiveItem(correspondingOption);
                    }
                }
                this._changeDetectorRef.markForCheck();
            };
        /**
         * Finds and selects and option based on its value.
         * @returns Option that has the corresponding value.
         */
        /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
        NxDropdownComponent.prototype._selectValue = /**
         * Finds and selects and option based on its value.
         * @private
         * @param {?} value
         * @return {?} Option that has the corresponding value.
         */
            function (value) {
                var _this = this;
                /** @type {?} */
                var correspondingOption = this.options.find(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) {
                    try {
                        // Treat null as a special reset value.
                        return option.value != null && _this._compareWith(option.value, value);
                    }
                    catch (error) {
                        if (core$1.isDevMode()) {
                            // Notify developers of errors in their comparator.
                            console.warn(error);
                        }
                        return false;
                    }
                }));
                if (correspondingOption) {
                    this._selectionModel.select(correspondingOption);
                }
                return correspondingOption;
            };
        /** Emits change event to set the model value. */
        /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
        NxDropdownComponent.prototype._propagateChanges = /**
         * Emits change event to set the model value.
         * @private
         * @param {?=} fallbackValue
         * @return {?}
         */
            function (fallbackValue) {
                /** @type {?} */
                var valueToEmit = null;
                if (this.isMultiSelect) {
                    valueToEmit = (( /** @type {?} */(this.selected))).map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.value; }));
                }
                else {
                    valueToEmit = this.selected ? (( /** @type {?} */(this.selected))).value : fallbackValue;
                }
                this._value = valueToEmit;
                this.valueChange.emit(valueToEmit);
                this._onChange(valueToEmit);
                this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
                this._changeDetectorRef.markForCheck();
            };
        /** Sorts the selected values in the selected based on their order in the panel. */
        /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._sortValues = /**
         * Sorts the selected values in the selected based on their order in the panel.
         * @private
         * @return {?}
         */
            function () {
                if (this.isMultiSelect) {
                    /** @type {?} */
                    var options_1 = this.options.toArray();
                    this._selectionModel.sort(( /**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */function (a, b) { return options_1.indexOf(a) - options_1.indexOf(b); }));
                    this.stateChanges.next();
                }
            };
        /** Focuses the select element. */
        /**
         * Focuses the select element.
         * @return {?}
         */
        NxDropdownComponent.prototype.focus = /**
         * Focuses the select element.
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /** Opens the panel of the dropdown. */
        /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.openPanel = /**
         * Opens the panel of the dropdown.
         * @return {?}
         */
            function () {
                if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
                    return;
                }
                this._panelOpen = true;
                this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
                this._keyManager.withHorizontalOrientation(null);
                this._highlightCorrectOption();
                this._changeDetectorRef.markForCheck();
            };
        /** Closes the panel of the dropdown. */
        /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
        NxDropdownComponent.prototype.closePanel = /**
         * Closes the panel of the dropdown.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._panelOpen) {
                    this._panelOpen = false;
                    this._keyManager.withHorizontalOrientation('ltr');
                    this._changeDetectorRef.markForCheck();
                    this._onTouched();
                    this.openedChange.emit(false);
                    // defer the focus if the dropdown triggers actions that detach
                    // a template/view from the DOM to prevent changed after checked errors
                    setTimeout(( /**
                     * @return {?}
                     */function () { return _this.focus(); }));
                }
            };
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        // calculate inital scrollTop when the dropdown opens
        // scrolls the selected item to the middle of the panel if possible
        /**
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._calculateScrollTop =
            // calculate inital scrollTop when the dropdown opens
            // scrolls the selected item to the middle of the panel if possible
            /**
             * @private
             * @return {?}
             */
            function () {
                // reset the scrolltop to make calculation easier
                this.panelBody.nativeElement.scrollTop = 0;
                this._scrollTop = 0;
                if (!this.empty) {
                    /** @type {?} */
                    var offset = this._getItemOffset(this._keyManager.activeItem);
                    /** @type {?} */
                    var panelHeight = this.panelBody.nativeElement.offsetHeight;
                    /** @type {?} */
                    var panelRect = this.panelBody.nativeElement.getBoundingClientRect();
                    /** @type {?} */
                    var middleOfPanel = panelRect.top + panelHeight / 2;
                    /** @type {?} */
                    var activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
                    if (offset > middleOfPanel) {
                        // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                        // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                        // to middle out the text a bit more add half of the height
                        // (this is still a few pixels off because the container is a bit larger than the font)
                        this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
                        this.panelBody.nativeElement.scrollTop = this._scrollTop;
                    }
                }
            };
        /** Scrolls the active option into view. */
        /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._scrollActiveOptionIntoView = /**
         * Scrolls the active option into view.
         * @private
         * @return {?}
         */
            function () {
                if (!this.panelOpen || !this._keyManager.activeItem) {
                    return;
                }
                /** @type {?} */
                var activeOptionIndex = this._keyManager.activeItemIndex || 0;
                /** @type {?} */
                var itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);
                this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
            };
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} options
         * @param {?} optionGroups
         * @return {?}
         */
        NxDropdownComponent.prototype._countGroupLabelsBeforeOption = /**
         * @private
         * @param {?} optionIndex
         * @param {?} options
         * @param {?} optionGroups
         * @return {?}
         */
            function (optionIndex, options, optionGroups) {
                if (optionGroups.length) {
                    /** @type {?} */
                    var optionsArray = options.toArray();
                    /** @type {?} */
                    var groups = optionGroups.toArray();
                    /** @type {?} */
                    var groupCounter = 0;
                    for (var i = 0; i < optionIndex + 1; i++) {
                        if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                            groupCounter++;
                        }
                    }
                    return groupCounter;
                }
                return 0;
            };
        /**
         * @private
         * @param {?} optionIndex
         * @param {?} optionHeight
         * @param {?} currentScrollPosition
         * @param {?} panelHeight
         * @return {?}
         */
        NxDropdownComponent.prototype._getOptionScrollPosition = /**
         * @private
         * @param {?} optionIndex
         * @param {?} optionHeight
         * @param {?} currentScrollPosition
         * @param {?} panelHeight
         * @return {?}
         */
            function (optionIndex, optionHeight, currentScrollPosition, panelHeight) {
                /** @type {?} */
                var optionOffset = optionIndex * optionHeight + itemPadding;
                if (this.showFilter) {
                    /** @type {?} */
                    var filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
                    optionOffset = optionIndex * optionHeight + filterHeight;
                }
                if (optionOffset < currentScrollPosition) {
                    return optionOffset;
                }
                if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
                    return Math.max(0, optionOffset - panelHeight + optionHeight);
                }
                return currentScrollPosition;
            };
        /**
         * @private
         * @param {?} item
         * @return {?}
         */
        NxDropdownComponent.prototype._getItemOffset = /**
         * @private
         * @param {?} item
         * @return {?}
         */
            function (item) {
                /** @type {?} */
                var itemRect = item.containerElement.nativeElement.getBoundingClientRect();
                return itemRect.top;
            };
        /**
         * @docs-private
         * Formfield Implementation
         */
        /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
        NxDropdownComponent.prototype.setDescribedByIds = /**
         * \@docs-private
         * Formfield Implementation
         * @param {?} ids
         * @return {?}
         */
            function (ids) {
                this.ariaDescribedby = ids.join(' ');
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.setAriaLabel = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._ariaLabel = value;
            };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaLabel = /**
         * @return {?}
         */
            function () {
                return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
            };
        Object.defineProperty(NxDropdownComponent.prototype, "empty", {
            /**
             * @docs-private
             * Whether the select has a value.
             */
            get: /**
             * \@docs-private
             * Whether the select has a value.
             * @return {?}
             */ function () {
                return !this._selectionModel || this._selectionModel.isEmpty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "hasValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._selectionModel.hasValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDropdownComponent.prototype, "shouldLabelFloat", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.focused || !this.empty;
            },
            enumerable: true,
            configurable: true
        });
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param value New value to be written to the model.
         */
        /** End Formfield */
        /** ControlValueAccessor */
        /**
         * Sets the select's value. Part of the ControlValueAccessor interface
         * required to integrate with Angular's core forms API.
         *
         * @param {?} value New value to be written to the model.
         * @return {?}
         */
        NxDropdownComponent.prototype.writeValue = /** End Formfield */
            /** ControlValueAccessor */
            /**
             * Sets the select's value. Part of the ControlValueAccessor interface
             * required to integrate with Angular's core forms API.
             *
             * @param {?} value New value to be written to the model.
             * @return {?}
             */
            function (value) {
                if (this.options) {
                    this._setSelectionByValue(value);
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NxDropdownComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouched = fn;
            };
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param isDisabled Sets whether the component is disabled.
         */
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
        NxDropdownComponent.prototype.setDisabledState = /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param {?} isDisabled Sets whether the component is disabled.
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            };
        /** End ControlValueAccessor */
        /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleKeydown = /**
         * End ControlValueAccessor
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleClosedKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var keyCode = event.keyCode;
                /** @type {?} */
                var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW ||
                    keyCode === keycodes.LEFT_ARROW || keyCode === keycodes.RIGHT_ARROW;
                /** @type {?} */
                var isOpenKey = keyCode === keycodes.ENTER || keyCode === keycodes.SPACE;
                // Open the select on ALT + arrow key to match the native <select>
                if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
                    event.preventDefault(); // prevents the page from scrolling down when pressing space
                    this.openPanel();
                }
                else if (!this.isMultiSelect && !this.disabled) {
                    this._keyManager.onKeydown(event);
                }
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._handleOpenKeydown = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var keyCode = event.keyCode;
                // all events other than the listed ones should be ignored or handled in _onFilter()
                if (!([keycodes.DOWN_ARROW, keycodes.UP_ARROW, keycodes.HOME, keycodes.END, keycodes.ENTER, keycodes.LEFT_ARROW, keycodes.RIGHT_ARROW, keycodes.SHIFT, keycodes.SPACE, keycodes.TAB].indexOf(keyCode) >= 0)) {
                    return;
                }
                /** @type {?} */
                var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW;
                /** @type {?} */
                var manager = this._keyManager;
                /** @type {?} */
                var allHidden = this.options.map(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return option._hidden; })).every(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return Boolean(option); }));
                if (keyCode === keycodes.HOME || keyCode === keycodes.END) {
                    event.preventDefault();
                    keyCode === keycodes.HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
                }
                else if (isArrowKey && event.altKey) {
                    // Close the select on ALT + arrow key to match the native <select>
                    event.preventDefault();
                    this.closePanel();
                }
                else if (keyCode === keycodes.ENTER && manager.activeItem && !allHidden) {
                    event.preventDefault();
                    manager.activeItem._selectViaInteraction();
                }
                else if (keyCode === keycodes.ENTER && allHidden) {
                    event.preventDefault();
                    this.closePanel();
                }
                else if (!this.showFilter && keyCode === keycodes.SPACE && manager.activeItem) {
                    event.preventDefault();
                    manager.activeItem._selectViaInteraction();
                }
                else if (keyCode === keycodes.TAB) {
                    this.closePanel();
                }
                else {
                    /** @type {?} */
                    var previouslyFocusedIndex = manager.activeItemIndex;
                    manager.onKeydown(event);
                    if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                        manager.activeItemIndex !== previouslyFocusedIndex) {
                        manager.activeItem._selectViaInteraction();
                    }
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxDropdownComponent.prototype.formatValue = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.valueFormatter(value);
            };
        /** Called when the user types in the filter input */
        /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
        NxDropdownComponent.prototype._onFilter = /**
         * Called when the user types in the filter input
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                this.currentFilter = event.target.value;
                this.filterChanges.next(event.target.value);
                /** @type {?} */
                var allHidden = this.options.map(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return option._hidden; })).every(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) { return Boolean(option); }));
                if (allHidden) {
                    this._keyManager.setActiveItem(null);
                }
                else {
                    this._keyManager.setFirstItemActive();
                }
            };
        Object.defineProperty(NxDropdownComponent.prototype, "triggerValue", {
            /**
             * @docs-private
             * The value displayed in the trigger.
             */
            get: /**
             * \@docs-private
             * The value displayed in the trigger.
             * @return {?}
             */ function () {
                if (this.empty) {
                    return '';
                }
                if (this.isMultiSelect) {
                    /** @type {?} */
                    var selectedOptions = this._selectionModel.selected.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.viewValue; }));
                    return selectedOptions.join(', ');
                }
                return this._selectionModel.selected[0].viewValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         */
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
        NxDropdownComponent.prototype._highlightCorrectOption = /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         * @private
         * @return {?}
         */
            function () {
                if (this._keyManager) {
                    if (this.empty) {
                        this._keyManager.setFirstItemActive();
                    }
                    else {
                        this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                    }
                }
            };
        /**
         * Callback that is invoked when the overlay panel has been attached.
         */
        /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
        NxDropdownComponent.prototype._onAttached = /**
         * Callback that is invoked when the overlay panel has been attached.
         * @return {?}
         */
            function () {
                var _this = this;
                this._changeDetectorRef.markForCheck();
                this.overlayDir.positionChange.pipe(operators.take(1)).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.panelBody.nativeElement.focus();
                    if (_this._keyManager.activeItem) {
                        _this._calculateScrollTop();
                    }
                    _this._changeDetectorRef.markForCheck();
                    _this.openedChange.emit(true);
                    if (_this.showFilter) {
                        _this.filterInput.nativeElement.focus();
                    }
                }));
            };
        /**
         * @return {?}
         */
        NxDropdownComponent.prototype._onFocus = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this._focused = true;
                    this.stateChanges.next();
                }
            };
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         */
        /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
        NxDropdownComponent.prototype._onBlur = /**
         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
         * "blur" to the panel when it opens, causing a false positive.
         * @return {?}
         */
            function () {
                this._focused = false;
                if (this.filterInput && this.showFilter) {
                    this._clearFilter();
                }
                if (!this.disabled && !this.panelOpen) {
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                    this.stateChanges.next();
                }
            };
        Object.defineProperty(NxDropdownComponent.prototype, "isFilterEmpty", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.currentFilter.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxDropdownComponent.prototype._clearFilter = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.filterInput.nativeElement.value = '';
                this.currentFilter = '';
                this.filterChanges.next('');
            };
        /** @docs-private determines the `aria-activedescendant` to be set on the host. */
        /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
        NxDropdownComponent.prototype._getAriaActiveDescendant = /**
         * \@docs-private determines the `aria-activedescendant` to be set on the host.
         * @return {?}
         */
            function () {
                if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
                    return this._keyManager.activeItem.id;
                }
                return null;
            };
        NxDropdownComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-dropdown',
                        template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                            { provide: formfield.NxFormfieldControl, useExisting: NxDropdownComponent },
                        ],
                        host: {
                            'role': 'button',
                            '[class.nx-dropdown]': 'true',
                            '[class.is-filled]': 'hasValue',
                            '[class.has-focus]': 'focused',
                            '[class.nx-dropdown--negative]': '_negative',
                            '[class.nx-dropdown--disabled]': 'disabled',
                            '[attr.aria-describedby]': 'ariaDescribedby || null',
                            '[attr.aria-required]': 'required',
                            '[attr.aria-label]': '_getAriaLabel()',
                            '[attr.aria-haspopup]': '"listbox"',
                            '[attr.aria-expanded]': 'panelOpen',
                            '[attr.disabled]': 'disabled || null',
                            '[attr.tabindex]': 'tabIndex',
                            '(keydown)': '_handleKeydown($event)',
                            '(focus)': '_onFocus()',
                            '(blur)': '_onBlur()',
                            '(click)': 'openPanel()'
                        },
                        styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxDropdownComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: core$1.ElementRef },
                { type: core$1.NgZone },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['tabindex',] }] },
                { type: formfield.NxFormfieldComponent, decorators: [{ type: core$1.Optional }] },
                { type: forms.NgControl, decorators: [{ type: core$1.Self }, { type: core$1.Optional }] },
                { type: forms.NgForm, decorators: [{ type: core$1.Optional }] },
                { type: forms.FormGroupDirective, decorators: [{ type: core$1.Optional }] }
            ];
        };
        NxDropdownComponent.propDecorators = {
            tabIndex: [{ type: core$1.Input }],
            _ariaLabel: [{ type: core$1.Input, args: ['nxAriaLabel',] }],
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            required: [{ type: core$1.Input, args: ['nxRequired',] }],
            styles: [{ type: core$1.Input, args: ['nxStyle',] }],
            showFilter: [{ type: core$1.Input, args: ['nxShowFilter',] }],
            filterPlaceholder: [{ type: core$1.Input, args: ['nxFilterPlaceholder',] }],
            openedChange: [{ type: core$1.Output }],
            _openedStream: [{ type: core$1.Output, args: ['opened',] }],
            _closedStream: [{ type: core$1.Output, args: ['closed',] }],
            filterChanges: [{ type: core$1.Output, args: ['filterInput',] }],
            valueChange: [{ type: core$1.Output, args: ['nxValueChange',] }],
            selectionChange: [{ type: core$1.Output }],
            panel: [{ type: core$1.ViewChild, args: ['panel',] }],
            panelBody: [{ type: core$1.ViewChild, args: ['panelBody',] }],
            trigger: [{ type: core$1.ViewChild, args: ['trigger',] }],
            filterInput: [{ type: core$1.ViewChild, args: ['filterInput',] }],
            overlayDir: [{ type: core$1.ViewChild, args: [overlay.CdkConnectedOverlay,] }],
            options: [{ type: core$1.ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
            groups: [{ type: core$1.ContentChildren, args: [NxDropdownGroupComponent,] }],
            _customClosedDropdownLabel: [{ type: core$1.ContentChild, args: [NxDropdownClosedLabelDirective,] }],
            _defaultClosedDropdownLabel: [{ type: core$1.ViewChild, args: ['defaultClosedDropdownLabel',] }],
            valueFormatter: [{ type: core$1.Input, args: ['nxValueFormatter',] }],
            compareWith: [{ type: core$1.Input }],
            filterFn: [{ type: core$1.Input }]
        };
        return NxDropdownComponent;
    }(NxDropdownControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDropdownModule = /** @class */ (function () {
        function NxDropdownModule() {
        }
        NxDropdownModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule,
                            checkbox.NxCheckboxModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            icon.NxIconModule,
                            observers.ObserversModule
                        ],
                        declarations: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ],
                        exports: [
                            NxDropdownComponent,
                            NxDropdownItemComponent,
                            NxDropdownGroupComponent,
                            NxDropdownClosedLabelDirective
                        ]
                    },] }
        ];
        return NxDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Option selected event
     */
    var /**
     * Option selected event
     */ NxAutocompleteOptionSelected = /** @class */ (function () {
        function NxAutocompleteOptionSelected(source, isUserInput) {
            if (isUserInput === void 0) {
                isUserInput = false;
            }
            this.source = source;
            this.isUserInput = isUserInput;
        }
        return NxAutocompleteOptionSelected;
    }());
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueIdCounter = 0;
    var NxAutocompleteOptionComponent = /** @class */ (function () {
        function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-autocomplete-option-" + _uniqueIdCounter++;
            this._selected = false;
            this._active = false;
            this._disabled = false;
            /**
             * Event emitted when the option is selected or deselected.
             */
            this.onSelectionChange = new core$1.EventEmitter();
        }
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "id", {
            /** Id of the autocomplete option. By default it is set to an incremented value. */
            get: /**
             * Id of the autocomplete option. By default it is set to an incremented value.
             * @return {?}
             */ function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: /**
             * Whether or not the option is currently selected.
             * @return {?}
             */ function () { return this._selected; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "active", {
            /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             */
            get: /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             * @return {?}
             */ function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "disabled", {
            /** Whether the option is disabled. */
            get: /**
             * Whether the option is disabled.
             * @return {?}
             */ function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Ensures the option is selected when activated from the keyboard. */
        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._handleKeydown = /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.keyCode === keycodes.ENTER || event.keyCode === keycodes.SPACE) {
                    this._selectViaInteraction();
                    // Prevent the page from scrolling down and form submits.
                    event.preventDefault();
                }
            };
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this._selected = true;
                    this._changeDetectorRef.markForCheck();
                    this._emitSelectionChangeEvent(true);
                }
            };
        /** Returns the correct tabindex for the option depending on disabled state. */
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._getTabIndex = /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
            function () {
                return this.disabled ? '-1' : '0';
            };
        /** Emits the selection change event. */
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
            function (isUserInput) {
                if (isUserInput === void 0) {
                    isUserInput = false;
                }
                this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
            };
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return (this.elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
            function () {
                if (!this._active) {
                    this._active = true;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
            function () {
                if (this._active) {
                    this._active = false;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @docs-private
         * Gets the label to be used when determining whether the option should be focused.
         */
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.getLabel = /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
            function () {
                return this.viewValue;
            };
        /** Selects the option. */
        /**
         * Selects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.select = /**
         * Selects the option.
         * @return {?}
         */
            function () {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            };
        /** Deselects the option. */
        /**
         * Deselects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.deselect = /**
         * Deselects the option.
         * @return {?}
         */
            function () {
                this._selected = false;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            };
        /**
         * @docs-private
         * Sets focus onto this option.
         */
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.focus = /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var element = this.elementRef.nativeElement;
                if (typeof element.focus === 'function') {
                    element.focus();
                }
            };
        NxAutocompleteOptionComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-autocomplete-option',
                        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        host: {
                            'role': 'option',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[id]': 'id',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                            '(click)': '_selectViaInteraction()',
                            '(keydown)': '_handleKeydown($event)',
                            '[class.nx-active]': 'active',
                            '[class.nx-disabled]': 'disabled',
                            '[style.display]': '\'block\'' // needed for to be able to calculate offset height
                        },
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host:focus{outline:0}.nx-autocomplete-option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:highlightText}}.nx-autocomplete-option__label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteOptionComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxAutocompleteOptionComponent.propDecorators = {
            disabled: [{ type: core$1.Input }],
            value: [{ type: core$1.Input }],
            onSelectionChange: [{ type: core$1.Output }]
        };
        return NxAutocompleteOptionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    var /**
     * Event object that is emitted when an autocomplete option is selected.
     */ NxAutocompleteSelectedEvent = /** @class */ (function () {
        function NxAutocompleteSelectedEvent(source, option) {
            this.source = source;
            this.option = option;
        }
        return NxAutocompleteSelectedEvent;
    }());
    var NxAutocompleteComponent = /** @class */ (function () {
        function NxAutocompleteComponent(_changeDetectorRef, _elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            /**
             * Whether the autocomplete panel should be visible, depending on option length.
             */
            this.showPanel = false;
            this._isOpen = false;
            this._items = null;
            this._hasItems = false;
            /**
             * Event that is emitted whenever an option from the list is selected.
             */
            this.optionSelected = new core$1.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is opened.
             */
            this.opened = new core$1.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is closed.
             */
            this.closed = new core$1.EventEmitter();
            this._classList = {};
            /**
             * Unique ID to be used by autocomplete trigger's "aria-owns" property.
             */
            this.id = "nx-autocomplete-" + _uniqueAutocompleteIdCounter++;
            // As autocomplete option can hold any value, we might need a converter
            // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
            /**
             * Value to string converter.
             */
            this.valueFormatter = ( /**
             * @param {?} value
             * @return {?}
             */function (value) { return value ? value.toString() : null; });
        }
        Object.defineProperty(NxAutocompleteComponent.prototype, "isOpen", {
            /** Whether the autocomplete panel is open. */
            get: /**
             * Whether the autocomplete panel is open.
             * @return {?}
             */ function () { return this._isOpen && this.showPanel; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "items", {
            get: /**
             * @return {?}
             */ function () {
                return this._items;
            },
            /** Items observable. If given, autocomplete takes care of the options and ng-content is discarderd */
            set: /**
             * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._hasItems = true;
                if (Array.isArray(val)) {
                    this._items = val;
                }
                else if (val instanceof rxjs.Observable) {
                    if (this._itemsSubscription) {
                        this._itemsSubscription.unsubscribe();
                    }
                    this._itemsSubscription = val.subscribe(( /**
                     * @param {?} itms
                     * @return {?}
                     */function (itms) {
                        _this._items = itms;
                        _this._changeDetectorRef.markForCheck();
                        // and check visibility in next cycle, when options are set
                        setTimeout(( /**
                         * @return {?}
                         */function () { return _this._setVisibility(); }));
                    }));
                }
                else if (val === null) {
                    this._items = val;
                }
                else {
                    throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "hasItems", {
            /**
             * @docs-private
             * Is items observable set
             */
            get: /**
             * \@docs-private
             * Is items observable set
             * @return {?}
             */ function () {
                return this._hasItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "options", {
            /** Autocomplete options */
            get: /**
             * Autocomplete options
             * @return {?}
             */ function () {
                return this.hasItems ? this._vOptions : this._cOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "classList", {
            /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             */
            set: /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (value && value.length) {
                    value.split(' ').forEach(( /**
                     * @param {?} className
                     * @return {?}
                     */function (className) { return _this._classList[className.trim()] = true; }));
                    this._elementRef.nativeElement.className = '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();
                this._setVisibility();
            };
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._itemsSubscription) {
                    this._itemsSubscription.unsubscribe();
                }
            };
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         */
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setScrollTop = /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
            function (scrollTop) {
                if (this.panel) {
                    this.panel.nativeElement.scrollTop = scrollTop;
                }
            };
        /** Returns the panel's scrollTop. */
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._getScrollTop = /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
            function () {
                return this.panel ? this.panel.nativeElement.scrollTop : 0;
            };
        /** Panel should hide itself when the option list is empty. */
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setVisibility = /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
            function () {
                this.showPanel = !!(this.options && this.options.length);
                this._classList['nx-autocomplete-visible'] = this.showPanel;
                this._classList['nx-autocomplete-hidden'] = !this.showPanel;
                this._changeDetectorRef.markForCheck();
            };
        /** Emits the `select` event. */
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        NxAutocompleteComponent.prototype._emitSelectEvent = /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                /** @type {?} */
                var event = new NxAutocompleteSelectedEvent(this, option);
                this.optionSelected.emit(event);
            };
        NxAutocompleteComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-autocomplete',
                        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxAutocomplete',
                        host: {
                            'class': 'nx-autocomplete'
                        },
                        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:24px;overflow-y:auto;overflow-x:hidden;max-height:336px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: core$1.ElementRef }
            ];
        };
        NxAutocompleteComponent.propDecorators = {
            template: [{ type: core$1.ViewChild, args: [core$1.TemplateRef,] }],
            panel: [{ type: core$1.ViewChild, args: ['panel',] }],
            items: [{ type: core$1.Input }],
            optionSelected: [{ type: core$1.Output }],
            opened: [{ type: core$1.Output }],
            closed: [{ type: core$1.Output }],
            _vOptions: [{ type: core$1.ViewChildren, args: [NxAutocompleteOptionComponent,] }],
            _cOptions: [{ type: core$1.ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
            classList: [{ type: core$1.Input, args: ['class',] }],
            valueFormatter: [{ type: core$1.Input, args: ['nxValueFormatter',] }]
        };
        return NxAutocompleteComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */
    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core$1.forwardRef(( /**
         * @return {?}
         */function () { return NxAutocompleteTriggerDirective; })),
        multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */
    function getNxAutocompleteMissingPanelError() {
        return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' +
            'Make sure that the id passed to the `nxAutocomplete` is correct and that ' +
            'you\'re attempting to open it after the ngAfterContentInit hook.');
    }
    var NxAutocompleteTriggerDirective = /** @class */ (function () {
        function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
            var _this = this;
            this._element = _element;
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this._changeDetectorRef = _changeDetectorRef;
            this._dir = _dir;
            this._nxFormField = _nxFormField;
            this._nxWordField = _nxWordField;
            this._document = _document;
            this._viewportRuler = _viewportRuler;
            this._componentDestroyed = false;
            /**
             * Whether or not the label state is being overridden.
             */
            this._manuallyFloatingLabel = false;
            /**
             * Subscription to viewport size changes.
             */
            this._viewportSubscription = rxjs.Subscription.EMPTY;
            /**
             * Stream of keyboard events that can close the panel.
             */
            this._closeKeyEventStream = new rxjs.Subject();
            /**
             * Value changes
             */
            this._valueChanges = new rxjs.Subject();
            this._itemsCb = null;
            this._debounce = 400;
            this._autocompleteDisabled = false;
            this._overlayAttached = false;
            /**
             * Stream of autocomplete option selections.
             */
            this.optionSelections = rxjs.defer(( /**
             * @return {?}
             */function () {
                if (_this.autocomplete && _this.autocomplete.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.autocomplete.options.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.onSelectionChange; }))));
                }
                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                // Return a stream that we'll replace with the real one once everything is in place.
                return _this._zone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(( /**
             * @return {?}
             */function () { return _this.optionSelections; })));
            }));
            /**
             * `View -> model callback called when value changes`
             */
            this._onChange = ( /**
             * @param {?} val
             * @return {?}
             */function (val) {
                _this._valueChanges.next(val);
            });
            /**
             * `View -> model callback called when autocomplete has been touched`
             */
            this._onTouched = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "itemsCb", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsCb;
            },
            /** The items callback. Called with input value, must return Observable of Array of strings */
            set: /**
             * The items callback. Called with input value, must return Observable of Array of strings
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (typeof val === 'function') {
                    this._itemsCb = val;
                }
                else {
                    throw new Error('Wrong value type for nxAutocompleteItems');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "debounce", {
            /** Debounce in ms before items callback is triggered. Defaults to 400 */
            set: /**
             * Debounce in ms before items callback is triggered. Defaults to 400
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._debounce = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "autocompleteDisabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._autocompleteDisabled;
            },
            /** Whether autocomplete functionality is disabled. */
            set: /**
             * Whether autocomplete functionality is disabled.
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._autocompleteDisabled = val;
                this._bindAutocompleteItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelOpen", {
            /** Whether or not the autocomplete panel is open. */
            get: /**
             * Whether or not the autocomplete panel is open.
             * @return {?}
             */ function () {
                return this._overlayAttached && this.autocomplete.showPanel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "activeOption", {
            /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
            get: /**
             * The currently active option, coerced to NxAutocompleteOptionComponent type.
             * @return {?}
             */ function () {
                if (this.autocomplete && this.autocomplete._keyManager) {
                    return this.autocomplete._keyManager.activeItem;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_outsideClickStream", {
            /** Stream of clicks outside of the autocomplete panel. */
            get: /**
             * Stream of clicks outside of the autocomplete panel.
             * @private
             * @return {?}
             */ function () {
                var _this = this;
                if (!this._document) {
                    return rxjs.of(null);
                }
                return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))
                    .pipe(operators.filter(( /**
             * @param {?} event
             * @return {?}
             */function (event) {
                    /** @type {?} */
                    var clickTarget = ( /** @type {?} */(event.target));
                    /** @type {?} */
                    var formField = _this._formField ?
                        _this._formField.elementRef.nativeElement : null;
                    return _this._overlayAttached &&
                        clickTarget !== _this._element.nativeElement &&
                        (!formField || !formField.contains(clickTarget)) &&
                        (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_formField", {
            get: /**
             * @private
             * @return {?}
             */ function () {
                if (this._nxFormField) {
                    return this._nxFormField;
                }
                else if (this._nxWordField) {
                    return this._nxWordField;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._viewportSubscription.unsubscribe();
                this._componentDestroyed = true;
                this._destroyPanel();
                this._closeKeyEventStream.complete();
                if (this._controlValueChangesSubscription) {
                    this._controlValueChangesSubscription.unsubscribe();
                }
                if (this._itemsSubscription) {
                    this._itemsSubscription.unsubscribe();
                }
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this._bindAutocompleteItems();
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._bindAutocompleteItems();
            };
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         */
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._bindAutocompleteItems = /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._controlValueChangesSubscription) {
                    this._controlValueChangesSubscription.unsubscribe();
                }
                if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
                    /** @type {?} */
                    var itemsSubject_1 = new rxjs.Subject();
                    this.autocomplete.items = itemsSubject_1;
                    /** @type {?} */
                    var valueChanges = this._formField &&
                        this._formField._control &&
                        this._formField._control.ngControl &&
                        this._formField._control.ngControl.valueChanges ?
                        this._formField._control.ngControl.valueChanges : this._valueChanges;
                    this._controlValueChangesSubscription = valueChanges.pipe(operators.debounceTime(this._debounce))
                        .subscribe(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input$$1) {
                        if (_this._itemsSubscription) {
                            _this._itemsSubscription.unsubscribe();
                        }
                        _this._itemsSubscription = _this._itemsCb(input$$1).pipe(operators.first()).subscribe(( /**
                         * @param {?} result
                         * @return {?}
                         */function (result) {
                            itemsSubject_1.next(result);
                        }), ( /**
                         * @param {?} err
                         * @return {?}
                         */function (err) {
                            // On error reset
                            // TODO: Log error?
                            itemsSubject_1.next([]);
                        }));
                    }));
                }
            };
        /** Opens the autocomplete suggestion panel. */
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.openPanel = /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
            function () {
                if (!this.autocompleteDisabled) {
                    this._attachOverlay();
                    this._floatLabel();
                }
            };
        /** Closes the autocomplete suggestion panel. */
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.closePanel = /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
            function () {
                this._resetLabel();
                if (!this._overlayAttached) {
                    return;
                }
                if (this.panelOpen) {
                    // Only emit if the panel was visible.
                    this.autocomplete.closed.emit();
                }
                this.autocomplete._isOpen = this._overlayAttached = false;
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                    this._closingActionsSubscription.unsubscribe();
                }
                // Note that in some cases this can end up being called after the component is destroyed.
                // Add a check to ensure that we don't try to run change detection on a destroyed view.
                if (!this._componentDestroyed) {
                    // We need to trigger change detection manually, because
                    // `fromEvent` doesn't seem to do it at the proper time.
                    // This ensures that the label is reset when the
                    // user clicks outside.
                    this._changeDetectorRef.detectChanges();
                }
            };
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelClosingActions", {
            /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             */
            get: /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             * @return {?}
             */ function () {
                var _this = this;
                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(( /**
                 * @return {?}
                 */function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ?
                    this._overlayRef.detachments().pipe(operators.filter(( /**
                     * @return {?}
                     */function () { return _this._overlayAttached; }))) :
                    rxjs.of());
            },
            enumerable: true,
            configurable: true
        });
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.writeValue =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                Promise.resolve(null).then(( /**
                 * @return {?}
                 */function () { return _this._setTriggerValue(value); }));
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnChange =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onChange = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnTouched =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onTouched = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.setDisabledState =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} isDisabled
             * @return {?}
             */
            function (isDisabled) {
                this._element.nativeElement.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var keyCode = event.keyCode;
                // Prevent the default action on all escape key presses. This is here primarily to bring IE
                // in line with other browsers. By default, pressing escape on IE will cause it to revert
                // the input value to the one that it had on focus, however it won't dispatch any events
                // which means that the model value will be out of sync with the view.
                if (keyCode === keycodes.ESCAPE) {
                    event.preventDefault();
                }
                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                if (this.panelOpen && (keyCode === keycodes.ESCAPE || (keyCode === keycodes.UP_ARROW && event.altKey))) {
                    this._resetActiveItem();
                    this._closeKeyEventStream.next();
                    event.stopPropagation();
                }
                else if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {
                    this.activeOption._selectViaInteraction();
                    this._resetActiveItem();
                    event.preventDefault();
                }
                else {
                    /** @type {?} */
                    var prevActiveItem = this.autocomplete._keyManager.activeItem;
                    /** @type {?} */
                    var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;
                    if (this.panelOpen || keyCode === keycodes.TAB) {
                        this.autocomplete._keyManager.onKeydown(event);
                    }
                    else if (isArrowKey && this._isFieldEnabled()) {
                        this.openPanel();
                    }
                    if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                        this._scrollToOption();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleInput = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var target = ( /** @type {?} */(event.target));
                /** @type {?} */
                var value = target.value;
                // Based on `NumberValueAccessor` from forms.
                if (target.type === 'number') {
                    value = value === '' ? null : parseFloat(value);
                }
                // If the input has a placeholder, IE will fire the `input` event on page load,
                // focus and blur, in addition to when the user actually changed the value. To
                // filter out all of the extra events, we save the value on focus and between
                // `input` events, and we check whether it changed.
                // See: https://connect.microsoft.com/IE/feedback/details/885747/
                if (this._isFieldEnabled() && this._previousValue !== value &&
                    document.activeElement === event.target) {
                    this._previousValue = value;
                    this._onChange(value);
                    this.openPanel();
                }
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleFocus = /**
         * @return {?}
         */
            function () {
                if (this._isFieldEnabled()) {
                    this._previousValue = this._element.nativeElement.value;
                    this.openPanel();
                }
            };
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @param shouldAnimate Whether the label should be animated when it is floated.
         */
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._floatLabel = /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
            function () {
                if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
                    this._nxFormField.floatLabel = 'always';
                    this._manuallyFloatingLabel = true;
                }
            };
        /** If the label has been manually elevated, return it to its normal state. */
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetLabel = /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
            function () {
                if (this._manuallyFloatingLabel) {
                    this._nxFormField.floatLabel = 'auto';
                    this._manuallyFloatingLabel = false;
                }
            };
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         */
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollToOption = /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
            function () {
                if (this.autocomplete.options.length === 0) {
                    return;
                }
                /** @type {?} */
                var optionOffset = 0;
                /** @type {?} */
                var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;
                if (this.autocomplete._keyManager.activeItem) {
                    optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
                }
                /** @type {?} */
                var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);
                this.autocomplete._setScrollTop(newScrollPosition);
            };
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         */
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._subscribeToClosingActions = /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));
                /** @type {?} */
                var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(( /**
                 * @return {?}
                 */function () { return _this._positionStrategy.reapplyLastPosition(); })), 
                // Defer emitting to the stream until the next tick, because changing
                // bindings in here will cause "changed after checked" errors.
                operators.delay(0));
                // When the zone is stable initially, and when the option list changes...
                return rxjs.merge(firstStable, optionChanges)
                    .pipe(
                // create a new stream of panelClosingActions, replacing any previous streams
                // that were created, and flatten it so our stream only emits closing events...
                operators.switchMap(( /**
                 * @return {?}
                 */function () {
                    _this._resetActiveItem();
                    _this.autocomplete._setVisibility();
                    return _this.panelClosingActions;
                })), 
                // when the first closing event occurs...
                operators.take(1))
                    // set the value, close the panel, and complete.
                    .subscribe(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this._setValueAndClose(event); }));
            };
        /** Destroys the autocomplete suggestion panel. */
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._destroyPanel = /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this.closePanel();
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setTriggerValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ?
                    this.autocomplete.valueFormatter(value) :
                    value;
                // Simply falling back to an empty string if the display value is falsy does not work properly.
                // The display value can also be the number zero and shouldn't fall back to an empty string.
                /** @type {?} */
                var inputValue = toDisplay != null ? toDisplay : '';
                // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
                // through change detection.
                if (this._formField) {
                    this._formField._control.value = inputValue;
                }
                else {
                    this._element.nativeElement.value = inputValue;
                }
            };
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         */
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setValueAndClose = /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event && event.source) {
                    this._clearPreviousSelectedOption(event.source);
                    this._setTriggerValue(event.source.value);
                    this._onChange(event.source.value);
                    this._element.nativeElement.focus();
                    this.autocomplete._emitSelectEvent(event.source);
                }
                this.closePanel();
            };
        /**
         * Clear any previous selected option and emit a selection change event for this option
         */
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._clearPreviousSelectedOption = /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
            function (skip) {
                this.autocomplete.options.forEach(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) {
                    if (option !== skip && option.selected) {
                        option.deselect();
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._attachOverlay = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.autocomplete) {
                    throw getNxAutocompleteMissingPanelError();
                }
                if (!this._overlayRef) {
                    this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);
                    this._overlayRef = this._overlay.create(this._getOverlayConfig());
                    if (this._viewportRuler) {
                        this._viewportSubscription = this._viewportRuler.change().subscribe(( /**
                         * @return {?}
                         */function () {
                            if (_this.panelOpen && _this._overlayRef) {
                                _this._overlayRef.updateSize({ minWidth: _this._getHostWidth() });
                            }
                        }));
                    }
                }
                else {
                    /** Update the panel width, in case the host width has changed */
                    this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
                }
                if (this._overlayRef && !this._overlayRef.hasAttached()) {
                    this._overlayRef.attach(this._portal);
                    this._closingActionsSubscription = this._subscribeToClosingActions();
                }
                /** @type {?} */
                var wasOpen = this.panelOpen;
                this.autocomplete._setVisibility();
                this.autocomplete._isOpen = this._overlayAttached = true;
                // We need to do an extra `panelOpen` check in here, because the
                // autocomplete won't be shown if there are no options.
                if (this.panelOpen && wasOpen !== this.panelOpen) {
                    this.autocomplete.opened.emit();
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayConfig = /**
         * @private
         * @return {?}
         */
            function () {
                return new overlay.OverlayConfig({
                    positionStrategy: this._getOverlayPosition(),
                    scrollStrategy: this._scrollStrategy(),
                    minWidth: this._getHostWidth(),
                    direction: this._dir ? this._dir.value : 'ltr'
                });
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayPosition = /**
         * @private
         * @return {?}
         */
            function () {
                this._positionStrategy = this._overlay.position()
                    .flexibleConnectedTo(this._getConnectedElement())
                    .withViewportMargin(16)
                    .withPush(false)
                    .withPositions([
                    {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    },
                    {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom',
                    }
                ]);
                return this._positionStrategy;
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollStrategy = /**
         * @private
         * @return {?}
         */
            function () {
                return this._overlay.scrollStrategies.reposition();
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getConnectedElement = /**
         * @private
         * @return {?}
         */
            function () {
                return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
            };
        /** Returns the width of the input element, so the panel min-width can match it. */
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getHostWidth = /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
            function () {
                return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
            };
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         */
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetActiveItem = /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
            function () {
                this.autocomplete._keyManager.setActiveItem(-1);
            };
        /** Determines whether the panel can be opened. */
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._isFieldEnabled = /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var element = this._element.nativeElement;
                return !element.readOnly && !element.disabled;
            };
        NxAutocompleteTriggerDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
                        host: {
                            'role': 'combobox',
                            'autocomplete': 'off',
                            'aria-autocomplete': 'list',
                            '[attr.aria-activedescendant]': 'activeOption?.id',
                            '[attr.aria-expanded]': 'panelOpen.toString()',
                            '[attr.aria-owns]': 'autocomplete?.id',
                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                            // a little earlier. This avoids issues where IE delays the focusing of the input.
                            '(focusin)': '_handleFocus()',
                            '(blur)': '_onTouched()',
                            '(input)': '_handleInput($event)',
                            '(keydown)': '_handleKeydown($event)',
                        },
                        exportAs: 'nxAutocompleteTrigger',
                        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        NxAutocompleteTriggerDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: overlay.Overlay },
                { type: core$1.ViewContainerRef },
                { type: core$1.NgZone },
                { type: core$1.ChangeDetectorRef },
                { type: bidi.Directionality, decorators: [{ type: core$1.Optional }] },
                { type: formfield.NxFormfieldComponent, decorators: [{ type: core$1.Optional }, { type: core$1.Host }] },
                { type: naturalLanguageForm.NxWordComponent, decorators: [{ type: core$1.Optional }, { type: core$1.Host }] },
                { type: undefined, decorators: [{ type: core$1.Optional }, { type: core$1.Inject, args: [common.DOCUMENT,] }] },
                { type: overlay.ViewportRuler }
            ];
        };
        NxAutocompleteTriggerDirective.propDecorators = {
            autocomplete: [{ type: core$1.Input, args: ['nxAutocomplete',] }],
            itemsCb: [{ type: core$1.Input, args: ['nxAutocompleteItems',] }],
            debounce: [{ type: core$1.Input, args: ['nxAutocompleteDebounce',] }],
            autocompleteDisabled: [{ type: core$1.Input, args: ['nxAutocompleteDisabled',] }]
        };
        return NxAutocompleteTriggerDirective;
    }());
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */
    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAutocompleteModule = /** @class */ (function () {
        function NxAutocompleteModule() {
        }
        NxAutocompleteModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        imports: [common.CommonModule, overlay.OverlayModule, a11y.A11yModule]
                    },] }
        ];
        return NxAutocompleteModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxWordComponent = /** @class */ (function () {
        function NxWordComponent(elementRef, _changeDetectorRef, _renderer, _overlay) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._overlay = _overlay;
            this.subscription = rxjs.Subscription.EMPTY;
            this.subscriptionValues = rxjs.Subscription.EMPTY;
            /**
             * \@docs-private
             */
            this.hasErrors = false;
            /**
             * \@docs-private
             */
            this.inputChanges = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.currentTextWidth = 0;
            // this will apply different min-widths to our component through our styles
            /**
             * Provide a hint for a minimal width. The actual size will be determined for inputs for each change.
             */
            this.size = 'regular';
        }
        /**
         * @return {?}
         */
        NxWordComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._validateControlChild();
                this.subscription = this._control.stateChanges.pipe(operators.startWith(null)).subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.hasErrors = _this._control.errorState;
                    _this._changeDetectorRef.markForCheck();
                }));
                // if we have a ngcontrol available stick to its valueChanges subject
                if (this._control.ngControl) {
                    this.subscriptionValues = this._control.ngControl.valueChanges.subscribe(( /**
                     * @param {?} value
                     * @return {?}
                     */function (value) {
                        _this.updateCurrentTextWidth();
                        _this.inputChanges.next();
                    }));
                    // in any other case it is a bre input and input changes are signaled through simple state changes
                }
                else {
                    this.subscriptionValues = this._control.stateChanges.subscribe(( /**
                     * @param {?} value
                     * @return {?}
                     */function (value) {
                        _this.updateCurrentTextWidth();
                        _this.inputChanges.next();
                    }));
                }
                this._control.setAriaLabel(this.label);
            };
        /**
         * @return {?}
         */
        NxWordComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        /**
          @docs-private
          Calculate the width of the full text given by the input,
          that value is bound to this component so it can grow.
      
          The involved input is known to have a width of 100% an will fit the additional space given
          which completes the auto growing behavior.
        */
        /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */
        NxWordComponent.prototype.updateCurrentTextWidth = /**
         * \@docs-private
         * Calculate the width of the full text given by the input,
         * that value is bound to this component so it can grow.
         * The involved input is known to have a width of 100% an will fit the additional space given
         * which completes the auto growing behavior.
         * @return {?}
         */
            function () {
                // provide the canvas only lazy
                if (!this.measureCanvas) {
                    this.measureCanvas = this._renderer.createElement('canvas');
                }
                /** @type {?} */
                var ctx = this.measureCanvas.getContext('2d');
                /** @type {?} */
                var inputRef = this._control.elementRef;
                /** @type {?} */
                var styles = window.getComputedStyle(inputRef.nativeElement);
                ctx.font = utils.getFontShorthand(styles);
                /** @type {?} */
                var metrics = ctx.measureText(this._control.value);
                // add 1px (cursor width) to prevent jumping of the text on blur.
                /** @type {?} */
                var newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
                // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
                // Works as promised as long as there is not other tag around the word. Not expected but possible.
                /** @type {?} */
                var parent = this.elementRef.nativeElement.parentElement;
                /** @type {?} */
                var parentMeasurement = parent.getBoundingClientRect();
                // Limit to own given minimal width
                this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
                // Limit to container width
                this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
                this._popover.updatePosition();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxWordComponent.prototype.repositionError = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this._popover) {
                    this._popover.updatePosition();
                }
            };
        // Fail if the required control is missing.
        // Fail if the required control is missing.
        /**
         * @protected
         * @return {?}
         */
        NxWordComponent.prototype._validateControlChild =
            // Fail if the required control is missing.
            /**
             * @protected
             * @return {?}
             */
            function () {
                if (!this._control) {
                    throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxWordComponent.prototype.getConnectedOverlayOrigin = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.elementRef;
            };
        Object.defineProperty(NxWordComponent.prototype, "isFocused", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._control.focused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxWordComponent.prototype, "isFilled", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return !this._control.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxWordComponent.prototype, "hasDropdown", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return Boolean(this._dropdown);
            },
            enumerable: true,
            configurable: true
        });
        NxWordComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-word',
                        template: "<div\n  class=\"nx-word__input-wrapper\"\n  [nxPopoverTriggerFor]=\"popoverHover\"\n  nxPopoverTrigger='manual'\n  nxPopoverCloseable=\"false\"\n  nxPopoverDirection=\"top\"\n  [nxPopoverShow]=\"hasErrors && _errorChildren.length > 0\">\n\n  <!-- We only allow formfield controls here -->\n  <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n    <ng-content select=\"[nxInput]\"></ng-content>\n  </div>\n  <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popoverHover>\n  <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n",
                        host: {
                            '[class.size-short]': 'size == "short"',
                            '[class.size-regular]': 'size == "regular"',
                            '[class.size-long]': 'size == "long"',
                            '[class.has-error]': 'hasErrors',
                            '[class.is-focused]': 'isFocused',
                            '[class.is-filled]': 'isFilled',
                            '[class.has-dropdown]': 'hasDropdown',
                        },
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;width:100%}:host .nx-word__inner-wrapper{border-bottom:2px solid #d9d9d9}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width:991px){:host.size-long{min-width:280px}}@media (max-width:703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:0;box-shadow:none;border-bottom-width:2px}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:#006192;font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom:2px solid #d9d9d9}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-2px}:host ::ng-deep nx-dropdown.is-filled{border-color:#007ab3;color:#006192}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-filled) .nx-word__inner-wrapper,:host(.is-focused) .nx-word__inner-wrapper{border-color:#007ab3}:host(.has-error) .nx-word__inner-wrapper{border-color:#dc3149}:host.has-error ::ng-deep nx-dropdown{color:#dc3149;border-color:#dc3149}:host.has-error ::ng-deep .c-input.has-error{color:#dc3149}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:#fff;color:#fff}:host-context(.is-negative) ::ng-deep .c-input{color:#fff}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:#fff}.nx-word__inner-wrapper{height:52px}@media (max-width:991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}.nx-word__inner-wrapper{height:36px}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:36px}:host-context(.nx-natural-language-form--small) ::ng-deep nx-dropdown .nx-dropdown__container{margin-bottom:2px}"]
                    }] }
        ];
        /** @nocollapse */
        NxWordComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: core$1.ChangeDetectorRef },
                { type: core$1.Renderer2 },
                { type: overlay.Overlay }
            ];
        };
        NxWordComponent.propDecorators = {
            _control: [{ type: core$1.ContentChild, args: [formfield.NxFormfieldControl,] }],
            _errorChildren: [{ type: core$1.ContentChildren, args: [formfield.NxFormfieldErrorDirective,] }],
            _popover: [{ type: core$1.ViewChild, args: [popover.NxPopoverTriggerDirective,] }],
            _dropdown: [{ type: core$1.ContentChild, args: [dropdown.NxDropdownComponent,] }],
            currentTextWidth: [{ type: core$1.HostBinding, args: ['style.width.px',] }],
            size: [{ type: core$1.Input, args: ['nxSize',] }],
            label: [{ type: core$1.Input, args: ['nxLabel',] }]
        };
        return NxWordComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_SIZE$3 = 'large';
    var NxNaturalLanguageFormComponent = /** @class */ (function () {
        function NxNaturalLanguageFormComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._negative = false;
            /**
             * \@docs-private
             */
            this.resizeEvent$ = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.updatePopoversSubscription = rxjs.Subscription.EMPTY;
            /**
             * \@docs-private
             */
            this._size = DEFAULT_SIZE$3;
        }
        Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the negative set of stylings should be used. */
            set: /**
             * Whether the negative set of stylings should be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNaturalLanguageFormComponent.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            /**
             * Sets the size of the NLF. Default value: large
             */
            set: /**
             * Sets the size of the NLF. Default value: large
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._size = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.onResize = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.resizeEvent$.next();
            };
        /**
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Collect all words and listen for changes so we can update any open error popover
                // which would otherwise get wrongly positioned.
                /** @type {?} */
                var subjects = this._words.map(( /**
                 * @param {?} word
                 * @return {?}
                 */function (word) { return word.inputChanges; }));
                /** @type {?} */
                var source = rxjs.merge.apply(void 0, __spread(subjects));
                this.updatePopoversSubscription = source.subscribe(( /**
                 * @return {?}
                 */function () {
                    _this.updatePositionPopovers();
                }));
                this.resizeObservable = this.resizeEvent$.pipe(operators.throttleTime(500), operators.delay(100));
                this.resizeObservable.subscribe(( /**
                 * @return {?}
                 */function () { return _this.resizeWords(); }));
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.resizeWords = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._words.forEach(( /**
                 * @param {?} word
                 * @return {?}
                 */function (word) {
                    word.updateCurrentTextWidth();
                }));
            };
        /**
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.updatePopoversSubscription.unsubscribe();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNaturalLanguageFormComponent.prototype.updatePositionPopovers = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this._words) {
                    this._words.forEach(( /**
                     * @param {?} word
                     * @return {?}
                     */function (word) {
                        word.repositionError();
                    }));
                }
            };
        NxNaturalLanguageFormComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-natural-language-form',
                        template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative',
                            '[class.nx-natural-language-form--small]': 'size === "small"',
                            '[class.nx-natural-language-form--large]': 'size === "large"',
                        },
                        styles: [":host{display:block;padding-top:72px;padding-bottom:80px;color:#414141;font-weight:300;font-size:40px;line-height:52px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}:host.is-negative{color:#fff}@media (max-width:991px){:host{font-size:26px;line-height:36px}}@media (max-width:703px){:host{font-size:26px}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:26px;line-height:32px;letter-spacing:.3px}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}"]
                    }] }
        ];
        /** @nocollapse */
        NxNaturalLanguageFormComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxNaturalLanguageFormComponent.propDecorators = {
            _words: [{ type: core$1.ContentChildren, args: [NxWordComponent,] }],
            negative: [{ type: core$1.Input, args: ['nxNegative',] }],
            size: [{ type: core$1.Input }],
            onResize: [{ type: core$1.HostListener, args: ['window:orientationchange', ['$event'],] }, { type: core$1.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return NxNaturalLanguageFormComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNaturalLanguageFormModule = /** @class */ (function () {
        function NxNaturalLanguageFormModule() {
        }
        NxNaturalLanguageFormModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            input.NxInputModule,
                            popover.NxPopoverModule
                        ],
                        declarations: [
                            NxNaturalLanguageFormComponent,
                            NxWordComponent
                        ],
                        exports: [
                            NxNaturalLanguageFormComponent,
                            NxWordComponent
                        ]
                    },] }
        ];
        return NxNaturalLanguageFormModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ICONS = {
        info: 'info-circle',
        error: 'exclamation-circle',
        success: 'check-circle',
        warning: 'exclamation-triangle'
    };
    var NxMessageComponent = /** @class */ (function () {
        function NxMessageComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._context = 'regular';
            this._showIcon = false;
            this._closable = false;
            this._closeButtonLabel = 'Close dialog';
            /**
             * Event emitted when the close icon of the message has been clicked.
             */
            this.closeEvent = new core$1.EventEmitter();
        }
        Object.defineProperty(NxMessageComponent.prototype, "context", {
            get: /**
             * @return {?}
             */ function () {
                return this._context;
            },
            /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular' */
            set: /**
             * Sets the context of the message.
             * The message box will color accordingly. Default: 'regular'
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._context) {
                    this._context = value;
                    this._icon = this.getIconName();
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "showIcon", {
            get: /**
             * @return {?}
             */ function () {
                return this._showIcon;
            },
            /**
             * Whether an icon that belongs to the context of the message should be displayed.
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * @deletion-target 9.0.0
             * */
            set: /**
             * Whether an icon that belongs to the context of the message should be displayed.
             * @deprecated The `showIcon` attribute should be always true in future. Messages without an icon are deprecated.
             * \@deletion-target 9.0.0
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._showIcon = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closable", {
            get: /**
             * @return {?}
             */ function () {
                return this._closable;
            },
            /** Whether a message should have a close icon in order to be dismissed. */
            set: /**
             * Whether a message should have a close icon in order to be dismissed.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._closable) {
                    this._closable = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "icon", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._icon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMessageComponent.prototype, "closeButtonLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._closeButtonLabel;
            },
            /** Sets the label of the close button of the message. */
            set: /**
             * Sets the label of the close button of the message.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._closeButtonLabel) {
                    this._closeButtonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype._emitCloseEvent = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.closeEvent.emit();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMessageComponent.prototype.getIconName = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this._context === 'info') {
                    return ICONS.info;
                }
                else if (this._context === 'error') {
                    return ICONS.error;
                }
                else if (this._context === 'success') {
                    return ICONS.success;
                }
                else if (this._context === 'warning') {
                    return ICONS.warning;
                }
                return '';
            };
        NxMessageComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-message',
                        template: "<nx-icon *ngIf=\"showIcon && context !== 'regular'\"\n         class=\"nx-message__icon\"\n         [name]=\"icon\"\n         size=\"s\">\n</nx-icon>\n<button\n  *ngIf=\"closable\"\n  (click)=\"_emitCloseEvent()\"\n  [attr.aria-label]=\"closeButtonLabel\"\n  tabindex=\"0\"\n  class=\"nx-message__close-icon\">\n    <nx-icon\n      name=\"close\"\n      size=\"s\"\n      aria-hidden=\"true\">\n    </nx-icon>\n</button>\n\n\n<div class=\"nx-message__content-wrapper\">\n  <div class=\"nx-message__content\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxMessage',
                        host: {
                            '[class.context-info]': 'context === "info"',
                            '[class.context-error]': 'context === "error"',
                            '[class.context-success]': 'context === "success"',
                            '[class.context-warning]': 'context === "warning"',
                            '[class.nx-message--closable]': 'closable'
                        },
                        styles: [":host{width:100%;color:#414141;display:flex;align-items:flex-start;position:relative;background-color:#fff;border:1px solid;border-radius:4px;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:23px;margin:12px 0;font-size:16px;line-height:24px}.nx-message__content-wrapper{max-width:100%}:host,:host(.context-regular){border-color:#414141}:host(.context-info){border-color:#496ebd}:host(.context-info) .nx-message__icon{color:#496ebd}:host(.context-error){border-color:#dc3149}:host(.context-error) .nx-message__icon{color:#dc3149}:host(.context-success){border-color:#1e8927}:host(.context-success) .nx-message__icon{color:#1e8927}:host(.context-warning){border-color:#efbe25}:host(.context-warning) .nx-message__icon{color:#efbe25}.nx-message__icon{margin-right:16px}@media (max-width:703px){:host{padding:31px;display:block}:host(.context-error) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-info) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-success) .nx-message__icon~.nx-message__content-wrapper .nx-message__content,:host(.context-warning) .nx-message__icon~.nx-message__content-wrapper .nx-message__content{display:inline;margin-left:31px}.nx-message__icon{position:absolute}}:host(.nx-message--closable){padding-right:39px}@media (max-width:703px){:host(.nx-message--closable){padding-right:31px}}.nx-message__close-icon{position:absolute;top:16px;right:16px;cursor:pointer;background-color:transparent;border:none;outline:0;padding:0;display:flex;align-items:center}.nx-message__close-icon nx-icon{font-size:16px;color:nx-colors(grey-tones,grey-tone-1)}:host-context([data-whatinput=keyboard]) .nx-message__close-icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxMessageComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxMessageComponent.propDecorators = {
            context: [{ type: core$1.Input, args: ['nxContext',] }],
            showIcon: [{ type: core$1.Input }],
            closable: [{ type: core$1.Input }],
            closeButtonLabel: [{ type: core$1.Input }],
            closeEvent: [{ type: core$1.Output, args: ['close',] }]
        };
        return NxMessageComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxMessageModule = /** @class */ (function () {
        function NxMessageModule() {
        }
        NxMessageModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxMessageComponent
                        ],
                        exports: [
                            NxMessageComponent
                        ]
                    },] }
        ];
        return NxMessageModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPageSearchComponent = /** @class */ (function () {
        function NxPageSearchComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * An event emitted when the user clicks the search button.
             */
            this.buttonClick = new core$1.EventEmitter();
            this._buttonLabel = null;
            this._hideSearchButton = false;
            this._buttonLayout = '12,12,12,2';
            this._contentLayout = null;
        }
        Object.defineProperty(NxPageSearchComponent.prototype, "buttonLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._buttonLabel;
            },
            /** Sets the text label of the button. */
            set: /**
             * Sets the text label of the button.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._buttonLabel !== value) {
                    this._buttonLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "hideSearchButton", {
            get: /**
             * @return {?}
             */ function () {
                return this._hideSearchButton;
            },
            /** Whether the search button should be hidden. */
            set: /**
             * Whether the search button should be hidden.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._hideSearchButton = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "buttonLayout", {
            get: /**
             * @return {?}
             */ function () {
                return this._buttonLayout;
            },
            /** Layout of the search button inside of a NxGrid. Default: 12,12,12,2. */
            set: /**
             * Layout of the search button inside of a NxGrid. Default: 12,12,12,2.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._buttonLayout !== value) {
                    this._buttonLayout = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPageSearchComponent.prototype, "contentLayout", {
            get: /**
             * @return {?}
             */ function () {
                if (this._contentLayout) {
                    return this._contentLayout;
                }
                return !this.hideSearchButton ? '12,12,12,10' : '12';
            },
            /** Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden). */
            set: /**
             * Layout of the content area inside of a NxGrid. Default: 12,12,12,10 | 12 (if search button is hidden).
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._contentLayout !== value) {
                    this._contentLayout = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPageSearchComponent.prototype.onButtonClick = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this.buttonClick.emit();
            };
        NxPageSearchComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-page-search',
                        template: "<div class=\"nx-pagesearch\">\n  <div nxLayout=\"grid\">\n    <div nxRow>\n      <div [nxCol]=\"contentLayout\" class=\"nx-pagesearch--content\">\n        <ng-content></ng-content>\n      </div>\n      <div [nxCol]=\"buttonLayout\" *ngIf=\"!hideSearchButton\" class=\"nx-pagesearch__actions\">\n        <button nxButton=\"primary medium\" (click)=\"onButtonClick()\">{{buttonLabel}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [".nx-pagesearch{padding:32px 0;background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5)}.nx-pagesearch ::ng-deep .nx-formfield__wrapper{padding-bottom:0}.nx-pagesearch ::ng-deep .c-input{font-size:30px;font-weight:300;line-height:32px;height:auto}.nx-pagesearch ::ng-deep .nx-formfield__prefix{color:#007ab3}.nx-pagesearch ::ng-deep button{margin:0}.nx-pagesearch ::ng-deep .nx-icon--auto{font-size:24px}.nx-pagesearch .nx-pagesearch__actions{display:flex;align-items:center}"]
                    }] }
        ];
        /** @nocollapse */
        NxPageSearchComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxPageSearchComponent.propDecorators = {
            buttonClick: [{ type: core$1.Output, args: ['nxButtonClick',] }],
            buttonLabel: [{ type: core$1.Input, args: ['nxButtonLabel',] }],
            hideSearchButton: [{ type: core$1.Input, args: ['nxHideSearchButton',] }],
            buttonLayout: [{ type: core$1.Input, args: ['nxButtonLayout',] }],
            contentLayout: [{ type: core$1.Input, args: ['nxContentLayout',] }]
        };
        return NxPageSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPageSearchModule = /** @class */ (function () {
        function NxPageSearchModule() {
        }
        NxPageSearchModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            autocomplete.NxAutocompleteModule,
                            formfield.NxFormfieldModule,
                            button.NxButtonModule,
                            grid.NxGridModule
                        ],
                        declarations: [
                            NxPageSearchComponent
                        ],
                        exports: [
                            NxPageSearchComponent
                        ]
                    },] }
        ];
        return NxPageSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRatingComponent = /** @class */ (function () {
        function NxRatingComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._value = 0;
            this._disabled = false;
            this._negative = false;
            this._startLabel = null;
            this._endLabel = null;
            this._ariaLabel = ['1/5', '2/5', '3/5', '4/5', '5/5'];
            /**
             * An event is dispatched each time when the rating changes.
             */
            this.valueChange = new core$1.EventEmitter();
            this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            this.onChangeCallback = ( /**
             * @param {?} option
             * @return {?}
             */function (option) { });
        }
        Object.defineProperty(NxRatingComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** Sets the selected rating 1 - 5. */
            set: /**
             * Sets the selected rating 1 - 5.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this._value = coercion.coerceNumberProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether the rating component should be disabled. */
            set: /**
             * Whether the rating component should be disabled.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (this._disabled === newValue) {
                    return;
                }
                this._disabled = coercion.coerceBooleanProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the negative colors be used. */
            set: /**
             * Whether the negative colors be used.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (this._negative === newValue) {
                    return;
                }
                this._negative = coercion.coerceBooleanProperty(newValue);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "startLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._startLabel;
            },
            /** Sets the label painted at the start of the rating component. */
            set: /**
             * Sets the label painted at the start of the rating component.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this._startLabel = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "endLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._endLabel;
            },
            /** Sets the label painted at the end of the rating component. */
            set: /**
             * Sets the label painted at the end of the rating component.
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this._endLabel = newValue;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxRatingComponent.prototype, "ariaLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._ariaLabel;
            },
            set: /**
             * @param {?} newAriaLabels
             * @return {?}
             */ function (newAriaLabels) {
                this._ariaLabel = newAriaLabels;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /** Whether the given rating is selected. */
        /**
         * Whether the given rating is selected.
         * @param {?} index
         * @return {?}
         */
        NxRatingComponent.prototype.isSelected = /**
         * Whether the given rating is selected.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index <= this.value;
            };
        /** Allows to set the rating. */
        /**
         * Allows to set the rating.
         * @param {?} value
         * @return {?}
         */
        NxRatingComponent.prototype.setSelection = /**
         * Allows to set the rating.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!this.disabled) {
                    this.value = value;
                    this.valueChange.emit(value);
                    this.onTouchedCallback();
                    this.onChangeCallback(this.value);
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.handleKeyUp = /**
         * \@docs-private
         * @param {?} event
         * @param {?} rating
         * @return {?}
         */
            function (event, rating) {
                /** @type {?} */
                var keyCode = event.keyCode;
                event.preventDefault();
                event.stopPropagation();
                if (keyCode === keycodes.ENTER) {
                    this.setSelection(rating);
                }
                if (keyCode === keycodes.RIGHT_ARROW) {
                    this.value = Math.min(this.value + 1, 5);
                    /** @type {?} */
                    var elementRef = this.icons.toArray()[this.value - 1];
                    elementRef.nativeElement.focus();
                }
                if (keyCode === keycodes.LEFT_ARROW) {
                    this.value = Math.max(this.value - 1, 1);
                    /** @type {?} */
                    var elementRef = this.icons.toArray()[this.value - 1];
                    elementRef.nativeElement.focus();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NxRatingComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRatingComponent.prototype.registerOnChange = /**
         * @param {?} callback
         * @return {?}
         */
            function (callback) {
                this.onChangeCallback = callback;
            };
        /**
         * @param {?} callback
         * @return {?}
         */
        NxRatingComponent.prototype.registerOnTouched = /**
         * @param {?} callback
         * @return {?}
         */
            function (callback) {
                this.onTouchedCallback = callback;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxRatingComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.getAriaLabel = /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
            function (rating) {
                return this.ariaLabel[rating - 1];
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
        NxRatingComponent.prototype.getIconName = /**
         * \@docs-private
         * @param {?} rating
         * @return {?}
         */
            function (rating) {
                return 'star' + ((!this.isSelected(rating)) ? '-o' : '');
            };
        NxRatingComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-rating',
                        template: "  <div class=\"nx-rating__container\" role=\"radiogroup\">\n    <nx-icon *ngFor=\"let rating of [1,2,3,4,5]\"\n      (click)=\"setSelection(rating)\"\n      (keyup)=\"handleKeyUp($event, rating)\"\n      role=\"radio\"\n      [attr.aria-label]=\"getAriaLabel(rating)\"\n      [attr.aria-checked]=\"isSelected(rating)\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      class=\"nx-rating__icon\"\n      [name]=\"getIconName(rating)\"\n      size=\"m\">\n    </nx-icon>\n  </div>\n  <div class=\"nx-rating__label\" *ngIf=\"startLabel || endLabel\">\n    <span class=\"nx-rating__label--start\">{{startLabel}}</span>\n    <span class=\"nx-rating__label--end\">{{endLabel}}</span>\n  </div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core$1.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NxRatingComponent; })),
                                multi: true
                            }
                        ],
                        host: {
                            '[class.nx-rating--negative]': 'negative',
                            '[class.nx-rating--disabled]': 'disabled',
                        },
                        styles: [":host{display:inline-block}:host(.nx-rating--negative){color:#fff}:host(.nx-rating--disabled){cursor:not-allowed;color:#c2c2c2;outline:0}:host(.nx-rating--disabled) .nx-rating__label{color:#c2c2c2}:host(.nx-rating--disabled) .nx-rating__icon{cursor:not-allowed}.nx-rating__container{display:flex}.nx-rating__label{display:flex;font-size:16px}.nx-rating__label--end{margin-left:auto}.nx-rating__icon{font-size:40px;width:auto;height:40px;background:0 0;border:none;margin-right:16px;cursor:pointer;outline:0}.nx-rating__icon:last-child{margin-right:0}:host-context([data-whatinput=keyboard]) .nx-rating__icon:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxRatingComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxRatingComponent.propDecorators = {
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            disabled: [{ type: core$1.Input, args: ['nxDisabled',] }],
            negative: [{ type: core$1.Input, args: ['nxNegative',] }],
            startLabel: [{ type: core$1.Input, args: ['nxStartLabel',] }],
            endLabel: [{ type: core$1.Input, args: ['nxEndLabel',] }],
            ariaLabel: [{ type: core$1.Input, args: ['nxAriaLabel',] }],
            valueChange: [{ type: core$1.Output, args: ['nxValueChange',] }],
            icons: [{ type: core$1.ViewChildren, args: [icon.NxIconComponent, { read: core$1.ElementRef },] }]
        };
        return NxRatingComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxRatingModule = /** @class */ (function () {
        function NxRatingModule() {
        }
        NxRatingModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxRatingComponent
                        ],
                        exports: [
                            NxRatingComponent
                        ]
                    },] }
        ];
        return NxRatingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNumberStepperIntl = /** @class */ (function () {
        function NxNumberStepperIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            /**
             * The aria label for the decrement '-' button
             */
            this.decrementAriaLabel = 'Decrement';
            /**
             * The aria label for the increment '+' button
             */
            this.incrementAriaLabel = 'Increment';
        }
        NxNumberStepperIntl.decorators = [
            { type: core$1.Injectable }
        ];
        return NxNumberStepperIntl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxAutoResizeDirective = /** @class */ (function () {
        function NxAutoResizeDirective(_element, _renderer, _cdr) {
            this._element = _element;
            this._renderer = _renderer;
            this._cdr = _cdr;
            this._resize = true;
            this.updateInputWidth = this.updateInputWidth.bind(this);
        }
        Object.defineProperty(NxAutoResizeDirective.prototype, "resize", {
            get: /**
             * @return {?}
             */ function () {
                return this._resize;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._resize = coercion.coerceBooleanProperty(value);
                if (this._resize) {
                    this._addEventListener();
                    this.updateInputWidth();
                }
                else {
                    this._removeEventListener();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.resize) {
                    this._addEventListener();
                }
            };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._removeEventListener();
            };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype.updateInputWidth = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var measureCanvas = this._renderer.createElement('canvas');
                /** @type {?} */
                var ctx = measureCanvas.getContext('2d');
                /** @type {?} */
                var styles = window.getComputedStyle(this._element.nativeElement);
                ctx.font = utils.getFontShorthand(styles);
                /** @type {?} */
                var metrics = ctx.measureText(this._element.nativeElement.value);
                /** @type {?} */
                var padding = this.sumStyles(styles.paddingLeft, styles.paddingRight);
                /** @type {?} */
                var border = this.sumStyles(styles.borderLeftWidth, styles.borderRightWidth);
                // the pixels are needed, because despite the correct calculation the last pixels of a number are always cut
                /** @type {?} */
                var newWidth = metrics.width + padding + border + 16;
                // Limit to own given minimal width
                /** @type {?} */
                var parsed = parseFloat(styles.minWidth);
                this.width = Math.max(Number.isNaN(parsed) ? 0 : parsed, newWidth);
                // needed when the outer component is onPush
                this._cdr.markForCheck();
            };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype._addEventListener = /**
         * @return {?}
         */
            function () {
                this._element.nativeElement.addEventListener('input', this.updateInputWidth, true);
                this._element.nativeElement.addEventListener('change', this.updateInputWidth, true);
            };
        /**
         * @return {?}
         */
        NxAutoResizeDirective.prototype._removeEventListener = /**
         * @return {?}
         */
            function () {
                this._element.nativeElement.removeEventListener('input', this.updateInputWidth, true);
                this._element.nativeElement.removeEventListener('change', this.updateInputWidth, true);
            };
        /**
         * @param {?} left
         * @param {?} right
         * @return {?}
         */
        NxAutoResizeDirective.prototype.sumStyles = /**
         * @param {?} left
         * @param {?} right
         * @return {?}
         */
            function (left, right) {
                left = parseInt(left, 10);
                right = parseInt(right, 10);
                left = Number.isNaN(left) ? 0 : left;
                right = Number.isNaN(right) ? 0 : right;
                return left + right;
            };
        NxAutoResizeDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: 'input[nxAutoResize]'
                    },] }
        ];
        /** @nocollapse */
        NxAutoResizeDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: core$1.Renderer2 },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxAutoResizeDirective.propDecorators = {
            width: [{ type: core$1.HostBinding, args: ['style.width.px',] }],
            resize: [{ type: core$1.Input, args: ['nxAutoResize',] }]
        };
        return NxAutoResizeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SIZE_MAPPING = {
        big: 'nx-stepper--big',
        normal: ''
    };
    /** @type {?} */
    var STYLE_MAPPING = {
        regular: '',
        bold: 'nx-stepper__input--bold',
        light: 'nx-stepper__input--light'
    };
    /** @type {?} */
    var DEFAULT_CLASSES$1 = ['nx-stepper'];
    /** @type {?} */
    var INPUT_CLASSES = ['nx-stepper__input'];
    /** @type {?} */
    var ALLOWED_CHARACTERS = new RegExp(/^-?[0-9]\d*(\.\d+)?$/g);
    /** @type {?} */
    var CUSTOM_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core$1.forwardRef(( /**
         * @return {?}
         */function () { return NxNumberStepperComponent; })),
        multi: true
    };
    /** @type {?} */
    var CUSTOM_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core$1.forwardRef(( /**
         * @return {?}
         */function () { return NxNumberStepperComponent; })),
        multi: true
    };
    /** @type {?} */
    var nextUniqueId = 0;
    var NxNumberStepperComponent = /** @class */ (function (_super) {
        __extends(NxNumberStepperComponent, _super);
        function NxNumberStepperComponent(_changeDetectorRef, _renderer, _elementRef, _intl) {
            var _this = _super.call(this, SIZE_MAPPING, DEFAULT_CLASSES$1, _elementRef, _renderer) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._intl = _intl;
            _this._step = 1;
            _this._min = 0;
            _this._max = 100;
            _this._value = 0;
            _this._label = null;
            _this._resize = false;
            _this._negative = false;
            _this._leadingZero = true;
            /**
             * \@docs-private
             */
            _this.inputClassNames = utils.mapClassNames('regular', INPUT_CLASSES, STYLE_MAPPING);
            /**
             * \@docs-private
             */
            _this.inputId = "nx-number-stepper-" + nextUniqueId++;
            /**
             * \@docs-private
             */
            _this.ariaDescribedBy = null;
            /**
             * An event emitted on value change.
             */
            _this.valueChange = new core$1.EventEmitter();
            _this.onChangeCallback = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            _this.onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            _this._intlSubscription = _this._intl.changes.subscribe(( /**
             * @return {?}
             */function () { return _this._changeDetectorRef.markForCheck(); }));
            return _this;
        }
        Object.defineProperty(NxNumberStepperComponent.prototype, "resize", {
            get: /**
             * @return {?}
             */ function () {
                return this._resize;
            },
            /** Whether the input should be resized. Default: false */
            set: /**
             * Whether the input should be resized. Default: false
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._resize = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this._label;
            },
            /** Defines the the label shown above the stepper input. */
            set: /**
             * Defines the the label shown above the stepper input.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._label !== value) {
                    this._label = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "style", {
            get: /**
             * @return {?}
             */ function () {
                return this._style;
            },
            /**
             * Defines the font weight of the input.
             *
             * Possible values: regular, bold, light. Default value: regular
             *
             * @deprecated The style input is not available anymore, only default font-weight should be used.
             * @deletion-target 8.0.0
             */
            set: /**
             * Defines the font weight of the input.
             *
             * Possible values: regular, bold, light. Default value: regular
             *
             * @deprecated The style input is not available anymore, only default font-weight should be used.
             * \@deletion-target 8.0.0
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._style === value) {
                    return;
                }
                this._style = value;
                this.inputClassNames = utils.mapClassNames(value, INPUT_CLASSES, STYLE_MAPPING);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            /** Sets the step size. Default: 1 */
            set: /**
             * Sets the step size. Default: 1
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only internal changes no need to call markForCheck
                this._step = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this._min;
            },
            /** Sets the minimum accepted number. Default: 0 */
            set: /**
             * Sets the minimum accepted number. Default: 0
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this._max;
            },
            /** Sets the maximum accepted number. Default: 100 */
            set: /**
             * Sets the maximum accepted number. Default: 100
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = Number(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            /** Sets the value of the number-stepper. */
            set: /**
             * Sets the value of the number-stepper.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                if (this._value !== null) {
                    this.setInputValue(this._value);
                }
                else {
                    this.setInputValue(0);
                }
                this.triggerResize();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the negative set of styling should be used. */
            set: /**
             * Whether the negative set of styling should be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._negative !== value) {
                    this._negative = coercion.coerceBooleanProperty(value);
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxNumberStepperComponent.prototype, "leadingZero", {
            get: /**
             * @return {?}
             */ function () {
                return this._leadingZero;
            },
            /** Whether the number stepper value should have a leading zero.
             *
             * Default value is true.
             */
            set: /**
             * Whether the number stepper value should have a leading zero.
             *
             * Default value is true.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._leadingZero !== value) {
                    this._leadingZero = coercion.coerceBooleanProperty(value);
                    this.setInputValue(this.value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.setInputValue(this._value);
            };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // defer to prevent checked after change errors
                if (this.resize) {
                    setTimeout(( /**
                     * @return {?}
                     */function () { return _this.triggerResize(); }));
                }
                if (this.ngContentWrapper) {
                    this.ariaDescribedBy = this.ngContentWrapper.nativeElement.children.length > 0 ? "label-for-" + this.inputId : null;
                }
            };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._intlSubscription.unsubscribe();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.setInputValue = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this.leadingZero) {
                    this.numberInput.nativeElement.value = utils.pad(value.toString(), 2);
                }
                else {
                    this.numberInput.nativeElement.value = value.toString();
                }
            };
        /* ControlValueAccessor Implementations */
        /* ControlValueAccessor Implementations */
        /**
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.writeValue = /* ControlValueAccessor Implementations */
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxNumberStepperComponent.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxNumberStepperComponent.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxNumberStepperComponent.prototype.onInputChange = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.validateUserInput(event.target.value)) {
                    this._value = null;
                }
                else {
                    this._value = Number(event.target.value);
                }
                this.valueChange.emit(this._value);
                this.onChangeCallback(this._value);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} input
         * @return {?}
         */
        NxNumberStepperComponent.prototype.validateUserInput = /**
         * \@docs-private
         * @param {?} input
         * @return {?}
         */
            function (input$$1) {
                return !!input$$1.match(ALLOWED_CHARACTERS);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.increment = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var newValue;
                if (this.isBetweenLimits(this._value)) {
                    newValue = this.getNextGreaterValue(this._value);
                }
                else {
                    newValue = this.enforceLimits(this._value);
                }
                this.value = newValue;
                this.valueChange.emit(this._value);
                this.onChangeCallback(this._value);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.triggerResize = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                if (this.resize) {
                    this.autoResize.updateInputWidth();
                    this._changeDetectorRef.markForCheck();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.decrement = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var newValue;
                if (this.isBetweenLimits(this._value)) {
                    newValue = this.getNextLowerValue(this._value);
                }
                else {
                    newValue = this.enforceLimits(this._value);
                }
                this.value = newValue;
                this.valueChange.emit(this._value);
                this.onChangeCallback(this._value);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.enforceLimits = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value > this._max) {
                    return this._max;
                }
                else if (value < this._min) {
                    return this._min;
                }
                return value;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        NxNumberStepperComponent.prototype.getNextLowerValue = /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
            function (start) {
                // if there is an invalid input start is null
                if (!start) {
                    start = 0;
                }
                /** @type {?} */
                var next;
                if (this.isValidStep(start)) {
                    next = (new decimal_js.Decimal(start).minus(new decimal_js.Decimal(this._step))).toNumber();
                }
                else {
                    next = new decimal_js.Decimal(start).toNearest(this._step, decimal_js.Decimal.ROUND_DOWN).toNumber();
                }
                return this.enforceLimits(next);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
        NxNumberStepperComponent.prototype.getNextGreaterValue = /**
         * \@docs-private
         * @param {?} start
         * @return {?}
         */
            function (start) {
                /** @type {?} */
                var next;
                if (!start) {
                    start = 0;
                }
                if (this.isValidStep(start)) {
                    next = (new decimal_js.Decimal(start).plus(new decimal_js.Decimal(this._step))).toNumber();
                }
                else {
                    next = new decimal_js.Decimal(start).toNearest(this._step, decimal_js.Decimal.ROUND_UP).toNumber();
                }
                return this.enforceLimits(next);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isBetweenLimits = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return value <= this._max && value >= this._min;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isMinimum = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this._value === this._min;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isMaximum = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this._value === this._max;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.isValidStep = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === null) {
                    value = new decimal_js.Decimal(0);
                }
                /** @type {?} */
                var min = new decimal_js.Decimal(this._min);
                /** @type {?} */
                var valueDec = new decimal_js.Decimal(value);
                /** @type {?} */
                var checkValue = (min.minus(valueDec)).mod(new decimal_js.Decimal(this._step)).toNumber();
                if (this.isBetweenLimits(value) && ((this.isMinimum() || this.isMaximum()) ||
                    checkValue === 0)) {
                    return true;
                }
                return false;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
        NxNumberStepperComponent.prototype.userInputToNumber = /**
         * \@docs-private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var current = value === '' ? 0 : value;
                return parseInt(current, 10);
            };
        /**
         * @return {?}
         */
        NxNumberStepperComponent.prototype._validateFn = /**
         * @return {?}
         */
            function () {
                // the manual user input must match min + n * step, e.g. minimum 1 step 2: 1, 3, 5, 7 etc.
                if (!this.isValidStep(this._value)) {
                    return { nxNumberStepperStepError: 'Value is not a valid step' };
                }
                else if (this._value === null) {
                    return { nxNumberStepperFormatError: 'Not a valid number' };
                }
                return null;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} c
         * @return {?}
         */
        NxNumberStepperComponent.prototype.validate = /**
         * \@docs-private
         * @param {?} c
         * @return {?}
         */
            function (c) {
                return this._validateFn();
            };
        Object.defineProperty(NxNumberStepperComponent.prototype, "_buttonType", {
            get: /**
             * @return {?}
             */ function () {
                return 'secondary' + (this.negative ? ' negative' : '');
            },
            enumerable: true,
            configurable: true
        });
        NxNumberStepperComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-number-stepper',
                        template: "<div *ngIf=\"label\" class=\"nx-stepper__label\">\n  <label [for]=\"inputId\">\n    {{label}}\n  </label>\n</div>\n<div #customLabel *ngIf=\"!label\" [id]=\"ariaDescribedBy\">\n  <ng-content></ng-content>\n</div>\n<div class=\"nx-stepper__input-container\">\n  <button\n    [attr.aria-label]=\"_intl.decrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__down nx-stepper__control\"\n    (click)=\"decrement()\"\n    [disabled]=\"value <= min\">\n    <nx-icon name=\"minus\" size=\"s\"></nx-icon>\n  </button>\n  <div class=\"nx-stepper__input-wrapper\">\n    <div class=\"nx-stepper__inner-wrapper\">\n        <ng-content select=\"nx-number-stepper-prefix\"></ng-content>\n\n        <input #numberInput [nxAutoResize]=\"resize\"\n        [attr.aria-describedby]=\"ariaDescribedBy\"\n        [id]=\"inputId\" [ngClass]=\"inputClassNames\"\n        (input)=\"onInputChange($event)\"\n        (keydown.arrowup)=\"increment()\"\n        (keydown.arrowdown)=\"decrement()\"/>\n\n        <ng-content select=\"nx-number-stepper-suffix\"></ng-content>\n    </div>\n    <div class=\"nx-stepper__input-underline\"></div>\n  </div>\n\n  <button\n    [attr.aria-label]=\"_intl.incrementAriaLabel\"\n    [nxButton]=\"_buttonType\"\n    class=\"nx-stepper__up nx-stepper__control\"\n    (click)=\"increment()\"\n    [disabled]=\"value >= max\">\n    <nx-icon name=\"plus\" size=\"s\"></nx-icon>\n  </button>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        inputs: ['classNames: nxSize'],
                        host: {
                            '[class.is-negative]': 'negative'
                        },
                        providers: [CUSTOM_VALUE_ACCESSOR, CUSTOM_VALIDATOR],
                        styles: [":host{display:block}:host input{padding:0}.nx-stepper__input-container{align-items:flex-end;display:flex;margin-top:12px}.nx-stepper__label{display:flex;font-size:20px;line-height:28px}.nx-stepper__control{width:32px;height:32px;min-height:32px;font-size:24px;margin:0;padding:0}.nx-stepper__control:disabled{background-color:rgba(255,255,255,.4);border-color:#006192;color:#006192;opacity:.4}.nx-stepper__input{width:56px;min-width:56px}.nx-stepper__input,::ng-deep .nx-stepper__prefix,::ng-deep .nx-stepper__suffix{background:0 0;outline:0;border:0;text-align:center;color:#414141;font-size:20px;line-height:28px;height:28px}::ng-deep .nx-stepper__suffix{margin-left:4px}::ng-deep .nx-stepper__prefix{margin-right:4px}.nx-stepper__input-wrapper{display:flex;align-items:center;flex-direction:column;margin:0 16px}.nx-stepper__inner-wrapper{height:28px;display:flex;align-items:baseline}.nx-stepper__input-underline{width:100%;margin-top:2px;height:2px;background:#414141}:host.nx-stepper--big .nx-stepper__control{width:72px;min-height:48px;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input{width:72px;min-width:72px}:host.nx-stepper--big .nx-stepper__input,:host.nx-stepper--big ::ng-deep .nx-stepper__prefix,:host.nx-stepper--big ::ng-deep .nx-stepper__suffix{color:#414141;font-size:40px;line-height:48px;height:48px;letter-spacing:.3px;padding:0;margin-bottom:0}:host.nx-stepper--big .nx-stepper__input-wrapper{margin:0 24px}:host.nx-stepper--big .nx-stepper__input-underline{margin-top:-2px}:host.nx-stepper--big .nx-stepper__inner-wrapper{height:48px}:host.is-negative .nx-stepper__label{color:#fff}:host.is-negative .nx-stepper__input{color:#fff}:host.is-negative .nx-stepper__input-underline{background:#fff}"]
                    }] }
        ];
        /** @nocollapse */
        NxNumberStepperComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: core$1.Renderer2 },
                { type: core$1.ElementRef },
                { type: NxNumberStepperIntl }
            ];
        };
        NxNumberStepperComponent.propDecorators = {
            numberInput: [{ type: core$1.ViewChild, args: ['numberInput',] }],
            ngContentWrapper: [{ type: core$1.ViewChild, args: ['customLabel',] }],
            autoResize: [{ type: core$1.ViewChild, args: [NxAutoResizeDirective,] }],
            valueChange: [{ type: core$1.Output, args: ['nxValueChange',] }],
            resize: [{ type: core$1.Input, args: ['nxResize',] }],
            label: [{ type: core$1.Input, args: ['nxLabel',] }],
            style: [{ type: core$1.Input, args: ['nxStyle',] }],
            step: [{ type: core$1.Input, args: ['nxStep',] }],
            min: [{ type: core$1.Input, args: ['nxMin',] }],
            max: [{ type: core$1.Input, args: ['nxMax',] }],
            value: [{ type: core$1.Input, args: ['nxValue',] }],
            negative: [{ type: core$1.Input }],
            leadingZero: [{ type: core$1.Input }]
        };
        return NxNumberStepperComponent;
    }(core.MappedStyles));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive used to pass a suffix to the number stepper.
     */
    var NxNumberStepperPrefixDirective = /** @class */ (function () {
        function NxNumberStepperPrefixDirective() {
        }
        NxNumberStepperPrefixDirective.decorators = [
            { type: core$1.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-number-stepper-prefix',
                        host: {
                            'class': 'nx-stepper__prefix'
                        }
                    },] }
        ];
        return NxNumberStepperPrefixDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive used to pass a suffix to the number stepper.
     */
    var NxNumberStepperSuffixDirective = /** @class */ (function () {
        function NxNumberStepperSuffixDirective() {
        }
        NxNumberStepperSuffixDirective.decorators = [
            { type: core$1.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-number-stepper-suffix',
                        host: {
                            'class': 'nx-stepper__suffix'
                        }
                    },] }
        ];
        return NxNumberStepperSuffixDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxNumberStepperModule = /** @class */ (function () {
        function NxNumberStepperModule() {
        }
        NxNumberStepperModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            input.NxInputModule,
                            forms.FormsModule,
                            icon.NxIconModule,
                            button.NxButtonModule,
                            common.CommonModule
                        ],
                        exports: [
                            NxNumberStepperComponent,
                            NxAutoResizeDirective,
                            NxNumberStepperPrefixDirective,
                            NxNumberStepperSuffixDirective
                        ],
                        declarations: [
                            NxNumberStepperComponent,
                            NxAutoResizeDirective,
                            NxNumberStepperPrefixDirective,
                            NxNumberStepperSuffixDirective
                        ],
                        providers: [NxNumberStepperIntl],
                    },] }
        ];
        return NxNumberStepperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DefaultPaginationTexts = {
        previous: 'Previous',
        next: 'Next',
        first: 'First',
        last: 'Last',
        ofLabel: 'of',
        ariaLabel: 'Please select your page'
    };
    /**
     * InjectionToken for pagination that can be used to override default locale code.
     * @type {?}
     */
    var NX_PAGINATION_TEXTS = new core$1.InjectionToken('nx-pagination-texts');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxPaginationUtils = /** @class */ (function () {
        function NxPaginationUtils() {
            this._pagesToShow = 3;
            this._elipsisText = '...';
            this._classExpanded = 'expanded-view';
        }
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getPages = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
            function (currentPage, totalPages) {
                /** @type {?} */
                var pages = [];
                /** @type {?} */
                var start = [];
                /** @type {?} */
                var middle = [];
                /** @type {?} */
                var end = [];
                // First array -> start
                start = this.getStartArray(currentPage, totalPages);
                // Second array -> middle
                middle = this.getMiddleArray(currentPage, totalPages);
                // Third array -> end
                end = this.getEndArray(currentPage, totalPages);
                pages = __spread(start, middle, end);
                return pages;
            };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getMiddleArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
            function (currentPage, totalPages) {
                /** @type {?} */
                var pageNumber = currentPage < 6 ? 4 : currentPage - 1;
                /** @type {?} */
                var middle = [];
                while (middle.length < 3 &&
                    pageNumber >= 2 &&
                    pageNumber <= totalPages - 3 &&
                    (pageNumber <= currentPage + 1 && pageNumber >= currentPage - 1)) {
                    middle.push(this.createPaginationItem(pageNumber, pageNumber));
                    pageNumber++;
                }
                return middle;
            };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getEndArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
            function (currentPage, totalPages) {
                /** @type {?} */
                var end = [];
                /** @type {?} */
                var currentItemToShow = totalPages <= 3 ? totalPages + 1 :
                    totalPages <= 6 ? totalPages - (totalPages - 4) : totalPages - 2;
                /** @type {?} */
                var showEllipsis = currentPage < totalPages - 4;
                while (currentItemToShow <= totalPages) {
                    /** @type {?} */
                    var endItem = end.length === 0 && showEllipsis ?
                        this.createPaginationItem(this._elipsisText, currentItemToShow, true) :
                        this.createPaginationItem(currentItemToShow, currentItemToShow, true);
                    end.push(endItem);
                    currentItemToShow++;
                }
                return end;
            };
        /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
        NxPaginationUtils.prototype.getStartArray = /**
         * @param {?} currentPage
         * @param {?} totalPages
         * @return {?}
         */
            function (currentPage, totalPages) {
                /** @type {?} */
                var counterPages = 0;
                /** @type {?} */
                var start = [];
                /** @type {?} */
                var maxSizeArray = 3;
                while (counterPages < maxSizeArray && counterPages < totalPages) {
                    /** @type {?} */
                    var startItem = counterPages === 2 && currentPage > 5 ?
                        this.createPaginationItem(this._elipsisText, counterPages, true) :
                        this.createPaginationItem(counterPages + 1, counterPages + 1, true);
                    start.push(startItem);
                    counterPages++;
                }
                return start;
            };
        /**
         * @private
         * @param {?} label
         * @param {?} value
         * @param {?=} classExpanded
         * @return {?}
         */
        NxPaginationUtils.prototype.createPaginationItem = /**
         * @private
         * @param {?} label
         * @param {?} value
         * @param {?=} classExpanded
         * @return {?}
         */
            function (label, value, classExpanded) {
                return { label: label, value: value, class: classExpanded ? this._classExpanded : '' };
            };
        NxPaginationUtils.decorators = [
            { type: core$1.Injectable }
        ];
        return NxPaginationUtils;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPaginationComponent = /** @class */ (function () {
        function NxPaginationComponent(paginationTexts, paginationUtilsService, _changeDetectorRef) {
            this.paginationUtilsService = paginationUtilsService;
            this._changeDetectorRef = _changeDetectorRef;
            this._type = 'simple';
            /**
             * \@docs-private
             */
            this.totalNumberPages = 0;
            /**
             * An event emitted when the previous page button is clicked.
             */
            this.nxGoPrev = new core$1.EventEmitter();
            /**
             * An event emitted when the next page button is clicked
             */
            this.nxGoNext = new core$1.EventEmitter();
            /**
             * An event emitted when a page number is clicked.
             * Provides the number of the page as parameter.
             */
            this.nxGoPage = new core$1.EventEmitter();
            this.paginationTexts = paginationTexts || DefaultPaginationTexts;
        }
        Object.defineProperty(NxPaginationComponent.prototype, "page", {
            get: /**
             * @return {?}
             */ function () { return this._page; },
            /** Sets the current page. */
            set: /**
             * Sets the current page.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._page = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "count", {
            get: /**
             * @return {?}
             */ function () { return this._count; },
            /** Number of total items over all pages. */
            set: /**
             * Number of total items over all pages.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._count = value;
                this.totalNumberPages = this.calculateTotalPages();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "perPage", {
            get: /**
             * @return {?}
             */ function () { return this._perPage; },
            /** Sets the number of items you want to show per page. */
            set: /**
             * Sets the number of items you want to show per page.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._perPage = value;
                this.totalNumberPages = this.calculateTotalPages();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxPaginationComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () { return this._type; },
            /**
             * Determines the type of pagination.
             *
             * Values: simple |advanced, default: simple.
             */
            set: /**
             * Determines the type of pagination.
             *
             * Values: simple |advanced, default: simple.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._type = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.totalNumberPages = this.calculateTotalPages();
            };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                if (this.type === 'advanced' && (!this.paginationTexts.last || !this.paginationTexts.first)) {
                    console.warn('Please define aria labels for the last and first arrows.');
                }
            };
        /** Returns the number of the first page. */
        /**
         * Returns the number of the first page.
         * @return {?}
         */
        NxPaginationComponent.prototype.getMin = /**
         * Returns the number of the first page.
         * @return {?}
         */
            function () {
                return ((this._perPage * this._page) - this._perPage) + 1;
            };
        /** Returns the number of the last page. */
        /**
         * Returns the number of the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.getMax = /**
         * Returns the number of the last page.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var max = this._perPage * this._page;
                if (max > this._count) {
                    max = this._count;
                }
                return max;
            };
        /** Returns the total number of pages */
        /**
         * Returns the total number of pages
         * @return {?}
         */
        NxPaginationComponent.prototype.calculateTotalPages = /**
         * Returns the total number of pages
         * @return {?}
         */
            function () {
                return Math.ceil(this._count / this._perPage) || 0;
            };
        /** Directs to the page with number n. */
        /**
         * Directs to the page with number n.
         * @param {?} n
         * @return {?}
         */
        NxPaginationComponent.prototype.onPage = /**
         * Directs to the page with number n.
         * @param {?} n
         * @return {?}
         */
            function (n) {
                this.nxGoPage.emit(n);
            };
        /** Directs to the previous page. */
        /**
         * Directs to the previous page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onPrev = /**
         * Directs to the previous page.
         * @return {?}
         */
            function () {
                if (!this._isPaginationPreviousDisabled()) {
                    this.nxGoPrev.emit();
                }
            };
        /** Directs to the next page. */
        /**
         * Directs to the next page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onNext = /**
         * Directs to the next page.
         * @return {?}
         */
            function () {
                if (!this._isPaginationNextDisabled()) {
                    this.nxGoNext.emit();
                }
            };
        /** Directs to the first page. */
        /**
         * Directs to the first page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onFirst = /**
         * Directs to the first page.
         * @return {?}
         */
            function () {
                if (!this._isPaginationPreviousDisabled()) {
                    this.onPage(1);
                }
            };
        /** Directs to the last page. */
        /**
         * Directs to the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.onLast = /**
         * Directs to the last page.
         * @return {?}
         */
            function () {
                if (!this._isPaginationNextDisabled()) {
                    this.onPage(this.totalNumberPages);
                }
            };
        /** Returns if the current page is the last page. */
        /**
         * Returns if the current page is the last page.
         * @return {?}
         */
        NxPaginationComponent.prototype.lastPage = /**
         * Returns if the current page is the last page.
         * @return {?}
         */
            function () {
                return this._perPage * this._page >= this._count;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPaginationComponent.prototype.getPages = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.paginationUtilsService.getPages(this._page, this.totalNumberPages);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        NxPaginationComponent.prototype.getPaginationItemClasses = /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var classes = {
                    'is-ellipsis': page.label === '...',
                    'nx-pagination__item--expanded-view': page.class === 'expanded-view'
                };
                return classes;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
        NxPaginationComponent.prototype.getPaginationNumberClasses = /**
         * \@docs-private
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var classes = {
                    'is-active': page.value === this.page,
                    'nx-pagination__ellipsis': page.label === '...',
                    'nx-pagination__link': page.label !== '...'
                };
                return classes;
            };
        /** Returns true, if `nxCount` is greater than 0, else false. */
        /**
         * Returns true, if `nxCount` is greater than 0, else false.
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationVisible = /**
         * Returns true, if `nxCount` is greater than 0, else false.
         * @return {?}
         */
            function () {
                return this.count > 0;
            };
        /** Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false. */
        /**
         * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationCompactVisible = /**
         * Returns true, if `nxCount` is greater than 0 and the type of pagination is 'simple', else false.
         * @return {?}
         */
            function () {
                return this.type.includes('simple') && this.count > 0;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPaginationComponent.prototype.isPaginationContainerVisible = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.type.includes('advanced');
            };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype._isPaginationPreviousDisabled = /**
         * @return {?}
         */
            function () {
                return this.page === this.getMin();
            };
        /**
         * @return {?}
         */
        NxPaginationComponent.prototype._isPaginationNextDisabled = /**
         * @return {?}
         */
            function () {
                return this.page === this.totalNumberPages;
            };
        NxPaginationComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-pagination',
                        template: "<nav *ngIf=\"isPaginationVisible()\"  aria-label=\"Page navigation\" class=\"nx-pagination\" >\n  <ul *ngIf=\"isPaginationContainerVisible()\"  [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination__container\">\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.first\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--first\"\n        (click)=\"onFirst()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-first\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-previous\">\n      <button\n        [attr.aria-label]=\"paginationTexts.previous\"\n        [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n        [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--previous\"\n        (click)=\"onPrev()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n      </button>\n    </li>\n    <li *ngFor=\"let pageNum of getPages()\" class=\"nx-pagination__item\" [ngClass]=\"getPaginationItemClasses(pageNum)\">\n      <button class=\"nx-pagination--number\"\n        *ngIf=\"pageNum.label !== '...'\"\n        (click)=\"onPage(pageNum.value)\"\n        [attr.aria-curent]=\"pageNum.value === page\"\n        [ngClass]=\"getPaginationNumberClasses(pageNum)\">\n        {{ pageNum.label }}\n      </button>\n      <span *ngIf=\"pageNum.label === '...'\">\n        {{ pageNum.label }}\n      </span>\n    </li>\n    <li class=\"nx-pagination__item nx-pagination__item-next\">\n      <button\n        [attr.aria-label]=\"paginationTexts.next\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--next\"\n        (click)=\"onNext()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n      </button>\n    </li>\n    <li class=\"nx-pagination__item\">\n      <button\n        [attr.aria-label]=\"paginationTexts.last\"\n        [class.is-disabled]=\"_isPaginationNextDisabled()\"\n        [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n        class=\"nx-pagination__link nx-pagination__link--last\"\n        (click)=\"onLast()\">\n        <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-last\"></nx-icon>\n      </button>\n    </li>\n  </ul>\n</nav>\n<nav *ngIf=\"isPaginationCompactVisible()\" [attr.aria-label]=\"paginationTexts.ariaLabel\" class=\"nx-pagination-compact\" >\n  <button [attr.aria-label]=\"paginationTexts.previous\"\n    class=\"nx-pagination-compact__previous\"\n    [class.is-disabled]=\"_isPaginationPreviousDisabled()\"\n    [tabindex]=\"_isPaginationPreviousDisabled() ? -1 : 0\"\n\n    (click)=\"onPrev()\">\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-left\"></nx-icon>\n    <span class=\"nx-pagination-compact__direction-label\">\n      {{ paginationTexts.previous }}\n    </span>\n  </button>\n  <div class=\"nx-pagination-compact__display\">\n      <span class=\"nx-pagination-compact__current-page\">{{ page }}</span>\n      <span class=\"nx-pagination-compact__page-separator\"> {{ paginationTexts.ofLabel }} </span>\n      <span class=\"nx-pagination-compact__total-pages\">{{ totalNumberPages }}</span>\n  </div>\n  <button\n    class=\"nx-pagination-compact__next\"\n    [class.is-disabled]=\"_isPaginationNextDisabled()\"\n    [tabindex]=\"_isPaginationNextDisabled() ? -1 : 0\"\n    [attr.aria-label]=\"paginationTexts.next\"\n    (click)=\"onNext()\">\n    <span class=\"nx-pagination-compact__direction-label\"> {{ paginationTexts.next }} </span>\n    <nx-icon class=\"nx-pagination__arrow\" name=\"arrow-right\"></nx-icon>\n  </button>\n</nav>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host button:focus{outline:0}:host button::-moz-focus-inner{border:0}.nx-pagination__container{display:flex;font-size:16px;margin:8px 0;padding:0}@media (min-width:704px){.nx-pagination__container{margin:8px 0 40px}}.nx-pagination__item{margin:0 16px;list-style:none}.nx-pagination__item:first-child,.nx-pagination__item:last-child{margin:0}.nx-pagination__item.is-ellipsis{font-weight:700}.nx-pagination__item--expanded-view{display:block}.nx-pagination__link{color:#006192;font-weight:600;padding:0;text-decoration:none;background-color:#fff;border:0;cursor:pointer}.nx-pagination__link.is-active{color:#414141;font-weight:700;cursor:default}nx-icon.nx-pagination__arrow{font-size:24px}.nx-pagination-compact{display:flex;font-size:16px;margin:16px 0;padding:0}@media (min-width:704px){.nx-pagination-compact{margin:40px 0}}.nx-pagination-compact__display{color:#414141;display:flex;line-height:24px}.nx-pagination-compact__current-page{font-weight:700;margin-right:8px}.nx-pagination-compact__total-pages{margin-left:8px}.nx-pagination-compact__next,.nx-pagination-compact__previous,.nx-pagination__arrow-first,.nx-pagination__arrow-last{color:#006192;font-weight:600;text-decoration:none;text-transform:uppercase;display:flex;align-items:center;padding:0;background-color:#fff;cursor:pointer;border:0}.nx-pagination-compact__previous{margin-right:32px}.nx-pagination-compact__next{margin-left:32px}.nx-pagination-compact__direction-label{display:block;letter-spacing:1px}.nx-pagination-compact__direction-label:first-child{margin-right:8px}.nx-pagination-compact__direction-label:last-child{margin-left:8px}.nx-pagination-compact__next.is-disabled,.nx-pagination-compact__previous.is-disabled,.nx-pagination__link.is-disabled{color:rgba(0,97,146,.4);cursor:not-allowed}:host-context([data-whatinput=keyboard]) .nx-pagination--number:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__next:focus,:host-context([data-whatinput=keyboard]) .nx-pagination-compact__previous:focus,:host-context([data-whatinput=keyboard]) .nx-pagination__link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-pagination__link--first,.nx-pagination__link--last,.nx-pagination__link--next,.nx-pagination__link--previous{display:flex;align-items:center}.nx-pagination__item-next{margin-right:8px}.nx-pagination__item-previous{margin-left:8px}"]
                    }] }
        ];
        /** @nocollapse */
        NxPaginationComponent.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core$1.Optional }, { type: core$1.Inject, args: [NX_PAGINATION_TEXTS,] }] },
                { type: NxPaginationUtils },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxPaginationComponent.propDecorators = {
            page: [{ type: core$1.Input, args: ['nxPage',] }],
            count: [{ type: core$1.Input, args: ['nxCount',] }],
            perPage: [{ type: core$1.Input, args: ['nxPerPage',] }],
            type: [{ type: core$1.Input, args: ['nxType',] }],
            nxGoPrev: [{ type: core$1.Output }],
            nxGoNext: [{ type: core$1.Output }],
            nxGoPage: [{ type: core$1.Output }]
        };
        return NxPaginationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxPaginationModule = /** @class */ (function () {
        function NxPaginationModule() {
        }
        NxPaginationModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule, icon.NxIconModule
                        ],
                        declarations: [
                            NxPaginationComponent
                        ],
                        exports: [
                            NxPaginationComponent
                        ],
                        providers: [
                            NxPaginationUtils
                        ]
                    },] }
        ];
        return NxPaginationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TableDataSource = /** @class */ (function (_super) {
        __extends(TableDataSource, _super);
        function TableDataSource(_datachange) {
            var _this = _super.call(this) || this;
            _this._datachange = _datachange;
            return _this;
        }
        /** @docs-private Connect function called by the table to retrieve one stream containing the data to render. */
        /**
         * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
         * @return {?}
         */
        TableDataSource.prototype.connect = /**
         * \@docs-private Connect function called by the table to retrieve one stream containing the data to render.
         * @return {?}
         */
            function () {
                return this._datachange;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        TableDataSource.prototype.disconnect = /**
         * \@docs-private
         * @return {?}
         */
            function () { };
        return TableDataSource;
    }(collections.DataSource));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAPPING$2 = {
        light: 'nx-table--light',
        border: 'nx-table--light nx-table--with-border'
    };
    /** @type {?} */
    var DEFAULT_CLASSES$2 = ['nx-table '];
    var NxDynamicTableComponent = /** @class */ (function () {
        function NxDynamicTableComponent(el, _changeDetectorRef) {
            this.el = el;
            this._changeDetectorRef = _changeDetectorRef;
            this._tableStyles = '';
            this._dataChange = new rxjs.BehaviorSubject([]);
            this._classNames = utils.mapClassNames('', DEFAULT_CLASSES$2, MAPPING$2);
            /**
             * An event is dispatched when a row is clicked.
             */
            this.nxRowClick = new core$1.EventEmitter();
        }
        Object.defineProperty(NxDynamicTableComponent.prototype, "data", {
            get: /**
             * @return {?}
             */ function () {
                return this._data;
            },
            /** Sets the data that it will show in the table. */
            set: /**
             * Sets the data that it will show in the table.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._data = value
                    .filter(( /**
             * @param {?} element
             * @return {?}
             */function (element) { return element; }));
                // If user dont pass displayedColumns the table will show all data and the name of columns will be the key of data
                if (!this._displayedColumns) {
                    /** @type {?} */
                    var keys_1 = [];
                    /** @type {?} */
                    var cArray_1 = [];
                    // For catch keys of data Objects and assing title, key and type string by default to displayedColumns
                    this._data
                        .forEach(( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) {
                        for (var key in element) {
                            if (keys_1.indexOf(key) === -1) {
                                keys_1.push(key);
                                cArray_1.push({ title: key, key: key, type: 'string' });
                            }
                        }
                    }));
                    this._columnKeys = keys_1;
                    this._displayedColumns = cArray_1;
                    // need to call markForCheck as the setter changes displayedColumns here
                    // sidenote: isn't needed for the data itself as it gets passed to the cdk-table
                    // by the datasource observable
                    this._changeDetectorRef.markForCheck();
                }
                this._dataChange.next(this._data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "displayedColumns", {
            get: /**
             * @return {?}
             */ function () {
                return this._displayedColumns;
            },
            /** Sets the name order and type of columns. */
            set: /**
             * Sets the name order and type of columns.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._displayedColumns = value;
                this._columnKeys = value.map(( /**
                 * @param {?} column
                 * @return {?}
                 */function (column) { return column.key; }));
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "styles", {
            /** @deprecated The default and light header styling will be removed.
             * @deletion-target 8.0.0
            */
            set: /**
             * @deprecated The default and light header styling will be removed.
             * \@deletion-target 8.0.0
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._tableStyles === value) {
                    return;
                }
                this._classNames = utils.mapClassNames(value, DEFAULT_CLASSES$2, MAPPING$2);
                this._tableStyles = value;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "dataSource", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._dataSource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "classNames", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._classNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxDynamicTableComponent.prototype, "columnKeys", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._columnKeys;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxDynamicTableComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this._data) {
                    this._data = [];
                    this._dataChange.next(this._data);
                }
                this._dataSource = new TableDataSource(this._dataChange);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} row
         * @return {?}
         */
        NxDynamicTableComponent.prototype.handleRowClick = /**
         * \@docs-private
         * @param {?} row
         * @return {?}
         */
            function (row) {
                this.nxRowClick.emit(row);
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} element
         * @return {?}
         */
        NxDynamicTableComponent.prototype.isNumeric = /**
         * \@docs-private
         * @param {?} element
         * @return {?}
         */
            function (element) {
                if (element.type === 'numeric') {
                    return true;
                }
                return false;
            };
        NxDynamicTableComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-dynamic-table',
                        template: "<div class=\"nx-table__container\" *ngIf=\"data && data.length > 0\">\n  <div class=\"nx-table__scroll\">\n    <cdk-table [dataSource]=\"dataSource\" [ngClass]=\"classNames\">\n      <!-- Column Definition -->\n      <ng-container *ngFor=\"let element of displayedColumns\" cdkColumnDef=\"{{element.key}}\">\n        <cdk-header-cell *cdkHeaderCellDef class=\"nx-table__header-cell\"\n                         [ngClass]=\"{'nx-table__header-cell--number': isNumeric(element) }\">\n          <div class=\"nx-table__header-title--block\">\n            <span class=\"nx-table__header-title\"> {{element.title}}</span>\n          </div>\n        </cdk-header-cell>\n        <cdk-cell *cdkCellDef=\"let row\" class=\"nx-table__cell\"\n                  [ngClass]=\"{'nx-table__cell--number': isNumeric(element) }\" [innerHTML]=\"row[element.key]\"></cdk-cell>\n      </ng-container>\n\n      <!-- Header and Row Declarations -->\n      <cdk-header-row *cdkHeaderRowDef=\"columnKeys\" class=\"nx-table__header-row\"></cdk-header-row>\n      <cdk-row *cdkRowDef=\"let row; columns: columnKeys\" class=\"nx-table__row\"\n               (dblclick)=\"handleRowClick(row)\"></cdk-row>\n\n    </cdk-table>\n  </div>\n</div>\n<div class=\"nx-table__appendix\" *ngIf=\"data.length === 0\">\n  <ng-content></ng-content>\n</div>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [".nx-table{border-top:2px solid #d9d9d9;border-bottom:2px solid #414141;font-size:16px;text-align:left;width:100%;line-height:24px;color:#414141;display:table}.nx-table--light.nx-table{border-top:1px solid #d9d9d9}.nx-table__container{margin:32px 0}.nx-table__scroll{max-width:100%;overflow:hidden;overflow-x:auto}.nx-table__header-cell{background-color:#d9d9d9;border:1px solid #fff;border-right:none;color:#414141;padding:21px 16px 23px;position:relative;font-size:16px;line-height:24px;font-weight:700}.nx-table__header-row .nx-table__header-cell:last-child{border-right:1px solid #fff}.nx-table__header-row{background-color:#d9d9d9;border-spacing:1px none}.nx-table--light .nx-table__header-row{background-color:#fff;border-bottom:2px solid #414141;border-top:1px solid #d9d9d9}.nx-table__header-cell--number{display:flex;position:relative}.nx-table__header-cell--number .nx-table__header-title--block{justify-content:flex-end}.nx-table__cell{padding:24px 16px;vertical-align:top}.nx-table__cell--number,.nx-table__header-cell--number{text-align:right}.nx-table__row{background-color:#fff}.nx-table__header-row,.nx-table__row{display:table-row;vertical-align:inherit;border-color:inherit}.nx-table__row:nth-child(2n+1){background-color:#ececec}.nx-table--light.nx-table--with-border .nx-table__row{background-color:#fff}.nx-table--light .nx-table__header-cell{background-color:#fff;border:none;border-bottom:2px solid #414141;padding-top:23px;padding-bottom:22px}.nx-table--light.nx-table--with-border .nx-table__cell{padding-bottom:23px;border-bottom:1px solid #d9d9d9}.nx-table__row:last-child .nx-table__cell{padding-bottom:22px;border-bottom:none}.nx-table__cell,.nx-table__header-cell{display:table-cell;vertical-align:inherit}"]
                    }] }
        ];
        /** @nocollapse */
        NxDynamicTableComponent.ctorParameters = function () {
            return [
                { type: core$1.ElementRef },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxDynamicTableComponent.propDecorators = {
            data: [{ type: core$1.Input, args: ['nxData',] }],
            displayedColumns: [{ type: core$1.Input, args: ['nxDisplayedColumns',] }],
            styles: [{ type: core$1.Input, args: ['nxType',] }],
            nxRowClick: [{ type: core$1.Output }]
        };
        return NxDynamicTableComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxDynamicTableModule = /** @class */ (function () {
        function NxDynamicTableModule() {
        }
        NxDynamicTableModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxDynamicTableComponent],
                        exports: [NxDynamicTableComponent],
                        imports: [common.CommonModule, table.CdkTableModule, scrolling.ScrollDispatchModule]
                    },] }
        ];
        return NxDynamicTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_TYPE$4 = 'regular';
    var NxAccordionDirective = /** @class */ (function (_super) {
        __extends(NxAccordionDirective, _super);
        function NxAccordionDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._style = 'regular';
            _this._negative = null;
            return _this;
        }
        Object.defineProperty(NxAccordionDirective.prototype, "style", {
            get: /**
             * @return {?}
             */ function () {
                return this._style;
            },
            /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'
             */
            set: /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = value ? value : DEFAULT_TYPE$4;
                var _a = __read(value.match(/regular|light/) || [DEFAULT_TYPE$4], 1), newValue = _a[0];
                this._style = ( /** @type {?} */(newValue));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAccordionDirective.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the negative set of styles should be used. */
            set: /**
             * Whether the negative set of styles should be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        NxAccordionDirective.decorators = [
            { type: core$1.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-accordion',
                        host: {
                            '[class.nx-accordion]': 'true',
                            'role': 'presentation'
                        }
                    },] }
        ];
        NxAccordionDirective.propDecorators = {
            style: [{ type: core$1.Input, args: ['nxStyle',] }],
            negative: [{ type: core$1.Input }]
        };
        return NxAccordionDirective;
    }(accordion.CdkAccordion));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nxAccordionAnimations = {
        bodyExpansion: animations.trigger('bodyExpansion', [
            animations.state('closed', animations.style({ height: '0px', visibility: 'hidden' })),
            animations.state('open', animations.style({ height: '*', visibility: 'visible' })),
            animations.transition('open <=> closed', animations.animate('.5s cubic-bezier(0.86, 0, 0.07, 1)'))
        ]),
        indicatorRotate: animations.trigger('indicatorRotate', [
            animations.state('closed', animations.style({ transform: 'rotate(0deg)' })),
            animations.state('open', animations.style({ transform: 'rotate(180deg)' })),
            animations.transition('open <=> closed', animations.animate('.3s ease')),
        ])
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxExpansionPanelBodyDirective = /** @class */ (function () {
        function NxExpansionPanelBodyDirective(_template) {
            this._template = _template;
        }
        NxExpansionPanelBodyDirective.decorators = [
            { type: core$1.Directive, args: [{ selector: '[nxExpansionPanelBody]' },] }
        ];
        /** @nocollapse */
        NxExpansionPanelBodyDirective.ctorParameters = function () {
            return [
                { type: core$1.TemplateRef }
            ];
        };
        return NxExpansionPanelBodyDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId$c = 0;
    /** @type {?} */
    var DEFAULT_TYPE$5 = 'regular';
    var 0 = undefined;
    var NxExpansionPanelComponent = /** @class */ (function (_super) {
        __extends(NxExpansionPanelComponent, _super);
        function NxExpansionPanelComponent(accordion$$1, _changeDetectorRef, _expansionDispatcher, _viewContainerRef) {
            var _this = _super.call(this, accordion$$1, _changeDetectorRef, _expansionDispatcher) || this;
            _this._viewContainerRef = _viewContainerRef;
            _this._negative = null;
            _this._accordionStyle = DEFAULT_TYPE$5;
            _this._style = null;
            _this._headerId = "nx-expansion-panel-header-" + nextId$c++;
            /**
             * Stream that emits for changes in `\@Input` properties.
             */
            _this._inputChanges = new rxjs.Subject();
            _this.accordion = accordion$$1;
            return _this;
        }
        Object.defineProperty(NxExpansionPanelComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the negative set of styles should be used. */
            set: /**
             * Whether the negative set of styles should be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._negative = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxExpansionPanelComponent.prototype, "style", {
            get: /**
             * @return {?}
             */ function () {
                return this._style;
            },
            /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'.
             */
            set: /**
             * Value for the styling that should be chosen.
             * Default value: 'regular'.
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = value ? value : DEFAULT_TYPE$5;
                var _a = __read(value.match(/regular|light/) || [DEFAULT_TYPE$5], 1), newValue = _a[0];
                this._style = ( /** @type {?} */(newValue));
                this._accordionStyle = ( /** @type {?} */(newValue));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxExpansionPanelComponent.prototype, "portal", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._portal;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.lazyContent) {
                    // Render the content as soon as the panel becomes open.
                    this.opened.pipe(operators.startWith(null), operators.filter(( /**
                     * @return {?}
                     */function () { return _this.expanded && !_this._portal; })), operators.take(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._portal = new portal.TemplatePortal(_this.lazyContent._template, _this._viewContainerRef);
                    }));
                }
                // Inherit appearance given by the accordion (if any).
                if (Boolean(this.accordion)) {
                    if (this.style === null && this.accordion.style !== null) {
                        this.style = this.accordion.style;
                    }
                    if (this.negative === null && this.accordion.negative !== null) {
                        this.negative = this.accordion.negative;
                    }
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this._inputChanges.next(changes);
            };
        /**
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                this._inputChanges.complete();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelComponent.prototype.getOpenState = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.expanded ? 'open' : 'closed';
            };
        NxExpansionPanelComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-expansion-panel',
                        exportAs: 'NxExpansionPanelComponent',
                        template: "<ng-content select=\"nx-expansion-panel-header\"></ng-content>\n\n<div class=\"nx-expansion-panel__content\" role=\"region\" [@bodyExpansion]=\"getOpenState()\"\n  [attr.aria-labelledby]=\"_headerId\" [id]=\"id\">\n  <div class=\"nx-expansion-panel__body\">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]=\"portal\"></ng-template>\n  </div>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        animations: [nxAccordionAnimations.bodyExpansion],
                        host: {
                            '[class.nx-expanded]': 'expanded',
                            '[class.nx-expansion-panel--light]': '_accordionStyle === "light"',
                            '[class.nx-expansion-panel--regular]': '_accordionStyle === "regular"',
                            '[class.nx-expansion-panel--negative]': 'negative'
                        },
                        providers: [
                            // Provide NxAccordionDirective as undefined to prevent nested expansion panels from registering
                            // to the same accordion.
                            { provide: NxAccordionDirective, useValue: 0 },
                        ],
                        styles: [":host{display:block}:host(.nx-expansion-panel--negative) ::ng-deep div.nx-expansion-panel__body *{color:#fff}.nx-expansion-panel__content{overflow:hidden;display:block}.nx-expansion-panel__body{font-size:16px;line-height:24px;padding:24px 88px 32px 32px}@media (max-width:703px){.nx-expansion-panel__body{padding:24px 16px 32px}:host:last-child ::ng-deep .nx-expansion-panel__header-content,:host:only-child ::ng-deep .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-content{border-top:1px solid #d9d9d9;border-bottom:none}:host(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__body{padding-top:0}:host(.nx-expansion-panel--light):first-child ::ng-deep .nx-expansion-panel__header-content{border-top:none}"]
                    }] }
        ];
        /** @nocollapse */
        NxExpansionPanelComponent.ctorParameters = function () {
            return [
                { type: NxAccordionDirective, decorators: [{ type: core$1.Optional }, { type: core$1.SkipSelf }] },
                { type: core$1.ChangeDetectorRef },
                { type: collections.UniqueSelectionDispatcher },
                { type: core$1.ViewContainerRef }
            ];
        };
        NxExpansionPanelComponent.propDecorators = {
            negative: [{ type: core$1.Input }],
            style: [{ type: core$1.Input, args: ['nxStyle',] }],
            lazyContent: [{ type: core$1.ContentChild, args: [NxExpansionPanelBodyDirective,] }]
        };
        return NxExpansionPanelComponent;
    }(accordion.CdkAccordionItem));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxExpansionPanelHeaderComponent = /** @class */ (function () {
        function NxExpansionPanelHeaderComponent(panel, _changeDetectorRef) {
            var _this = this;
            this.panel = panel;
            this._changeDetectorRef = _changeDetectorRef;
            this._parentChangeSubscription = rxjs.Subscription.EMPTY;
            this._parentChangeSubscription = rxjs.merge(panel.opened, panel.closed, panel._inputChanges.pipe(operators.filter(( /**
             * @param {?} changes
             * @return {?}
             */function (changes) { return !!(changes.hideToggle || changes.disabled); }))))
                .subscribe(( /**
         * @return {?}
         */function () { return _this._changeDetectorRef.markForCheck(); }));
        }
        /**
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._parentChangeSubscription.unsubscribe();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.isExpanded = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.panel.expanded;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.getOpenState = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.panel.getOpenState();
            };
        /**
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype._getPanelId = /**
         * @return {?}
         */
            function () {
                return this.panel.id;
            };
        /**
         * Toggle the expansion panel.
         */
        /**
         * Toggle the expansion panel.
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.toggle = /**
         * Toggle the expansion panel.
         * @return {?}
         */
            function () {
                this.panel.toggle();
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxExpansionPanelHeaderComponent.prototype.keydown = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.keyCode) {
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.toggle();
                        break;
                    default:
                        return;
                }
            };
        NxExpansionPanelHeaderComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-expansion-panel-header',
                        template: "<div class=\"nx-expansion-panel__header-content\">\n  <ng-content select=\"nx-expansion-panel-title\"></ng-content>\n  <ng-content select=\"nx-expansion-panel-description\"></ng-content>\n  <nx-icon\n    [@indicatorRotate]=\"getOpenState()\"\n    class=\"nx-expansion-panel__chevron\"\n    name=\"chevron-down\">\n  </nx-icon>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        animations: [nxAccordionAnimations.indicatorRotate],
                        host: {
                            '[class.nx-expanded]': 'isExpanded()',
                            'class': 'nx-expansion-panel__header',
                            'role': 'button',
                            '[attr.id]': 'panel._headerId',
                            '[attr.tabindex]': 'panel.disabled ? -1 : 0',
                            '[attr.aria-controls]': '_getPanelId()',
                            '[attr.aria-expanded]': 'isExpanded()',
                            '[attr.aria-disabled]': 'panel.disabled',
                            '(keydown)': 'keydown($event)',
                            '(click)': 'toggle()'
                        },
                        styles: [":host:focus{outline:0}.nx-expansion-panel__header-content{width:100%;cursor:pointer;align-items:center;color:#414141;display:flex;justify-content:space-between;position:relative;padding:24px 32px;margin-top:16px;background:#f5f5f5;outline:0;border:none}::ng-deep .nx-expansion-panel__header-title{font-size:26px;font-weight:300;line-height:32px;letter-spacing:.3px;text-align:left;margin-right:32px}:host-context(.nx-expansion-panel--negative) .nx-expansion-panel__header-content{background-color:#fff}.nx-expansion-panel__chevron{color:#006192;pointer-events:none;font-size:24px}:host-context(.nx-expansion-panel--light) .nx-expansion-panel__header-content{margin-top:0;background:0 0}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{color:#006192;letter-spacing:.2px;font-weight:400;font-size:20px;line-height:28px}@media (max-width:703px){.nx-expansion-panel__header-content{padding:16px;margin-top:0;border-top:1px solid #d9d9d9}::ng-deep .nx-expansion-panel__header-title{font-size:20px;line-height:28px;margin-right:16px;font-weight:400}:host(.nx-expanded) .nx-expansion-panel__header-content{border-bottom:1px solid #d9d9d9}:host-context(.nx-expansion-panel--light) ::ng-deep .nx-expansion-panel__header-title{line-height:24px;font-size:16px}:host-context(.nx-expansion-panel--light.nx-expanded) .nx-expansion-panel__header-content{border-bottom:none}}:host[aria-disabled=true] .nx-expansion-panel__header-content{cursor:not-allowed}:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__chevron,:host[aria-disabled=true] ::ng-deep .nx-expansion-panel__header-title{color:#c2c2c2}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) .nx-expansion-panel__header-content{border-color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__header-title{color:#fff}:host-context(.nx-expansion-panel--light.nx-expansion-panel--negative) ::ng-deep .nx-expansion-panel__chevron{color:#fff}:host-context([data-whatinput=keyboard]):focus .nx-expansion-panel__header-content{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-top-color:transparent;z-index:1}"]
                    }] }
        ];
        /** @nocollapse */
        NxExpansionPanelHeaderComponent.ctorParameters = function () {
            return [
                { type: NxExpansionPanelComponent, decorators: [{ type: core$1.Host }] },
                { type: core$1.ChangeDetectorRef }
            ];
        };
        return NxExpansionPanelHeaderComponent;
    }());
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */
    var NxExpansionPanelDescriptionDirective = /** @class */ (function () {
        function NxExpansionPanelDescriptionDirective() {
        }
        NxExpansionPanelDescriptionDirective.decorators = [
            { type: core$1.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-expansion-panel-description',
                        host: {
                            class: 'nx-expansion-panel__header-description'
                        }
                    },] }
        ];
        return NxExpansionPanelDescriptionDirective;
    }());
    /**
     * This directive is to be used inside of the NxExpansionPanelHeader component.
     */
    var NxExpansionPanelTitleDirective = /** @class */ (function () {
        function NxExpansionPanelTitleDirective() {
        }
        NxExpansionPanelTitleDirective.decorators = [
            { type: core$1.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'nx-expansion-panel-title',
                        host: {
                            class: 'nx-expansion-panel__header-title'
                        }
                    },] }
        ];
        return NxExpansionPanelTitleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAccordionModule = /** @class */ (function () {
        function NxAccordionModule() {
        }
        NxAccordionModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            portal.PortalModule,
                            icon.NxIconModule
                        ],
                        exports: [
                            NxAccordionDirective,
                            NxExpansionPanelComponent,
                            NxExpansionPanelHeaderComponent,
                            NxExpansionPanelDescriptionDirective,
                            NxExpansionPanelTitleDirective,
                            NxExpansionPanelBodyDirective
                        ],
                        declarations: [
                            NxAccordionDirective,
                            NxExpansionPanelComponent,
                            NxExpansionPanelHeaderComponent,
                            NxExpansionPanelDescriptionDirective,
                            NxExpansionPanelTitleDirective,
                            NxExpansionPanelBodyDirective
                        ],
                        providers: [],
                    },] }
        ];
        return NxAccordionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @abstract
     */
    var /**
     * \@docs-private
     * @abstract
     */ NxTabGroupBase = /** @class */ (function () {
        function NxTabGroupBase() {
        }
        return NxTabGroupBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabComponent = /** @class */ (function () {
        function NxTabComponent(_viewContainerRef, _tabGroup) {
            this._viewContainerRef = _viewContainerRef;
            this._tabGroup = _tabGroup;
            /**
             * The portal that will be the hosted content of the tab
             */
            this._contentPortal = null;
            /**
             * Emits whenever the internal state of the tab changes.
             */
            this._stateChanges = new rxjs.Subject();
            /**
             * Whether the tab is currently active.
             */
            this.isActive = false;
            if (!this._tabGroup) {
                throw Error("The nx-tab element has to be wrapped in a nx-tab-group to work.\n      Please provide a nx-tab-group element and place your tabs inside it.");
            }
        }
        Object.defineProperty(NxTabComponent.prototype, "label", {
            /** Sets the label of the tab shown in the tablist. */
            get: /**
             * Sets the label of the tab shown in the tablist.
             * @return {?}
             */ function () {
                return this._label;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._label !== value) {
                    this._label = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabComponent.prototype, "content", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._contentPortal;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        NxTabComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.hasOwnProperty('label')) {
                    this._stateChanges.next();
                }
            };
        /**
         * @return {?}
         */
        NxTabComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._contentPortal = new portal.TemplatePortal(this._implicitContent, this._viewContainerRef);
            };
        /**
         * @return {?}
         */
        NxTabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._stateChanges.complete();
            };
        NxTabComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tab',
                        exportAs: 'nxTab',
                        template: "<ng-template><ng-content></ng-content></ng-template>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NxTabComponent.ctorParameters = function () {
            return [
                { type: core$1.ViewContainerRef },
                { type: NxTabGroupBase, decorators: [{ type: core$1.Inject, args: [NxTabGroupBase,] }, { type: core$1.Optional }, { type: core$1.Host }] }
            ];
        };
        NxTabComponent.propDecorators = {
            label: [{ type: core$1.Input }],
            _implicitContent: [{ type: core$1.ViewChild, args: [core$1.TemplateRef,] }]
        };
        return NxTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabBodyComponent = /** @class */ (function () {
        function NxTabBodyComponent() {
            this._active = false;
        }
        Object.defineProperty(NxTabBodyComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._active = coercion.coerceBooleanProperty(value);
                if (this._active) {
                    this.attach();
                }
                else {
                    this.detach();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.attach = /**
         * @return {?}
         */
            function () {
                if (!this.portalOutlet.hasAttached()) {
                    this.portalOutlet.attach(this.content);
                }
            };
        /**
         * @return {?}
         */
        NxTabBodyComponent.prototype.detach = /**
         * @return {?}
         */
            function () {
                if (this.portalOutlet.hasAttached()) {
                    this.portalOutlet.detach();
                }
            };
        NxTabBodyComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tab-body',
                        template: "<ng-template cdkPortalOutlet></ng-template>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}"]
                    }] }
        ];
        NxTabBodyComponent.propDecorators = {
            content: [{ type: core$1.Input }],
            active: [{ type: core$1.Input }],
            portalOutlet: [{ type: core$1.ViewChild, args: [portal.CdkPortalOutlet,] }]
        };
        return NxTabBodyComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabChangeEvent = /** @class */ (function () {
        function NxTabChangeEvent() {
        }
        return NxTabChangeEvent;
    }());
    /** @type {?} */
    var nextId$d = 0;
    /** @type {?} */
    var MOBILE_BREAKPOINT = 480;
    var NxTabGroupComponent = /** @class */ (function () {
        function NxTabGroupComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._selectedIndex = null;
            this._negative = false;
            this._indexToSelect = 0;
            this._autoselect = true;
            this._mobileAccordion = true;
            this._showAccordion = false;
            /**
             * An event emitted when the selected tab has changed.
             */
            this.selectedIndexChange = new core$1.EventEmitter();
            /**
             * An event emitted when the selected tab has changed.
             */
            this.selectedTabChange = new core$1.EventEmitter();
            /**
             * An event emitted when focus has changed within a tab group.
             *
             * **Note:** is not supported in mobile view.
             */
            this.focusChange = new core$1.EventEmitter();
            /**
             * Subscription to tabs being added/removed.
             */
            this._tabsSubscription = rxjs.Subscription.EMPTY;
            /**
             * Subscription to changes in the tab labels.
             */
            this._tabLabelSubscription = rxjs.Subscription.EMPTY;
            this._groupId = nextId$d++;
        }
        Object.defineProperty(NxTabGroupComponent.prototype, "selectedIndex", {
            /** Sets the selected tab. */
            get: /**
             * Sets the selected tab.
             * @return {?}
             */ function () {
                return this._selectedIndex;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._indexToSelect = coercion.coerceNumberProperty(value, null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "negative", {
            /** Whether the negative set of styling should be used. */
            get: /**
             * Whether the negative set of styling should be used.
             * @return {?}
             */ function () {
                return this._negative;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._negative) {
                    this._negative = coercion.coerceBooleanProperty(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "autoselect", {
            /** Whether the tab should be immediately selected on focus. */
            get: /**
             * Whether the tab should be immediately selected on focus.
             * @return {?}
             */ function () {
                return this._autoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._autoselect = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabGroupComponent.prototype, "mobileAccordion", {
            /** Whether the tabs should to accordion on mobile viewports. */
            get: /**
             * Whether the tabs should to accordion on mobile viewports.
             * @return {?}
             */ function () {
                return this._mobileAccordion;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mobileAccordion = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._switchAppearance(window.innerWidth);
            };
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscribeToTabLabels();
                // Subscribe to changes in the amount of tabs, in order to be
                // able to re-render the content as new tabs are added or removed.
                this._tabsSubscription = this.tabs.changes.subscribe(( /**
                 * @return {?}
                 */function () {
                    /** @type {?} */
                    var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
                    // Maintain the previously-selected tab if a new tab is added or removed and there is no
                    // explicit change that selects a different tab.
                    if (indexToSelect === _this._selectedIndex) {
                        /** @type {?} */
                        var tabs = _this.tabs.toArray();
                        for (var i = 0; i < tabs.length; i++) {
                            if (tabs[i].isActive) {
                                // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                                // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                                // adding a tab within the `selectedIndexChange` event.
                                _this._indexToSelect = _this._selectedIndex = i;
                                break;
                            }
                        }
                    }
                    _this._changeDetectorRef.markForCheck();
                }));
            };
        /**
          * After the content is checked, this component knows what tabs have been defined
          * and what the selected index should be.
          */
        /**
         * After the content is checked, this component knows what tabs have been defined
         * and what the selected index should be.
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngAfterContentChecked = /**
         * After the content is checked, this component knows what tabs have been defined
         * and what the selected index should be.
         * @return {?}
         */
            function () {
                var _this = this;
                // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
                // the amount of tabs changes before the actual change detection runs.
                /** @type {?} */
                var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                // If there is a change in selected index, emit a change event. Should not trigger if
                // the selected index has not yet been initialized.
                if (this._selectedIndex !== indexToSelect) {
                    /** @type {?} */
                    var isFirstRun_1 = this._selectedIndex == null;
                    if (!isFirstRun_1) {
                        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
                    }
                    // Changing these values after change detection has run
                    // since the checked content may contain references to them.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        _this.tabs.forEach(( /**
                         * @param {?} tab
                         * @param {?} index
                         * @return {?}
                         */function (tab, index) { return tab.isActive = index === indexToSelect; }));
                        if (!isFirstRun_1) {
                            _this.selectedIndexChange.emit(indexToSelect);
                        }
                    }));
                }
                if (this._selectedIndex !== indexToSelect) {
                    this._selectedIndex = indexToSelect;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @return {?}
         */
        NxTabGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabsSubscription.unsubscribe();
                this._tabLabelSubscription.unsubscribe();
            };
        /**
        * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
        * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
        * binding to be updated, we need to subscribe to changes in it and trigger change detection
        * manually.
        */
        /**
         * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
         * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
         * binding to be updated, we need to subscribe to changes in it and trigger change detection
         * manually.
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._subscribeToTabLabels = /**
         * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
         * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
         * binding to be updated, we need to subscribe to changes in it and trigger change detection
         * manually.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._tabLabelSubscription) {
                    this._tabLabelSubscription.unsubscribe();
                }
                this._tabLabelSubscription = rxjs.merge.apply(void 0, __spread(this.tabs.map(( /**
                 * @param {?} tab
                 * @return {?}
                 */function (tab) { return tab._stateChanges; })))).subscribe(( /**
                 * @return {?}
                 */function () { return _this._changeDetectorRef.markForCheck(); }));
            };
        /** Clamps the given index to the bounds of 0 and the tabs length. */
        /**
         * Clamps the given index to the bounds of 0 and the tabs length.
         * @private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._clampTabIndex = /**
         * Clamps the given index to the bounds of 0 and the tabs length.
         * @private
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Note the `|| 0`, which ensures that values like NaN can't get through
                // and which would otherwise throw the component into an infinite loop
                // (since Math.max(NaN, 0) === NaN).
                return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype.focusChanged = /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this.focusChange.emit(this._createChangeEvent(index));
            };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._createChangeEvent = /**
         * @private
         * @param {?} index
         * @return {?}
         */
            function (index) {
                /** @type {?} */
                var event = new NxTabChangeEvent;
                event.index = index;
                if (this.tabs && this.tabs.length) {
                    event.tab = this.tabs.toArray()[index];
                }
                return event;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype.handleClick = /**
         * \@docs-private
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this.selectedIndex = this.tabHeader.focusIndex = index;
            };
        /**
         * @docs-private
         * Returns the tabindex for a tab label
         */
        /**
         * \@docs-private
         * Returns the tabindex for a tab label
         * @param {?} tab
         * @param {?} idx
         * @return {?}
         */
        NxTabGroupComponent.prototype.getTabIndex = /**
         * \@docs-private
         * Returns the tabindex for a tab label
         * @param {?} tab
         * @param {?} idx
         * @return {?}
         */
            function (tab, idx) {
                return this.selectedIndex === idx ? 0 : -1;
            };
        /** Returns a unique id for each tab label element */
        /**
         * Returns a unique id for each tab label element
         * @param {?} i
         * @return {?}
         */
        NxTabGroupComponent.prototype._getTabLabelId = /**
         * Returns a unique id for each tab label element
         * @param {?} i
         * @return {?}
         */
            function (i) {
                return "nx-tab-label-" + this._groupId + "-" + i;
            };
        /** Returns a unique id for each tab content element */
        /**
         * Returns a unique id for each tab content element
         * @param {?} i
         * @return {?}
         */
        NxTabGroupComponent.prototype._getTabContentId = /**
         * Returns a unique id for each tab content element
         * @param {?} i
         * @return {?}
         */
            function (i) {
                return "nx-tab-content-" + this._groupId + "-" + i;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
        NxTabGroupComponent.prototype.onResize = /**
         * \@docs-private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._switchAppearance(event.target.innerWidth);
            };
        /**
         * @private
         * @param {?} viewPortWidth
         * @return {?}
         */
        NxTabGroupComponent.prototype._switchAppearance = /**
         * @private
         * @param {?} viewPortWidth
         * @return {?}
         */
            function (viewPortWidth) {
                if (!this._mobileAccordion) {
                    return;
                }
                if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
                    this._showMobileVersion();
                }
                else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
                    this._showDesktopVersion();
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._showMobileVersion = /**
         * @private
         * @return {?}
         */
            function () {
                this._showAccordion = true;
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @private
         * @return {?}
         */
        NxTabGroupComponent.prototype._showDesktopVersion = /**
         * @private
         * @return {?}
         */
            function () {
                this._showAccordion = false;
                this._changeDetectorRef.markForCheck();
            };
        /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         */
        /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         * @param {?} index
         * @return {?}
         */
        NxTabGroupComponent.prototype._panelOpened = /**
         * Emulate the tab change event when an accordion panel is opened in
         * mobile viewports.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this.selectedIndex = index;
            };
        NxTabGroupComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tab-group',
                        template: "\n  <nx-tab-header *ngIf=\"!_showAccordion\"\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabel\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      {{tab.label}}\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(!_showAccordion && selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [content]=\"tab.content\"\n      [active]=\"!_showAccordion && selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n\n  <nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n    <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\">\n      <nx-expansion-panel-header>\n        <nx-expansion-panel-title>{{tab.label}}</nx-expansion-panel-title>\n      </nx-expansion-panel-header>\n      <ng-template [cdkPortalOutlet]=\"tab.content\"></ng-template>\n    </nx-expansion-panel>\n  </nx-accordion>\n",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative'
                        },
                        providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                        styles: [":host{display:block}.nx-tab-header__item{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px;outline:0}.nx-tab-header__item::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabGroupComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxTabGroupComponent.propDecorators = {
            tabs: [{ type: core$1.ContentChildren, args: [NxTabComponent,] }],
            tabBodyChildren: [{ type: core$1.ViewChildren, args: [NxTabBodyComponent,] }],
            tabHeader: [{ type: core$1.ViewChild, args: ['tabHeader',] }],
            panels: [{ type: core$1.ViewChildren, args: [accordion$1.NxExpansionPanelComponent,] }],
            accordion: [{ type: core$1.ViewChild, args: [accordion$1.NxAccordionDirective,] }],
            selectedIndex: [{ type: core$1.Input }],
            negative: [{ type: core$1.Input }],
            autoselect: [{ type: core$1.Input }],
            mobileAccordion: [{ type: core$1.Input }],
            selectedIndexChange: [{ type: core$1.Output }],
            selectedTabChange: [{ type: core$1.Output }],
            focusChange: [{ type: core$1.Output }],
            onResize: [{ type: core$1.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return NxTabGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabLabelDirective = /** @class */ (function () {
        function NxTabLabelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        NxTabLabelDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.elementRef.nativeElement.focus();
            };
        NxTabLabelDirective.decorators = [
            { type: core$1.Directive, args: [{ selector: '[nxTabLabel]' },] }
        ];
        /** @nocollapse */
        NxTabLabelDirective.ctorParameters = function () {
            return [
                { type: core$1.ElementRef }
            ];
        };
        return NxTabLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     */
    var NxTabHeaderComponent = /** @class */ (function () {
        function NxTabHeaderComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._selectedIndex = 0;
            this._autoselect = true;
            this.selectFocusedIndex = new core$1.EventEmitter();
            this.indexFocused = new core$1.EventEmitter();
        }
        Object.defineProperty(NxTabHeaderComponent.prototype, "selectedIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectedIndex;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._selectedIndex = value;
                if (this._keyManager) {
                    this._keyManager.updateActiveItemIndex(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabHeaderComponent.prototype, "focusIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._keyManager ? this._keyManager.activeItemIndex : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                    return;
                }
                this._keyManager.setActiveItem(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxTabHeaderComponent.prototype, "autoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._autoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._autoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxTabHeaderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () { };
        /**
         * @return {?}
         */
        NxTabHeaderComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._keyManager = new a11y.FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
                this._keyManager.updateActiveItemIndex(0);
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @private
         * @param {?} idx
         * @return {?}
         */
        NxTabHeaderComponent.prototype._isValidIndex = /**
         * @private
         * @param {?} idx
         * @return {?}
         */
            function (idx) {
                if (!this.labels) {
                    return true;
                }
                return !!this.labels.toArray()[idx];
            };
        /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         */
        /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         * @param {?} event
         * @return {?}
         */
        NxTabHeaderComponent.prototype.handleKeydown = /**
         * Handles keyboard inputs on the labels
         * If autoselect is enabled the tab gets changed immediately
         * If autoselect is disabled only the focus changes but the user still has to select the item
         * by himself
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.keyCode) {
                    case keycodes.HOME:
                        this._keyManager.setFirstItemActive();
                        event.preventDefault();
                        break;
                    case keycodes.END:
                        this._keyManager.setLastItemActive();
                        event.preventDefault();
                        break;
                    case keycodes.ENTER:
                    case keycodes.SPACE:
                        this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                        event.preventDefault();
                        break;
                    default:
                        this._keyManager.onKeydown(event);
                }
                if (this.autoselect) {
                    this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                }
                else if (event.keyCode !== keycodes.ENTER && event.keyCode !== keycodes.SPACE) {
                    this.indexFocused.emit(this._keyManager.activeItemIndex);
                }
            };
        NxTabHeaderComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tab-header',
                        template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabHeaderComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxTabHeaderComponent.propDecorators = {
            selectedIndex: [{ type: core$1.Input }],
            autoselect: [{ type: core$1.Input }],
            selectFocusedIndex: [{ type: core$1.Output }],
            indexFocused: [{ type: core$1.Output }],
            labels: [{ type: core$1.ContentChildren, args: [NxTabLabelDirective,] }]
        };
        return NxTabHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabNavBarComponent = /** @class */ (function () {
        function NxTabNavBarComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._negative = false;
        }
        Object.defineProperty(NxTabNavBarComponent.prototype, "negative", {
            get: /**
             * @return {?}
             */ function () {
                return this._negative;
            },
            /** Whether the tab nav bar has negative styling. */
            set: /**
             * Whether the tab nav bar has negative styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this.negative) {
                    this._negative = newValue;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        NxTabNavBarComponent.decorators = [
            { type: core$1.Component, args: [{
                        selector: 'nx-tab-nav-bar',
                        template: "<ng-content></ng-content>",
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class.is-negative]': 'negative',
                            'role': 'navigation',
                        },
                        styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host-context([data-whatinput=keyboard]) nx-tab-link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
                    }] }
        ];
        /** @nocollapse */
        NxTabNavBarComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef }
            ];
        };
        NxTabNavBarComponent.propDecorators = {
            negative: [{ type: core$1.Input }]
        };
        return NxTabNavBarComponent;
    }());
    var NxTabLinkDirective = /** @class */ (function () {
        function NxTabLinkDirective(_tabNavBar) {
            this._tabNavBar = _tabNavBar;
            this._active = false;
            if (!this._tabNavBar) {
                throw Error("The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.");
            }
        }
        Object.defineProperty(NxTabLinkDirective.prototype, "active", {
            /** Whether the tab link is active and has the active styling. */
            get: /**
             * Whether the tab link is active and has the active styling.
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._active) {
                    this._active = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        NxTabLinkDirective.decorators = [
            { type: core$1.Directive, args: [{
                        selector: '[nxTabLink]',
                        host: {
                            '[class.nx-tab-link]': 'true',
                            '[class.is-active]': 'active',
                            '[attr.aria-current]': 'active',
                        }
                    },] }
        ];
        /** @nocollapse */
        NxTabLinkDirective.ctorParameters = function () {
            return [
                { type: NxTabNavBarComponent, decorators: [{ type: core$1.Optional }, { type: core$1.SkipSelf }] }
            ];
        };
        NxTabLinkDirective.propDecorators = {
            active: [{ type: core$1.Input }]
        };
        return NxTabLinkDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxTabsModule = /** @class */ (function () {
        function NxTabsModule() {
        }
        NxTabsModule.decorators = [
            { type: core$1.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            portal.PortalModule,
                            accordion$1.NxAccordionModule
                        ],
                        exports: [
                            NxTabComponent,
                            NxTabGroupComponent,
                            NxTabLabelDirective,
                            NxTabHeaderComponent,
                            NxTabBodyComponent,
                            NxTabNavBarComponent,
                            NxTabLinkDirective
                        ],
                        declarations: [
                            NxTabComponent,
                            NxTabGroupComponent,
                            NxTabLabelDirective,
                            NxTabHeaderComponent,
                            NxTabBodyComponent,
                            NxTabNavBarComponent,
                            NxTabLinkDirective
                        ],
                        providers: [],
                    },] }
        ];
        return NxTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BREAKPOINT_MOBILE = '(max-width: 703px)';
    /** @type {?} */
    var BREAKPOINT_TABLET = '(min-width: 704px) and (max-width: 992px)';
    /** @type {?} */
    var BREAKPOINT_DESKTOP = '(min-width: 993px)';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MappedStyles = /** @class */ (function () {
        function MappedStyles(mapping, baseClasses, _elementRef, _renderer) {
            if (baseClasses === void 0) {
                baseClasses = [];
            }
            this.mapping = mapping;
            this.baseClasses = baseClasses;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.classNames = '';
        }
        Object.defineProperty(MappedStyles.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._classNames === value) {
                    return;
                }
                utils.removeClasses(this._renderer, this._elementRef, this._classNamesSanitized);
                this._classNamesSanitized = utils.mapClassNames(value, this.baseClasses, this.mapping);
                this._classNames = value;
                utils.appendClasses(this._renderer, this._elementRef, this._classNamesSanitized);
            },
            enumerable: true,
            configurable: true
        });
        return MappedStyles;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardComponent = /** @class */ (function () {
        function NxCardComponent(_changeDetectorRef, tabindex) {
            this._changeDetectorRef = _changeDetectorRef;
            this._disabled = false;
            /**
             * Event emitted when the selected value has changed.
             */
            this.selectedChange = new core$1.EventEmitter();
            this._tabindex = tabindex;
        }
        Object.defineProperty(NxCardComponent.prototype, "selectable", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectable;
            },
            /** Whether this card is selectable or not.  */
            set: /**
             * Whether this card is selectable or not.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._selectable = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCardComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            /** Whether this card is selected or not.  */
            set: /**
             * Whether this card is selected or not.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._selected = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxCardComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            /** Whether the card is disabled.  */
            set: /**
             * Whether the card is disabled.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxCardComponent.prototype._toggleSelected = /**
         * @return {?}
         */
            function () {
                if (this.selectable && !this.disabled) {
                    this.selected = !this.selected;
                    this.selectedChange.emit(this.selected);
                }
            };
        /**
         * @return {?}
         */
        NxCardComponent.prototype._getTabindex = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return '-1';
                }
                if (this.selectable) {
                    return this._tabindex || '0';
                }
                return this._tabindex || '';
            };
        NxCardComponent.decorators = [
            { type: core$1.Component, args: [{
                        template: '<ng-content></ng-content>',
                        selector: 'nx-card',
                        changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                        host: {
                            'class': 'nx-card',
                            '[class.is-selectable]': 'selectable',
                            '[class.is-selected]': 'selected',
                            '[class.is-disabled]': 'disabled',
                            '[attr.aria-disabled]': 'disabled',
                            '(click)': '_toggleSelected()',
                            '(keydown.enter)': '_toggleSelected()',
                            '[attr.tabindex]': '_getTabindex()'
                        },
                        styles: [":host{background:#fff;border:1px solid #d9d9d9;border-radius:4px;box-shadow:none;display:inline-block;margin-bottom:24px;padding:24px;transition:background-color .2s,box-shadow .2s}:host.is-selectable{cursor:pointer}:host.is-selectable:hover{background-color:#f5f5f5}:host.is-selectable:focus,:host.is-selectable:hover{outline:0}:host.is-selected{box-shadow:0 8px 24px rgba(65,65,65,.35);background-color:#f5f5f5}:host.is-disabled{cursor:not-allowed;opacity:.4}:host.is-disabled:hover{background-color:#fff}:host.is-disabled:focus{outline:0}:host-context([data-whatinput=keyboard]):focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}@media screen and (-ms-high-contrast:active){:host.is-selectable:focus,:host.is-selectable:hover{border-color:highlight}:host.is-selected{box-shadow:0 0 0 2px windowText}:host.is-selected:focus,:host.is-selected:hover{box-shadow:0 0 0 2px highlight}}"]
                    }] }
        ];
        /** @nocollapse */
        NxCardComponent.ctorParameters = function () {
            return [
                { type: core$1.ChangeDetectorRef },
                { type: String, decorators: [{ type: core$1.Attribute, args: ['tabindex',] }] }
            ];
        };
        NxCardComponent.propDecorators = {
            selectable: [{ type: core$1.Input }],
            selected: [{ type: core$1.Input }],
            disabled: [{ type: core$1.Input }],
            selectedChange: [{ type: core$1.Output }]
        };
        return NxCardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxCardModule = /** @class */ (function () {
        function NxCardModule() {
        }
        NxCardModule.decorators = [
            { type: core$1.NgModule, args: [{
                        declarations: [NxCardComponent],
                        exports: [NxCardComponent],
                        imports: [
                            common.CommonModule
                        ]
                    },] }
        ];
        return NxCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NdbxModule = NdbxModule;
    exports.NxButtonModule = NxButtonModule;
    exports.NxButtonComponent = NxButtonComponent;
    exports.NxIconButtonComponent = NxIconButtonComponent;
    exports.NxCheckboxModule = NxCheckboxModule;
    exports.NxCheckboxChangeEvent = NxCheckboxChangeEvent;
    exports.NxCheckboxGroupComponent = NxCheckboxGroupComponent;
    exports.NxCheckboxComponent = NxCheckboxComponent;
    exports.NxRadioModule = NxRadioModule;
    exports.NxRadioGroupComponent = NxRadioGroupComponent;
    exports.NxRadioComponent = NxRadioComponent;
    exports.NxCopytextModule = NxCopytextModule;
    exports.NxCopytextComponent = NxCopytextComponent;
    exports.NxHeadlineModule = NxHeadlineModule;
    exports.NxHeadlineComponent = NxHeadlineComponent;
    exports.NxLinkModule = NxLinkModule;
    exports.NxLinkComponent = NxLinkComponent;
    exports.NxCircleToggleModule = NxCircleToggleModule;
    exports.NxMobileToggleButtonComponent = NxMobileToggleButtonComponent;
    exports.ToggleChangeEvent = ToggleChangeEvent;
    exports.NxCircleToggleComponent = NxCircleToggleComponent;
    exports.NxIconToggleButtonComponent = NxIconToggleButtonComponent;
    exports.NxCircleToggleGroupComponent = NxCircleToggleGroupComponent;
    exports.NxListModule = NxListModule;
    exports.NxListComponent = NxListComponent;
    exports.NxRadioToggleModule = NxRadioToggleModule;
    exports.NxRadioToggleComponent = NxRadioToggleComponent;
    exports.NxCheckboxCircleModule = NxCheckboxCircleModule;
    exports.NxCheckboxCircleComponent = NxCheckboxCircleComponent;
    exports.NxSpinnerComponent = NxSpinnerComponent;
    exports.NxSpinnerModule = NxSpinnerModule;
    exports.NxModalModule = NxModalModule;
    exports.NxModalActionsDirective = NxModalActionsDirective;
    exports.NxModalContentDirective = NxModalContentDirective;
    exports.NxModalComponent = NxModalComponent;
    exports.NxOpenModalOnClickDirective = NxOpenModalOnClickDirective;
    exports.NxModalService = NxModalService;
    exports.NxSwitcherModule = NxSwitcherModule;
    exports.NxSwitcherComponent = NxSwitcherComponent;
    exports.NxPopoverModule = NxPopoverModule;
    exports.NxPopoverComponent = NxPopoverComponent;
    exports.NxPopoverTriggerDirective = NxPopoverTriggerDirective;
    exports.NxPopoverContentDirective = NxPopoverContentDirective;
    exports.NxTaglistModule = NxTaglistModule;
    exports.NxTaglistComponent = NxTaglistComponent;
    exports.NxImageModule = NxImageModule;
    exports.NxFigureComponent = NxFigureComponent;
    exports.NxImageDirective = NxImageDirective;
    exports.NxRadioCircleModule = NxRadioCircleModule;
    exports.NxRadioCircleComponent = NxRadioCircleComponent;
    exports.NxRadioCircleSvgButtonComponent = NxRadioCircleSvgButtonComponent;
    exports.NxRadioCircleIconButtonComponent = NxRadioCircleIconButtonComponent;
    exports.NxVideoModule = NxVideoModule;
    exports.NxVideoComponent = NxVideoComponent;
    exports.NxDropdownModule = NxDropdownModule;
    exports.NxDropdownSelectChange = NxDropdownSelectChange;
    exports.SELECT_PANEL_MAX_HEIGHT = SELECT_PANEL_MAX_HEIGHT;
    exports.NxDropdownComponent = NxDropdownComponent;
    exports.NxDropdownItemChange = NxDropdownItemChange;
    exports.NxDropdownItemComponent = NxDropdownItemComponent;
    exports.NxDropdownGroupComponent = NxDropdownGroupComponent;
    exports.NxAutocompleteModule = NxAutocompleteModule;
    exports.NxAutocompleteOptionSelected = NxAutocompleteOptionSelected;
    exports.NxAutocompleteOptionComponent = NxAutocompleteOptionComponent;
    exports.NxAutocompleteSelectedEvent = NxAutocompleteSelectedEvent;
    exports.NxAutocompleteComponent = NxAutocompleteComponent;
    exports.getNxAutocompleteMissingPanelError = getNxAutocompleteMissingPanelError;
    exports.NX_AUTOCOMPLETE_VALUE_ACCESSOR = NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    exports.NxAutocompleteTriggerDirective = NxAutocompleteTriggerDirective;
    exports.NxNaturalLanguageFormModule = NxNaturalLanguageFormModule;
    exports.NxNaturalLanguageFormComponent = NxNaturalLanguageFormComponent;
    exports.NxWordComponent = NxWordComponent;
    exports.NxMessageModule = NxMessageModule;
    exports.NxMessageComponent = NxMessageComponent;
    exports.NxPageSearchModule = NxPageSearchModule;
    exports.NxPageSearchComponent = NxPageSearchComponent;
    exports.NxRatingModule = NxRatingModule;
    exports.NxRatingComponent = NxRatingComponent;
    exports.NxNumberStepperModule = NxNumberStepperModule;
    exports.NxNumberStepperComponent = NxNumberStepperComponent;
    exports.NxNumberStepperPrefixDirective = NxNumberStepperPrefixDirective;
    exports.NxNumberStepperSuffixDirective = NxNumberStepperSuffixDirective;
    exports.NxNumberStepperIntl = NxNumberStepperIntl;
    exports.NxPaginationModule = NxPaginationModule;
    exports.NxPaginationComponent = NxPaginationComponent;
    exports.DefaultPaginationTexts = DefaultPaginationTexts;
    exports.NX_PAGINATION_TEXTS = NX_PAGINATION_TEXTS;
    exports.NxPaginationUtils = NxPaginationUtils;
    exports.NxDynamicTableModule = NxDynamicTableModule;
    exports.NxDynamicTableComponent = NxDynamicTableComponent;
    exports.NxExpansionPanelComponent = NxExpansionPanelComponent;
    exports.NxAccordionDirective = NxAccordionDirective;
    exports.NxAccordionModule = NxAccordionModule;
    exports.NxTabsModule = NxTabsModule;
    exports.NxTabComponent = NxTabComponent;
    exports.NxTabChangeEvent = NxTabChangeEvent;
    exports.NxTabGroupComponent = NxTabGroupComponent;
    exports.NxTabHeaderComponent = NxTabHeaderComponent;
    exports.NxTabBodyComponent = NxTabBodyComponent;
    exports.NxTabLabelDirective = NxTabLabelDirective;
    exports.NxTabNavBarComponent = NxTabNavBarComponent;
    exports.NxTabLinkDirective = NxTabLinkDirective;
    exports.BREAKPOINT_MOBILE = BREAKPOINT_MOBILE;
    exports.BREAKPOINT_TABLET = BREAKPOINT_TABLET;
    exports.BREAKPOINT_DESKTOP = BREAKPOINT_DESKTOP;
    exports.MappedStyles = MappedStyles;
    exports.NxCardComponent = NxCardComponent;
    exports.NxCardModule = NxCardModule;
    exports.p = nxAccordionAnimations;
    exports.q = NxExpansionPanelBodyDirective;
    exports.s = NxExpansionPanelDescriptionDirective;
    exports.r = NxExpansionPanelHeaderComponent;
    exports.t = NxExpansionPanelTitleDirective;
    exports.a = NX_BUTTON_HOST_BINDINGS;
    exports.b = NxButtonBase;
    exports.c = ToggleButton;
    exports.n = NxDropdownClosedLabelDirective;
    exports.m = NxDropdownControl;
    exports.d = NxListIconComponent;
    exports.g = fadeIn;
    exports.h = fadeOut;
    exports.j = scaleDown;
    exports.i = scaleUp;
    exports.o = NxAutoResizeDirective;
    exports.l = NxRadioCircleButton;
    exports.e = NxRadioToggleButtonBaseComponent;
    exports.f = NxRadioToggleButtonComponent;
    exports.u = NxTabGroupBase;
    exports.k = NxTagComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=allianz-ngx-ndbx.umd.js.map