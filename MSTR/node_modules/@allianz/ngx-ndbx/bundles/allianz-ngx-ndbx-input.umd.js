(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('@angular/forms'), require('rxjs'), require('@allianz/ngx-ndbx/formfield'), require('@allianz/ngx-ndbx/utils'), require('@angular/core'), require('@angular/cdk/keycodes'), require('@allianz/ngx-ndbx/icon')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/input', ['exports', '@angular/common', '@angular/cdk/coercion', '@angular/cdk/platform', '@angular/forms', 'rxjs', '@allianz/ngx-ndbx/formfield', '@allianz/ngx-ndbx/utils', '@angular/core', '@angular/cdk/keycodes', '@allianz/ngx-ndbx/icon'], factory) :
    (factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].input = {}),global.ng.common,global.ng.cdk.coercion,global.ng.cdk.platform,global.ng.forms,global.rxjs,global.allianz['ngx-ndbx'].formfield,global.allianz['ngx-ndbx'].utils,global.ng.core,global.ng.cdk.keycodes,global.allianz['ngx-ndbx'].icon));
}(this, (function (exports,common,coercion,platform,forms,rxjs,formfield,utils,core,keycodes,icon) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NX_INPUT_VALUE_ACCESSOR = new core.InjectionToken('NX_INPUT_VALUE_ACCESSOR');
    /** @type {?} */
    var INVALID_TYPES = [
        'button',
        'checkbox',
        'file',
        'hidden',
        'image',
        'radio',
        'range',
        'reset',
        'submit'
    ];
    var ɵ0 = /**
     * @param {?} t
     * @return {?}
     */ function (t) { return platform.getSupportedInputTypes().has(t); };
    /** @type {?} */
    var NEVER_EMPTY = [
        'date',
        'datetime',
        'datetime-local',
        'month',
        'time',
        'week'
    ].filter((ɵ0));
    /** @type {?} */
    var nextUniqueId = 0;
    var NxInputDirective = /** @class */ (function () {
        function NxInputDirective(_elementRef, ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor) {
            this._elementRef = _elementRef;
            this.ngControl = ngControl;
            this._parentForm = _parentForm;
            this._parentFormGroup = _parentFormGroup;
            this._errorStateMatcher = _errorStateMatcher;
            this._type = 'text';
            this._uid = "nx-input-" + nextUniqueId++;
            this._disabled = false;
            this._required = false;
            this._readonly = false;
            /**
             * \@docs-private
             */
            this.errorState = false;
            /**
             * \@docs-private
             */
            this.stateChanges = new rxjs.Subject();
            /**
             * \@docs-private
             */
            this.focused = false;
            this.id = this.id;
            // This will enable other directives to plugin itself as the value accessor
            // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
            // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
            // See the datefield for details.
            this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
            this._previousNativeValue = this.value;
        }
        Object.defineProperty(NxInputDirective.prototype, "id", {
            /** The id of the input. */
            get: /**
             * The id of the input.
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value || this._uid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "value", {
            /** The input element's value. */
            get: /**
             * The input element's value.
             * @return {?}
             */ function () { return this._inputValueAccessor.value; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this.value) {
                    this._inputValueAccessor.value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "readonly", {
            /** Whether the element is readonly. */
            get: /**
             * Whether the element is readonly.
             * @return {?}
             */ function () { return this._readonly; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._readonly = coercion.coerceBooleanProperty(value);
                this.stateChanges.next();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "disabled", {
            /** Whether the input is disabled. */
            get: /**
             * Whether the input is disabled.
             * @return {?}
             */ function () {
                if (this.ngControl && this.ngControl.disabled !== null) {
                    return this.ngControl.disabled;
                }
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
                // Browsers may not fire the blur event if the input is disabled too quickly.
                // Reset from here to ensure that the element doesn't become stuck.
                if (this.focused) {
                    this.focused = false;
                    this.stateChanges.next();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "required", {
            /** Whether the element is required. */
            get: /**
             * Whether the element is required.
             * @return {?}
             */ function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this._required = coercion.coerceBooleanProperty(value); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "type", {
            /** Sets the type of the input element (e.g. password, text etc). */
            get: /**
             * Sets the type of the input element (e.g. password, text etc).
             * @return {?}
             */ function () { return this._type; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._type = value || 'text';
                this._validateType();
                // When using Angular inputs, developers are no longer able to set the properties on the native
                // input element. To ensure that bindings for `type` work, we need to sync the setter
                // with the native property. Textarea elements don't support the type property or attribute.
                if (!this._isTextarea() && platform.getSupportedInputTypes().has(this._type)) {
                    this._elementRef.nativeElement.type = this._type;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxInputDirective.prototype, "elementRef", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this._elementRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxInputDirective.prototype._onInput = /**
         * @return {?}
         */
            function () {
                // force to to run change detection so we know about changes in the native form input
            };
        /**
         * @param {?} isFocused
         * @return {?}
         */
        NxInputDirective.prototype._focusChanged = /**
         * @param {?} isFocused
         * @return {?}
         */
            function (isFocused) {
                if (isFocused !== this.focused && !this.readonly) {
                    this.focused = isFocused;
                    this.stateChanges.next();
                }
            };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.stateChanges.next();
            };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.stateChanges.complete();
            };
        /**
         * @return {?}
         */
        NxInputDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this.ngControl) {
                    // We need to re-evaluate this on every change detection cycle, because there are some
                    // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                    // that whatever logic is in here has to be super lean or we risk destroying the performance.
                    this.updateErrorState();
                }
                else {
                    // When the input isn't used together with `@angular/forms`, we need to check manually for
                    // changes to the native `value` property in order to update the floating label.
                    this._dirtyCheckNativeValue();
                }
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxInputDirective.prototype.updateErrorState = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var oldState = this.errorState;
                /** @type {?} */
                var parent = this._parentFormGroup || this._parentForm;
                /** @type {?} */
                var control = this.ngControl ? ( /** @type {?} */(this.ngControl.control)) : null;
                /** @type {?} */
                var newState = this._errorStateMatcher.isErrorState(control, parent);
                if (newState !== oldState) {
                    this.errorState = newState;
                    this.stateChanges.next();
                }
            };
        /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         */
        /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         * @param {?} ids
         * @return {?}
         */
        NxInputDirective.prototype.setDescribedByIds = /**
         * Set a list of ids that is currently describing this input
         * (if you have hints and errors for example).
         * @param {?} ids
         * @return {?}
         */
            function (ids) {
                this._ariaDescribedby = ids.join(' ');
            };
        // allow to set a arial label value in case there
        // is not possibility to display a proper label
        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         */
        // allow to set a arial label value in case there
        // is not possibility to display a proper label
        /**
         * Method to set the aria label.
         * This is required if you use the input outside of a formfield
         * where you don't have a label connected.
         * @param {?} value
         * @return {?}
         */
        NxInputDirective.prototype.setAriaLabel =
            // allow to set a arial label value in case there
            // is not possibility to display a proper label
            /**
             * Method to set the aria label.
             * This is required if you use the input outside of a formfield
             * where you don't have a label connected.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._ariaLabel = value;
            };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isBadInput = /**
         * @protected
         * @return {?}
         */
            function () {
                // The `validity` property won't be present on platform-server.
                /** @type {?} */
                var validity = (( /** @type {?} */(this._elementRef.nativeElement))).validity;
                return validity && validity.badInput;
            };
        Object.defineProperty(NxInputDirective.prototype, "empty", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isNeverEmpty = /**
         * @protected
         * @return {?}
         */
            function () {
                return NEVER_EMPTY.indexOf(this._type) > -1;
            };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._isTextarea = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var nativeElement = this._elementRef.nativeElement;
                return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
            };
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._validateType = /**
         * @protected
         * @return {?}
         */
            function () {
                if (INVALID_TYPES.indexOf(this._type) > -1) {
                    throw new Error("Input of type '" + this._type + "' is not supported");
                }
            };
        Object.defineProperty(NxInputDirective.prototype, "shouldLabelFloat", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return this.focused || !this.empty;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @protected
         * @return {?}
         */
        NxInputDirective.prototype._dirtyCheckNativeValue = /**
         * @protected
         * @return {?}
         */
            function () {
                /** @type {?} */
                var newValue = this.value;
                if (this._previousNativeValue !== newValue) {
                    this._previousNativeValue = newValue;
                    this.stateChanges.next();
                }
            };
        NxInputDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                        host: {
                            '[class.c-input]': 'true',
                            '[attr.id]': 'id',
                            '[class.is-filled]': 'empty === false',
                            '[class.is-disabled]': 'disabled',
                            '[class.has-error]': 'errorState',
                            '[class.is-focused]': 'focused',
                            '[attr.aria-label]': '_ariaLabel || null',
                            '[attr.aria-describedby]': '_ariaDescribedby || null',
                            '[attr.aria-invalid]': 'errorState',
                            '[attr.aria-required]': 'required.toString()',
                            '(blur)': '_focusChanged(false)',
                            '(focus)': '_focusChanged(true)',
                            '(input)': '_onInput()',
                        },
                        providers: [{ provide: formfield.NxFormfieldControl, useExisting: NxInputDirective }],
                    },] }
        ];
        /** @nocollapse */
        NxInputDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
                { type: forms.NgForm, decorators: [{ type: core.Optional }] },
                { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
                { type: utils.ErrorStateMatcher },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [NX_INPUT_VALUE_ACCESSOR,] }] }
            ];
        };
        NxInputDirective.propDecorators = {
            _ariaLabel: [{ type: core.Input, args: ['nxAriaLabel',] }],
            id: [{ type: core.Input }],
            value: [{ type: core.Input }],
            readonly: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            type: [{ type: core.Input }]
        };
        return NxInputDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var visibilityIcons = {
        show: 'password-show-o',
        hide: 'password-hide-o'
    };
    var NxPasswordToggleComponent = /** @class */ (function () {
        function NxPasswordToggleComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * \@docs-private
             */
            this._currentIcon = visibilityIcons['show'];
            /**
             * \@docs-private
             */
            this._pressed = false;
            this._ariaLabel = 'Show password';
        }
        Object.defineProperty(NxPasswordToggleComponent.prototype, "ariaLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this._ariaLabel;
            },
            /** Sets the aria-label needed for accessibility.
             * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
             * E.g if you have an `input[type=password]` at the beginning then the
             * password will be hidden and the correct aria-label would be 'Show password.'
             */
            set: /**
             * Sets the aria-label needed for accessibility.
             * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
             * E.g if you have an `input[type=password]` at the beginning then the
             * password will be hidden and the correct aria-label would be 'Show password.'
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._ariaLabel) {
                    this._ariaLabel = value;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (!this.control) {
                    console.warn('You need to pass an input as a control to the password toggle.');
                }
                else {
                    // show the right icon according to the initial type of the input
                    this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
                }
            };
        /** Toggles the type of the input. */
        /**
         * Toggles the type of the input.
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.toggleInputType = /**
         * Toggles the type of the input.
         * @return {?}
         */
            function () {
                if (this.control) {
                    this.control.type = this.control.type === 'password' ? 'text' : 'password';
                    this._pressed = !this._pressed;
                    this.toggleIcon();
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**@docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxPasswordToggleComponent.prototype.toggleIcon = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
            };
        /**@docs-private */
        /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
        NxPasswordToggleComponent.prototype._onKeydown = /**
         * \@docs-private
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                if ($event && ($event.keyCode === keycodes.ENTER || $event.keyCode === keycodes.SPACE)) {
                    this.toggleInputType();
                }
            };
        Object.defineProperty(NxPasswordToggleComponent.prototype, "tabindex", {
            /**@docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                if (this.control) {
                    return this.control.disabled ? -1 : 0;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        NxPasswordToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-password-toggle',
                        template: "<nx-icon\n      aria-hidden=\"true\"\n      [name]=\"_currentIcon\">\n    </nx-icon>",
                        host: {
                            '[attr.aria-label]': 'ariaLabel',
                            '[attr.tabindex]': 'tabindex',
                            '[attr.aria-pressed]': '_pressed',
                            'role': 'button',
                            '(click)': 'toggleInputType()',
                            '(keydown)': '_onKeydown($event)'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}:host:focus{outline:0}:host-context([data-whatinput=keyboard]):focus ::ng-deep nx-icon{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}:host-context(.is-disabled){pointer-events:none}"]
                    }] }
        ];
        /** @nocollapse */
        NxPasswordToggleComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        NxPasswordToggleComponent.propDecorators = {
            control: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input }]
        };
        return NxPasswordToggleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxInputModule = /** @class */ (function () {
        function NxInputModule() {
        }
        NxInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule,
                            icon.NxIconModule
                        ],
                        declarations: [
                            NxInputDirective,
                            NxPasswordToggleComponent
                        ],
                        exports: [
                            formfield.NxFormfieldModule,
                            NxInputDirective,
                            NxPasswordToggleComponent
                        ]
                    },] }
        ];
        return NxInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NxInputModule = NxInputModule;
    exports.NX_INPUT_VALUE_ACCESSOR = NX_INPUT_VALUE_ACCESSOR;
    exports.NxInputDirective = NxInputDirective;
    exports.NxPasswordToggleComponent = NxPasswordToggleComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=allianz-ngx-ndbx-input.umd.js.map