(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/a11y'), require('@allianz/ngx-ndbx/formfield'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/core'), require('@angular/forms'), require('rxjs'), require('rxjs/operators'), require('@allianz/ngx-ndbx/natural-language-form')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/autocomplete', ['exports', '@angular/cdk/a11y', '@allianz/ngx-ndbx/formfield', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/common', '@angular/core', '@angular/forms', 'rxjs', 'rxjs/operators', '@allianz/ngx-ndbx/natural-language-form'], factory) :
    (factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].autocomplete = {}),global.ng.cdk.a11y,global.allianz['ngx-ndbx'].formfield,global.ng.cdk.bidi,global.ng.cdk.coercion,global.ng.cdk.keycodes,global.ng.cdk.overlay,global.ng.cdk.portal,global.ng.common,global.ng.core,global.ng.forms,global.rxjs,global.rxjs.operators,global.allianz['ngx-ndbx']['natural-language-form']));
}(this, (function (exports,a11y,formfield,bidi,coercion,keycodes,overlay,portal,common,core,forms,rxjs,operators,naturalLanguageForm) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Option selected event
     */
    var /**
     * Option selected event
     */ NxAutocompleteOptionSelected = /** @class */ (function () {
        function NxAutocompleteOptionSelected(source, isUserInput) {
            if (isUserInput === void 0) {
                isUserInput = false;
            }
            this.source = source;
            this.isUserInput = isUserInput;
        }
        return NxAutocompleteOptionSelected;
    }());
    /**
     * Option IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueIdCounter = 0;
    var NxAutocompleteOptionComponent = /** @class */ (function () {
        function NxAutocompleteOptionComponent(elementRef, _changeDetectorRef) {
            this.elementRef = elementRef;
            this._changeDetectorRef = _changeDetectorRef;
            this._id = "nx-autocomplete-option-" + _uniqueIdCounter++;
            this._selected = false;
            this._active = false;
            this._disabled = false;
            /**
             * Event emitted when the option is selected or deselected.
             */
            this.onSelectionChange = new core.EventEmitter();
        }
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "id", {
            /** Id of the autocomplete option. By default it is set to an incremented value. */
            get: /**
             * Id of the autocomplete option. By default it is set to an incremented value.
             * @return {?}
             */ function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: /**
             * Whether or not the option is currently selected.
             * @return {?}
             */ function () { return this._selected; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "active", {
            /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             */
            get: /**
             * Whether or not the option is currently active and ready to be selected.
             * An active option displays styles as if it is focused, but the
             * focus is actually retained somewhere else. This comes in handy
             * for components like autocomplete where focus must remain on the input.
             * @return {?}
             */ function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "disabled", {
            /** Whether the option is disabled. */
            get: /**
             * Whether the option is disabled.
             * @return {?}
             */ function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Ensures the option is selected when activated from the keyboard. */
        /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._handleKeydown = /**
         * Ensures the option is selected when activated from the keyboard.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.keyCode === keycodes.ENTER || event.keyCode === keycodes.SPACE) {
                    this._selectViaInteraction();
                    // Prevent the page from scrolling down and form submits.
                    event.preventDefault();
                }
            };
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         */
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._selectViaInteraction = /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this._selected = true;
                    this._changeDetectorRef.markForCheck();
                    this._emitSelectionChangeEvent(true);
                }
            };
        /** Returns the correct tabindex for the option depending on disabled state. */
        /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._getTabIndex = /**
         * Returns the correct tabindex for the option depending on disabled state.
         * @return {?}
         */
            function () {
                return this.disabled ? '-1' : '0';
            };
        /** Emits the selection change event. */
        /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @private
         * @param {?=} isUserInput
         * @return {?}
         */
            function (isUserInput) {
                if (isUserInput === void 0) {
                    isUserInput = false;
                }
                this.onSelectionChange.emit(new NxAutocompleteOptionSelected(this, isUserInput));
            };
        Object.defineProperty(NxAutocompleteOptionComponent.prototype, "viewValue", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () {
                return (this.elementRef.nativeElement.textContent || '').trim();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setActiveStyles = /**
         * \@docs-private
         * This method sets display styles on the option to make it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
            function () {
                if (!this._active) {
                    this._active = true;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         */
        /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.setInactiveStyles = /**
         * \@docs-private
         * This method removes display styles on the option that made it appear
         * active. This is used by the ActiveDescendantKeyManager so key
         * events will display the proper options as active on arrow key events.
         * @return {?}
         */
            function () {
                if (this._active) {
                    this._active = false;
                    this._changeDetectorRef.markForCheck();
                }
            };
        /**
         * @docs-private
         * Gets the label to be used when determining whether the option should be focused.
         */
        /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.getLabel = /**
         * \@docs-private
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
            function () {
                return this.viewValue;
            };
        /** Selects the option. */
        /**
         * Selects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.select = /**
         * Selects the option.
         * @return {?}
         */
            function () {
                this._selected = true;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            };
        /** Deselects the option. */
        /**
         * Deselects the option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.deselect = /**
         * Deselects the option.
         * @return {?}
         */
            function () {
                this._selected = false;
                this._changeDetectorRef.markForCheck();
                this._emitSelectionChangeEvent();
            };
        /**
         * @docs-private
         * Sets focus onto this option.
         */
        /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
        NxAutocompleteOptionComponent.prototype.focus = /**
         * \@docs-private
         * Sets focus onto this option.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var element = this.elementRef.nativeElement;
                if (typeof element.focus === 'function') {
                    element.focus();
                }
            };
        NxAutocompleteOptionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete-option',
                        template: "<div class=\"nx-autocomplete-option\" [class.nx-active]=\"active\">\n  <div class=\"nx-autocomplete-option__label\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                        host: {
                            'role': 'option',
                            '[attr.tabindex]': '_getTabIndex()',
                            '[id]': 'id',
                            '[attr.aria-selected]': 'selected.toString()',
                            '[attr.aria-disabled]': 'disabled.toString()',
                            '(click)': '_selectViaInteraction()',
                            '(keydown)': '_handleKeydown($event)',
                            '[class.nx-active]': 'active',
                            '[class.nx-disabled]': 'disabled',
                            '[style.display]': '\'block\'' // needed for to be able to calculate offset height
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host:focus{outline:0}.nx-autocomplete-option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-autocomplete-option.nx-active,.nx-autocomplete-option:hover{color:highlightText}}.nx-autocomplete-option__label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host-context([data-whatinput=keyboard]) .nx-autocomplete-option.nx-active .nx-autocomplete-option__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteOptionComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef }
            ];
        };
        NxAutocompleteOptionComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            onSelectionChange: [{ type: core.Output }]
        };
        return NxAutocompleteOptionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Autocomplete IDs need to be unique across components, so this counter exists outside of
     * the component definition.
     * @type {?}
     */
    var _uniqueAutocompleteIdCounter = 0;
    /**
     * Event object that is emitted when an autocomplete option is selected.
     */
    var /**
     * Event object that is emitted when an autocomplete option is selected.
     */ NxAutocompleteSelectedEvent = /** @class */ (function () {
        function NxAutocompleteSelectedEvent(source, option) {
            this.source = source;
            this.option = option;
        }
        return NxAutocompleteSelectedEvent;
    }());
    var NxAutocompleteComponent = /** @class */ (function () {
        function NxAutocompleteComponent(_changeDetectorRef, _elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._elementRef = _elementRef;
            /**
             * Whether the autocomplete panel should be visible, depending on option length.
             */
            this.showPanel = false;
            this._isOpen = false;
            this._items = null;
            this._hasItems = false;
            /**
             * Event that is emitted whenever an option from the list is selected.
             */
            this.optionSelected = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Event that is emitted when the autocomplete panel is closed.
             */
            this.closed = new core.EventEmitter();
            this._classList = {};
            /**
             * Unique ID to be used by autocomplete trigger's "aria-owns" property.
             */
            this.id = "nx-autocomplete-" + _uniqueAutocompleteIdCounter++;
            // As autocomplete option can hold any value, we might need a converter
            // to get a string representation, which can be stored in input. Default value ? value.toString() : null.
            /**
             * Value to string converter.
             */
            this.valueFormatter = ( /**
             * @param {?} value
             * @return {?}
             */function (value) { return value ? value.toString() : null; });
        }
        Object.defineProperty(NxAutocompleteComponent.prototype, "isOpen", {
            /** Whether the autocomplete panel is open. */
            get: /**
             * Whether the autocomplete panel is open.
             * @return {?}
             */ function () { return this._isOpen && this.showPanel; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "items", {
            get: /**
             * @return {?}
             */ function () {
                return this._items;
            },
            /** Items observable. If given, autocomplete takes care of the options and ng-content is discarderd */
            set: /**
             * Items observable. If given, autocomplete takes care of the options and ng-content is discarderd
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._hasItems = true;
                if (Array.isArray(val)) {
                    this._items = val;
                }
                else if (val instanceof rxjs.Observable) {
                    if (this._itemsSubscription) {
                        this._itemsSubscription.unsubscribe();
                    }
                    this._itemsSubscription = val.subscribe(( /**
                     * @param {?} itms
                     * @return {?}
                     */function (itms) {
                        _this._items = itms;
                        _this._changeDetectorRef.markForCheck();
                        // and check visibility in next cycle, when options are set
                        setTimeout(( /**
                         * @return {?}
                         */function () { return _this._setVisibility(); }));
                    }));
                }
                else if (val === null) {
                    this._items = val;
                }
                else {
                    throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "hasItems", {
            /**
             * @docs-private
             * Is items observable set
             */
            get: /**
             * \@docs-private
             * Is items observable set
             * @return {?}
             */ function () {
                return this._hasItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "options", {
            /** Autocomplete options */
            get: /**
             * Autocomplete options
             * @return {?}
             */ function () {
                return this.hasItems ? this._vOptions : this._cOptions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteComponent.prototype, "classList", {
            /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             */
            set: /**
             * Takes classes set on the host nx-autocomplete element and applies them to the panel
             * inside the overlay container to allow for easy styling.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (value && value.length) {
                    value.split(' ').forEach(( /**
                     * @param {?} className
                     * @return {?}
                     */function (className) { return _this._classList[className.trim()] = true; }));
                    this._elementRef.nativeElement.className = '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();
                this._setVisibility();
            };
        /**
         * @return {?}
         */
        NxAutocompleteComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._itemsSubscription) {
                    this._itemsSubscription.unsubscribe();
                }
            };
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         */
        /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setScrollTop = /**
         * Sets the panel scrollTop. This allows us to manually scroll to display options
         * above or below the fold, as they are not actually being focused when active.
         * @param {?} scrollTop
         * @return {?}
         */
            function (scrollTop) {
                if (this.panel) {
                    this.panel.nativeElement.scrollTop = scrollTop;
                }
            };
        /** Returns the panel's scrollTop. */
        /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._getScrollTop = /**
         * Returns the panel's scrollTop.
         * @return {?}
         */
            function () {
                return this.panel ? this.panel.nativeElement.scrollTop : 0;
            };
        /** Panel should hide itself when the option list is empty. */
        /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
        NxAutocompleteComponent.prototype._setVisibility = /**
         * Panel should hide itself when the option list is empty.
         * @return {?}
         */
            function () {
                this.showPanel = !!(this.options && this.options.length);
                this._classList['nx-autocomplete-visible'] = this.showPanel;
                this._classList['nx-autocomplete-hidden'] = !this.showPanel;
                this._changeDetectorRef.markForCheck();
            };
        /** Emits the `select` event. */
        /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
        NxAutocompleteComponent.prototype._emitSelectEvent = /**
         * Emits the `select` event.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                /** @type {?} */
                var event = new NxAutocompleteSelectedEvent(this, option);
                this.optionSelected.emit(event);
            };
        NxAutocompleteComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'nx-autocomplete',
                        template: "<ng-template>\n  <div class=\"nx-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel>\n    <ng-container *ngIf=\"hasItems\">\n      <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n        {{item}}\n      </nx-autocomplete-option>\n    </ng-container>\n    <ng-container *ngIf=\"!hasItems\">\n      <ng-content></ng-content>\n    </ng-container>\n  </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        exportAs: 'nxAutocomplete',
                        host: {
                            'class': 'nx-autocomplete'
                        },
                        styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:#fff;box-shadow:0 2px 4px rgba(65,65,65,.5);padding:24px;overflow-y:auto;overflow-x:hidden;max-height:336px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}@media screen and (-ms-high-contrast:active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}"]
                    }] }
        ];
        /** @nocollapse */
        NxAutocompleteComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef },
                { type: core.ElementRef }
            ];
        };
        NxAutocompleteComponent.propDecorators = {
            template: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
            panel: [{ type: core.ViewChild, args: ['panel',] }],
            items: [{ type: core.Input }],
            optionSelected: [{ type: core.Output }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            _vOptions: [{ type: core.ViewChildren, args: [NxAutocompleteOptionComponent,] }],
            _cOptions: [{ type: core.ContentChildren, args: [NxAutocompleteOptionComponent, { descendants: true },] }],
            classList: [{ type: core.Input, args: ['class',] }],
            valueFormatter: [{ type: core.Input, args: ['nxValueFormatter',] }]
        };
        return NxAutocompleteComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provider that allows the autocomplete to register as a ControlValueAccessor.
     * \@docs-private
     * @type {?}
     */
    var NX_AUTOCOMPLETE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return NxAutocompleteTriggerDirective; })),
        multi: true
    };
    /**
     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
     * @return {?}
     */
    function getNxAutocompleteMissingPanelError() {
        return Error('Attempting to open an undefined instance of `nx-autocomplete`. ' +
            'Make sure that the id passed to the `nxAutocomplete` is correct and that ' +
            'you\'re attempting to open it after the ngAfterContentInit hook.');
    }
    var NxAutocompleteTriggerDirective = /** @class */ (function () {
        function NxAutocompleteTriggerDirective(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _nxFormField, _nxWordField, _document, _viewportRuler) {
            var _this = this;
            this._element = _element;
            this._overlay = _overlay;
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this._changeDetectorRef = _changeDetectorRef;
            this._dir = _dir;
            this._nxFormField = _nxFormField;
            this._nxWordField = _nxWordField;
            this._document = _document;
            this._viewportRuler = _viewportRuler;
            this._componentDestroyed = false;
            /**
             * Whether or not the label state is being overridden.
             */
            this._manuallyFloatingLabel = false;
            /**
             * Subscription to viewport size changes.
             */
            this._viewportSubscription = rxjs.Subscription.EMPTY;
            /**
             * Stream of keyboard events that can close the panel.
             */
            this._closeKeyEventStream = new rxjs.Subject();
            /**
             * Value changes
             */
            this._valueChanges = new rxjs.Subject();
            this._itemsCb = null;
            this._debounce = 400;
            this._autocompleteDisabled = false;
            this._overlayAttached = false;
            /**
             * Stream of autocomplete option selections.
             */
            this.optionSelections = rxjs.defer(( /**
             * @return {?}
             */function () {
                if (_this.autocomplete && _this.autocomplete.options) {
                    return rxjs.merge.apply(void 0, __spread(_this.autocomplete.options.map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (option) { return option.onSelectionChange; }))));
                }
                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                // Return a stream that we'll replace with the real one once everything is in place.
                return _this._zone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(( /**
             * @return {?}
             */function () { return _this.optionSelections; })));
            }));
            /**
             * `View -> model callback called when value changes`
             */
            this._onChange = ( /**
             * @param {?} val
             * @return {?}
             */function (val) {
                _this._valueChanges.next(val);
            });
            /**
             * `View -> model callback called when autocomplete has been touched`
             */
            this._onTouched = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "itemsCb", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsCb;
            },
            /** The items callback. Called with input value, must return Observable of Array of strings */
            set: /**
             * The items callback. Called with input value, must return Observable of Array of strings
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (typeof val === 'function') {
                    this._itemsCb = val;
                }
                else {
                    throw new Error('Wrong value type for nxAutocompleteItems');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "debounce", {
            /** Debounce in ms before items callback is triggered. Defaults to 400 */
            set: /**
             * Debounce in ms before items callback is triggered. Defaults to 400
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._debounce = coercion.coerceNumberProperty(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "autocompleteDisabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._autocompleteDisabled;
            },
            /** Whether autocomplete functionality is disabled. */
            set: /**
             * Whether autocomplete functionality is disabled.
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._autocompleteDisabled = val;
                this._bindAutocompleteItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelOpen", {
            /** Whether or not the autocomplete panel is open. */
            get: /**
             * Whether or not the autocomplete panel is open.
             * @return {?}
             */ function () {
                return this._overlayAttached && this.autocomplete.showPanel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "activeOption", {
            /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
            get: /**
             * The currently active option, coerced to NxAutocompleteOptionComponent type.
             * @return {?}
             */ function () {
                if (this.autocomplete && this.autocomplete._keyManager) {
                    return this.autocomplete._keyManager.activeItem;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_outsideClickStream", {
            /** Stream of clicks outside of the autocomplete panel. */
            get: /**
             * Stream of clicks outside of the autocomplete panel.
             * @private
             * @return {?}
             */ function () {
                var _this = this;
                if (!this._document) {
                    return rxjs.of(null);
                }
                return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))
                    .pipe(operators.filter(( /**
             * @param {?} event
             * @return {?}
             */function (event) {
                    /** @type {?} */
                    var clickTarget = ( /** @type {?} */(event.target));
                    /** @type {?} */
                    var formField = _this._formField ?
                        _this._formField.elementRef.nativeElement : null;
                    return _this._overlayAttached &&
                        clickTarget !== _this._element.nativeElement &&
                        (!formField || !formField.contains(clickTarget)) &&
                        (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                })));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "_formField", {
            get: /**
             * @private
             * @return {?}
             */ function () {
                if (this._nxFormField) {
                    return this._nxFormField;
                }
                else if (this._nxWordField) {
                    return this._nxWordField;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._viewportSubscription.unsubscribe();
                this._componentDestroyed = true;
                this._destroyPanel();
                this._closeKeyEventStream.complete();
                if (this._controlValueChangesSubscription) {
                    this._controlValueChangesSubscription.unsubscribe();
                }
                if (this._itemsSubscription) {
                    this._itemsSubscription.unsubscribe();
                }
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this._bindAutocompleteItems();
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._bindAutocompleteItems();
            };
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         */
        /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._bindAutocompleteItems = /**
         * Binds or rebinds the autocomplete items. Prerequisites:
         * - items callback has to be defined
         * - autocomplete panel has to be bound
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._controlValueChangesSubscription) {
                    this._controlValueChangesSubscription.unsubscribe();
                }
                if (typeof this._itemsCb === 'function' && this.autocomplete && !this.autocompleteDisabled) {
                    /** @type {?} */
                    var itemsSubject_1 = new rxjs.Subject();
                    this.autocomplete.items = itemsSubject_1;
                    /** @type {?} */
                    var valueChanges = this._formField &&
                        this._formField._control &&
                        this._formField._control.ngControl &&
                        this._formField._control.ngControl.valueChanges ?
                        this._formField._control.ngControl.valueChanges : this._valueChanges;
                    this._controlValueChangesSubscription = valueChanges.pipe(operators.debounceTime(this._debounce))
                        .subscribe(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) {
                        if (_this._itemsSubscription) {
                            _this._itemsSubscription.unsubscribe();
                        }
                        _this._itemsSubscription = _this._itemsCb(input).pipe(operators.first()).subscribe(( /**
                         * @param {?} result
                         * @return {?}
                         */function (result) {
                            itemsSubject_1.next(result);
                        }), ( /**
                         * @param {?} err
                         * @return {?}
                         */function (err) {
                            // On error reset
                            // TODO: Log error?
                            itemsSubject_1.next([]);
                        }));
                    }));
                }
            };
        /** Opens the autocomplete suggestion panel. */
        /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.openPanel = /**
         * Opens the autocomplete suggestion panel.
         * @return {?}
         */
            function () {
                if (!this.autocompleteDisabled) {
                    this._attachOverlay();
                    this._floatLabel();
                }
            };
        /** Closes the autocomplete suggestion panel. */
        /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.closePanel = /**
         * Closes the autocomplete suggestion panel.
         * @return {?}
         */
            function () {
                this._resetLabel();
                if (!this._overlayAttached) {
                    return;
                }
                if (this.panelOpen) {
                    // Only emit if the panel was visible.
                    this.autocomplete.closed.emit();
                }
                this.autocomplete._isOpen = this._overlayAttached = false;
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                    this._closingActionsSubscription.unsubscribe();
                }
                // Note that in some cases this can end up being called after the component is destroyed.
                // Add a check to ensure that we don't try to run change detection on a destroyed view.
                if (!this._componentDestroyed) {
                    // We need to trigger change detection manually, because
                    // `fromEvent` doesn't seem to do it at the proper time.
                    // This ensures that the label is reset when the
                    // user clicks outside.
                    this._changeDetectorRef.detectChanges();
                }
            };
        Object.defineProperty(NxAutocompleteTriggerDirective.prototype, "panelClosingActions", {
            /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             */
            get: /**
             * A stream of actions that should close the autocomplete panel, including
             * when an option is selected, on blur, and when TAB is pressed.
             * @return {?}
             */ function () {
                var _this = this;
                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(( /**
                 * @return {?}
                 */function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._outsideClickStream, this._overlayRef ?
                    this._overlayRef.detachments().pipe(operators.filter(( /**
                     * @return {?}
                     */function () { return _this._overlayAttached; }))) :
                    rxjs.of());
            },
            enumerable: true,
            configurable: true
        });
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.writeValue =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                var _this = this;
                Promise.resolve(null).then(( /**
                 * @return {?}
                 */function () { return _this._setTriggerValue(value); }));
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnChange =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onChange = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.registerOnTouched =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onTouched = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype.setDisabledState =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} isDisabled
             * @return {?}
             */
            function (isDisabled) {
                this._element.nativeElement.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var keyCode = event.keyCode;
                // Prevent the default action on all escape key presses. This is here primarily to bring IE
                // in line with other browsers. By default, pressing escape on IE will cause it to revert
                // the input value to the one that it had on focus, however it won't dispatch any events
                // which means that the model value will be out of sync with the view.
                if (keyCode === keycodes.ESCAPE) {
                    event.preventDefault();
                }
                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                if (this.panelOpen && (keyCode === keycodes.ESCAPE || (keyCode === keycodes.UP_ARROW && event.altKey))) {
                    this._resetActiveItem();
                    this._closeKeyEventStream.next();
                    event.stopPropagation();
                }
                else if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {
                    this.activeOption._selectViaInteraction();
                    this._resetActiveItem();
                    event.preventDefault();
                }
                else {
                    /** @type {?} */
                    var prevActiveItem = this.autocomplete._keyManager.activeItem;
                    /** @type {?} */
                    var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;
                    if (this.panelOpen || keyCode === keycodes.TAB) {
                        this.autocomplete._keyManager.onKeydown(event);
                    }
                    else if (isArrowKey && this._isFieldEnabled()) {
                        this.openPanel();
                    }
                    if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                        this._scrollToOption();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleInput = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var target = ( /** @type {?} */(event.target));
                /** @type {?} */
                var value = target.value;
                // Based on `NumberValueAccessor` from forms.
                if (target.type === 'number') {
                    value = value === '' ? null : parseFloat(value);
                }
                // If the input has a placeholder, IE will fire the `input` event on page load,
                // focus and blur, in addition to when the user actually changed the value. To
                // filter out all of the extra events, we save the value on focus and between
                // `input` events, and we check whether it changed.
                // See: https://connect.microsoft.com/IE/feedback/details/885747/
                if (this._isFieldEnabled() && this._previousValue !== value &&
                    document.activeElement === event.target) {
                    this._previousValue = value;
                    this._onChange(value);
                    this.openPanel();
                }
            };
        /**
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._handleFocus = /**
         * @return {?}
         */
            function () {
                if (this._isFieldEnabled()) {
                    this._previousValue = this._element.nativeElement.value;
                    this.openPanel();
                }
            };
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @param shouldAnimate Whether the label should be animated when it is floated.
         */
        /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._floatLabel = /**
         * In "auto" mode, the label will animate down as soon as focus is lost.
         * This causes the value to jump when selecting an option with the mouse.
         * This method manually floats the label until the panel can be closed.
         * @private
         * @return {?}
         */
            function () {
                if (this._nxFormField && this._nxFormField.floatLabel === 'auto') {
                    this._nxFormField.floatLabel = 'always';
                    this._manuallyFloatingLabel = true;
                }
            };
        /** If the label has been manually elevated, return it to its normal state. */
        /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetLabel = /**
         * If the label has been manually elevated, return it to its normal state.
         * @private
         * @return {?}
         */
            function () {
                if (this._manuallyFloatingLabel) {
                    this._nxFormField.floatLabel = 'auto';
                    this._manuallyFloatingLabel = false;
                }
            };
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         */
        /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollToOption = /**
         * Given that we are not actually focusing active options, we must manually adjust scroll
         * to reveal options below the fold. First, we find the offset of the option from the top
         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
         * the panel height + the option height, so the active option will be just visible at the
         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
         * will become the offset. If that offset is visible within the panel already, the scrollTop is
         * not adjusted.
         * @private
         * @return {?}
         */
            function () {
                if (this.autocomplete.options.length === 0) {
                    return;
                }
                /** @type {?} */
                var optionOffset = 0;
                /** @type {?} */
                var optionHeight = this.autocomplete.options.first.elementRef.nativeElement.offsetHeight;
                if (this.autocomplete._keyManager.activeItem) {
                    optionOffset = this.autocomplete._keyManager.activeItem.elementRef.nativeElement.offsetTop;
                }
                /** @type {?} */
                var newScrollPosition = _getOptionScrollPosition(optionOffset, optionHeight, this.autocomplete._getScrollTop(), this.autocomplete.panel.nativeElement.offsetHeight);
                this.autocomplete._setScrollTop(newScrollPosition);
            };
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         */
        /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._subscribeToClosingActions = /**
         * This method listens to a stream of panel closing actions and resets the
         * stream every time the option list changes.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));
                /** @type {?} */
                var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(( /**
                 * @return {?}
                 */function () { return _this._positionStrategy.reapplyLastPosition(); })), 
                // Defer emitting to the stream until the next tick, because changing
                // bindings in here will cause "changed after checked" errors.
                operators.delay(0));
                // When the zone is stable initially, and when the option list changes...
                return rxjs.merge(firstStable, optionChanges)
                    .pipe(
                // create a new stream of panelClosingActions, replacing any previous streams
                // that were created, and flatten it so our stream only emits closing events...
                operators.switchMap(( /**
                 * @return {?}
                 */function () {
                    _this._resetActiveItem();
                    _this.autocomplete._setVisibility();
                    return _this.panelClosingActions;
                })), 
                // when the first closing event occurs...
                operators.take(1))
                    // set the value, close the panel, and complete.
                    .subscribe(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this._setValueAndClose(event); }));
            };
        /** Destroys the autocomplete suggestion panel. */
        /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._destroyPanel = /**
         * Destroys the autocomplete suggestion panel.
         * @private
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this.closePanel();
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setTriggerValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var toDisplay = this.autocomplete && this.autocomplete.valueFormatter ?
                    this.autocomplete.valueFormatter(value) :
                    value;
                // Simply falling back to an empty string if the display value is falsy does not work properly.
                // The display value can also be the number zero and shouldn't fall back to an empty string.
                /** @type {?} */
                var inputValue = toDisplay != null ? toDisplay : '';
                // If it's used within a `NxFormField` or `NxWord`, we should set it through the property so it can go
                // through change detection.
                if (this._formField) {
                    this._formField._control.value = inputValue;
                }
                else {
                    this._element.nativeElement.value = inputValue;
                }
            };
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         */
        /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._setValueAndClose = /**
         * This method closes the panel, and if a value is specified, also sets the associated
         * control to that value. It will also mark the control as dirty if this interaction
         * stemmed from the user.
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event && event.source) {
                    this._clearPreviousSelectedOption(event.source);
                    this._setTriggerValue(event.source.value);
                    this._onChange(event.source.value);
                    this._element.nativeElement.focus();
                    this.autocomplete._emitSelectEvent(event.source);
                }
                this.closePanel();
            };
        /**
         * Clear any previous selected option and emit a selection change event for this option
         */
        /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._clearPreviousSelectedOption = /**
         * Clear any previous selected option and emit a selection change event for this option
         * @private
         * @param {?} skip
         * @return {?}
         */
            function (skip) {
                this.autocomplete.options.forEach(( /**
                 * @param {?} option
                 * @return {?}
                 */function (option) {
                    if (option !== skip && option.selected) {
                        option.deselect();
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._attachOverlay = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.autocomplete) {
                    throw getNxAutocompleteMissingPanelError();
                }
                if (!this._overlayRef) {
                    this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);
                    this._overlayRef = this._overlay.create(this._getOverlayConfig());
                    if (this._viewportRuler) {
                        this._viewportSubscription = this._viewportRuler.change().subscribe(( /**
                         * @return {?}
                         */function () {
                            if (_this.panelOpen && _this._overlayRef) {
                                _this._overlayRef.updateSize({ minWidth: _this._getHostWidth() });
                            }
                        }));
                    }
                }
                else {
                    /** Update the panel width, in case the host width has changed */
                    this._overlayRef.updateSize({ minWidth: this._getHostWidth() });
                }
                if (this._overlayRef && !this._overlayRef.hasAttached()) {
                    this._overlayRef.attach(this._portal);
                    this._closingActionsSubscription = this._subscribeToClosingActions();
                }
                /** @type {?} */
                var wasOpen = this.panelOpen;
                this.autocomplete._setVisibility();
                this.autocomplete._isOpen = this._overlayAttached = true;
                // We need to do an extra `panelOpen` check in here, because the
                // autocomplete won't be shown if there are no options.
                if (this.panelOpen && wasOpen !== this.panelOpen) {
                    this.autocomplete.opened.emit();
                }
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayConfig = /**
         * @private
         * @return {?}
         */
            function () {
                return new overlay.OverlayConfig({
                    positionStrategy: this._getOverlayPosition(),
                    scrollStrategy: this._scrollStrategy(),
                    minWidth: this._getHostWidth(),
                    direction: this._dir ? this._dir.value : 'ltr'
                });
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getOverlayPosition = /**
         * @private
         * @return {?}
         */
            function () {
                this._positionStrategy = this._overlay.position()
                    .flexibleConnectedTo(this._getConnectedElement())
                    .withViewportMargin(16)
                    .withPush(false)
                    .withPositions([
                    {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    },
                    {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom',
                    }
                ]);
                return this._positionStrategy;
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._scrollStrategy = /**
         * @private
         * @return {?}
         */
            function () {
                return this._overlay.scrollStrategies.reposition();
            };
        /**
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getConnectedElement = /**
         * @private
         * @return {?}
         */
            function () {
                return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
            };
        /** Returns the width of the input element, so the panel min-width can match it. */
        /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._getHostWidth = /**
         * Returns the width of the input element, so the panel min-width can match it.
         * @private
         * @return {?}
         */
            function () {
                return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
            };
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         */
        /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._resetActiveItem = /**
         * Resets the active item to -1 so arrow events will activate the
         * correct options, or to 0 if the consumer opted into it.
         * @private
         * @return {?}
         */
            function () {
                this.autocomplete._keyManager.setActiveItem(-1);
            };
        /** Determines whether the panel can be opened. */
        /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
        NxAutocompleteTriggerDirective.prototype._isFieldEnabled = /**
         * Determines whether the panel can be opened.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var element = this._element.nativeElement;
                return !element.readOnly && !element.disabled;
            };
        NxAutocompleteTriggerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "input[nxAutocomplete], textarea[nxAutocomplete]",
                        host: {
                            'role': 'combobox',
                            'autocomplete': 'off',
                            'aria-autocomplete': 'list',
                            '[attr.aria-activedescendant]': 'activeOption?.id',
                            '[attr.aria-expanded]': 'panelOpen.toString()',
                            '[attr.aria-owns]': 'autocomplete?.id',
                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                            // a little earlier. This avoids issues where IE delays the focusing of the input.
                            '(focusin)': '_handleFocus()',
                            '(blur)': '_onTouched()',
                            '(input)': '_handleInput($event)',
                            '(keydown)': '_handleKeydown($event)',
                        },
                        exportAs: 'nxAutocompleteTrigger',
                        providers: [NX_AUTOCOMPLETE_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        NxAutocompleteTriggerDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: overlay.Overlay },
                { type: core.ViewContainerRef },
                { type: core.NgZone },
                { type: core.ChangeDetectorRef },
                { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
                { type: formfield.NxFormfieldComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
                { type: naturalLanguageForm.NxWordComponent, decorators: [{ type: core.Optional }, { type: core.Host }] },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: overlay.ViewportRuler }
            ];
        };
        NxAutocompleteTriggerDirective.propDecorators = {
            autocomplete: [{ type: core.Input, args: ['nxAutocomplete',] }],
            itemsCb: [{ type: core.Input, args: ['nxAutocompleteItems',] }],
            debounce: [{ type: core.Input, args: ['nxAutocompleteDebounce',] }],
            autocompleteDisabled: [{ type: core.Input, args: ['nxAutocompleteDisabled',] }]
        };
        return NxAutocompleteTriggerDirective;
    }());
    /**
     * Determines the position to which to scroll a panel in order for an option to be into view.
     * \@docs-private
     * @param {?} optionOffset Option offset
     * @param {?} optionHeight Height of the options.
     * @param {?} currentScrollPosition Current scroll position of the panel.
     * @param {?} panelHeight Height of the panel.
     * @return {?}
     */
    function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxAutocompleteModule = /** @class */ (function () {
        function NxAutocompleteModule() {
        }
        NxAutocompleteModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        exports: [NxAutocompleteComponent, NxAutocompleteOptionComponent, NxAutocompleteTriggerDirective],
                        imports: [common.CommonModule, overlay.OverlayModule, a11y.A11yModule]
                    },] }
        ];
        return NxAutocompleteModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NxAutocompleteModule = NxAutocompleteModule;
    exports.NxAutocompleteOptionSelected = NxAutocompleteOptionSelected;
    exports.NxAutocompleteOptionComponent = NxAutocompleteOptionComponent;
    exports.NxAutocompleteSelectedEvent = NxAutocompleteSelectedEvent;
    exports.NxAutocompleteComponent = NxAutocompleteComponent;
    exports.getNxAutocompleteMissingPanelError = getNxAutocompleteMissingPanelError;
    exports.NX_AUTOCOMPLETE_VALUE_ACCESSOR = NX_AUTOCOMPLETE_VALUE_ACCESSOR;
    exports.NxAutocompleteTriggerDirective = NxAutocompleteTriggerDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=allianz-ngx-ndbx-autocomplete.umd.js.map