(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/utils', ['exports', '@angular/core'], factory) :
    (factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].utils = {}),global.ng.core));
}(this, (function (exports,i0) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function isString(value) {
        return typeof value === 'string';
    }
    /**
     * @param {?} str
     * @param {?=} length
     * @param {?=} padCharacter
     * @return {?}
     */
    function pad(str, length, padCharacter) {
        if (length === void 0) {
            length = 2;
        }
        if (padCharacter === void 0) {
            padCharacter = '0';
        }
        if (!isString(str) || str.length >= length) {
            return str;
        }
        while (str.length < length) {
            str = padCharacter + str;
        }
        return str;
    }
    // DATE -> YYYY-MM-DD
    /**
     * @param {?} date
     * @return {?}
     */
    function formatDate(date) {
        /** @type {?} */
        var dateOfBirth = [
            String(date.getFullYear()),
            pad(String(date.getMonth() + 1)),
            pad(String(date.getDate()))
        ].join('-');
        return dateOfBirth;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    function formatDateHuman(date) {
        /** @type {?} */
        var dateOfBirth = [
            pad(String(date.getDate())),
            pad(String(date.getMonth() + 1)),
            String(date.getFullYear())
        ].join('-');
        return dateOfBirth;
    }
    /*
      Purpose of this function is to allow a list of short keywords
      expand to longer bem class names with will then be applied to the classname value.

      This function will map a list of keys to values in a MAPPING list.
      Whatever value is found will replace the keyword.
      Every keyword not found will just transfered wiithmout modifying.
    */
    /**
     * @param {?} value
     * @param {?=} DEFAULTS
     * @param {?=} MAPPING
     * @return {?}
     */
    function mapClassNames(value, DEFAULTS, MAPPING) {
        if (DEFAULTS === void 0) {
            DEFAULTS = [];
        }
        if (MAPPING === void 0) {
            MAPPING = {};
        }
        /** @type {?} */
        var sanitizedList = __spread(DEFAULTS);
        if (typeof value === 'string') {
            /** @type {?} */
            var mappedClasses = getClassNameList(value, MAPPING);
            sanitizedList = __spread(sanitizedList, mappedClasses);
        }
        return sanitizedList.join(' ').trim();
    }
    /**
     * @param {?} value
     * @param {?=} MAPPING
     * @return {?}
     */
    function getClassNameList(value, MAPPING) {
        if (MAPPING === void 0) {
            MAPPING = {};
        }
        /** @type {?} */
        var mappedClasses = [];
        if (typeof value === 'string') {
            /** @type {?} */
            var classNames = value.split(' ');
            /** @type {?} */
            var keys_1 = Object.keys(MAPPING);
            mappedClasses = classNames.map(( /**
             * @param {?} className
             * @return {?}
             */function (className) {
                if (keys_1.indexOf(className) > -1) {
                    return MAPPING[className];
                }
                else {
                    return className;
                }
            }));
        }
        return mappedClasses;
    }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} classes
     * @return {?}
     */
    function appendClasses(renderer, element, classes) {
        if (renderer && element && classes) {
            classes.split(' ').forEach(( /**
             * @param {?} item
             * @return {?}
             */function (item) {
                renderer.addClass(element.nativeElement, item);
            }));
        }
    }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} classes
     * @return {?}
     */
    function removeClasses(renderer, element, classes) {
        if (renderer && element && classes) {
            classes.split(' ').forEach(( /**
             * @param {?} item
             * @return {?}
             */function (item) {
                renderer.removeClass(element.nativeElement, item);
            }));
        }
    }
    // YYYY-MM-DD -> DATE
    /**
     * @param {?} dateString
     * @return {?}
     */
    function parseDate(dateString) {
        return new Date(dateString);
    }
    // Manually compose a font shorthand defintion as it's not
    // guaranteed to be given by the computed style object.
    /**
     * @param {?} style
     * @return {?}
     */
    function getFontShorthand(style) {
        var font = style.font, fontStyle = style.fontStyle, fontVariant = style.fontVariant, fontWeight = style.fontWeight, fontSize = style.fontSize, lineHeight = style.lineHeight, fontFamily = style.fontFamily;
        if (font.length > 0) {
            return font;
        }
        return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSize + "/" + lineHeight + " " + fontFamily;
    }
    /**
     * @param {?} number
     * @return {?}
     */
    function numberOfDecimals(number) {
        /** @type {?} */
        var parsed = Number(number);
        if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
            return 0;
        }
        /** @type {?} */
        var match = (parsed.toString()).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
        if (!match[1]) {
            return 0;
        }
        return match[1].length;
    }
    /**
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function clamp(value, min, max) {
        if (min === void 0) {
            min = 0;
        }
        if (max === void 0) {
            max = 1;
        }
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Provider that defines when form controls have an error.
     */
    var ErrorStateMatcher = /** @class */ (function () {
        function ErrorStateMatcher() {
        }
        /**
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
        ErrorStateMatcher.prototype.isErrorState = /**
         * @param {?} control
         * @param {?} form
         * @return {?}
         */
            function (control, form) {
                return !!(control && control.invalid && (control.touched || (form && form.submitted)));
            };
        ErrorStateMatcher.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = i0.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
        return ErrorStateMatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.isString = isString;
    exports.pad = pad;
    exports.formatDate = formatDate;
    exports.formatDateHuman = formatDateHuman;
    exports.mapClassNames = mapClassNames;
    exports.getClassNameList = getClassNameList;
    exports.appendClasses = appendClasses;
    exports.removeClasses = removeClasses;
    exports.parseDate = parseDate;
    exports.getFontShorthand = getFontShorthand;
    exports.numberOfDecimals = numberOfDecimals;
    exports.clamp = clamp;
    exports.ErrorStateMatcher = ErrorStateMatcher;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=allianz-ngx-ndbx-utils.umd.js.map