(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@allianz/ngx-ndbx/formfield'), require('@angular/core'), require('@angular/forms'), require('@angular/cdk/coercion'), require('@allianz/ngx-ndbx/input'), require('@angular/cdk/keycodes')) :
    typeof define === 'function' && define.amd ? define('@allianz/ngx-ndbx/mask', ['exports', '@angular/common', '@allianz/ngx-ndbx/formfield', '@angular/core', '@angular/forms', '@angular/cdk/coercion', '@allianz/ngx-ndbx/input', '@angular/cdk/keycodes'], factory) :
    (factory((global.allianz = global.allianz || {}, global.allianz['ngx-ndbx'] = global.allianz['ngx-ndbx'] || {}, global.allianz['ngx-ndbx'].mask = {}),global.ng.common,global.allianz['ngx-ndbx'].formfield,global.ng.core,global.ng.forms,global.ng.cdk.coercion,global.allianz['ngx-ndbx'].input,global.ng.cdk.keycodes));
}(this, (function (exports,common,formfield,core,forms,coercion,input,keycodes) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NX_MASK_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return NxMaskDirective; })),
        multi: true
    };
    /** @type {?} */
    var NX_MASK_VALIDATORS = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(( /**
         * @return {?}
         */function () { return NxMaskDirective; })),
        multi: true
    };
    var NxMaskDirective = /** @class */ (function () {
        function NxMaskDirective(_elementRef) {
            this._elementRef = _elementRef;
            this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
            this._dropSpecialCharacters = false;
            this._position = null;
            this._validateMask = true;
            this._onChangeCallback = ( /**
             * @param {?} _
             * @return {?}
             */function (_) { });
            this._onTouchedCallback = ( /**
             * @return {?}
             */function () { });
            this._validatorOnChange = ( /**
             * @return {?}
             */function () { });
        }
        Object.defineProperty(NxMaskDirective.prototype, "mask", {
            get: /**
             * @return {?}
             */ function () {
                return this._mask;
            },
            /** Sets the mask.  */
            set: /**
             * Sets the mask.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!value) {
                    value = '';
                }
                if (value !== this._mask) {
                    this._mask = value;
                    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                    this._validatorOnChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "separators", {
            get: /**
             * @return {?}
             */ function () {
                return this._separators;
            },
            /**
             * Sets the keys that are recognized as separators.
             * Default separators: / ( ) . : - + , and space.
             */
            set: /**
             * Sets the keys that are recognized as separators.
             * Default separators: / ( ) . : - + , and space.
             * @param {?} values
             * @return {?}
             */ function (values) {
                this._separators = values;
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                this._validatorOnChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "dropSpecialCharacters", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropSpecialCharacters;
            },
            /** Whether the separators should be dropped in the control value accessor. */
            set: /**
             * Whether the separators should be dropped in the control value accessor.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._dropSpecialCharacters) {
                    this._dropSpecialCharacters = newValue;
                    this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NxMaskDirective.prototype, "validateMask", {
            get: /**
             * @return {?}
             */ function () {
                return this._validateMask;
            },
            /** Whether the mask validation should be applied on the input. Default: true. */
            set: /**
             * Whether the mask validation should be applied on the input. Default: true.
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._validateMask) {
                    this._validateMask = newValue;
                    this._validatorOnChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /** Returns the unmasked value. */
        /**
         * Returns the unmasked value.
         * @return {?}
         */
        NxMaskDirective.prototype.getUnmaskedValue = /**
         * Returns the unmasked value.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var unmaskedValue = this.separators.reduce(( /**
                 * @param {?} unmasked
                 * @param {?} separator
                 * @return {?}
                 */function (unmasked, separator) {
                    return unmasked.split(separator).join('');
                }), this._elementRef.nativeElement.value);
                return unmaskedValue;
            };
        /**
         * this._position can be set to a new value in this function;
         * it is used to set the cursor position after checking the masked input in _onInputChange().
         */
        /**
         * this._position can be set to a new value in this function;
         * it is used to set the cursor position after checking the masked input in _onInputChange().
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onKeydown = /**
         * this._position can be set to a new value in this function;
         * it is used to set the cursor position after checking the masked input in _onInputChange().
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var keyCode = event.keyCode;
                /** @type {?} */
                var location = event.location;
                /** @type {?} */
                var input$$1 = ( /** @type {?} */(event.target));
                /** @type {?} */
                var currentValue = this._elementRef.nativeElement.value;
                // row of characters is selected: set cursor position to end of new entered character
                if (input$$1.selectionStart !== input$$1.selectionEnd) {
                    /** @type {?} */
                    var nextCharacterInMask = input$$1.selectionStart;
                    while (this.isSeparator(this._mask[nextCharacterInMask])) {
                        nextCharacterInMask++;
                    }
                    /** @type {?} */
                    var positionChange = this._isKeyCodeAllowed(keyCode, location, ( /** @type {?} */(this.mask[nextCharacterInMask])))
                        ? this._calculateCursorShift(input$$1.selectionStart)
                        : 0;
                    this._position = input$$1.selectionStart + positionChange;
                }
                else if (keyCode === keycodes.BACKSPACE || keyCode === keycodes.DELETE) {
                    // if backspace pressed, cursor has to move one character to start
                    /** @type {?} */
                    var backspaceShift = keyCode === keycodes.BACKSPACE ? 1 : 0;
                    /** @type {?} */
                    var lastCharacter = currentValue.substring(input$$1.selectionStart - backspaceShift, input$$1.selectionEnd - backspaceShift + 1);
                    /** @type {?} */
                    var selectionAtLastCharacter = (input$$1.selectionStart === currentValue.length - 1 + backspaceShift);
                    // if last character is deleted: only delete last character, do not trigger input event again
                    // (here the separator would be added again)
                    if (selectionAtLastCharacter) {
                        this.updateValue(currentValue.substring(0, currentValue.length - 1));
                        event.preventDefault();
                        // do not delete a separator, only set cursor position
                    }
                    else if (this.isSeparator(lastCharacter)) {
                        input$$1.setSelectionRange(input$$1.selectionStart - backspaceShift, input$$1.selectionEnd - backspaceShift);
                        event.preventDefault();
                        // for any other character: decrease cursor position by one.
                        // the input is modified and will be validated in _onInputChange().
                    }
                    else {
                        this._position = input$$1.selectionStart - backspaceShift;
                    }
                }
                else {
                    this._position = input$$1.selectionStart;
                    /** @type {?} */
                    var nextCharacterInMask = input$$1.selectionStart;
                    while (this.isSeparator(this._mask[nextCharacterInMask])) {
                        nextCharacterInMask++;
                    }
                    if (this._isKeyCodeAllowed(keyCode, location, ( /** @type {?} */(this._mask[nextCharacterInMask])))) {
                        // if mask is already filled up, do not allow any inputs
                        if (currentValue.length === this.mask.length) {
                            input$$1.setSelectionRange(nextCharacterInMask, nextCharacterInMask);
                            event.preventDefault();
                        }
                        else {
                            this._position = nextCharacterInMask + 1;
                        }
                    }
                }
            };
        /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         */
        /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         * @private
         * @param {?} position
         * @return {?}
         */
        NxMaskDirective.prototype._calculateCursorShift = /**
         * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
         * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
         * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
         * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
         * @private
         * @param {?} position
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var shift = 0;
                // tracks if the entered letter was already placed in the current mask
                // and therefor was considered in the cursor calculation.
                /** @type {?} */
                var characterWasEntered = false;
                if (!this.isSeparator(this.mask[position + shift])) {
                    shift++;
                    characterWasEntered = true;
                }
                while (this.isSeparator(this.mask[position + shift])) {
                    shift++;
                }
                if (!characterWasEntered) {
                    shift++;
                }
                return shift;
            };
        /**
         * @private
         * @param {?} value
         * @param {?} location
         * @return {?}
         */
        NxMaskDirective.prototype._keyCodeIsNumber = /**
         * @private
         * @param {?} value
         * @param {?} location
         * @return {?}
         */
            function (value, location) {
                return ((value >= keycodes.ZERO && value <= keycodes.NINE)
                    || (location === 3 && value >= keycodes.NUMPAD_ZERO && value <= keycodes.NUMPAD_NINE));
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype._keyCodeIsLetter = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return (value >= keycodes.A && value <= keycodes.Z);
            };
        /**
         * @private
         * @param {?} value
         * @param {?} location
         * @param {?} maskedValue
         * @return {?}
         */
        NxMaskDirective.prototype._isKeyCodeAllowed = /**
         * @private
         * @param {?} value
         * @param {?} location
         * @param {?} maskedValue
         * @return {?}
         */
            function (value, location, maskedValue) {
                if ((maskedValue === '0' && this._keyCodeIsNumber(value, location))
                    || (maskedValue === 'A' && (this._keyCodeIsNumber(value, location) || this._keyCodeIsLetter(value)))
                    || (maskedValue === 'S' && this._keyCodeIsLetter(value))) {
                    return true;
                }
                return false;
            };
        /**
         * @private
         * @param {?} value
         * @param {?} maskedValue
         * @return {?}
         */
        NxMaskDirective.prototype._isStringAllowed = /**
         * @private
         * @param {?} value
         * @param {?} maskedValue
         * @return {?}
         */
            function (value, maskedValue) {
                if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
                    || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
                    || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
                    return true;
                }
                return false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onInputChange = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var input$$1 = ( /** @type {?} */(event.target));
                this.updateValue(this.getMaskedString(input$$1.value));
                if (this._position !== null) {
                    input$$1.setSelectionRange(this._position, this._position);
                    this._position = null;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NxMaskDirective.prototype._onPaste = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var input$$1 = ( /** @type {?} */(event.target));
                /** @type {?} */
                var pastedData = (event.clipboardData || (( /** @type {?} */(window))).clipboardData).getData('text');
                /** @type {?} */
                var maskedString = this.getMaskedString(pastedData, input$$1.selectionStart);
                this._position = input$$1.selectionStart + maskedString.length;
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.updateValue = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._elementRef.nativeElement.value = value;
                if (!this.dropSpecialCharacters) {
                    this._onChangeCallback(value);
                }
                else {
                    this._onChangeCallback(this.getUnmaskedValue());
                }
            };
        /**
         * @private
         * @param {?} inputValue
         * @param {?=} maskStartIndex
         * @return {?}
         */
        NxMaskDirective.prototype.getMaskedString = /**
         * @private
         * @param {?} inputValue
         * @param {?=} maskStartIndex
         * @return {?}
         */
            function (inputValue, maskStartIndex) {
                if (maskStartIndex === void 0) {
                    maskStartIndex = 0;
                }
                /** @type {?} */
                var formattedValue = '';
                /** @type {?} */
                var maskIndex = maskStartIndex;
                /** @type {?} */
                var inputIndex = 0;
                /** @type {?} */
                var carot = 0;
                // insert if next in mask is separator
                while (this.isSeparator(this.mask[maskIndex])) {
                    formattedValue += this.mask[maskIndex];
                    maskIndex++;
                }
                while (inputIndex < inputValue.length) {
                    // test if letters are valid
                    if (this._isStringAllowed(inputValue[inputIndex], ( /** @type {?} */(this.mask[maskIndex])))) {
                        formattedValue += inputValue[inputIndex];
                        inputIndex++;
                        maskIndex++;
                    }
                    else {
                        inputIndex++;
                    }
                    // insert if next in mask is separator
                    while (this.isSeparator(this.mask[maskIndex])) {
                        formattedValue += this.mask[maskIndex];
                        // shift for _position
                        if (maskIndex === this._position + carot) {
                            carot++;
                        }
                        maskIndex++;
                    }
                }
                if (carot > 0) {
                    this._position = this._position + carot;
                }
                return formattedValue;
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.isSeparator = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return (this._separators.indexOf(value) !== -1);
            };
        // control value accessor
        // control value accessor
        /**
         * @param {?} value
         * @return {?}
         */
        NxMaskDirective.prototype.writeValue =
            // control value accessor
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!value) {
                    value = '';
                }
                this.updateValue(this.getMaskedString(value));
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this._onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this._onTouchedCallback = onTouched;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        NxMaskDirective.prototype.registerOnValidatorChange = /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._validatorOnChange = fn;
            };
        /**
         * @return {?}
         */
        NxMaskDirective.prototype._validateFn = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var inputLength = this._elementRef.nativeElement.value.length;
                /** @type {?} */
                var maskLength = this._mask.length;
                if (inputLength !== maskLength) {
                    return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
                }
                return null;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @return {?}
         */
        NxMaskDirective.prototype.validate = /**
         * \@docs-private
         * @return {?}
         */
            function () {
                return this.validateMask ? this._validateFn() : null;
            };
        NxMaskDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[nxMask]',
                        host: {
                            '(input)': '_onInputChange($event)',
                            '(keydown)': '_onKeydown($event)',
                            '(paste)': '_onPaste($event)',
                            '(blur)': '_onTouchedCallback()'
                        },
                        exportAs: 'nxMaskDirective',
                        providers: [
                            NX_MASK_VALUE_ACCESSOR,
                            { provide: input.NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                            NX_MASK_VALIDATORS
                        ]
                    },] }
        ];
        /** @nocollapse */
        NxMaskDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        NxMaskDirective.propDecorators = {
            mask: [{ type: core.Input, args: ['nxMask',] }],
            separators: [{ type: core.Input }],
            dropSpecialCharacters: [{ type: core.Input }],
            validateMask: [{ type: core.Input }]
        };
        return NxMaskDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NxMaskModule = /** @class */ (function () {
        function NxMaskModule() {
        }
        NxMaskModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            formfield.NxFormfieldModule
                        ],
                        declarations: [
                            NxMaskDirective
                        ],
                        exports: [
                            formfield.NxFormfieldModule,
                            NxMaskDirective
                        ]
                    },] }
        ];
        return NxMaskModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NxMaskModule = NxMaskModule;
    exports.NX_MASK_VALUE_ACCESSOR = NX_MASK_VALUE_ACCESSOR;
    exports.NX_MASK_VALIDATORS = NX_MASK_VALIDATORS;
    exports.NxMaskDirective = NxMaskDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=allianz-ngx-ndbx-mask.umd.js.map