import { CommonModule } from '@angular/common';
import { removeClasses, mapClassNames } from '@allianz/ngx-ndbx/utils';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { filter, startWith, takeUntil } from 'rxjs/operators';
import { Subject, merge } from 'rxjs';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { Input, ViewChild, ChangeDetectionStrategy, Component, ContentChildren, forwardRef, QueryList, Renderer2, ChangeDetectorRef, Inject, HostListener, NgModule } from '@angular/core';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
/**
 * \@docs-private
 */
class NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * \@docs-private
         */
        this.toggleButtonId = 'nx-radio-toggle-button-' + nextId++;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    triggerInputClick(event) {
        event.stopPropagation();
        this.toggleInput.nativeElement.click();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setFirstButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--first');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setLastButton() {
        this.renderer.addClass(this.labelContainer.nativeElement, 'nx-radio-toggle__label-container--last');
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resetClasses() {
        removeClasses(this.renderer, this.labelContainer, 'nx-radio-toggle__label-container--first nx-radio-toggle__label-container--last');
    }
}
NxRadioToggleButtonBaseComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    labelContainer: [{ type: ViewChild, args: ['toggleButtonLabelContainer',] }],
    toggleInput: [{ type: ViewChild, args: ['toggleInput',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$1 = 0;
/** @type {?} */
const MAPPING = {
    'negative': 'nx-radio-toggle--negative',
    'small': 'nx-radio-toggle--small',
};
class NxRadioToggleComponent {
    /**
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     */
    constructor(renderer, _changeDetectorRef) {
        this.renderer = renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleId = (nextId$1++).toString();
        this._destroyed = new Subject();
        this._disabled = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /**
         * \@docs-private
         */
        this.toggleButtons = new QueryList();
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} option
         * @return {?}
         */
        (option) => { });
    }
    /**
     * Sets the component to the disabled state.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Sets the name used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToToggleButtonsChange();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.toggleButtons.changes, this._destroyed);
        merge(...this.toggleButtons.map((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.onChecked)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this._selection = change.value;
            this.onChangeCallback(this._selection);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToToggleButtonsChange() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), takeUntil(this._destroyed)).subscribe((/**
         * @param {?} toggles
         * @return {?}
         */
        (toggles) => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout((/**
                     * @return {?}
                     */
                    () => toggle.select()));
                }
            }));
            toggles.first.setFirstButton();
            toggles.last.setLastButton();
        }));
    }
    /**
     * @param {?} onChangeCallback
     * @return {?}
     */
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    /**
     * @param {?} onTouchedCallback
     * @return {?}
     */
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /**
     * Preselects the respective options.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._selection = value;
        /** @type {?} */
        const correspondingButton = this.toggleButtons.find((/**
         * @param {?} button
         * @return {?}
         */
        (button) => button.value === this._selection));
        if (correspondingButton) {
            ((/** @type {?} */ (correspondingButton))).select();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /**
     * Sets the modifiers for the component.
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        /** @type {?} */
        const modifierClasses = mapClassNames(value, [], MAPPING);
        modifierClasses.split(' ')
            .forEach((/**
         * @param {?} className
         * @return {?}
         */
        className => this.renderer.addClass(this.toggleContainer.nativeElement, className)));
    }
    /**
     * \@docs-private
     * @param {?} selection
     * @return {?}
     */
    set selection(selection) {
        this._selection = selection;
        this.onChangeCallback(selection);
    }
    /**
     * @return {?}
     */
    get selection() {
        return this._selection;
    }
}
NxRadioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle',
                template: "<div #toggleContainer class=\"nx-radio-toggle\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n   <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioToggleComponent)),
                        multi: true
                    }
                ],
                styles: [".nx-radio-toggle{display:flex;height:100%}.nx-radio-toggle:focus+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#006192}.nx-radio-toggle:hover+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#075994}@media (max-width:703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}"]
            }] }
];
/** @nocollapse */
NxRadioToggleComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NxRadioToggleComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    toggleContainer: [{ type: ViewChild, args: ['toggleContainer',] }],
    name: [{ type: Input, args: ['nxName',] }],
    toggleButtons: [{ type: ContentChildren, args: [NxRadioToggleButtonBaseComponent,] }],
    writeValue: [{ type: Input, args: ['nxSelection',] }],
    style: [{ type: Input, args: ['nxStyle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxRadioToggleButtonChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
class NxRadioToggleButtonComponent extends NxRadioToggleButtonBaseComponent {
    /**
     * @param {?} radioToggle
     * @param {?} renderer
     * @param {?} _changeDetectorRef
     * @param {?} _toggleDispatcher
     */
    constructor(radioToggle, renderer, _changeDetectorRef, _toggleDispatcher) {
        super(renderer);
        this.radioToggle = radioToggle;
        this._changeDetectorRef = _changeDetectorRef;
        this._toggleDispatcher = _toggleDispatcher;
        /**
         * \@docs-private
         */
        // emits when the button is checked to notify the group
        this.onChecked = new Subject();
        this._destroyed = new Subject();
        this._disabled = false;
        this._selected = false;
        /**
         * Unregister function for _expansionDispatcher.
         */
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this._removeUniqueSelectionListener = this._toggleDispatcher.listen((/**
         * @param {?} id
         * @param {?} radioToggleId
         * @return {?}
         */
        (id, radioToggleId) => {
            if (this.radioToggle && this.radioToggle.id === radioToggleId && this.id !== id) {
                this._selected = false;
                // need to let change detector know in case that the select() function was called on another button
                this._changeDetectorRef.markForCheck();
            }
        }));
        this.radioToggle._disableChange.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled || (this.radioToggle && this.radioToggle.disabled);
    }
    /**
     * Sets the checked state and notify siblings and the parent group about the change
     * @param {?} value
     * @return {?}
     */
    // Only use this if you want the onChecked event to be fired, this will inform the parent about the change!
    // To select a button without firing the event use the select() function
    set selected(value) {
        if (this._selected !== value) {
            this._selected = value;
            if (this._selected) {
                this._notifySiblings();
                this._emitCheckedEvent();
            }
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeUniqueSelectionListener();
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get toggleId() {
        return this.radioToggle.id;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get id() {
        return this.toggleButtonId;
    }
    /**
     * @private
     * @return {?}
     */
    _notifySiblings() {
        /** @type {?} */
        const toggleId = this.radioToggle ? this.radioToggle.id : this.id;
        this._toggleDispatcher.notify(this.id, toggleId);
    }
    /**
     * @private
     * @return {?}
     */
    _emitCheckedEvent() {
        this.onChecked.next(new NxRadioToggleButtonChange(this, this.value));
    }
    // Does NOT emit the onChecked event. Useful when you need to set initial
    // state. Used by the parent to set checked states on initialization and during
    // writeValue() changes.
    /**
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._notifySiblings();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    onKeyupSpace() {
        this._selected = false;
        this._notifySiblings();
    }
}
NxRadioToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-toggle-button',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<input [attr.id]=\"toggleButtonId\"\n    #toggleInput\n    [attr.name]=\"toggleId\"\n    [checked]=\"selected\"\n    class=\"nx-radio-toggle__input\"\n    type=\"radio\"\n    (click)=\"selected = true\"\n    [disabled]=\"disabled\">\n<div (click)=\"triggerInputClick($event)\" #toggleButtonLabelContainer class=\"nx-radio-toggle__label-container\">\n  <label [attr.for]=\"toggleButtonId\" class=\"nx-radio-toggle__label\">\n      <nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n      <ng-content></ng-content>\n  </label>\n</div>\n\n\n",
                providers: [
                    {
                        provide: NxRadioToggleButtonBaseComponent, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioToggleButtonComponent))
                    }
                ],
                styles: [":host{display:flex;position:relative;flex-direction:row}.nx-radio-toggle__input{opacity:0;position:absolute}.nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#003781;border-color:#003781;color:#fff}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#b2d7e8;border-color:#b2d7e8;color:#fff;cursor:not-allowed}.nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:not-allowed}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#007ab3;border-color:#007ab3;color:#fff;cursor:default}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{cursor:default}@media screen and (-ms-high-contrast:active){.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#ff0;cursor:default;border-color:inherit}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-radio-toggle__label{background-color:#000}}.nx-toggle-button__mobile-check{display:none;font-size:24px;margin-right:8px;height:24px}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{font-size:14px;min-height:16px;padding:6px;text-transform:none;line-height:16px}.nx-radio-toggle{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-radius:4px 0 0 4px;border-width:2px 0 2px 2px}@media (max-width:703px){:host{width:100%}.nx-radio-toggle__input:checked+.nx-radio-toggle__label-container .nx-toggle-button__mobile-check{display:inline-block}:host-context(.nx-radio-toggle--small) .nx-radio-toggle__label-container{line-height:24px;padding:11px 31px}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--first{border-width:2px 2px 1px;border-radius:4px 4px 0 0}}.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-radius:0 4px 4px 0;border-width:2px}@media (max-width:703px){.nx-radio-toggle__label-container.nx-radio-toggle__label-container--last{border-width:1px 2px 2px;border-radius:0 0 4px 4px}}.nx-radio-toggle__label-container{padding:10px 30px;border:2px solid #007ab3;border-radius:0;border-width:2px 0 2px 2px;color:#007ab3;cursor:pointer;flex-grow:1;font-size:16px;font-weight:600;line-height:24px;text-align:center;text-transform:uppercase;transition:background-color .2s,border-color .2s,color .2s;display:flex;align-items:center;height:100%;min-height:24px}@media (max-width:703px){.nx-radio-toggle__label-container{border-width:1px 2px;justify-content:center;padding:11px 31px}}.nx-radio-toggle__label-container:hover{background-color:#075994;border-color:#075994;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:active+.nx-radio-toggle__label-container{background-color:#c2c2c2;border-color:#c2c2c2;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:disabled+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#d9d9d9}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__input:checked+.nx-radio-toggle__label-container{background-color:#fff;border-color:#fff;color:#007ab3}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container{border-color:#fff;color:#fff}:host-context(.nx-radio-toggle--negative) .nx-radio-toggle__label-container:hover{background-color:#d9d9d9;border-color:#d9d9d9;color:#007ab3}.nx-radio-toggle__label{display:flex;align-items:center;cursor:pointer}:host-context([data-whatinput=keyboard]) .nx-radio-toggle__input:focus+.nx-radio-toggle__label-container{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
            }] }
];
/** @nocollapse */
NxRadioToggleButtonComponent.ctorParameters = () => [
    { type: NxRadioToggleComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NxRadioToggleComponent)),] }] },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: UniqueSelectionDispatcher }
];
NxRadioToggleButtonComponent.propDecorators = {
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    selected: [{ type: Input, args: ['nxSelected',] }],
    onKeyupSpace: [{ type: HostListener, args: ['keyup.space',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRadioToggleModule {
}
NxRadioToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                exports: [NxRadioToggleComponent, NxRadioToggleButtonComponent],
                imports: [CommonModule, FormsModule, NxIconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxRadioToggleModule, NxRadioToggleComponent, NxRadioToggleButtonBaseComponent as ɵa, NxRadioToggleButtonComponent as ɵb };

//# sourceMappingURL=allianz-ngx-ndbx-radio-toggle.js.map