import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { CommonModule } from '@angular/common';
import { Input, Component, ChangeDetectorRef, ChangeDetectionStrategy, Renderer2, ElementRef, Output, EventEmitter, NgModule } from '@angular/core';
import { SPACE, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAX_WIDTH = 400;
/** @type {?} */
const MIN_WIDTH = 56;
/** @type {?} */
const AUTO_COLLAPSE_WIDTH = 168;
/** @type {?} */
const RESIZE_STEP_SIZE = 20;
class NxSidebarComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} renderer
     * @param {?} _element
     */
    constructor(_changeDetectorRef, renderer, _element) {
        this._changeDetectorRef = _changeDetectorRef;
        this.renderer = renderer;
        this._element = _element;
        /**
         * Emits the new width of the sidebar on resize or on close/open event.
         */
        this.widthChange = new EventEmitter();
        this._resizeable = false;
        this._minWidth = MIN_WIDTH;
        this._resizeHandleAriaLabel = '';
        this._open = true;
        this._width = 0;
        this._resizing = false;
        this._previousWidth = 0;
        this._isMobile = false;
        this._resizeWidth = 0;
        this._unsubscribeListeners = [];
        this._onResize = this._onResize.bind(this);
        this._onResizeEnd = this._onResizeEnd.bind(this);
    }
    /**
     * If set to `true` this will enable dynamic resizing of the sidebar.
     * @param {?} value
     * @return {?}
     */
    set resizeable(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._resizeable) {
            this._resizeable = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get resizeable() {
        return this._resizeable;
    }
    /**
     * Sets the minimal width (in pixel) of the sidebar.
     * @param {?} value
     * @return {?}
     */
    set minWidth(value) {
        this._minWidth = coerceNumberProperty(value) || MIN_WIDTH;
    }
    /**
     * @return {?}
     */
    get minWidth() {
        return this._minWidth;
    }
    /**
     * This sets the accessibility label for the resize handle of the sidebar.
     * @param {?} value
     * @return {?}
     */
    set resizeHandleAriaLabel(value) {
        if (value !== this._resizeHandleAriaLabel) {
            this._resizeHandleAriaLabel = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get resizeHandleAriaLabel() {
        return this._resizeHandleAriaLabel;
    }
    /**
     * This reflects the current open state of the sidebar.
     * It will be `true` if the sidebar is expanded and `false` if the sidebar is closed.
     * @param {?} value
     * @return {?}
     */
    set open(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._open) {
            this._open = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get open() {
        return this._open;
    }
    /**
     * This sets the width of the sidebar.
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        /** @type {?} */
        const newValue = Math.max(value, this.minWidth);
        if (newValue !== this._width) {
            this._width = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get width() {
        return this._width;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.width = this._element.nativeElement.clientWidth;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeDragEventListeners();
    }
    /**
     * This will expand the sidebar to its full width.
     * @return {?}
     */
    expand() {
        this.open = true;
    }
    /**
     * This will close the sidebar to its minimal width.
     * @return {?}
     */
    close() {
        this.open = false;
    }
    /**
     * This will close or expand the sidebar depending if its expanded or closed.
     * @return {?}
     */
    toggle() {
        if (this.open) {
            this.close();
        }
        else {
            this.expand();
        }
        this._emitWidthChange(this._sidebarElementWidth);
    }
    /**
     * @return {?}
     */
    get _sidebarElementWidth() {
        if (this._resizing) {
            return this._resizeWidth;
        }
        return this.open ? this.width : this.minWidth;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onResizeStart(event) {
        if (event.type.startsWith('touch')) {
            event = event.changedTouches[0];
        }
        this._resizeStartX = event.screenX;
        this._resizeStartWidth = this.open ? this.width : this.minWidth;
        this._resizeWidth = this.width;
        this._attachDragEventListeners();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onResize(event) {
        this._resizing = true;
        if (event.type.startsWith('touch')) {
            event = event.changedTouches[0];
        }
        /** @type {?} */
        const dx = event.screenX - this._resizeStartX;
        this._resizeWidth = Math.max(this.minWidth, this._resizeStartWidth + dx);
        this.open = this._resizeWidth > this.minWidth;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onResizeEnd(event) {
        this._resizing = false;
        this._removeDragEventListeners();
        if (this._isMouseDrag(this._resizeStartX, event.screenX)) {
            if (this._resizeWidth < AUTO_COLLAPSE_WIDTH) {
                this.open = false;
                this._emitWidthChange(this._sidebarElementWidth);
            }
            else {
                this.open = true;
                this.width = Math.min(MAX_WIDTH, this._resizeWidth);
                this._emitWidthChange(this.width);
            }
        }
        this._resizeWidth = 0;
    }
    /**
     * @return {?}
     */
    _onToggleClick() {
        this.toggle();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onResizeHandleClick(event) {
        if (this._isMouseDrag(this._resizeStartX, event.screenX)) {
            return;
        }
        this.toggle();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onSidebarKeydown(event) {
        if (event.which === SPACE) {
            event.preventDefault();
            this.toggle();
        }
        else if (event.which === LEFT_ARROW) {
            this.width = this.width - RESIZE_STEP_SIZE;
            if (this.width <= AUTO_COLLAPSE_WIDTH) {
                this.open = false;
                this.width = AUTO_COLLAPSE_WIDTH + 1;
            }
            this._emitWidthChange(this.width);
        }
        else if (event.which === RIGHT_ARROW) {
            if (this.open) {
                this.width = Math.min(MAX_WIDTH, this.width + RESIZE_STEP_SIZE);
            }
            else {
                this.open = true;
                this.width = Math.max(this.width, AUTO_COLLAPSE_WIDTH);
            }
            this._emitWidthChange(this.width);
        }
    }
    /**
     * @private
     * @param {?} width
     * @return {?}
     */
    _emitWidthChange(width) {
        this.widthChange.emit(width);
    }
    /**
     * @private
     * @param {?} startX
     * @param {?} endX
     * @return {?}
     */
    _isMouseDrag(startX, endX) {
        return Math.abs(endX - startX) > 5;
    }
    /**
     * @private
     * @return {?}
     */
    _attachDragEventListeners() {
        this._unsubscribeListeners.push(this.renderer.listen('document', 'mousemove', this._onResize));
        this._unsubscribeListeners.push(this.renderer.listen('document', 'mouseup', this._onResizeEnd));
        this._unsubscribeListeners.push(this.renderer.listen('document', 'touchmove', this._onResize));
        this._unsubscribeListeners.push(this.renderer.listen('document', 'touchend', this._onResizeEnd));
    }
    /**
     * @private
     * @return {?}
     */
    _removeDragEventListeners() {
        this._unsubscribeListeners.forEach((/**
         * @param {?} unsubscribe
         * @return {?}
         */
        unsubscribe => unsubscribe()));
    }
}
NxSidebarComponent.decorators = [
    { type: Component, args: [{
                template: "<div class=\"nx-sidebar__box\"\n  [attr.aria-expanded]=\"open\">\n  <div class=\"nx-sidebar__content\">\n    <ng-content></ng-content>\n  </div>\n  <div class=\"nx-sidebar__toggle\">\n    <button class=\"nx-sidebar__toggle-button\"\n        (click)=\"_onToggleClick()\"\n        [attr.aria-label]=\"resizeHandleAriaLabel\"\n        type=\"button\">\n        <nx-icon name=\"chevron-left\" aria-hidden=\"true\"></nx-icon>\n        <nx-icon name=\"chevron-left\" aria-hidden=\"true\"></nx-icon>\n    </button>\n  </div>\n</div>\n\n<button class=\"nx-sidebar__handle\"\n  *ngIf=\"resizeable\"\n  tabindex=\"0\"\n  type=\"button\"\n  (mousedown)=\"_onResizeStart($event)\"\n  (keydown)=\"_onSidebarKeydown($event)\"\n  (touchstart)=\"_onResizeStart($event)\"\n  (click)=\"_onResizeHandleClick($event)\"\n  [attr.aria-label]=\"resizeHandleAriaLabel\"></button>\n",
                selector: 'nx-sidebar',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-resizing]': '_resizing',
                    '[class.is-closed]': '!open',
                    '[style.width.px]': `_sidebarElementWidth`
                },
                styles: [":host{position:relative;height:100%;transition:width .15s;display:flex;flex:0 0 auto;width:280px}:host.is-resizing{transition:none}@media (max-width:703px){:host{width:100%;position:absolute;transition:none}:host .nx-sidebar__handle{display:none}}:host.is-closed .nx-sidebar__toggle-button{-webkit-transform:rotateZ(180deg);transform:rotateZ(180deg)}.nx-sidebar__toggle{display:flex;padding:16px 0;justify-content:flex-end;flex-shrink:0}.nx-sidebar__toggle::after,.nx-sidebar__toggle::before{content:'';display:block;flex:0 1 24px}.nx-sidebar__handle{position:absolute;right:-14px;top:0;bottom:0;display:flex;flex:0 0 16px;justify-content:center;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;box-shadow:none;background:0 0;margin:0;cursor:col-resize;color:#c2c2c2;outline:0;z-index:1}.nx-sidebar__handle::before{content:'||';font-size:14px;letter-spacing:-1px;font-weight:600;color:inherit}.nx-sidebar__handle::-moz-focus-inner{border:0}.nx-sidebar__toggle-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;box-shadow:none;background:0 0;margin:0;padding:0;cursor:pointer;color:#414141;outline:0;white-space:nowrap;font-size:22px}.nx-sidebar__toggle-button:hover{color:#999}.nx-sidebar__toggle-button:active{color:#5b5b5b}:host-context([data-whatinput=keyboard]) .nx-sidebar__toggle-button:focus{box-shadow:0 0 0 4px #009de6;border-radius:4px}.nx-sidebar__toggle-button>nx-icon:last-child{margin-left:-16px}.nx-sidebar__toggle-button::-moz-focus-inner{border:0}.nx-sidebar__box{height:100%;flex:1 1 100%;display:flex;overflow:hidden;flex-direction:column;background-color:#f5f5f5}@media screen and (-ms-high-contrast:active){.nx-sidebar__handle::before{box-shadow:0 0 0 6px window,0 0 0 8px windowText}.nx-sidebar__toggle-button{border:1px solid windowText;padding-top:4px}.nx-sidebar__box{border-right:1px solid windowText}}.nx-sidebar__content{flex:1 1 100%;overflow:hidden;overflow-y:auto;padding-top:16px}"]
            }] }
];
/** @nocollapse */
NxSidebarComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
NxSidebarComponent.propDecorators = {
    widthChange: [{ type: Output }],
    resizeable: [{ type: Input }],
    minWidth: [{ type: Input }],
    resizeHandleAriaLabel: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxSidebarModule {
}
NxSidebarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NxIconModule],
                declarations: [NxSidebarComponent],
                exports: [NxSidebarComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxSidebarModule, MAX_WIDTH, MIN_WIDTH, AUTO_COLLAPSE_WIDTH, RESIZE_STEP_SIZE, NxSidebarComponent };

//# sourceMappingURL=allianz-ngx-ndbx-sidebar.js.map