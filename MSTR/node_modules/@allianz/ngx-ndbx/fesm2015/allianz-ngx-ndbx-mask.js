import { CommonModule } from '@angular/common';
import { NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { Directive, Input, ElementRef, forwardRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NX_INPUT_VALUE_ACCESSOR } from '@allianz/ngx-ndbx/input';
import { BACKSPACE, DELETE, ZERO, NINE, NUMPAD_ZERO, NUMPAD_NINE, A, Z } from '@angular/cdk/keycodes';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
/** @type {?} */
const NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => NxMaskDirective)),
    multi: true
};
class NxMaskDirective {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._position = null;
        this._validateMask = true;
        this._onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        this._validatorOnChange = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Sets the mask.
     * @param {?} value
     * @return {?}
     */
    set mask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get mask() {
        return this._mask;
    }
    /**
     * Sets the keys that are recognized as separators.
     * Default separators: / ( ) . : - + , and space.
     * @param {?} values
     * @return {?}
     */
    set separators(values) {
        this._separators = values;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._validatorOnChange();
    }
    /**
     * @return {?}
     */
    get separators() {
        return this._separators;
    }
    /**
     * Whether the separators should be dropped in the control value accessor.
     * @param {?} value
     * @return {?}
     */
    set dropSpecialCharacters(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._dropSpecialCharacters) {
            this._dropSpecialCharacters = newValue;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        }
    }
    /**
     * @return {?}
     */
    get dropSpecialCharacters() {
        return this._dropSpecialCharacters;
    }
    /**
     * Whether the mask validation should be applied on the input. Default: true.
     * @param {?} value
     * @return {?}
     */
    set validateMask(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._validateMask) {
            this._validateMask = newValue;
            this._validatorOnChange();
        }
    }
    /**
     * @return {?}
     */
    get validateMask() {
        return this._validateMask;
    }
    /**
     * Returns the unmasked value.
     * @return {?}
     */
    getUnmaskedValue() {
        /** @type {?} */
        const unmaskedValue = this.separators.reduce((/**
         * @param {?} unmasked
         * @param {?} separator
         * @return {?}
         */
        function (unmasked, separator) {
            return unmasked.split(separator).join('');
        }), this._elementRef.nativeElement.value);
        return unmaskedValue;
    }
    /**
     * this._position can be set to a new value in this function;
     * it is used to set the cursor position after checking the masked input in _onInputChange().
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const location = event.location;
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const currentValue = this._elementRef.nativeElement.value;
        // row of characters is selected: set cursor position to end of new entered character
        if (input.selectionStart !== input.selectionEnd) {
            /** @type {?} */
            let nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            /** @type {?} */
            const positionChange = this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this.mask[nextCharacterInMask])))
                ? this._calculateCursorShift(input.selectionStart)
                : 0;
            this._position = input.selectionStart + positionChange;
        }
        else if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            /** @type {?} */
            const backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            /** @type {?} */
            const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            /** @type {?} */
            const selectionAtLastCharacter = (input.selectionStart === currentValue.length - 1 + backspaceShift);
            // if last character is deleted: only delete last character, do not trigger input event again
            // (here the separator would be added again)
            if (selectionAtLastCharacter) {
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                event.preventDefault();
                // do not delete a separator, only set cursor position
            }
            else if (this.isSeparator(lastCharacter)) {
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
                // for any other character: decrease cursor position by one.
                // the input is modified and will be validated in _onInputChange().
            }
            else {
                this._position = input.selectionStart - backspaceShift;
            }
        }
        else {
            this._position = input.selectionStart;
            /** @type {?} */
            let nextCharacterInMask = input.selectionStart;
            while (this.isSeparator(this._mask[nextCharacterInMask])) {
                nextCharacterInMask++;
            }
            if (this._isKeyCodeAllowed(keyCode, location, (/** @type {?} */ (this._mask[nextCharacterInMask])))) {
                // if mask is already filled up, do not allow any inputs
                if (currentValue.length === this.mask.length) {
                    input.setSelectionRange(nextCharacterInMask, nextCharacterInMask);
                    event.preventDefault();
                }
                else {
                    this._position = nextCharacterInMask + 1;
                }
            }
        }
    }
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     * @private
     * @param {?} position
     * @return {?}
     */
    _calculateCursorShift(position) {
        /** @type {?} */
        let shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        /** @type {?} */
        let characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @return {?}
     */
    _keyCodeIsNumber(value, location) {
        return ((value >= ZERO && value <= NINE)
            || (location === 3 && value >= NUMPAD_ZERO && value <= NUMPAD_NINE));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _keyCodeIsLetter(value) {
        return (value >= A && value <= Z);
    }
    /**
     * @private
     * @param {?} value
     * @param {?} location
     * @param {?} maskedValue
     * @return {?}
     */
    _isKeyCodeAllowed(value, location, maskedValue) {
        if ((maskedValue === '0' && this._keyCodeIsNumber(value, location))
            || (maskedValue === 'A' && (this._keyCodeIsNumber(value, location) || this._keyCodeIsLetter(value)))
            || (maskedValue === 'S' && this._keyCodeIsLetter(value))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} maskedValue
     * @return {?}
     */
    _isStringAllowed(value, maskedValue) {
        if ((maskedValue === '0' && /^[0-9]{1}$/.test(value))
            || (maskedValue === 'A' && /^[a-zA-Z0-9]{1}$/.test(value))
            || (maskedValue === 'S' && /^[a-zA-Z]{1}$/.test(value))) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        this.updateValue(this.getMaskedString(input.value));
        if (this._position !== null) {
            input.setSelectionRange(this._position, this._position);
            this._position = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onPaste(event) {
        /** @type {?} */
        const input = (/** @type {?} */ (event.target));
        /** @type {?} */
        const pastedData = (event.clipboardData || ((/** @type {?} */ (window))).clipboardData).getData('text');
        /** @type {?} */
        const maskedString = this.getMaskedString(pastedData, input.selectionStart);
        this._position = input.selectionStart + maskedString.length;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this._elementRef.nativeElement.value = value;
        if (!this.dropSpecialCharacters) {
            this._onChangeCallback(value);
        }
        else {
            this._onChangeCallback(this.getUnmaskedValue());
        }
    }
    /**
     * @private
     * @param {?} inputValue
     * @param {?=} maskStartIndex
     * @return {?}
     */
    getMaskedString(inputValue, maskStartIndex = 0) {
        /** @type {?} */
        let formattedValue = '';
        /** @type {?} */
        let maskIndex = maskStartIndex;
        /** @type {?} */
        let inputIndex = 0;
        /** @type {?} */
        let carot = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], (/** @type {?} */ (this.mask[maskIndex])))) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                // shift for _position
                if (maskIndex === this._position + carot) {
                    carot++;
                }
                maskIndex++;
            }
        }
        if (carot > 0) {
            this._position = this._position + carot;
        }
        return formattedValue;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    isSeparator(value) {
        return (this._separators.indexOf(value) !== -1);
    }
    // control value accessor
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!value) {
            value = '';
        }
        this.updateValue(this.getMaskedString(value));
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this._onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this._onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    /**
     * @return {?}
     */
    _validateFn() {
        /** @type {?} */
        const inputLength = this._elementRef.nativeElement.value.length;
        /** @type {?} */
        const maskLength = this._mask.length;
        if (inputLength !== maskLength) {
            return { nxMaskLengthError: { 'length': maskLength, 'actual': inputLength } };
        }
        return null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    validate() {
        return this.validateMask ? this._validateFn() : null;
    }
}
NxMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nxMask]',
                host: {
                    '(input)': '_onInputChange($event)',
                    '(keydown)': '_onKeydown($event)',
                    '(paste)': '_onPaste($event)',
                    '(blur)': '_onTouchedCallback()'
                },
                exportAs: 'nxMaskDirective',
                providers: [
                    NX_MASK_VALUE_ACCESSOR,
                    { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective },
                    NX_MASK_VALIDATORS
                ]
            },] }
];
/** @nocollapse */
NxMaskDirective.ctorParameters = () => [
    { type: ElementRef }
];
NxMaskDirective.propDecorators = {
    mask: [{ type: Input, args: ['nxMask',] }],
    separators: [{ type: Input }],
    dropSpecialCharacters: [{ type: Input }],
    validateMask: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxMaskModule {
}
NxMaskModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule
                ],
                declarations: [
                    NxMaskDirective
                ],
                exports: [
                    NxFormfieldModule,
                    NxMaskDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxMaskModule, NX_MASK_VALUE_ACCESSOR, NX_MASK_VALIDATORS, NxMaskDirective };

//# sourceMappingURL=allianz-ngx-ndbx-mask.js.map