import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { CommonModule } from '@angular/common';
import { NxCheckboxModule } from '@allianz/ngx-ndbx/checkbox';
import { ActiveDescendantKeyManager, A11yModule } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, SHIFT, TAB } from '@angular/cdk/keycodes';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { NxFormfieldControl, NxFormfieldComponent, NxFormfieldModule } from '@allianz/ngx-ndbx/formfield';
import { Subject, defer, merge } from 'rxjs';
import { takeUntil, filter, map, startWith, switchMap, take } from 'rxjs/operators';
import { Input, ChangeDetectionStrategy, Component, ChangeDetectorRef, ElementRef, EventEmitter, Inject, Optional, Output, ViewChild, Directive, TemplateRef, Attribute, ContentChildren, isDevMode, NgZone, Self, ContentChild, NgModule } from '@angular/core';
import { ObserversModule } from '@angular/cdk/observers';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * \@docs-private
 * @return {?}
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}
/**
 * Returns an exception to be thrown when assigning a non-function value to the comparator
 * used to determine if a value corresponds to an option. Note that whether the function
 * actually takes two values and returns a boolean is not checked.
 * @return {?}
 */
function getNxDropdownNonFunctionValueError() {
    return Error('`compareWith` must be a function.');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class NxDropdownControl extends NxFormfieldControl {
    constructor() {
        super(...arguments);
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown!
         */
        this.isMultiSelect = false;
    }
}
NxDropdownControl.propDecorators = {
    isMultiSelect: [{ type: Input, args: ['nxIsMultiselect',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownGroupComponent {
}
NxDropdownGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-group',
                template: "<div class=\"nx-dropdown-results__group\">\n  <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n  <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}:host:first-child .nx-dropdown-results__group{background-color:rgba(236,236,236,.5)}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-style:italic;padding:24px 32px 16px;font-weight:700;font-size:12px;line-height:16px}"]
            }] }
];
NxDropdownGroupComponent.propDecorators = {
    label: [{ type: Input, args: ['nxLabel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownItemChange {
    /**
     * @param {?} item
     * @param {?=} isUserInput
     */
    constructor(item, isUserInput = false) {
        this.item = item;
        this.isUserInput = isUserInput;
    }
}
/**
 * the unique id counter
 * @type {?}
 */
let nextId = 0;
class NxDropdownItemComponent {
    /**
     * @param {?} _dropdown
     * @param {?} group
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     */
    constructor(_dropdown, group, _changeDetectorRef, _elementRef) {
        this._dropdown = _dropdown;
        this.group = group;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = `nx-dropdown-item-${nextId++}`;
        this._selected = false;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Event emitted when the option is selected or deselected.
         */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
        ((/** @type {?} */ (this._dropdown))).filterChanges.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._showOrHideByFilter(value);
        }));
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        ((/** @type {?} */ (this._dropdown)))._closedStream.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._hidden = false;
        }));
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * Whether the item is selected.
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Whether the item is active.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * \@docs-private
     * Whether the parent dropdown is in multiselect mode.
     * @return {?}
     */
    get multiselect() {
        return this._dropdown && this._dropdown.isMultiSelect;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            /** @type {?} */
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onClick(event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    _selectViaInteraction() {
        this._selected = this.multiselect ? !this._selected : true;
        this._changeDetectorRef.markForCheck();
        this._emitSelectionChangeEvent(true);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    show() {
        this._hidden = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    hide() {
        this._hidden = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} search
     * @return {?}
     */
    _showOrHideByFilter(search) {
        /** @type {?} */
        const constraint = ((/** @type {?} */ (this._dropdown))).filterFn(search, this.viewValue);
        this._hidden = constraint ? false : true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get _formattedValue() {
        return ((/** @type {?} */ (this._dropdown))).valueFormatter(this.value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get viewValue() {
        return (this._elementRef.nativeElement.textContent || '').trim();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * @private
     * @param {?=} isUserInput
     * @return {?}
     */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setActiveStyles() {
        this._active = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setInactiveStyles() {
        this._active = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    getLabel() {
        return this.value;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    _isContentEmpty(element) {
        return element.children.length === 0 && !element.textContent.trim();
    }
    /**
     * @return {?}
     */
    _onLabelChange() {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._changeDetectorRef.detectChanges();
    }
}
NxDropdownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown-item',
                template: "<div #container class=\"nx-dropdown-results__option\"\n     [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n\n   <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n       <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n      <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n  <div class=\"nx-dropdown-results__option-label\" >\n    <span #content (cdkObserveContent)=\"_onLabelChange()\">\n      <ng-content></ng-content>\n    </span>\n    <ng-container *ngIf=\"_isContentEmpty(content)\">\n      {{_formattedValue}}\n    </ng-container>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[id]': 'id',
                    'role': 'option',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[class.nx-hidden]': '_hidden',
                    '[class.nx-dropdown-item--active]': 'active',
                    '[class.nx-selected]': 'selected',
                    '[class.nx-multiselect]': 'multiselect',
                    '(click)': '_onClick($event)'
                },
                styles: [":host{display:block}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:20px;line-height:28px;letter-spacing:.2px;padding:0 32px 16px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}.nx-dropdown-results__option-label{overflow:hidden;text-overflow:ellipsis;padding:0 12px;margin:0 -12px}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}:host(.nx-multiselect) ::ng-deep .nx-checkbox__label{height:28px;display:flex;align-items:center}:host(.nx-dropdown-item--active),:host:hover{color:#007ab3}@media screen and (-ms-high-contrast:active){:host(.nx-dropdown-item--active),:host:hover{color:highlightText}}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}.nx-dropdown-results__option-checkicon{opacity:0;width:16px;height:16px;margin-right:8px}.nx-dropdown-results__option-checkicon nx-icon{font-size:16px}:host-context([data-whatinput=keyboard]).nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}:host-context([data-whatinput=keyboard]).nx-multiselect.nx-dropdown-item--active ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}"]
            }] }
];
/** @nocollapse */
NxDropdownItemComponent.ctorParameters = () => [
    { type: NxDropdownControl, decorators: [{ type: Inject, args: [NxDropdownControl,] }] },
    { type: NxDropdownGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NxDropdownItemComponent.propDecorators = {
    value: [{ type: Input, args: ['nxValue',] }],
    onSelectionChange: [{ type: Output }],
    containerElement: [{ type: ViewChild, args: ['container',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This Directive solely purpose is to mark given ng-template and project it into the required destination.
class NxDropdownClosedLabelDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NxDropdownClosedLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxClosedLabel]'
            },] }
];
/** @nocollapse */
NxDropdownClosedLabelDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the select value has changed.
 * @template T
 */
class NxDropdownSelectChange {
    /**
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
// used in calculation of scrolltop to correctly show some space to the top of the panel
/** @type {?} */
const itemPadding = 16;
// Max-height: 6 items x 44px + 16px padding before first item
/** @type {?} */
const SELECT_PANEL_MAX_HEIGHT = 280;
class NxDropdownComponent extends NxDropdownControl {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _elementRef
     * @param {?} _ngZone
     * @param {?} tabIndex
     * @param {?} formFieldComponent
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, _elementRef, _ngZone, tabIndex, formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        this._focused = false;
        /**
         * Whether or not the overlay panel is open.
         */
        this._panelOpen = false;
        /**
         * \@docs-private
         */
        this.errorState = false;
        /**
         * The scroltop of the panelBody.
         */
        this._scrollTop = 0;
        /**
         * The minimal space between the viewport and the overlay
         */
        this._overlayViewportMargin = 16;
        /**
         * \@docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        /**
         * The IDs of child options to be passed to the aria-owns attribute.
         */
        this._optionIds = '';
        this._tabIndex = 0;
        /**
         * \@docs-private
         */
        this.currentFilter = '';
        /**
         * Label to describe the component.
         */
        this._ariaLabel = '';
        this._style = '';
        /**
         * Whether the dropdown should render in its negative style or not.
         */
        this._negative = false;
        /**
         * Whether the dropdown should be shown with an additional filter input.
         */
        this.showFilter = false;
        /**
         * Text displayed as placeholder for the filter.
         */
        this.filterPlaceholder = '';
        /**
         * Event emitted when the select panel has been toggled.
         */
        this.openedChange = new EventEmitter();
        /**
         * Event emitted when the select has been opened.
         */
        this._openedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the select has been closed.
         */
        this._closedStream = this.openedChange.pipe(filter((/**
         * @param {?} o
         * @return {?}
         */
        o => !o)), map((/**
         * @return {?}
         */
        () => { })));
        /**
         * Event emitted when the user types in the filter input.
         */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * \@docs-private
         */
        this.valueChange = new EventEmitter();
        /**
         * Event emitted when the selected value has been changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.optionSelectionChanges = defer((/**
         * @return {?}
         */
        () => {
            if (this.options) {
                return merge(...this.options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.onSelectionChange)));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap((/**
             * @return {?}
             */
            () => this.optionSelectionChanges)));
        }));
        /**
         * This position config ensures that the top "start" corner of the overlay
         * is aligned with with the top "start" of the origin by default (overlapping
         * the trigger completely). If the panel cannot fit below the trigger, it
         * will fall back to a position above the trigger.
         */
        this._positions = [{
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            }, {
                originX: 'start',
                originY: 'center',
                overlayX: 'start',
                overlayY: 'center'
            }, {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            }];
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        /**
         * Function that transforms the value into a string.
         * This function is used for displaying and filtering the content
         * ( Default: (value) => value ? value.toString() : null; ).
         */
        this.valueFormatter = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            return value == null ? '' : value.toString();
        });
        /**
         * Comparison function to specify which option is displayed. Defaults to object equality.
         */
        this._compareWith = (/**
         * @param {?} o1
         * @param {?} o2
         * @return {?}
         */
        (o1, o2) => o1 === o2);
        this._filterFn = (/**
         * @param {?} search
         * @param {?} itemValue
         * @return {?}
         */
        (search, itemValue) => {
            return itemValue.toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) >= 0;
        });
        /**
         * `View -> model callback called when value changes`
         */
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * `View -> model callback called when select has been touched`
         */
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * @return {?}
     */
    get tabIndex() { return this.disabled ? -1 : this._tabIndex; }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /**
     * Selected value
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /**
     * Whether the dropdown is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * If set to 'negative', the component is displayed with the negative set of styles.
     * @param {?} value
     * @return {?}
     */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /**
     * \@docs-private
     * The currently selected option.
     * @return {?}
     */
    get selected() {
        return this.isMultiSelect ? this._selectionModel.selected : this._selectionModel.selected[0];
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get label() {
        return this.formFieldComponent ? this.formFieldComponent.label : '';
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     * @return {?}
     */
    get compareWith() { return this._compareWith; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._compareWith = fn;
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value. The dropdown items will use this function to set their
     * visibility state.
     * A boolean should be returned.
     * @return {?}
     */
    get filterFn() { return this._filterFn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    set filterFn(fn) {
        if (typeof fn !== 'function') {
            throw getNxDropdownNonFunctionValueError();
        }
        this._filterFn = fn;
    }
    /**
     * \@docs-private
     * Whether the select is focused.
     * @return {?}
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._closedDropdownLabel =
            this._customClosedDropdownLabel && this._customClosedDropdownLabel.templateRef || this._defaultClosedDropdownLabel;
        this._initKeyManager();
        this._selectionModel.onChange.pipe(takeUntil(this._destroy)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            event.added.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.select()));
            event.removed.forEach((/**
             * @param {?} option
             * @return {?}
             */
            option => option.deselect()));
        }));
        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            this._resetOptions();
            this._initializeSelection();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * \@docs-private
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateErrorState() {
        /** @type {?} */
        const oldState = this.errorState;
        /** @type {?} */
        const parent = this._parentFormGroup || this._parentForm;
        /** @type {?} */
        const control = this.ngControl ? (/** @type {?} */ (this.ngControl.control)) : null;
        /** @type {?} */
        const newState = this.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Sets up a key manager to listen to keyboard events on the overlay panel.
     * @private
     * @return {?}
     */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.options)
            .withTypeAhead()
            .withWrap()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate((/**
         * @param {?} item
         * @return {?}
         */
        item => item._hidden));
        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        }));
        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._panelOpen && this.panel) {
                // Delay the auto scrolling until all items have settled otherwise the item containers might
                // not exist yet
                this._ngZone.onStable
                    .asObservable()
                    .pipe(take(1)).subscribe((/**
                 * @return {?}
                 */
                () => this._scrollActiveOptionIntoView()));
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _resetOptions() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            this._onSelect(event.item, event.isUserInput);
            if (event.isUserInput && !this.isMultiSelect && this._panelOpen) {
                this.closePanel();
            }
        }));
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._stateChanges)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @return {?}
         */
        () => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
                this.stateChanges.next();
            }));
        }));
        this._setOptionIds();
    }
    /**
     * Records option IDs to pass to the aria-owns property.
     * @private
     * @return {?}
     */
    _setOptionIds() {
        this._optionIds = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option.id)).join(' ');
    }
    /**
     * Invoked when an option is clicked.
     * @private
     * @param {?} option
     * @param {?} isUserInput
     * @return {?}
     */
    _onSelect(option, isUserInput) {
        /** @type {?} */
        const wasSelected = this._selectionModel.isSelected(option);
        if (option.value == null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(option.value);
        }
        else {
            option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
            if (isUserInput) {
                this._keyManager.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
                if (isUserInput) {
                    // In case the user selected the option with their mouse, we
                    // want to restore focus back to the trigger, in order to
                    // prevent the select keyboard controls from clashing with
                    // the ones from `mat-option`.
                    this.focus();
                }
            }
        }
        if (wasSelected !== this._selectionModel.isSelected(option)) {
            this._propagateChanges();
        }
        this.stateChanges.next();
    }
    /**
     * @private
     * @return {?}
     */
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        }));
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     * @private
     * @param {?} value
     * @return {?}
     */
    _setSelectionByValue(value) {
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            this._selectionModel.clear();
            value.forEach((/**
             * @param {?} currentValue
             * @return {?}
             */
            (currentValue) => this._selectValue(currentValue)));
            this._sortValues();
        }
        else {
            this._selectionModel.clear();
            /** @type {?} */
            const correspondingOption = this._selectValue(value);
            // Shift focus to the active item. Note that we shouldn't do this in multiple
            // mode, because we don't know what option the user interacted with last.
            if (correspondingOption) {
                this._keyManager.setActiveItem(correspondingOption);
            }
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     * @private
     * @param {?} value
     * @return {?} Option that has the corresponding value.
     */
    _selectValue(value) {
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            try {
                // Treat null as a special reset value.
                return option.value != null && this._compareWith(option.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        }));
        if (correspondingOption) {
            this._selectionModel.select(correspondingOption);
        }
        return correspondingOption;
    }
    /**
     * Emits change event to set the model value.
     * @private
     * @param {?=} fallbackValue
     * @return {?}
     */
    _propagateChanges(fallbackValue) {
        /** @type {?} */
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = ((/** @type {?} */ (this.selected))).map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.value));
        }
        else {
            valueToEmit = this.selected ? ((/** @type {?} */ (this.selected))).value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Sorts the selected values in the selected based on their order in the panel.
     * @private
     * @return {?}
     */
    _sortValues() {
        if (this.isMultiSelect) {
            /** @type {?} */
            const options = this.options.toArray();
            this._selectionModel.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => options.indexOf(a) - options.indexOf(b)));
            this.stateChanges.next();
        }
    }
    /**
     * Focuses the select element.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * Opens the panel of the dropdown.
     * @return {?}
     */
    openPanel() {
        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
            return;
        }
        this._panelOpen = true;
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._keyManager.withHorizontalOrientation(null);
        this._highlightCorrectOption();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Closes the panel of the dropdown.
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this._keyManager.withHorizontalOrientation('ltr');
            this._changeDetectorRef.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            setTimeout((/**
             * @return {?}
             */
            () => this.focus()));
        }
    }
    // calculate inital scrollTop when the dropdown opens
    // scrolls the selected item to the middle of the panel if possible
    /**
     * @private
     * @return {?}
     */
    _calculateScrollTop() {
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        this._scrollTop = 0;
        if (!this.empty) {
            /** @type {?} */
            const offset = this._getItemOffset(this._keyManager.activeItem);
            /** @type {?} */
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            /** @type {?} */
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            /** @type {?} */
            const middleOfPanel = panelRect.top + panelHeight / 2;
            /** @type {?} */
            const activeItemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                // to middle out the text a bit more add half of the height
                // (this is still a few pixels off because the container is a bit larger than the font)
                this._scrollTop = offset - middleOfPanel + (activeItemRect.height - itemPadding) / 2;
                this.panelBody.nativeElement.scrollTop = this._scrollTop;
            }
        }
    }
    /**
     * Scrolls the active option into view.
     * @private
     * @return {?}
     */
    _scrollActiveOptionIntoView() {
        if (!this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        /** @type {?} */
        const activeOptionIndex = this._keyManager.activeItemIndex || 0;
        /** @type {?} */
        const itemRect = this._keyManager.activeItem.containerElement.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const labelCount = this._countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.groups);
        this.panelBody.nativeElement.scrollTop = this._getOptionScrollPosition(activeOptionIndex + labelCount, itemRect.height, this.panelBody.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
    }
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} options
     * @param {?} optionGroups
     * @return {?}
     */
    _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
        if (optionGroups.length) {
            /** @type {?} */
            const optionsArray = options.toArray();
            /** @type {?} */
            const groups = optionGroups.toArray();
            /** @type {?} */
            let groupCounter = 0;
            for (let i = 0; i < optionIndex + 1; i++) {
                if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                    groupCounter++;
                }
            }
            return groupCounter;
        }
        return 0;
    }
    /**
     * @private
     * @param {?} optionIndex
     * @param {?} optionHeight
     * @param {?} currentScrollPosition
     * @param {?} panelHeight
     * @return {?}
     */
    _getOptionScrollPosition(optionIndex, optionHeight, currentScrollPosition, panelHeight) {
        /** @type {?} */
        let optionOffset = optionIndex * optionHeight + itemPadding;
        if (this.showFilter) {
            /** @type {?} */
            const filterHeight = this.panel.nativeElement.querySelector('.nx-dropdown__filter').getBoundingClientRect().height;
            optionOffset = optionIndex * optionHeight + filterHeight;
        }
        if (optionOffset < currentScrollPosition) {
            return optionOffset;
        }
        if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
            return Math.max(0, optionOffset - panelHeight + optionHeight);
        }
        return currentScrollPosition;
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    _getItemOffset(item) {
        /** @type {?} */
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top;
    }
    /**
     * \@docs-private
     * Formfield Implementation
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    /**
     * @return {?}
     */
    _getAriaLabel() {
        return this._ariaLabel || (this.formFieldComponent ? this.formFieldComponent.label : null);
    }
    /**
     * \@docs-private
     * Whether the select has a value.
     * @return {?}
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * @param {?} value New value to be written to the model.
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this._setSelectionByValue(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param {?} isDisabled Sets whether the component is disabled.
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectorRef.markForCheck();
        this.stateChanges.next();
    }
    /**
     * End ControlValueAccessor
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleClosedKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        /** @type {?} */
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel();
        }
        else if (!this.isMultiSelect && !this.disabled) {
            this._keyManager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    _handleOpenKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        // all events other than the listed ones should be ignored or handled in _onFilter()
        if (!([DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].indexOf(keyCode) >= 0)) {
            return;
        }
        /** @type {?} */
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        /** @type {?} */
        const manager = this._keyManager;
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            /** @type {?} */
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem &&
                manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /**
     * \@docs-private
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /**
     * Called when the user types in the filter input
     * @param {?} event
     * @return {?}
     */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        /** @type {?} */
        const allHidden = this.options.map((/**
         * @param {?} option
         * @return {?}
         */
        option => option._hidden)).every((/**
         * @param {?} option
         * @return {?}
         */
        option => Boolean(option)));
        if (allHidden) {
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    /**
     * \@docs-private
     * The value displayed in the trigger.
     * @return {?}
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            /** @type {?} */
            const selectedOptions = this._selectionModel.selected.map((/**
             * @param {?} option
             * @return {?}
             */
            option => option.viewValue));
            return selectedOptions.join(', ');
        }
        return this._selectionModel.selected[0].viewValue;
    }
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     * @private
     * @return {?}
     */
    _highlightCorrectOption() {
        if (this._keyManager) {
            if (this.empty) {
                this._keyManager.setFirstItemActive();
            }
            else {
                this._keyManager.setActiveItem(this._selectionModel.selected[0]);
            }
        }
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     * @return {?}
     */
    _onAttached() {
        this._changeDetectorRef.markForCheck();
        this.overlayDir.positionChange.pipe(take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.panelBody.nativeElement.focus();
            if (this._keyManager.activeItem) {
                this._calculateScrollTop();
            }
            this._changeDetectorRef.markForCheck();
            this.openedChange.emit(true);
            if (this.showFilter) {
                this.filterInput.nativeElement.focus();
            }
        }));
    }
    /**
     * @return {?}
     */
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._changeDetectorRef.markForCheck();
            this.stateChanges.next();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _clearFilter() {
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /**
     * \@docs-private determines the `aria-activedescendant` to be set on the host.
     * @return {?}
     */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
NxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-dropdown',
                template: "\n<!-- input and stuff-->\n<div cdkOverlayOrigin\n    #origin=\"cdkOverlayOrigin\"\n    class=\"nx-dropdown__container\"\n    #trigger>\n  <div class=\"nx-dropdown__rendered\">\n    <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n  </div>\n  <div class=\"nx-dropdown__icon\">\n    <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n  </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n  <div *ngIf=\"triggerValue\">{{ triggerValue }}</div>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n  cdkConnectedOverlay\n  cdkConnectedOverlayHasBackdrop\n  cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n  [cdkConnectedOverlayOrigin]=\"origin\"\n  [cdkConnectedOverlayOpen]=\"panelOpen\"\n  [cdkConnectedOverlayPositions]=\"_positions\"\n  [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\"\n  [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n  [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n  [cdkConnectedOverlayPush]=\"true\"\n  (backdropClick)=\"closePanel()\"\n  (attach)=\"_onAttached()\"\n  (detach)=\"closePanel()\">\n\n  <div class=\"nx-dropdown__panel\"\n      (keydown)=\"_handleKeydown($event)\"\n      #panel>\n    <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\">\n      {{ label }}\n    </div>\n    \n    <div class=\"nx-dropdown__panel-body\" tabindex=\"-1\" #panelBody role=\"listbox\" [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\" [attr.aria-multiselectable]=\"isMultiSelect\">\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n          <input class=\"nx-dropdown__filter-input\" [class.is-filled]=\"!isFilterEmpty\"  #filterInput type=\"text\" (input)=\"_onFilter($event)\" [placeholder]=\"filterPlaceholder\">\n          <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n            <nx-icon name=\"close\"></nx-icon>\n          </span>\n        </div>\n        <ng-content></ng-content>\n      </div>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                    { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                ],
                host: {
                    'role': 'button',
                    '[class.nx-dropdown]': 'true',
                    '[class.is-filled]': 'hasValue',
                    '[class.has-focus]': 'focused',
                    '[class.nx-dropdown--negative]': '_negative',
                    '[class.nx-dropdown--disabled]': 'disabled',
                    '[attr.aria-describedby]': 'ariaDescribedby || null',
                    '[attr.aria-required]': 'required',
                    '[attr.aria-label]': '_getAriaLabel()',
                    '[attr.aria-haspopup]': '"listbox"',
                    '[attr.aria-expanded]': 'panelOpen',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'openPanel()'
                },
                styles: [":host{display:block}:host:focus{outline:0}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:#fff}.nx-dropdown__container{display:flex;justify-content:flex-end;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:0 2px 4px rgba(65,65,65,.5);border-radius:4px;background-color:#fff;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:20px}.nx-dropdown__panel:focus{outline:0}.nx-dropdown__icon{font-size:24px;line-height:1}.nx-dropdown__panel-header{line-height:16px;font-size:12px;padding:8px 24px;background-color:#ececec;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;font-weight:600}.nx-dropdown__panel-body{max-height:280px;overflow-y:auto;outline:0}.nx-dropdown__filter{position:relative;padding:16px 32px 24px}.nx-dropdown__filter-input{font-size:20px;border:0;border-bottom:1px solid #d9d9d9;color:#414141;width:100%;outline:0;background-color:transparent;font-weight:300}.nx-dropdown__filter-icon{position:absolute;right:32px;top:16px;cursor:pointer}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input.is-filled:focus{color:#007ab3;font-weight:600;border-bottom:1px solid #007ab3;overflow:ellipsis}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:#007ab3}@media screen and (-ms-high-contrast:active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText}}"]
            }] }
];
/** @nocollapse */
NxDropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: NxFormfieldComponent, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxDropdownComponent.propDecorators = {
    tabIndex: [{ type: Input }],
    _ariaLabel: [{ type: Input, args: ['nxAriaLabel',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input, args: ['nxRequired',] }],
    styles: [{ type: Input, args: ['nxStyle',] }],
    showFilter: [{ type: Input, args: ['nxShowFilter',] }],
    filterPlaceholder: [{ type: Input, args: ['nxFilterPlaceholder',] }],
    openedChange: [{ type: Output }],
    _openedStream: [{ type: Output, args: ['opened',] }],
    _closedStream: [{ type: Output, args: ['closed',] }],
    filterChanges: [{ type: Output, args: ['filterInput',] }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    selectionChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel',] }],
    panelBody: [{ type: ViewChild, args: ['panelBody',] }],
    trigger: [{ type: ViewChild, args: ['trigger',] }],
    filterInput: [{ type: ViewChild, args: ['filterInput',] }],
    overlayDir: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    options: [{ type: ContentChildren, args: [NxDropdownItemComponent, { descendants: true },] }],
    groups: [{ type: ContentChildren, args: [NxDropdownGroupComponent,] }],
    _customClosedDropdownLabel: [{ type: ContentChild, args: [NxDropdownClosedLabelDirective,] }],
    _defaultClosedDropdownLabel: [{ type: ViewChild, args: ['defaultClosedDropdownLabel',] }],
    valueFormatter: [{ type: Input, args: ['nxValueFormatter',] }],
    compareWith: [{ type: Input }],
    filterFn: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxDropdownModule {
}
NxDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    NxFormfieldModule,
                    NxCheckboxModule,
                    OverlayModule,
                    A11yModule,
                    NxIconModule,
                    ObserversModule
                ],
                declarations: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ],
                exports: [
                    NxDropdownComponent,
                    NxDropdownItemComponent,
                    NxDropdownGroupComponent,
                    NxDropdownClosedLabelDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxDropdownModule, NxDropdownSelectChange, SELECT_PANEL_MAX_HEIGHT, NxDropdownComponent, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective as ɵb, NxDropdownControl as ɵa };

//# sourceMappingURL=allianz-ngx-ndbx-dropdown.js.map