import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { Injectable, ChangeDetectionStrategy, Component, Input, ChangeDetectorRef, ElementRef, Self, Optional, NgModule } from '@angular/core';
import { NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { BACKSPACE, LEFT_ARROW, RIGHT_ARROW, SPACE } from '@angular/cdk/keycodes';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCodeInputIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /**
         * The aria label for the input field
         */
        this.inputFieldAriaLabel = 'Enter Key';
    }
}
NxCodeInputIntl.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_INPUT_LENGTH = 6;
/** @type {?} */
const TAG_NAME_INPUT = 'INPUT';
/** @type {?} */
const AUTO_UPPERCASE = 'upper';
/** @type {?} */
const AUTO_LOWERCASE = 'lower';
/** @type {?} */
const INPUT_FIELD_GAP = 'nx-code-input--gap';
class NxCodeInputComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _el
     * @param {?} _control
     * @param {?} _intl
     */
    constructor(_changeDetectorRef, _el, _control, _intl) {
        this._changeDetectorRef = _changeDetectorRef;
        this._el = _el;
        this._control = _control;
        this._intl = _intl;
        this._codeLength = DEFAULT_INPUT_LENGTH;
        this._type = 'text';
        this._tabindex = 0;
        /**
         * The user input in array form
         */
        this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        this._focused = false;
        /**
         * \@docs-private
         */
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        /**
         * \@docs-private
         */
        this.propagateTouch = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        if (this._control) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this._control.valueAccessor = this;
        }
    }
    /**
     * The length of the code input. Default: 6.
     * @param {?} value
     * @return {?}
     */
    set codeLength(value) {
        this._codeLength = value;
        this.setInputLength();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get codeLength() {
        return this._codeLength;
    }
    /**
     * The type of HTML input
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /* Sets the the tabindex if code input */
    /**
     * @param {?} value
     * @return {?}
     */
    set tabindex(value) {
        this._tabindex = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get tabindex() {
        return this._tabindex;
    }
    /**
     * Whether the form should auto capitalize or lowercase. (Optional)
     * @param {?} value
     * @return {?}
     */
    set convertTo(value) {
        this._convertTo = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Sets the length of the input fields.
     * @return {?}
     */
    setInputLength() {
        if (this.codeLength) {
            this._keyCode = new Array(this.codeLength);
        }
        else {
            this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        }
    }
    /**
     * Converts to upper or lowercase when enabled.
     * @param {?} value
     * @return {?}
     */
    _convertLetterSize(value) {
        if (value === 'ÃŸ') {
            return value;
        }
        if (typeof value === 'string') {
            if (this.convertTo === AUTO_UPPERCASE) {
                return value.toUpperCase();
            }
            else if (this.convertTo === AUTO_LOWERCASE) {
                return value.toLowerCase();
            }
            return value;
        }
    }
    /**
     * Reacts to keydown event.
     * @param {?} event
     * @return {?}
     */
    _keydownAction(event) {
        /** @type {?} */
        const previousInputField = event.target.previousElementSibling;
        /** @type {?} */
        const nextInputField = event.target.nextElementSibling;
        switch (event.keyCode) {
            case SPACE:
                return false;
            case BACKSPACE:
                if (event.target.value === '') {
                    if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                        previousInputField.focus();
                        previousInputField.select();
                    }
                }
                break;
            case LEFT_ARROW:
                if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                    event.preventDefault();
                    previousInputField.focus();
                    previousInputField.select();
                }
                break;
            case RIGHT_ARROW:
                if (nextInputField && nextInputField.tagName === TAG_NAME_INPUT) {
                    nextInputField.focus();
                    nextInputField.select();
                }
                event.preventDefault();
                break;
            default:
                break;
        }
    }
    /**
     * Selects the value on click of an input field.
     * @param {?} event
     * @return {?}
     */
    _selectText(event) {
        event.target.select();
    }
    /**
     * Automatically focuses and selects the next input on key input.
     * @param {?} event
     * @return {?}
     */
    _selectNextInput(event) {
        event.target.value = this._convertLetterSize(event.target.value);
        this.propagateChange(this._keyCode.join(''));
        if (event.target.value) {
            /** @type {?} */
            const nextInputField = event.target.nextSibling;
            if (nextInputField !== null && nextInputField.tagName === TAG_NAME_INPUT) {
                nextInputField.focus();
                if (nextInputField.value !== '') {
                    nextInputField.select();
                }
            }
        }
    }
    /**
     * Paste event to distribute content in input fields.
     * @param {?} event
     * @return {?}
     */
    _pasteClipboard(event) {
        /** @type {?} */
        let copiedText = '';
        if (event.clipboardData === undefined) {
            copiedText = ((/** @type {?} */ (window))).clipboardData.getData('text').replace(/ /g, '').split('');
        }
        else {
            copiedText = event.clipboardData.getData('text').replace(/ /g, '').split('');
        }
        /** @type {?} */
        let index = 0;
        /** @type {?} */
        let count = 0;
        for (let i = 0; i < this._el.nativeElement.children.length; i++) {
            if (event.srcElement === this._el.nativeElement.children.item(i)) {
                index = i;
            }
        }
        for (let i = index; i < this.codeLength; i++) {
            this._keyCode[i] = this._convertLetterSize(copiedText[count]);
            count++;
        }
        this.propagateChange(this._keyCode.join(''));
        if (index + copiedText.length < this.codeLength) {
            this._el.nativeElement.children.item(index + copiedText.length).focus();
            event.preventDefault();
        }
        else if (index + copiedText.length >= this.codeLength) {
            event.preventDefault();
        }
    }
    /**
     * Triggers when an input field is blurred.
     * @return {?}
     */
    _onBlur() {
        this._focused = false;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!this._focused) {
                this.propagateTouch(this._keyCode.join(''));
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * Sets _focused state and makes valid.
     * @return {?}
     */
    _setFocusState() {
        this._focused = true;
    }
    /**
     * Sets initial value, used by ControlValueAccessor.
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            /** @type {?} */
            const valueAsArray = value.split('').slice(0, this.codeLength);
            for (let i = 0; i < this.codeLength; i++) {
                this._keyCode[i] = valueAsArray[i];
            }
        }
        else {
            this.setInputLength();
        }
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    _trackByKeyCode(index, item) {
        return index;
    }
    /**
     * Adds a gap to input fields when appropriate.
     * @param {?} index
     * @return {?}
     */
    _inputGap(index) {
        switch (this.codeLength) {
            case 4:
            case 6:
            case 8:
                if (index === this.codeLength / 2) {
                    return INPUT_FIELD_GAP;
                }
                break;
            default:
                return;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.propagateTouch = fn;
    }
}
NxCodeInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-code-input',
                template: "<input type=\"text\"\n       class=\"nx-code-input__field\"\n       maxlength=\"1\"\n       *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode;\"\n       [(ngModel)]=\"_keyCode[i]\"\n       [ngClass]=\"_inputGap(i)\"\n       [attr.aria-label]=\"_intl.inputFieldAriaLabel\"\n       [attr.type]=\"type\"\n       (input)=\"_selectNextInput($event)\"\n       (paste)=\"_pasteClipboard($event)\"\n       (blur)=\"_onBlur()\"\n       (focus)=\"_setFocusState()\"\n       (click)=\"_selectText($event)\"\n       (keydown)=\"_keydownAction($event)\"\n       (ngModelChange)=\"_keyCode[i]=_convertLetterSize($event)\"\n/>\n",
                host: {
                    '[class.nx-code-input]': 'true',
                    '[class.has-error]': '_control ? _control.invalid && _control.touched : false',
                    '[attr.tabindex]': 'tabindex'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-code-input__field{margin:0 4px;text-align:center;font-weight:600;font-size:26px;line-height:32px;border:0;outline:0;caret-color:#006192;border-bottom:1px solid #414141;width:32px;color:#414141;border-radius:0;padding:0}.nx-code-input__field:focus{margin-bottom:-1px;color:#007ab3;border-bottom:2px solid currentColor}.nx-code-input--gap{margin-left:24px}:host.has-error .nx-code-input__field{margin-bottom:-1px;font-weight:700;color:#dc3149;border-bottom:2px solid #dc3149}"]
            }] }
];
/** @nocollapse */
NxCodeInputComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: NxCodeInputIntl }
];
NxCodeInputComponent.propDecorators = {
    codeLength: [{ type: Input, args: ['length',] }],
    type: [{ type: Input }],
    tabindex: [{ type: Input }],
    convertTo: [{ type: Input, args: ['nxConvertTo',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCodeInputModule {
}
NxCodeInputModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    NxCodeInputComponent,
                ],
                exports: [
                    NxCodeInputComponent,
                ],
                providers: [NxCodeInputIntl],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxCodeInputModule, NxCodeInputComponent, NxCodeInputIntl };

//# sourceMappingURL=allianz-ngx-ndbx-code-input.js.map