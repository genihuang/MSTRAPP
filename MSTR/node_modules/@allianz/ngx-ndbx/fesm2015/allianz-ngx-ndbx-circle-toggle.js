import { NxIconModule } from '@allianz/ngx-ndbx/icon';
import { CommonModule } from '@angular/common';
import { takeUntil, tap, startWith, filter } from 'rxjs/operators';
import { merge, Subject } from 'rxjs';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { UniqueSelectionDispatcher } from '@angular/cdk/collections';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Component, ContentChildren, EventEmitter, forwardRef, Input, Output, ChangeDetectorRef, ChangeDetectionStrategy, ViewChild, Optional, HostListener, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class ToggleButton {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
class NxCircleToggleGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `nx-circle-toggle-group-${nextId++}`;
        this._destroyed = new Subject();
        /**
         * An event emitted when the selection changes. Outputs the value of the currently selected button.
         */
        this.valueChange = new EventEmitter();
        this._name = `toggle-group-${nextId++}`;
        this._negative = false;
        this._responsive = true;
        this.onChangeCallback = (/**
         * @param {?} value
         * @return {?}
         */
        (value) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Id of the circle toggle group.
     *
     * If not set, the circle toggle group gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Name that is used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this.updateToggleButtonsNames();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the circle toggle group is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.disabled = value));
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Whether the circle toggle group uses the negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
        }
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.negative = value));
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * The value of the selected circle toggle in the circle toggle group.
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.writeValue(value);
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Whether the circle toggle group has a responsive behavior.
     * @param {?} value
     * @return {?}
     */
    set responsive(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.responsive) {
            this._responsive = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get responsive() {
        return this._responsive;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.value !== value) {
            this._value = value;
            this.notifySelectedChild(value);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscribeToSelectionChanges();
        // react if a content child is deleted, added etc.
        this.buttons.changes
            .pipe(startWith(this.buttons), filter((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => toggles.length > 0)), tap((/**
         * @param {?} toggles
         * @return {?}
         */
        toggles => Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            toggles.forEach((/**
             * @param {?} toggle
             * @return {?}
             */
            toggle => toggle.toggleButton.resetClasses()));
            this.buttons.first.toggleButton.setFirstButton();
            this.buttons.last.toggleButton.setLastButton();
        })))), takeUntil(this._destroyed))
            .subscribe((/**
         * @return {?}
         */
        () => this.subscribeToSelectionChanges()));
    }
    /**
     * \@docs-private
     * @return {?}
     */
    subscribeToSelectionChanges() {
        /** @type {?} */
        const changedOrDestroyed = merge(this.buttons.changes, this._destroyed);
        merge(...this.buttons.map((/**
         * @param {?} button
         * @return {?}
         */
        button => button.selectionChange)))
            .pipe(takeUntil(changedOrDestroyed))
            .subscribe((/**
         * @param {?} change
         * @return {?}
         */
        (change) => {
            this.onChangeCallback(change.value);
            this.valueChange.emit(change.value);
        }));
    }
    /**
     * \@docs-private
     * inform the selected button if the group selection is set programattically at the beginning
     * @param {?} newValue
     * @return {?}
     */
    notifySelectedChild(newValue) {
        if (this.buttons) {
            /** @type {?} */
            const selected = this.buttons.find((/**
             * @param {?} button
             * @return {?}
             */
            (button) => button.value === newValue));
            if (selected) {
                selected.setGroupSelection();
            }
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    updateToggleButtonsNames() {
        if (this.buttons) {
            this.buttons.forEach((/**
             * @param {?} button
             * @return {?}
             */
            button => button.name = this.name));
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get selectedButton() {
        return this.buttons ? this.buttons.find((/**
         * @param {?} button
         * @return {?}
         */
        button => button.checked)) : null;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get buttons() {
        return this._buttons;
    }
}
NxCircleToggleGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-circle-toggle-group',
                template: `<ng-content></ng-content>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleGroupComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.is-responsive]': 'responsive',
                    '[class.is-disabled]': 'disabled',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'name',
                    '[attr.name]': 'name',
                    '[attr.id]': 'id',
                    '[class.nx-circle-toggle-group]': 'true',
                    'role': 'radiogroup'
                },
                styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width:320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width:704px){:host(.is-responsive){flex-direction:row}}"]
            }] }
];
/** @nocollapse */
NxCircleToggleGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxCircleToggleGroupComponent.propDecorators = {
    _buttons: [{ type: ContentChildren, args: [ToggleButton,] }],
    valueChange: [{ type: Output }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    value: [{ type: Input }],
    responsive: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxMobileToggleButtonComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this.checked = false;
        this.negative = false;
        this.disabled = false;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setFirstButton() {
        this.isFirst = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    setLastButton() {
        this.isLast = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    resetClasses() {
        this.isFirst = false;
        this.isLast = false;
        this._changeDetectorRef.markForCheck();
    }
}
NxMobileToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-mobile-toggle-button',
                template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<span class=\"nx-toggle-button__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{hint}})</span>\n\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-disabled]': 'disabled',
                    '[class.is-negative]': 'negative',
                    '[class.is-first]': 'isFirst',
                    '[class.is-last]': 'isLast',
                    '[class.is-flipped]': 'checked'
                },
                styles: [":host{display:none;position:relative;transition:background-color .2s,border-color .2s,color .2s;flex-direction:row;border-width:1px 2px;border-color:#007ab3;border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center}@media (max-width:703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:#007ab3;font-weight:nx-font-weights(light);line-height:20px;font-size:14px}.nx-toggle-button__label-text{padding-top:0;padding-right:4px;font-weight:600;color:#007ab3}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:#fff}:host(.is-flipped.nx-toggle-button__mobile-check){opacity:1}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background:#007ab3}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:#fff}:host(.is-negative){border-color:#fff}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:#fff}:host(.is-negative.is-flipped){background-color:#fff}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:#007ab3}:host(.is-disabled){opacity:.4;cursor:not-allowed}"]
            }] }
];
/** @nocollapse */
NxMobileToggleButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxMobileToggleButtonComponent.propDecorators = {
    checked: [{ type: Input }],
    negative: [{ type: Input }],
    disabled: [{ type: Input }],
    hint: [{ type: Input }],
    label: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToggleChangeEvent {
    /**
     * @param {?} button
     * @param {?} value
     */
    constructor(button, value) {
        this.button = button;
        this.value = value;
    }
}
/** @type {?} */
let nextId$1 = 0;
class NxCircleToggleComponent extends ToggleButton {
    /**
     * @param {?} toggleGroup
     * @param {?} _checkedDispatcher
     * @param {?} _changeDetectorRef
     */
    constructor(/** @docs-private */ toggleGroup, _checkedDispatcher, _changeDetectorRef) {
        super();
        this.toggleGroup = toggleGroup;
        this._checkedDispatcher = _checkedDispatcher;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `toggle-button-${nextId$1++}`;
        /**
         * \@docs-private
         */
        this.inGroup = false;
        this._name = null;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         */
        this.checkedChange = new EventEmitter();
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         */
        this.selectionChange = new EventEmitter();
        this._checked = false;
        this._value = null;
        this._iconName = null;
        this._svg = null;
        this._svgChecked = null;
        this._label = null;
        this._hint = null;
        this._hover = false;
        /**
         * touched is set to true on touch devices.
         */
        this._touched = false;
        this._removeUniqueSelectionListener = (/**
         * @return {?}
         */
        () => { });
        this.onChangeCallback = (/**
         * @param {?} checked
         * @return {?}
         */
        (checked) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
        if (this.toggleGroup) {
            this.name = this.toggleGroup.name;
        }
    }
    /**
     * Id of the circle toggle.
     *
     * If not set, the circle toggle gets an incremented value by default.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Name that is used for accessibility.
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * Whether the circle toggle is checked.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.checked !== newValue) {
            this._checked = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * The value that is used in the model.
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this._value = newValue;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Id of the icon that should be displayed.
     * @param {?} name
     * @return {?}
     */
    set iconName(name) {
        this._iconName = name;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get iconName() {
        return this._iconName;
    }
    /**
     * SVG that is displayed if the circle toggle is unchecked.
     * @param {?} src
     * @return {?}
     */
    set svg(src) {
        this._svg = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svg() {
        return this._svg;
    }
    /**
     * SVG that is displayed if the circle toggle is checked.
     * @param {?} src
     * @return {?}
     */
    set svgChecked(src) {
        this._svgChecked = src;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get svgChecked() {
        return this._svgChecked;
    }
    /**
     * Label displayed below the circle.
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        this._label = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * Additional hint displayed below the label.
     * @param {?} value
     * @return {?}
     */
    set hint(value) {
        this._hint = value;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get hint() {
        return this._hint;
    }
    /**
     * Whether the circle toggle uses the negative set of styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Whether the circle toggle has a responsive behavior.
     * @param {?} value
     * @return {?}
     */
    set responsive(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.responsive !== newValue) {
            this._responsive = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get responsive() {
        return this._responsive;
    }
    /**
     * Whether the circle toggle is disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseEnter() {
        if (!this._touched) {
            this._hover = true;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onMouseLeave() {
        if (!this._touched) {
            this._hover = false;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    onTouchStart() {
        this._touched = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.toggleGroup) {
            this.attachListenerForGroup();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.toggleGroup) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.inGroup = true;
                this.negative = this.toggleGroup.negative;
                this.disabled = this.toggleGroup.disabled;
                this.responsive = this.toggleGroup.responsive;
                this.id = this.toggleGroup.id + `-button-${nextId$1++}`;
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // function returned by the listener
        this._removeUniqueSelectionListener();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    attachListenerForGroup() {
        this._removeUniqueSelectionListener =
            this._checkedDispatcher.listen((/**
             * @param {?} groupId
             * @param {?} buttonId
             * @return {?}
             */
            (groupId, buttonId) => {
                if (this.id !== buttonId && groupId === this.toggleGroup.id) {
                    this.checked = false;
                }
            }));
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    writeValue(newValue) {
        this.checked = newValue;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        if ((this.toggleGroup && this.checked) || this.disabled) {
            return;
        }
        else {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
            if (this.toggleGroup) {
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        }
    }
    /**
     * \@docs-private
     *
     * method called by the group if the internal value of the group is changed programatically,
     * does not trigger change emission
     * @return {?}
     */
    setGroupSelection() {
        // propagate changes only if the value in the group is different than the button checked value
        if (!this.checked) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgButton() {
        return !!this.svg && !!this.svgChecked;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get svgUrl() {
        /** @type {?} */
        let useFilledSvg = this.checked || (!this.disabled && this._hover);
        if (this.negative) {
            useFilledSvg = !useFilledSvg;
        }
        return useFilledSvg ? this.svgChecked : this.svg;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get type() {
        return this.toggleGroup ? 'radio' : 'checkbox';
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    handleEnterKey(event) {
        if (!this.toggleGroup) {
            this.toggle(event);
        }
    }
}
NxCircleToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-circle-toggle',
                template: "<input [id]=\"id + '-input'\"\n       class=\"nx-circle-toggle__input\"\n       [attr.aria-labelledby]=\"id + '-label'\"\n       [type]=\"type\"\n       [attr.name]=\"name\"\n       [checked]=\"checked\"\n       [disabled]= \"disabled\"\n       [attr.aria-checked]=\"checked\"\n       (keydown.enter)=\"handleEnterKey($event)\"\n       (click)=\"toggle($event)\">\n<label class=\"nx-circle-toggle__label\"\n  [for]=\"id + '-input'\"\n  [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [icon]=\"iconName\"\n      [negative]=\"negative\"\n      [svg]=\"svgUrl\"\n      [disabled]=\"disabled\"\n      [inGroup]=\"inGroup\"\n      [touched]=\"_touched\">\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button\n      [label]=\"label\"\n      [hint]=\"hint\"\n      [checked]=\"checked\"\n      [negative]=\"negative\"\n      [disabled]=\"disabled\">\n    </nx-mobile-toggle-button>\n</label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: ToggleButton,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent))
                    },
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxCircleToggleComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.nx-toggle-circle]': 'true',
                    '[class.in-group]': 'inGroup',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-responsive]': 'responsive'
                },
                styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width:703px){:host:not(.in-group){margin-right:48px}}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus,:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host-context([data-whatinput=keyboard]) .nx-circle-toggle__input:focus+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;z-index:1}"]
            }] }
];
/** @nocollapse */
NxCircleToggleComponent.ctorParameters = () => [
    { type: NxCircleToggleGroupComponent, decorators: [{ type: Optional }] },
    { type: UniqueSelectionDispatcher },
    { type: ChangeDetectorRef }
];
NxCircleToggleComponent.propDecorators = {
    name: [{ type: Input }],
    checkedChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    iconName: [{ type: Input, args: ['icon',] }],
    svg: [{ type: Input }],
    svgChecked: [{ type: Input }],
    label: [{ type: Input }],
    hint: [{ type: Input }],
    negative: [{ type: Input }],
    responsive: [{ type: Input }],
    disabled: [{ type: Input }],
    toggleButton: [{ type: ViewChild, args: [NxMobileToggleButtonComponent,] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxIconToggleButtonComponent {
    constructor() {
        this.inGroup = true;
    }
}
NxIconToggleButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-icon-toggle-button',
                template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n  <ng-container *ngIf=\"!inGroup\">\n    <span class=\"nx-toggle-circle__check-icon\">\n      <nx-icon name=\"check\"></nx-icon>\n    </span>\n    <div class=\"nx-toggle-circle__check-focus\"></div>\n  </ng-container>\n  <span class=\"nx-toggle-circle__icon\">\n    <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n    <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n  </span>\n</div>\n<span [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{label}}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{hint}}</span>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.nx-circle-button]': 'true',
                    '[class.is-flipped]': 'checked',
                    '[class.has-checkmark]': '!inGroup',
                    '[class.is-disabled]': 'disabled',
                    '[class.is-negative]': 'negative',
                    '[class.is-touched]': 'touched'
                },
                styles: ["@media (max-width:703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer}:host .nx-toggle-circle__label-text{position:relative;display:inline-block;padding-top:12px;line-height:24px;font-size:16px;max-width:16rem;z-index:1;color:#414141}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-text{color:#fff}}:host .is-label-bold{font-weight:700}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border:2px solid #007ab3;display:flex;align-items:center;justify-content:center;transition:background-color .2s,border-color .2s,box-shadow .2s}:host .nx-toggle-circle__check-icon{background-color:#3da556;border-radius:50%;border:2px solid #fff;color:#fff;font-size:24px;width:32px;height:32px;margin-left:12px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 48px + 2px);z-index:-1;opacity:0;transition:box-shadow .2s}:host .nx-toggle-circle__label-hint{color:#414141;display:inline-block;line-height:24px;font-size:16px;transition:color .2s;z-index:1}@media screen and (-ms-high-contrast:active){:host .nx-toggle-circle__label-hint{color:#fff}}@media (max-width:703px){:host .is-label-bold{font-weight:400}:host .nx-toggle-circle__label-hint{font-weight:300}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:#007ab3}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background:#007ab3}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:#fff}:host(.is-flipped) .nx-toggle-circle__check-focus,:host(.is-flipped) .nx-toggle-circle__check-icon{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:#006192;background:#006192}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#007ab3;background:#007ab3}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:#fff}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:transparent}:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__label-text{color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper,:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:#fff;background-color:#fff}:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon,:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon{color:#007ab3}"]
            }] }
];
NxIconToggleButtonComponent.propDecorators = {
    inGroup: [{ type: Input }],
    hint: [{ type: Input }],
    label: [{ type: Input }],
    checked: [{ type: Input }],
    icon: [{ type: Input }],
    svgUrl: [{ type: Input, args: ['svg',] }],
    disabled: [{ type: Input }],
    negative: [{ type: Input }],
    touched: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxCircleToggleModule {
}
NxCircleToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NxCircleToggleGroupComponent,
                    NxCircleToggleComponent,
                    NxIconToggleButtonComponent,
                    NxMobileToggleButtonComponent
                ],
                exports: [
                    NxCircleToggleGroupComponent,
                    NxIconToggleButtonComponent,
                    NxCircleToggleComponent,
                    NxMobileToggleButtonComponent
                ],
                imports: [
                    CommonModule,
                    NxIconModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxCircleToggleModule, NxMobileToggleButtonComponent, ToggleChangeEvent, NxCircleToggleComponent, NxIconToggleButtonComponent, NxCircleToggleGroupComponent, ToggleButton as ɵa };

//# sourceMappingURL=allianz-ngx-ndbx-circle-toggle.js.map