import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, EventEmitter, forwardRef, Input, Optional, Output, Self, NgModule } from '@angular/core';
import { FormGroupDirective, NG_VALUE_ACCESSOR, NgControl, NgForm } from '@angular/forms';
import { Subject } from 'rxjs';
import { NxLabelComponent } from '@allianz/ngx-ndbx/base';
import { NxIconModule } from '@allianz/ngx-ndbx/icon';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The change event object emitted by the radio group and radio button.
 */
class NxRadioChange {
    /**
     * The NxRadioComponent that emits the change event. NxRadioChange object can be instantiated with source radio component and a value.
     * @param {?} source
     * @param {?} value
     */
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
class NxRadioGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} ngControl
     * @param {?} _parentForm
     * @param {?} _parentFormGroup
     */
    constructor(_changeDetectorRef, ngControl, _parentForm, _parentFormGroup) {
        this._changeDetectorRef = _changeDetectorRef;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        // emits when the internal state changes on properties which are relevant
        // for the radio buttons so that they can mark themself for check
        this._stateChanges = new Subject();
        this._id = `nx-radio-group-${nextId++}`;
        this._disabled = false;
        this._negative = false;
        this._required = false;
        /**
         * An event is dispatched on each group value change.
         */
        this.groupValueChange = new EventEmitter();
        this._name = `nx-radio-group-${nextId++}`;
        this._value = null;
        // The currently selected radio button; should match _value
        this._selected = null;
        this._onChange = (/**
         * @return {?}
         */
        () => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Sets the Id of the radio group.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * Whether every radio button in this group should be disabled.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // inform childs about the change where CD should be triggered
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * Whether the radio group should have negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * Sets if at least an option should be selected.
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = coerceBooleanProperty(value);
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
    /**
     * Sets the name of this radio group, which is mandatory in conjunction with ngModel (Default: null).
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this._stateChanges.next();
    }
    /**
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * Sets the value of the selected radion button in this group (Default: null).
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        if (this._value !== newValue) {
            // Set this before proceeding to ensure no circular loop occurs with selection.
            this._value = newValue;
            this._updateSelectedRadioFromValue();
            this._checkSelectedRadioButton();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._updateSelectedRadioFromValue();
        this._checkSelectedRadioButton();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * \@docs-private this is meant to be called by the radio buttons in this group
     * @param {?} value
     * @return {?}
     */
    change(value) {
        this.value = value;
        this._onChange(value);
        this.groupValueChange.emit(new NxRadioChange(this._selected, this._value));
    }
    /**
     * \@docs-private this is meant to be called by the radio buttons in this group.
     * @return {?}
     */
    touch() {
        if (this._onTouched) {
            this._onTouched();
        }
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @private
     * @return {?}
     */
    _updateSelectedRadioFromValue() {
        // If the value already matches the selected radio, do nothing.
        /** @type {?} */
        const isAlreadySelected = this._selected != null && this._selected.value === this._value;
        if (this._radios != null && !isAlreadySelected) {
            this._selected = null;
            this._radios.forEach((/**
             * @param {?} radio
             * @return {?}
             */
            radio => {
                radio.checked = this.value === radio.value;
                if (radio.checked) {
                    this._selected = radio;
                }
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    _checkSelectedRadioButton() {
        if (this._selected && !this._selected.checked) {
            this._selected.checked = true;
        }
    }
}
NxRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio-group',
                template: "<div>\n  <div class=\"nx-radio-group__label\">\n    <ng-content select=\"nx-label\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__errors\">\n    <ng-content select=\"nx-error\"></ng-content>\n  </div>\n  <div class=\"nx-radio-group__controls\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'radiogroup',
                    '[attr.id]': 'id',
                    '[attr.required]': 'required',
                    '[class.nx-radio-group--negative]': 'negative',
                    '[attr.aria-labelledby]': 'this._label?.id  || null'
                },
                styles: [":host ::ng-deep nx-error{margin-bottom:8px}:host ::ng-deep nx-label{margin-bottom:16px;display:block}"]
            }] }
];
/** @nocollapse */
NxRadioGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: NgForm, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
NxRadioGroupComponent.propDecorators = {
    _label: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxLabelComponent)), {},] }],
    id: [{ type: Input, args: ['id',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    negative: [{ type: Input }],
    required: [{ type: Input }],
    groupValueChange: [{ type: Output, args: ['nxGroupValueChange',] }],
    _radios: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NxRadioComponent)), { descendants: true },] }],
    name: [{ type: Input }],
    value: [{ type: Input, args: ['nxValue',] }]
};
class NxRadioComponent {
    /**
     * @param {?} radioGroup
     * @param {?} _changeDetectorRef
     */
    constructor(radioGroup, _changeDetectorRef) {
        this.radioGroup = radioGroup;
        this._changeDetectorRef = _changeDetectorRef;
        this._id = `nx-radio-${nextId++}`;
        this._name = null;
        this._labelSize = 'big';
        this._negative = false;
        /**
         * An event is dispatched on each value change.
         */
        this.valueChange = new EventEmitter();
        this._value = null;
        this._checked = false;
        this._disabled = false;
        this._required = false;
        this.onChangeCallback = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this.onTouchedCallback = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * Sets the id of the radio component.
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get inputId() {
        return `${this.id}-input`;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get labelId() {
        return `${this.id}-label`;
    }
    // this is also the name attribute, which is mandatory in conjunction with ngModel, hence no nx prefix
    /**
     * Sets the name of this radio component, which is mandatory in conjunction with ngModel (Default: null).
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return (this.radioGroup && this.radioGroup.name) ? this.radioGroup.name : this._name;
    }
    /**
     * Sets the label size of the radio button.
     * The default value is `big`.
     * @param {?} value
     * @return {?}
     */
    set labelSize(value) {
        if (this._labelSize !== value) {
            this._labelSize = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get labelSize() {
        return this._labelSize;
    }
    /**
     * Whether the negative set of styles should be used.
     *
     * If the radio button is placed in a radio group, the negative value
     * is overwritten by the group's negative value.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (this._negative !== newValue) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this.radioGroup ? this.radioGroup.negative : this._negative;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Sets the value of the form control element (Default: null).
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value !== this._value) {
            this._value = value;
            this.onChangeCallback(value);
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * Whether the radio component is selected.
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        if (this._checked !== value) {
            this._checked = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get disabled() {
        return this._disabled || (this.radioGroup && this.radioGroup.disabled);
    }
    /**
     * Whether the radio button should be disabled or not.
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get required() {
        return this._required || (this.radioGroup && this.radioGroup.required);
    }
    /**
     * Sets if at least a radio button should be selected.
     * @param {?} value
     * @return {?}
     */
    set required(value) {
        this._required = value;
        // needed when the outer component is set to onPush because it is a native property
        // on the host element
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.radioGroup) {
            this.name = this.radioGroup.name;
            // when relevant properties of the parent like name and disabled change
            // we need to let change detection know that the template needs an update
            this._parentChangeSubscription = this.radioGroup._stateChanges.subscribe((/**
             * @return {?}
             */
            () => {
                this._changeDetectorRef.markForCheck();
            }));
            if (this.radioGroup.value === this._value) {
                this._checked = true;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._parentChangeSubscription) {
            this._parentChangeSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === this._value) {
            this._checked = true;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * \@docs-private
     * @return {?}
     */
    touch() {
        this.onTouchedCallback();
        if (this.radioGroup) {
            this.radioGroup.touch();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputChange(event) {
        event.stopPropagation();
        this._checked = true;
        this.valueChange.emit(new NxRadioChange(this, this._value));
        this.onChangeCallback(this.value);
        if (this.radioGroup && this.value !== this.radioGroup.value) {
            this.radioGroup.change(this.value);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onInputClick(event) {
        // make sure click event propagation on the visually hidden input
        // are stopped to prevent multiple events bubbling up.
        event.stopPropagation();
    }
    /**
     * \@docs-private
     * @return {?}
     */
    _controlInvalid() {
        /** @type {?} */
        const form = this.radioGroup && (this.radioGroup._parentFormGroup || this.radioGroup._parentForm);
        return !!(this.radioGroup && this.radioGroup.ngControl && this.radioGroup.ngControl.invalid
            && (this.radioGroup.ngControl.touched || (form && form.submitted)));
    }
}
NxRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-radio',
                template: "<input\n  type=\"radio\"\n  [id]=\"inputId\"\n  [attr.name]=\"name\"\n  [disabled]=\"disabled\"\n  (blur)=\"touch()\"\n  (change)=\"_onInputChange($event)\"\n  (click)=\"_onInputClick($event)\"\n  [checked]=\"checked\"\n  [attr.aria-labelledby]=\"labelId\"\n  class=\"nx-radio__input\">\n<label [id]=\"labelId\" [attr.for]=\"inputId\" class=\"nx-radio__label\">\n    <div class=\"nx-radio__circle\">\n      <div class=\"nx-radio__dot\"></div>\n    </div>\n    <span class=\"nx-radio__label--text\"><ng-content></ng-content></span>\n</label>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NxRadioComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[attr.required]': 'required',
                    '[class.nx-radio-button--small-label]': 'labelSize === "small"',
                    '[class.nx-radio-button--big-label]': 'labelSize === "big"',
                    '[class.nx-radio--negative]': 'negative',
                    '[class.has-error]': '_controlInvalid() || null',
                    '[attr.aria-invalid]': '_controlInvalid() || null'
                },
                styles: [":host{display:block;position:relative}:host.has-error .nx-radio__circle,:host.ng-invalid .nx-radio__circle{border-color:#dc3149}:host.has-error .nx-radio__input:checked+.nx-radio__label .nx-radio__dot,:host.ng-invalid .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#dc3149}.nx-radio__input{opacity:0;position:absolute}:host(.nx-radio-button--small-label) .nx-radio__label{font-size:16px;line-height:24px}:host(.nx-radio-button--big-label) .nx-radio__label{font-size:20px;line-height:28px}:host.nx-radio--negative .nx-radio__label--text{color:#fff}:host.nx-radio--negative .nx-radio__circle{border-color:#fff}:host.nx-radio--negative .nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background:#fff}:host.nx-radio--negative .nx-radio__input:disabled+.nx-radio__label{opacity:.4}.nx-radio__label{color:#414141;cursor:pointer;display:inline-flex;position:relative;align-items:center}.nx-radio__circle{border:2px solid #007ab3;border-radius:50%;width:24px;min-width:24px;height:24px;margin-right:12px;position:relative;display:flex;justify-content:center;align-items:center}.nx-radio__dot{width:8px;height:8px;background-color:transparent;border-radius:50%;transition:background-color .2s}.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:#007ab3}.nx-radio__input:disabled+.nx-radio__label{cursor:not-allowed;color:#c2c2c2}.nx-radio__input:disabled+.nx-radio__label .nx-radio__circle{border-color:#c2c2c2}.nx-radio__input:checked:disabled+.nx-radio__label .nx-radio__dot{background-color:#c2c2c2}:host-context([data-whatinput=keyboard]) .nx-radio__input:focus+.nx-radio__label .nx-radio__circle{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):hover .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#075994}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled])+.nx-radio__label .nx-radio__circle{border-color:#003781}:host:not(.nx-radio--negative):not(.ng-invalid):not(.has-error):active .nx-radio__input:not([disabled]):checked+.nx-radio__label .nx-radio__dot{background-color:#003781}@media screen and (-ms-high-contrast:active){.nx-radio__input:checked+.nx-radio__label .nx-radio__dot{background-color:windowText}.nx-radio__input:focus+.nx-radio__label{color:highlightText}.nx-radio__input:focus+.nx-radio__label .nx-radio__dot{background-color:highlightText}}"]
            }] }
];
/** @nocollapse */
NxRadioComponent.ctorParameters = () => [
    { type: NxRadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef }
];
NxRadioComponent.propDecorators = {
    id: [{ type: Input, args: ['id',] }],
    name: [{ type: Input, args: ['name',] }],
    labelSize: [{ type: Input }],
    negative: [{ type: Input }],
    valueChange: [{ type: Output, args: ['nxValueChange',] }],
    value: [{ type: Input, args: ['nxValue',] }],
    checked: [{ type: Input, args: ['nxChecked',] }],
    disabled: [{ type: Input, args: ['nxDisabled',] }],
    required: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxRadioModule {
}
NxRadioModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NxRadioComponent, NxRadioGroupComponent],
                exports: [NxRadioComponent, NxRadioGroupComponent],
                imports: [
                    NxIconModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxRadioModule, NxRadioGroupComponent, NxRadioComponent };

//# sourceMappingURL=allianz-ngx-ndbx-radio-button.js.map