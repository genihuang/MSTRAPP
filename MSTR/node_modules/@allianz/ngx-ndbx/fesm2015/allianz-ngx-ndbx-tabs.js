import { CommonModule } from '@angular/common';
import { TemplatePortal, CdkPortalOutlet, PortalModule } from '@angular/cdk/portal';
import { Subject, merge, Subscription } from 'rxjs';
import { NxAccordionDirective, NxExpansionPanelComponent, NxAccordionModule } from '@allianz/ngx-ndbx/accordion';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';
import { ChangeDetectionStrategy, Component, Input, TemplateRef, ViewChild, ViewContainerRef, Optional, Inject, Host, Directive, ElementRef, ChangeDetectorRef, ContentChildren, EventEmitter, Output, HostListener, ViewChildren, SkipSelf, NgModule } from '@angular/core';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @abstract
 */
class NxTabGroupBase {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabComponent {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _tabGroup
     */
    constructor(_viewContainerRef, _tabGroup) {
        this._viewContainerRef = _viewContainerRef;
        this._tabGroup = _tabGroup;
        /**
         * The portal that will be the hosted content of the tab
         */
        this._contentPortal = null;
        /**
         * Emits whenever the internal state of the tab changes.
         */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Sets the label of the tab shown in the tablist.
     * @return {?}
     */
    get label() {
        return this._label;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get content() {
        return this._contentPortal;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hasOwnProperty('label')) {
            this._stateChanges.next();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._contentPortal = new TemplatePortal(this._implicitContent, this._viewContainerRef);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.complete();
    }
}
NxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab',
                exportAs: 'nxTab',
                template: "<ng-template><ng-content></ng-content></ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NxTabComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NxTabGroupBase, decorators: [{ type: Inject, args: [NxTabGroupBase,] }, { type: Optional }, { type: Host }] }
];
NxTabComponent.propDecorators = {
    label: [{ type: Input }],
    _implicitContent: [{ type: ViewChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabBodyComponent {
    constructor() {
        this._active = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        this._active = coerceBooleanProperty(value);
        if (this._active) {
            this.attach();
        }
        else {
            this.detach();
        }
    }
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @return {?}
     */
    attach() {
        if (!this.portalOutlet.hasAttached()) {
            this.portalOutlet.attach(this.content);
        }
    }
    /**
     * @return {?}
     */
    detach() {
        if (this.portalOutlet.hasAttached()) {
            this.portalOutlet.detach();
        }
    }
}
NxTabBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-body',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}"]
            }] }
];
NxTabBodyComponent.propDecorators = {
    content: [{ type: Input }],
    active: [{ type: Input }],
    portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabLabelDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
}
NxTabLabelDirective.decorators = [
    { type: Directive, args: [{ selector: '[nxTabLabel]' },] }
];
/** @nocollapse */
NxTabLabelDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 */
class NxTabHeaderComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this._keyManager) {
            this._keyManager.updateActiveItemIndex(value);
        }
    }
    /**
     * @return {?}
     */
    get focusIndex() {
        return this._keyManager ? this._keyManager.activeItemIndex : 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusIndex(value) {
        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
            return;
        }
        this._keyManager.setActiveItem(value);
    }
    /**
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItemIndex(0);
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @param {?} idx
     * @return {?}
     */
    _isValidIndex(idx) {
        if (!this.labels) {
            return true;
        }
        return !!this.labels.toArray()[idx];
    }
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    }
}
NxTabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-header',
                template: "<div class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\">\n  <ng-content></ng-content>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block}.nx-tab-header{display:flex;align-items:flex-end;justify-content:center;padding:60px 0}"]
            }] }
];
/** @nocollapse */
NxTabHeaderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabHeaderComponent.propDecorators = {
    selectedIndex: [{ type: Input }],
    autoselect: [{ type: Input }],
    selectFocusedIndex: [{ type: Output }],
    indexFocused: [{ type: Output }],
    labels: [{ type: ContentChildren, args: [NxTabLabelDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabChangeEvent {
}
/** @type {?} */
let nextId = 0;
/** @type {?} */
const MOBILE_BREAKPOINT = 480;
class NxTabGroupComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._selectedIndex = null;
        this._negative = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * An event emitted when the selected tab has changed.
         */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /**
         * Subscription to tabs being added/removed.
         */
        this._tabsSubscription = Subscription.EMPTY;
        /**
         * Subscription to changes in the tab labels.
         */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._groupId = nextId++;
    }
    /**
     * Sets the selected tab.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /**
     * Whether the negative set of styling should be used.
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
        }
    }
    /**
     * Whether the tab should be immediately selected on focus.
     * @return {?}
     */
    get autoselect() {
        return this._autoselect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /**
     * Whether the tabs should to accordion on mobile viewports.
     * @return {?}
     */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._switchAppearance(window.innerWidth);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this.tabs.changes.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                /** @type {?} */
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._changeDetectorRef.markForCheck();
        }));
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     * @return {?}
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        /** @type {?} */
        const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            /** @type {?} */
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.tabs.forEach((/**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */
                (tab, index) => tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            }));
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     * @private
     * @return {?}
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map((/**
         * @param {?} tab
         * @return {?}
         */
        tab => tab._stateChanges)))
            .subscribe((/**
         * @return {?}
         */
        () => this._changeDetectorRef.markForCheck()));
    }
    /**
     * Clamps the given index to the bounds of 0 and the tabs length.
     * @private
     * @param {?} index
     * @return {?}
     */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _createChangeEvent(index) {
        /** @type {?} */
        const event = new NxTabChangeEvent;
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /**
     * \@docs-private
     * @param {?} index
     * @return {?}
     */
    handleClick(index) {
        this.selectedIndex = this.tabHeader.focusIndex = index;
    }
    /**
     * \@docs-private
     * Returns the tabindex for a tab label
     * @param {?} tab
     * @param {?} idx
     * @return {?}
     */
    getTabIndex(tab, idx) {
        return this.selectedIndex === idx ? 0 : -1;
    }
    /**
     * Returns a unique id for each tab label element
     * @param {?} i
     * @return {?}
     */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /**
     * Returns a unique id for each tab content element
     * @param {?} i
     * @return {?}
     */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    /**
     * \@docs-private
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this._switchAppearance(event.target.innerWidth);
    }
    /**
     * @private
     * @param {?} viewPortWidth
     * @return {?}
     */
    _switchAppearance(viewPortWidth) {
        if (!this._mobileAccordion) {
            return;
        }
        if (viewPortWidth <= MOBILE_BREAKPOINT && !this._showAccordion) {
            this._showMobileVersion();
        }
        else if (viewPortWidth > MOBILE_BREAKPOINT && this._showAccordion) {
            this._showDesktopVersion();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _showMobileVersion() {
        this._showAccordion = true;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    _showDesktopVersion() {
        this._showAccordion = false;
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     * @param {?} index
     * @return {?}
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-group',
                template: "\n  <nx-tab-header *ngIf=\"!_showAccordion\"\n      #tabHeader\n      [selectedIndex]=\"selectedIndex\"\n      (selectFocusedIndex)=\"selectedIndex = $event\"\n      (indexFocused)=\"focusChanged($event)\"\n      [autoselect]=\"autoselect\">\n    <button\n      type=\"button\"\n      nxTabLabel\n      *ngFor=\"let tab of tabs; let i = index\"\n      role=\"tab\"\n      (click)=\"handleClick(i)\"\n      class=\"nx-tab-header__item\"\n      [id]=\"_getTabLabelId(i)\"\n      [attr.aria-controls]=\"_getTabContentId(i)\"\n      [attr.aria-selected]=\"selectedIndex == i\"\n      [attr.tabindex]=\"getTabIndex(tab, i)\"\n      [class.nx-tab-header__item--active]=\"selectedIndex == i\">\n      {{tab.label}}\n    </button>\n  </nx-tab-header>\n\n  <div class=\"nx-tab-body__container\">\n    <nx-tab-body\n      *ngFor=\"let tab of tabs; let i = index\"\n      [id]=\"_getTabContentId(i)\"\n      role=\"tabpanel\"\n      [attr.tabindex]=\"(!_showAccordion && selectedIndex == i) ? 0 : -1\"\n      class=\"nx-tab__body\"\n      [attr.aria-labelledby]=\"_getTabContentId(i)\"\n      [class.nx-tab__body--active]=\"selectedIndex == i\"\n      [content]=\"tab.content\"\n      [active]=\"!_showAccordion && selectedIndex == i\"\n    ></nx-tab-body>\n  </div>\n\n  <nx-accordion *ngIf=\"_showAccordion\" [negative]=\"negative\">\n    <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\">\n      <nx-expansion-panel-header>\n        <nx-expansion-panel-title>{{tab.label}}</nx-expansion-panel-title>\n      </nx-expansion-panel-header>\n      <ng-template [cdkPortalOutlet]=\"tab.content\"></ng-template>\n    </nx-expansion-panel>\n  </nx-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative'
                },
                providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }],
                styles: [":host{display:block}.nx-tab-header__item{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px;outline:0}.nx-tab-header__item::-moz-focus-inner{border:0}:host-context([data-whatinput=keyboard]) .nx-tab-header__item:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}.nx-tab-header__item--active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) .nx-tab-header__item{color:#fff;border-bottom-color:#fff}"]
            }] }
];
/** @nocollapse */
NxTabGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabGroupComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NxTabComponent,] }],
    tabBodyChildren: [{ type: ViewChildren, args: [NxTabBodyComponent,] }],
    tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],
    panels: [{ type: ViewChildren, args: [NxExpansionPanelComponent,] }],
    accordion: [{ type: ViewChild, args: [NxAccordionDirective,] }],
    selectedIndex: [{ type: Input }],
    negative: [{ type: Input }],
    autoselect: [{ type: Input }],
    mobileAccordion: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    selectedTabChange: [{ type: Output }],
    focusChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabNavBarComponent {
    /**
     * @param {?} _changeDetectorRef
     */
    constructor(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._negative = false;
    }
    /**
     * Whether the tab nav bar has negative styling.
     * @param {?} value
     * @return {?}
     */
    set negative(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.negative) {
            this._negative = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    get negative() {
        return this._negative;
    }
}
NxTabNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'nx-tab-nav-bar',
                template: "<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class.is-negative]': 'negative',
                    'role': 'navigation',
                },
                styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host ::ng-deep a.nx-tab-link{text-decoration:none;border:none;background:0 0;color:#006192;border-bottom:2px solid #007ab3;padding:0 16px 6px;font-weight:400;font-size:18px;line-height:24px}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;transition:font-weight .3s;padding-bottom:4px}:host(.is-negative){color:#fff}:host(.is-negative) ::ng-deep a.nx-tab-link{color:#fff;border-bottom-color:#fff}:host-context([data-whatinput=keyboard]) nx-tab-link:focus{box-shadow:0 0 0 2px #fff,0 0 0 6px #009de6;border-radius:4px}"]
            }] }
];
/** @nocollapse */
NxTabNavBarComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NxTabNavBarComponent.propDecorators = {
    negative: [{ type: Input }]
};
class NxTabLinkDirective {
    /**
     * @param {?} _tabNavBar
     */
    constructor(_tabNavBar) {
        this._tabNavBar = _tabNavBar;
        this._active = false;
        if (!this._tabNavBar) {
            throw Error(`The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.`);
        }
    }
    /**
     * Whether the tab link is active and has the active styling.
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        /** @type {?} */
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._active) {
            this._active = value;
        }
    }
}
NxTabLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nxTabLink]',
                host: {
                    '[class.nx-tab-link]': 'true',
                    '[class.is-active]': 'active',
                    '[attr.aria-current]': 'active',
                }
            },] }
];
/** @nocollapse */
NxTabLinkDirective.ctorParameters = () => [
    { type: NxTabNavBarComponent, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
NxTabLinkDirective.propDecorators = {
    active: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NxTabsModule {
}
NxTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PortalModule,
                    NxAccordionModule
                ],
                exports: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective
                ],
                declarations: [
                    NxTabComponent,
                    NxTabGroupComponent,
                    NxTabLabelDirective,
                    NxTabHeaderComponent,
                    NxTabBodyComponent,
                    NxTabNavBarComponent,
                    NxTabLinkDirective
                ],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NxTabsModule, NxTabComponent, NxTabChangeEvent, NxTabGroupComponent, NxTabHeaderComponent, NxTabBodyComponent, NxTabLabelDirective, NxTabNavBarComponent, NxTabLinkDirective, NxTabGroupBase as Éµa };

//# sourceMappingURL=allianz-ngx-ndbx-tabs.js.map